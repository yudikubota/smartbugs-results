Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Fee
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:HasOwners
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Math
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Registry
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Stake
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle7530993238647820528/mustExplicit -j 1 -F /tmp/souffle-6fbfa647-489d-4f88-9a67-c22173bfff91 -D /tmp/souffle-6fbfa647-489d-4f88-9a67-c22173bfff91_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Stake
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:StandardToken
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Token
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Validating
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Versioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol:Withdrawing
[31mViolation[0m for LockedEther in contract 'Fee':
    |  * FEE tokens do not have limit. A new token can be generated by owner.
    |  */
  > |contract Fee is HasOwners, Versioned, StandardToken {
    |
    |  /* This notifies clients about the amount burnt */
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(249)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |pragma solidity 0.5.3;
    |
  > |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/external/Token.sol
    |
    |/*
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |  function _addOwner_(address owner) private validAddress(owner) {
    |    if (!isOwner[owner]) {
  > |      isOwner[owner] = true;
    |      owners.push(owner);
    |      emit OwnerAdded(owner);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(127)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |    if (!isOwner[owner]) {
    |      isOwner[owner] = true;
  > |      owners.push(owner);
    |      emit OwnerAdded(owner);
    |    }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(128)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |    if (isOwner[owner]) {
    |      require(owners.length > 1, "removing the last owner is not allowed");
  > |      isOwner[owner] = false;
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(137)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  > |          owners[i] = owners[owners.length - 1]; // replace map last entry
    |          delete owners[owners.length - 1];
    |          break;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(140)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |        if (owners[i] == owner) {
    |          owners[i] = owners[owners.length - 1]; // replace map last entry
  > |          delete owners[owners.length - 1];
    |          break;
    |        }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(141)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |    require(balances[msg.sender] >= _value, "sender has insufficient token balance");
    |    balances[msg.sender] -= _value;
  > |    balances[_to] += _value;
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(207)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value,
    |      "either from address has insufficient token balance, or insufficient amount was approved for sender");
  > |    balances[_to] += _value;
    |    balances[_from] -= _value;
    |    allowed[_from][msg.sender] -= _value;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(217)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |      "either from address has insufficient token balance, or insufficient amount was approved for sender");
    |    balances[_to] += _value;
  > |    balances[_from] -= _value;
    |    allowed[_from][msg.sender] -= _value;
    |    emit Transfer(_from, _to, _value);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(218)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |  * FEE tokens do not have limit. A new token can be generated by owner.
    |  */
  > |contract Fee is HasOwners, Versioned, StandardToken {
    |
    |  /* This notifies clients about the amount burnt */
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(249)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |
    |  function setMinter(address _minter) external onlyOwner validAddress(_minter) {
  > |    minter = _minter;
    |  }
    |
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(273)

[31mViolation[0m for UnrestrictedWrite in contract 'Fee':
    |    require(balances[msg.sender] >= quantity, "insufficient quantity to burn");
    |    balances[msg.sender] = Math.minus(balances[msg.sender], quantity);
  > |    totalSupply = Math.minus(totalSupply, quantity);
    |    emit Burn(msg.sender, quantity);
    |  }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(281)

[33mWarning[0m for UnrestrictedWrite in contract 'Fee':
    |  /// @param quantity The amount o
    |  function sendTokens(address to, uint quantity) public onlyMinter validAddress(to) notZero(quantity) {
  > |    balances[to] = Math.plus(balances[to], quantity);
    |    totalSupply = Math.plus(totalSupply, quantity);
    |    emit Transfer(address(0), to, quantity);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(290)

[33mWarning[0m for UnrestrictedWrite in contract 'Fee':
    |  function sendTokens(address to, uint quantity) public onlyMinter validAddress(to) notZero(quantity) {
    |    balances[to] = Math.plus(balances[to], quantity);
  > |    totalSupply = Math.plus(totalSupply, quantity);
    |    emit Transfer(address(0), to, quantity);
    |  }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(291)

[31mViolation[0m for LockedEther in contract 'HasOwners':
    |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/HasOwners.sol
    |
  > |contract HasOwners is Validating {
    |
    |  mapping(address => bool) public isOwner;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(109)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |pragma solidity 0.5.3;
    |
  > |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/external/Token.sol
    |
    |/*
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/HasOwners.sol
    |
  > |contract HasOwners is Validating {
    |
    |  mapping(address => bool) public isOwner;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(109)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |  function _addOwner_(address owner) private validAddress(owner) {
    |    if (!isOwner[owner]) {
  > |      isOwner[owner] = true;
    |      owners.push(owner);
    |      emit OwnerAdded(owner);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(127)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |    if (!isOwner[owner]) {
    |      isOwner[owner] = true;
  > |      owners.push(owner);
    |      emit OwnerAdded(owner);
    |    }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(128)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |    if (isOwner[owner]) {
    |      require(owners.length > 1, "removing the last owner is not allowed");
  > |      isOwner[owner] = false;
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(137)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  > |          owners[i] = owners[owners.length - 1]; // replace map last entry
    |          delete owners[owners.length - 1];
    |          break;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(140)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |        if (owners[i] == owner) {
    |          owners[i] = owners[owners.length - 1]; // replace map last entry
  > |          delete owners[owners.length - 1];
    |          break;
    |        }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(141)

[31mViolation[0m for MissingInputValidation in contract 'StandardToken':
    |contract StandardToken is Token {
    |
  > |  function transfer(address _to, uint _value) public returns (bool success) {
    |    //Default assumes totalSupply can"t be over max (2^256 - 1).
    |    //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap.
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(200)

[31mViolation[0m for MissingInputValidation in contract 'StandardToken':
    |  }
    |
  > |  function transferFrom(address _from, address _to, uint _value) public returns (bool success) {
    |    //same as above. Replace this line map the following if you want to protect against wrapping uints.
    |    //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(212)

[31mViolation[0m for MissingInputValidation in contract 'StandardToken':
    |  }
    |
  > |  function balanceOf(address _owner) public view returns (uint balance) {
    |    return balances[_owner];
    |  }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(224)

[31mViolation[0m for MissingInputValidation in contract 'StandardToken':
    |  }
    |
  > |  function approve(address _spender, uint _value) public returns (bool success) {
    |    allowed[msg.sender][_spender] = _value;
    |    emit Approval(msg.sender, _spender, _value);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(228)

[31mViolation[0m for MissingInputValidation in contract 'StandardToken':
    |  }
    |
  > |  function allowance(address _owner, address _spender) public view returns (uint remaining) {
    |    return allowed[_owner][_spender];
    |  }
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(234)

[31mViolation[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(balances[msg.sender] >= _value, "sender has insufficient token balance");
    |    balances[msg.sender] -= _value;
  > |    balances[_to] += _value;
    |    emit Transfer(msg.sender, _to, _value);
    |    return true;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(207)

[31mViolation[0m for UnrestrictedWrite in contract 'StandardToken':
    |    require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value,
    |      "either from address has insufficient token balance, or insufficient amount was approved for sender");
  > |    balances[_to] += _value;
    |    balances[_from] -= _value;
    |    allowed[_from][msg.sender] -= _value;
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(217)

[31mViolation[0m for UnrestrictedWrite in contract 'StandardToken':
    |      "either from address has insufficient token balance, or insufficient amount was approved for sender");
    |    balances[_to] += _value;
  > |    balances[_from] -= _value;
    |    allowed[_from][msg.sender] -= _value;
    |    emit Transfer(_from, _to, _value);
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(218)

[31mViolation[0m for LockedEther in contract 'Versioned':
    |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/Versioned.sol
    |
  > |contract Versioned {
    |  string public version;
    |
  at /unique_contracts/0xef4224fbe45b60f661afbb6c7eb072eafc6d5621.sol(154)