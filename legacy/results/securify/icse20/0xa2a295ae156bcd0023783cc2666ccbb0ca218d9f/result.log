Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:Address
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:BlockchainCutiesERC1155
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle6805262605701838690/mustExplicit -j 1 -F /tmp/souffle-667dd4ba-b99d-4a1f-93f9-2cef13090ce5 -D /tmp/souffle-667dd4ba-b99d-4a1f-93f9-2cef13090ce5_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:BlockchainCutiesERC1155
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:CommonConstants
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC1155
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC1155Metadata_URI
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC1155MixedFungible
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC1155URIProvider
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC165
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC20
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC20Proxy
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:ERC721Proxy
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:IERC1155
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:IERC1155Mintable
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:IERC1155TokenReceiver
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:MintCallbackInterface
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:Operators
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol:SafeMath
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'ERC1155':
    |
    |// A sample implementation of core ERC1155 function.
  > |contract ERC1155 is IERC1155, ERC165, CommonConstants
    |{
    |    using SafeMath for uint256;
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(285)

[31mViolation[0m for UnhandledException in contract 'ERC1155':
    |    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {
    |
  > |        (bool success, bytes memory returnData) = _to.call(
    |            abi.encodeWithSignature(
    |                "onERC1155Received(address,address,uint256,uint256,bytes)",
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(467)

[31mViolation[0m for UnhandledException in contract 'ERC1155':
    |    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {
    |
  > |        (bool success, bytes memory returnData) = _to.call(
    |            abi.encodeWithSignature(
    |                "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)",
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(495)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155':
    |        // SafeMath will throw with insuficient funds _from
    |        // or if _id is not valid (balance will be 0)
  > |        balances[_id][_from] = balances[_id][_from].sub(_value);
    |        balances[_id][_to]   = _value.add(balances[_id][_to]);
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(348)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155':
    |        // or if _id is not valid (balance will be 0)
    |        balances[_id][_from] = balances[_id][_from].sub(_value);
  > |        balances[_id][_to]   = _value.add(balances[_id][_to]);
    |
    |        // MUST emit event
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(349)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155':
    |            // SafeMath will throw with insuficient funds _from
    |            // or if _id is not valid (balance will be 0)
  > |            balances[id][_from] = balances[id][_from].sub(value);
    |            balances[id][_to]   = value.add(balances[id][_to]);
    |        }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(390)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155':
    |            // or if _id is not valid (balance will be 0)
    |            balances[id][_from] = balances[id][_from].sub(value);
  > |            balances[id][_to]   = value.add(balances[id][_to]);
    |        }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(391)

[31mViolation[0m for LockedEther in contract 'ERC1155MixedFungible':
    |    creating a fungible id.
    |*/
  > |contract ERC1155MixedFungible is ERC1155 {
    |
    |    // Use a split bit implementation.
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(528)

[31mViolation[0m for UnhandledException in contract 'ERC1155MixedFungible':
    |    function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal {
    |
  > |        (bool success, bytes memory returnData) = _to.call(
    |            abi.encodeWithSignature(
    |                "onERC1155Received(address,address,uint256,uint256,bytes)",
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(467)

[31mViolation[0m for UnhandledException in contract 'ERC1155MixedFungible':
    |    function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal {
    |
  > |        (bool success, bytes memory returnData) = _to.call(
    |            abi.encodeWithSignature(
    |                "onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)",
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(495)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155MixedFungible':
    |        if (isNonFungible(_id)) {
    |            require(nfOwners[_id] == _from);
  > |            nfOwners[_id] = _to;
    |            // You could keep balance of NF type in base type id like so:
    |            // uint256 baseType = getNonFungibleBaseType(_id);
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(586)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155MixedFungible':
    |            onTransferNft(_from, _to, _id);
    |        } else {
  > |            balances[_id][_from] = balances[_id][_from].sub(_value);
    |            balances[_id][_to]   = balances[_id][_to].add(_value);
    |            onTransfer20(_from, _to, _id, _value);
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(593)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155MixedFungible':
    |        } else {
    |            balances[_id][_from] = balances[_id][_from].sub(_value);
  > |            balances[_id][_to]   = balances[_id][_to].add(_value);
    |            onTransfer20(_from, _to, _id, _value);
    |        }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(594)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155MixedFungible':
    |            if (isNonFungible(id)) {
    |                require(nfOwners[id] == _from);
  > |                nfOwners[id] = _to;
    |            } else {
    |                balances[id][_from] = balances[id][_from].sub(value);
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(627)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155MixedFungible':
    |                nfOwners[id] = _to;
    |            } else {
  > |                balances[id][_from] = balances[id][_from].sub(value);
    |                balances[id][_to]   = value.add(balances[id][_to]);
    |            }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(629)

[33mWarning[0m for UnrestrictedWrite in contract 'ERC1155MixedFungible':
    |            } else {
    |                balances[id][_from] = balances[id][_from].sub(value);
  > |                balances[id][_to]   = value.add(balances[id][_to]);
    |            }
    |        }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(630)

[31mViolation[0m for LockedEther in contract 'ERC1155URIProvider':
    |
    |
  > |contract ERC1155URIProvider is Operators
    |{
    |    string public staticUri;
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(736)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC1155URIProvider':
    |        require(_newOwner != address(0));
    |
  > |        ownerAddress[_newOwner] = true;
    |    }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(708)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC1155URIProvider':
    |
    |    function removeOwner(address _oldOwner) external onlyOwner {
  > |        delete(ownerAddress[_oldOwner]);
    |    }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(712)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC1155URIProvider':
    |        require(_newOperator != address(0));
    |
  > |        operatorAddress[_newOperator] = true;
    |    }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(727)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC1155URIProvider':
    |
    |    function removeOperator(address _oldOperator) external onlyOwner {
  > |        delete(operatorAddress[_oldOperator]);
    |    }
    |}
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(731)

[31mViolation[0m for UnrestrictedWrite in contract 'ERC1155URIProvider':
    |
    |
  > |contract ERC1155URIProvider is Operators
    |{
    |    string public staticUri;
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(736)

[31mViolation[0m for MissingInputValidation in contract 'Operators':
    |    }
    |
  > |    function isOwner(address _addr) public view returns (bool) {
    |        return ownerAddress[_addr];
    |    }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(701)

[31mViolation[0m for MissingInputValidation in contract 'Operators':
    |    }
    |
  > |    function removeOwner(address _oldOwner) external onlyOwner {
    |        delete(ownerAddress[_oldOwner]);
    |    }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(711)

[31mViolation[0m for MissingInputValidation in contract 'Operators':
    |    }
    |
  > |    function isOperator(address _addr) public view returns (bool) {
    |        return operatorAddress[_addr] || ownerAddress[_addr];
    |    }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(720)

[31mViolation[0m for MissingInputValidation in contract 'Operators':
    |    }
    |
  > |    function removeOperator(address _oldOperator) external onlyOwner {
    |        delete(operatorAddress[_oldOperator]);
    |    }
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(730)

[31mViolation[0m for UnrestrictedWrite in contract 'Operators':
    |        require(_newOwner != address(0));
    |
  > |        ownerAddress[_newOwner] = true;
    |    }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(708)

[31mViolation[0m for UnrestrictedWrite in contract 'Operators':
    |
    |    function removeOwner(address _oldOwner) external onlyOwner {
  > |        delete(ownerAddress[_oldOwner]);
    |    }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(712)

[31mViolation[0m for UnrestrictedWrite in contract 'Operators':
    |        require(_newOperator != address(0));
    |
  > |        operatorAddress[_newOperator] = true;
    |    }
    |
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(727)

[31mViolation[0m for UnrestrictedWrite in contract 'Operators':
    |
    |    function removeOperator(address _oldOperator) external onlyOwner {
  > |        delete(operatorAddress[_oldOperator]);
    |    }
    |}
  at /unique_contracts/0xa2a295ae156bcd0023783cc2666ccbb0ca218d9f.sol(731)