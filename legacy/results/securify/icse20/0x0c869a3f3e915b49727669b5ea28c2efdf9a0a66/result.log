Processing contract: /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol:ERC20Token
Processing contract: /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol:Meritocracy
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for RepeatedCall in contract 'Meritocracy':
    |                c.allocation = 0;
    |                // WARN: Should totalReceived and totalForfeited be zeroed-out?
  > |                token.transfer(c.addr, r); // Transfer any owed tokens to contributor
    |        }
    |        lastForfeit = block.timestamp;
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(356)

[31mViolation[0m for TODAmount in contract 'Meritocracy':
    |        // Body
    |        token.transfer(owner,  token.balanceOf(address(this)));
  > |        owner.transfer(address(this).balance);
    |        emit EscapeHatchTriggered(msg.sender);
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(367)

[31mViolation[0m for TODReceiver in contract 'Meritocracy':
    |        // Body
    |        token.transfer(owner,  token.balanceOf(address(this)));
  > |        owner.transfer(address(this).balance);
    |        emit EscapeHatchTriggered(msg.sender);
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(367)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |
    |/*
  > |Future Goals:
    |- remove admins necessity
    |- encourage contributors to allocate
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(4)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |}
    |
  > |contract Meritocracy {
    |
    |    struct Status {
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(78)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        // cAllocator.inPot = true;
    |        for (uint256 i = 0; i < registry.length; i++) {
  > |               contributors[registry[i]].allocation += individualAmount;
    |        }
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(159)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        });
    |
  > |        cReceiver.status.push(s); // Record the history
    |        emit ContributorTransaction(cSender.addr, cReceiver.addr);
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(209)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        // Body
    |        Contributor storage c = contributors[_contributor];
  > |        c.addr = _contributor;
    |        registry.push(_contributor);
    |        emit ContributorAdded(_contributor);
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(259)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        Contributor storage c = contributors[_contributor];
    |        c.addr = _contributor;
  > |        registry.push(_contributor);
    |        emit ContributorAdded(_contributor);
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(260)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        address c = registry[idx];
    |        // Swap & Pop!
  > |        registry[idx] = registry[registryLength];
    |        registry.pop();
    |        delete contributors[c]; // TODO check if this works
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(289)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        // Swap & Pop!
    |        registry[idx] = registry[registryLength];
  > |        registry.pop();
    |        delete contributors[c]; // TODO check if this works
    |        // Set new IPFS hash for the list
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(290)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        registry[idx] = registry[registryLength];
    |        registry.pop();
  > |        delete contributors[c]; // TODO check if this works
    |        // Set new IPFS hash for the list
    |        contributorListIPFSHash = _contributorListIPFSHash;
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(291)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        require(_maxContributors > registry.length); // have to removeContributor first
    |        // Body
  > |        maxContributors = _maxContributors;
    |        emit MaxContributorsChanged(maxContributors);
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(301)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        require(block.timestamp >= lastForfeit + 6 days); // prevents admins accidently calling too quickly.
    |        // Body
  > |        lastForfeit = block.timestamp;
    |        for (uint256 i = 0; i < registryLength; i++) { // should never be longer than maxContributors, see addContributor
    |                Contributor storage c = contributors[registry[i]];
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(312)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        for (uint256 i = 0; i < registryLength; i++) { // should never be longer than maxContributors, see addContributor
    |                Contributor storage c = contributors[registry[i]];
  > |                c.totalForfeited += c.allocation; // Shaaaaame!
    |                c.allocation = 0;
    |                // cReceiver.inPot = false; // Contributor has to put tokens into next round
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(315)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |                Contributor storage c = contributors[registry[i]];
    |                c.totalForfeited += c.allocation; // Shaaaaame!
  > |                c.allocation = 0;
    |                // cReceiver.inPot = false; // Contributor has to put tokens into next round
    |        }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(316)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |                Contributor storage c = contributors[registry[i]];
    |                uint256 r =  c.received;
  > |                c.received = 0;
    |                c.allocation = 0;
    |                // WARN: Should totalReceived and totalForfeited be zeroed-out?
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(353)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |                uint256 r =  c.received;
    |                c.received = 0;
  > |                c.allocation = 0;
    |                // WARN: Should totalReceived and totalForfeited be zeroed-out?
    |                token.transfer(c.addr, r); // Transfer any owed tokens to contributor
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(354)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |                token.transfer(c.addr, r); // Transfer any owed tokens to contributor
    |        }
  > |        lastForfeit = block.timestamp;
    |        token = ERC20Token(_token);
    |        emit TokenChanged(_token);
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(358)

[33mWarning[0m for UnrestrictedWrite in contract 'Meritocracy':
    |        }
    |        lastForfeit = block.timestamp;
  > |        token = ERC20Token(_token);
    |        emit TokenChanged(_token);
    |    }
  at /unique_contracts/0x0c869a3f3e915b49727669b5ea28c2efdf9a0a66.sol(359)