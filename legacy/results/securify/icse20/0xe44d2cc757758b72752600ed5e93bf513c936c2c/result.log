Processing contract: /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol:ECDSA
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol:IERC20
Processing contract: /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol:IndexedMerkleProof
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol:InstaLend
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol:QRToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol:SafeMath
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'InstaLend':
    |
    |
  > |contract InstaLend {
    |    using SafeMath for uint;
    |
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(194)

[31mViolation[0m for RepeatedCall in contract 'InstaLend':
    |        uint256[] memory prevAmounts = new uint256[](tokens.length);
    |        for (uint i = 0; i < tokens.length; i++) {
  > |            prevAmounts[i] = tokens[i].balanceOf(address(this));
    |            require(tokens[i].transfer(target, amounts[i]));
    |        }
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(233)

[31mViolation[0m for RepeatedCall in contract 'InstaLend':
    |        for (uint i = 0; i < tokens.length; i++) {
    |            prevAmounts[i] = tokens[i].balanceOf(address(this));
  > |            require(tokens[i].transfer(target, amounts[i]));
    |        }
    |
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(234)

[31mViolation[0m for RepeatedCall in contract 'InstaLend':
    |        for (uint i = 0; i < tokens.length; i++) {
    |            uint256 expectedFees = amounts[i].mul(_feesPercent).div(100);
  > |            require(tokens[i].balanceOf(address(this)) >= prevAmounts[i].add(expectedFees));
    |            if (_feesReceiver != address(this)) {
    |                require(tokens[i].transfer(_feesReceiver, expectedFees));
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(244)

[31mViolation[0m for RepeatedCall in contract 'InstaLend':
    |            require(tokens[i].balanceOf(address(this)) >= prevAmounts[i].add(expectedFees));
    |            if (_feesReceiver != address(this)) {
  > |                require(tokens[i].transfer(_feesReceiver, expectedFees));
    |            }
    |        }
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(246)

[33mWarning[0m for RepeatedCall in contract 'InstaLend':
    |
    |        // Perform arbitrary call
  > |        (bool res,) = target.call(data);    // solium-disable-line security/no-low-level-calls
    |        require(res, "Invalid arbitrary call");
    |
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(238)

[31mViolation[0m for UnrestrictedWrite in contract 'InstaLend':
    |        notInLendingMode
    |    {
  > |        _inLendingMode = true;
    |
    |        // Backup original balances and lend tokens
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(228)

[31mViolation[0m for UnrestrictedWrite in contract 'InstaLend':
    |        }
    |
  > |        _inLendingMode = false;
    |    }
    |}
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(250)

[31mViolation[0m for LockedEther in contract 'QRToken':
    |
    |
  > |contract QRToken is InstaLend {
    |    using SafeMath for uint;
    |    using ECDSA for bytes;
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(264)

[31mViolation[0m for RepeatedCall in contract 'QRToken':
    |        uint256[] memory prevAmounts = new uint256[](tokens.length);
    |        for (uint i = 0; i < tokens.length; i++) {
  > |            prevAmounts[i] = tokens[i].balanceOf(address(this));
    |            require(tokens[i].transfer(target, amounts[i]));
    |        }
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(233)

[31mViolation[0m for RepeatedCall in contract 'QRToken':
    |        for (uint i = 0; i < tokens.length; i++) {
    |            prevAmounts[i] = tokens[i].balanceOf(address(this));
  > |            require(tokens[i].transfer(target, amounts[i]));
    |        }
    |
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(234)

[31mViolation[0m for RepeatedCall in contract 'QRToken':
    |        for (uint i = 0; i < tokens.length; i++) {
    |            uint256 expectedFees = amounts[i].mul(_feesPercent).div(100);
  > |            require(tokens[i].balanceOf(address(this)) >= prevAmounts[i].add(expectedFees));
    |            if (_feesReceiver != address(this)) {
    |                require(tokens[i].transfer(_feesReceiver, expectedFees));
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(244)

[31mViolation[0m for RepeatedCall in contract 'QRToken':
    |            require(tokens[i].balanceOf(address(this)) >= prevAmounts[i].add(expectedFees));
    |            if (_feesReceiver != address(this)) {
  > |                require(tokens[i].transfer(_feesReceiver, expectedFees));
    |            }
    |        }
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(246)

[33mWarning[0m for RepeatedCall in contract 'QRToken':
    |
    |        // Perform arbitrary call
  > |        (bool res,) = target.call(data);    // solium-disable-line security/no-low-level-calls
    |        require(res, "Invalid arbitrary call");
    |
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(238)

[33mWarning[0m for RepeatedCall in contract 'QRToken':
    |
    |        distribution.bitMask[index / 32] = distribution.bitMask[index / 32] | (1 << (index % 32));
  > |        require(distribution.token.transfer(msg.sender, distribution.sumAmount.div(distribution.codesCount)));
    |        emit Redeemed(root, index, msg.sender);
    |    }
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(334)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        notInLendingMode
    |    {
  > |        _inLendingMode = true;
    |
    |        // Backup original balances and lend tokens
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(228)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |
    |
  > |contract QRToken is InstaLend {
    |    using SafeMath for uint;
    |    using ECDSA for bytes;
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(264)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        require(token.transferFrom(msg.sender, address(this), sumTokenAmount));
    |        Distribution storage distribution = distributions[root];
  > |        distribution.token = token;
    |        distribution.sumAmount = sumTokenAmount;
    |        distribution.codesCount = codesCount;
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(308)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        Distribution storage distribution = distributions[root];
    |        distribution.token = token;
  > |        distribution.sumAmount = sumTokenAmount;
    |        distribution.codesCount = codesCount;
    |        distribution.deadline = deadline;
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(309)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        distribution.token = token;
    |        distribution.sumAmount = sumTokenAmount;
  > |        distribution.codesCount = codesCount;
    |        distribution.deadline = deadline;
    |        distribution.sponsor = msg.sender;
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(310)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        distribution.sumAmount = sumTokenAmount;
    |        distribution.codesCount = codesCount;
  > |        distribution.deadline = deadline;
    |        distribution.sponsor = msg.sender;
    |    }
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(311)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        distribution.codesCount = codesCount;
    |        distribution.deadline = deadline;
  > |        distribution.sponsor = msg.sender;
    |    }
    |
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(312)

[31mViolation[0m for UnrestrictedWrite in contract 'QRToken':
    |        }
    |        require(distribution.token.transfer(distribution.sponsor, distribution.sumAmount.sub(count)));
  > |        delete distributions[root];
    |    }
    |}
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(375)

[33mWarning[0m for UnrestrictedWrite in contract 'QRToken':
    |        }
    |
  > |        _inLendingMode = false;
    |    }
    |}
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(250)

[33mWarning[0m for UnrestrictedWrite in contract 'QRToken':
    |        require(distribution.bitMask[index / 32] & (1 << (index % 32)) == 0);
    |
  > |        distribution.bitMask[index / 32] = distribution.bitMask[index / 32] | (1 << (index % 32));
    |        require(distribution.token.transfer(msg.sender, distribution.sumAmount.div(distribution.codesCount)));
    |        emit Redeemed(root, index, msg.sender);
  at /unique_chucks/24/0xe44d2cc757758b72752600ed5e93bf513c936c2c.sol(333)