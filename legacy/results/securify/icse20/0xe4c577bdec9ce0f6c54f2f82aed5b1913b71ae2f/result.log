Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:Address
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:AggregatedTokenSwap
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:ExternalCall
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:IERC20
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:IGST2
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:Ownable
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:SafeERC20
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:SafeMath
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol:TokenSpender
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |            let x := mload(0x40)   // "Allocate" memory for output (0x40 is where "free memory" pointer is stored by convention)
    |            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that
  > |            result := call(
    |                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting
    |                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(23)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |        // or when resetting it to zero. To increase and decrease it, use
    |        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'
  > |        require((value == 0) || (token.allowance(address(this), spender) == 0));
    |        callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));
    |    }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(253)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |
    |        // solhint-disable-next-line avoid-low-level-calls
  > |        (bool success, bytes memory returndata) = address(token).call(data);
    |        require(success);
    |
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(285)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |                if (
    |                    address(fromToken) != ETH_ADDRESS &&
  > |                    fromToken.allowance(address(this), callAddresses[i]) == 0
    |                ) {
    |
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(387)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |            require(address(this).balance >= minTokensAmount);
    |        } else {
  > |            require(toToken.balanceOf(address(this)) >= minTokensAmount);
    |        }
    |
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(406)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |        //
    |
  > |        require(gasTokenBalance == gasToken.balanceOf(address(this)));
    |        if (mintGasPrice > 0) {
    |            audoRefundGas(returnAmount, mintGasPrice);
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(411)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |            return who.balance;
    |        } else {
  > |            return token.balanceOf(who);
    |        }
    |    }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(439)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |        if (address(token) == ETH_ADDRESS || token == IERC20(0)) {
    |            if (allowFail) {
  > |                return to.send(amount);
    |            } else {
    |                to.transfer(amount);
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(446)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |                return to.send(amount);
    |            } else {
  > |                to.transfer(amount);
    |                return true;
    |            }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(448)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |            }
    |
  > |            uint gasTokenBalance = IERC20(address(gasToken)).balanceOf(address(this));
    |
    |            if (tokensAmount > 0 && gasTokenBalance >= tokensAmount) {
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(509)

[31mViolation[0m for RepeatedCall in contract 'AggregatedTokenSwap':
    |            if (tokensAmount > 0 && gasTokenBalance >= tokensAmount) {
    |
  > |                return gasToken.freeUpTo(tokensAmount);
    |            } else {
    |
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(513)

[31mViolation[0m for TODAmount in contract 'AggregatedTokenSwap':
    |        if (address(token) == ETH_ADDRESS || token == IERC20(0)) {
    |            if (allowFail) {
  > |                return to.send(amount);
    |            } else {
    |                to.transfer(amount);
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(446)

[31mViolation[0m for TODAmount in contract 'AggregatedTokenSwap':
    |                return to.send(amount);
    |            } else {
  > |                to.transfer(amount);
    |                return true;
    |            }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(448)

[31mViolation[0m for TODAmount in contract 'AggregatedTokenSwap':
    |            IERC20 _gasToken = IERC20(address(gasToken));
    |
  > |            owner.transfer(address(this).balance);
    |            _gasToken.safeTransfer(owner, _gasToken.balanceOf(address(this)));
    |        }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(530)

[33mWarning[0m for TODAmount in contract 'AggregatedTokenSwap':
    |            let x := mload(0x40)   // "Allocate" memory for output (0x40 is where "free memory" pointer is stored by convention)
    |            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that
  > |            result := call(
    |                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting
    |                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(23)

[33mWarning[0m for TODReceiver in contract 'AggregatedTokenSwap':
    |            let x := mload(0x40)   // "Allocate" memory for output (0x40 is where "free memory" pointer is stored by convention)
    |            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that
  > |            result := call(
    |                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting
    |                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(23)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AggregatedTokenSwap':
    |            let x := mload(0x40)   // "Allocate" memory for output (0x40 is where "free memory" pointer is stored by convention)
    |            let d := add(data, 32) // First 32 bytes are the padded length of data, so exclude that
  > |            result := call(
    |                sub(gas, 34710),   // 34710 is the value that solidity is currently emitting
    |                                   // It includes callGas (700) + callVeryLow (3, to pay for SUB) + callValueTransferGas (9000) +
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(23)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AggregatedTokenSwap':
    |        if (address(token) == ETH_ADDRESS || token == IERC20(0)) {
    |            if (allowFail) {
  > |                return to.send(amount);
    |            } else {
    |                to.transfer(amount);
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(446)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AggregatedTokenSwap':
    |                return to.send(amount);
    |            } else {
  > |                to.transfer(amount);
    |                return true;
    |            }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(448)

[33mWarning[0m for UnrestrictedEtherFlow in contract 'AggregatedTokenSwap':
    |            IERC20 _gasToken = IERC20(address(gasToken));
    |
  > |            owner.transfer(address(this).balance);
    |            _gasToken.safeTransfer(owner, _gasToken.balanceOf(address(this)));
    |        }
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(530)

[33mWarning[0m for UnrestrictedWrite in contract 'AggregatedTokenSwap':
    |    function setFee(uint _fee) public onlyOwner {
    |
  > |        fee = _fee;
    |    }
    |
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(352)

[31mViolation[0m for LockedEther in contract 'TokenSpender':
    |
    |
  > |contract TokenSpender is Ownable {
    |
    |    using SafeERC20 for IERC20;
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(296)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenSpender':
    |    function renounceOwnership() public onlyOwner {
    |        emit OwnershipTransferred(_owner, address(0));
  > |        _owner = address(0);
    |    }
    |
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(203)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenSpender':
    |        require(newOwner != address(0));
    |        emit OwnershipTransferred(_owner, newOwner);
  > |        _owner = newOwner;
    |    }
    |}
  at /unique_chucks/12/0xe4c577bdec9ce0f6c54f2f82aed5b1913b71ae2f.sol(221)