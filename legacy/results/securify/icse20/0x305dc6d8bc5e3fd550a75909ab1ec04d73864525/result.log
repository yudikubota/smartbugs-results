Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:Address
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:DxMgnPool
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
java.io.IOException: Timeout for /tmp/binaries_souffle5489777634286986512/mustExplicit -j 1 -F /tmp/souffle-59f60639-e3e8-42ff-966e-26d373536c86 -D /tmp/souffle-59f60639-e3e8-42ff-966e-26d373536c86_OUT
	at ch.securify.analysis.AbstractDataflow.runCommand(AbstractDataflow.java:277)
	at ch.securify.analysis.AbstractDataflow.initDataflow(AbstractDataflow.java:169)
	at ch.securify.analysis.MustExplicitDataflow.<init>(MustExplicitDataflow.java:33)
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:33)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error in Securify
java.lang.RuntimeException
	at ch.securify.analysis.Dataflow.<init>(Dataflow.java:37)
	at ch.securify.analysis.DataflowFactory.getDataflow(DataflowFactory.java:54)
	at ch.securify.Main.checkPatterns(Main.java:388)
	at ch.securify.Main.processHexFile(Main.java:189)
	at ch.securify.Main.processCompilationOutput(Main.java:129)
	at ch.securify.Main.processSolidityFile(Main.java:100)
	at ch.securify.Main.main(Main.java:254)
Error, skipping: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:DxMgnPool
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:ERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:ERC20Mintable
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:GnosisMath
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:GnosisStandardToken
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:IDutchExchange
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:IERC20
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:MinterRole
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:MockContract
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:MockInterface
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:Ownable
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:Proxied
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:Proxy
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:Roles
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:SafeERC20
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:SafeMath
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:StandardTokenData
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:Token
Processing contract: /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol:TokenFRT
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'GnosisMath':
    |/// @author Alan Lu - <alan.lu@gnosis.pm>
    |/// @author Stefan George - <stefan@gnosis.pm>
  > |library GnosisMath {
    |    /*
    |     *  Constants
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(943)

[33mWarning[0m for UnrestrictedWrite in contract 'GnosisStandardToken':
    |
    |        balances[msg.sender] -= value;
  > |        balances[to] += value;
    |        emit Transfer(msg.sender, to, value);
    |        return true;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1241)

[33mWarning[0m for UnrestrictedWrite in contract 'GnosisStandardToken':
    |            return false;
    |        }
  > |        balances[from] -= value;
    |        allowances[from][msg.sender] -= value;
    |        balances[to] += value;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1257)

[33mWarning[0m for UnrestrictedWrite in contract 'GnosisStandardToken':
    |        balances[from] -= value;
    |        allowances[from][msg.sender] -= value;
  > |        balances[to] += value;
    |        emit Transfer(from, to, value);
    |        return true;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1259)

[31mViolation[0m for LockedEther in contract 'MockContract':
    | * Implementation of the MockInterface.
    | */
  > |contract MockContract is MockInterface {
    |	enum MockType { Return, Revert, OutOfGas }
    |	
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(442)

[31mViolation[0m for UnhandledException in contract 'MockContract':
    |
    |		// Record invocation as separate call so we don't rollback in case we are called with STATICCALL
  > |		(, bytes memory r) = address(this).call.gas(100000)(abi.encodeWithSignature("updateInvocationCount(bytes4,bytes)", methodId, msg.data));
    |		assert(r.length == 0);
    |		
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(729)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    | * Implementation of the MockInterface.
    | */
  > |contract MockContract is MockInterface {
    |	enum MockType { Return, Revert, OutOfGas }
    |	
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(442)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |	function trackMethodIdMock(bytes4 methodId) private {
    |		if (methodIdMocks[methodId] == 0x0) {
  > |			methodIdMocks[methodId] = methodIdMocks[SENTINEL_ANY_MOCKS];
    |			methodIdMocks[SENTINEL_ANY_MOCKS] = methodId;
    |		}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(484)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		if (methodIdMocks[methodId] == 0x0) {
    |			methodIdMocks[methodId] = methodIdMocks[SENTINEL_ANY_MOCKS];
  > |			methodIdMocks[SENTINEL_ANY_MOCKS] = methodId;
    |		}
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(485)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function _givenAnyReturn(bytes memory response) internal {
  > |		fallbackMockType = MockType.Return;
    |		fallbackExpectation = response;
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(490)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function givenAnyRevert() external {
  > |		fallbackMockType = MockType.Revert;
    |		fallbackRevertMessage = "";
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(512)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function givenAnyRevertWithMessage(string calldata message) external {
  > |		fallbackMockType = MockType.Revert;
    |		fallbackRevertMessage = message;
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(517)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function givenAnyRunOutOfGas() external {
  > |		fallbackMockType = MockType.OutOfGas;
    |	}
    |
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(522)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function _givenCalldataReturn(bytes memory call, bytes memory response) private  {
  > |		calldataMockTypes[call] = MockType.Return;
    |		calldataExpectations[call] = response;
    |		trackCalldataMock(call);
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(526)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |	function _givenMethodReturn(bytes memory call, bytes memory response) private {
    |		bytes4 method = bytesToBytes4(call);
  > |		methodIdMockTypes[method] = MockType.Return;
    |		methodIdExpectations[method] = response;
    |		trackMethodIdMock(method);		
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(550)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function givenCalldataRevert(bytes calldata call) external {
  > |		calldataMockTypes[call] = MockType.Revert;
    |		calldataRevertMessage[call] = "";
    |		trackCalldataMock(call);
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(573)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |	function givenMethodRevert(bytes calldata call) external {
    |		bytes4 method = bytesToBytes4(call);
  > |		methodIdMockTypes[method] = MockType.Revert;
    |		trackMethodIdMock(method);		
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(580)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function givenCalldataRevertWithMessage(bytes calldata call, string calldata message) external {
  > |		calldataMockTypes[call] = MockType.Revert;
    |		calldataRevertMessage[call] = message;
    |		trackCalldataMock(call);
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(585)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |	function givenMethodRevertWithMessage(bytes calldata call, string calldata message) external {
    |		bytes4 method = bytesToBytes4(call);
  > |		methodIdMockTypes[method] = MockType.Revert;
    |		methodIdRevertMessages[method] = message;
    |		trackMethodIdMock(method);		
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(592)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |	function givenCalldataRunOutOfGas(bytes calldata call) external {
  > |		calldataMockTypes[call] = MockType.OutOfGas;
    |		trackCalldataMock(call);
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(598)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |	function givenMethodRunOutOfGas(bytes calldata call) external {
    |		bytes4 method = bytesToBytes4(call);
  > |		methodIdMockTypes[method] = MockType.OutOfGas;
    |		trackMethodIdMock(method);	
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(604)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		while(mockHash != MOCKS_LIST_END_HASH) {
    |			// Reset all mock maps
  > |			calldataMockTypes[nextMock] = MockType.Return;
    |			calldataExpectations[nextMock] = hex"";
    |			calldataRevertMessage[nextMock] = "";
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(628)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		while(nextAnyMock != SENTINEL_ANY_MOCKS) {
    |			bytes4 currentAnyMock = nextAnyMock;
  > |			methodIdMockTypes[currentAnyMock] = MockType.Return;
    |			methodIdExpectations[currentAnyMock] = hex"";
    |			methodIdRevertMessages[currentAnyMock] = "";
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(645)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |			nextAnyMock = methodIdMocks[currentAnyMock];
    |			// Remove from linked list
  > |			methodIdMocks[currentAnyMock] = 0x0;
    |		}
    |		// Clear list
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(650)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		}
    |		// Clear list
  > |		methodIdMocks[SENTINEL_ANY_MOCKS] = SENTINEL_ANY_MOCKS;
    |
    |		fallbackExpectation = "";
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(653)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |
    |		fallbackExpectation = "";
  > |		fallbackMockType = MockType.Return;
    |		invocations = 0;
    |		resetCount += 1;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(656)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		fallbackExpectation = "";
    |		fallbackMockType = MockType.Return;
  > |		invocations = 0;
    |		resetCount += 1;
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(657)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		fallbackMockType = MockType.Return;
    |		invocations = 0;
  > |		resetCount += 1;
    |	}
    |
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(658)

[31mViolation[0m for UnrestrictedWrite in contract 'MockContract':
    |		invocations += 1;
    |		methodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;
  > |		calldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;
    |	}
    |
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(688)

[33mWarning[0m for UnrestrictedWrite in contract 'MockContract':
    |	function updateInvocationCount(bytes4 methodId, bytes memory originalMsgData) public {
    |		require(msg.sender == address(this), "Can only be called from the contract itself");
  > |		invocations += 1;
    |		methodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;
    |		calldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(686)

[33mWarning[0m for UnrestrictedWrite in contract 'MockContract':
    |		require(msg.sender == address(this), "Can only be called from the contract itself");
    |		invocations += 1;
  > |		methodIdInvocations[keccak256(abi.encodePacked(resetCount, methodId))] += 1;
    |		calldataInvocations[keccak256(abi.encodePacked(resetCount, originalMsgData))] += 1;
    |	}
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(687)

[31mViolation[0m for LockedEther in contract 'TokenFRT':
    |
    |/// @title Standard token contract with overflow protection
  > |contract TokenFRT is Proxied, GnosisStandardToken {
    |    address public owner;
    |
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1304)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenFRT':
    |
    |        balances[msg.sender] -= value;
  > |        balances[to] += value;
    |        emit Transfer(msg.sender, to, value);
    |        return true;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1241)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenFRT':
    |            return false;
    |        }
  > |        balances[from] -= value;
    |        allowances[from][msg.sender] -= value;
    |        balances[to] += value;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1257)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenFRT':
    |        balances[from] -= value;
    |        allowances[from][msg.sender] -= value;
  > |        balances[to] += value;
    |        emit Transfer(from, to, value);
    |        return true;
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1259)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenFRT':
    |        require(_minter != address(0), "The new minter must be a valid address");
    |
  > |        minter = _minter;
    |    }
    |
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1337)

[33mWarning[0m for UnrestrictedWrite in contract 'TokenFRT':
    |        require(msg.sender == owner, "Only the owner can update the owner");
    |        require(_owner != address(0), "The new owner must be a valid address");
  > |        owner = _owner;
    |    }
    |
  at /unique_contracts/0x305dc6d8bc5e3fd550a75909ab1ec04d73864525.sol(1345)