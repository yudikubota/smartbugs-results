Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Custodian
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Depositing
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:HasOwners
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Ledger
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:MerkleProof
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Stoppable
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Token
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Validating
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Versioned
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol:Withdrawing
[33mWarning[0m for LockedEther in contract 'Custodian':
    |// File: contracts/custodian/Custodian.sol
    |
  > |contract Custodian is Stoppable, HasOwners, MerkleProof, Ledger, Depositing, Withdrawing, Versioned {
    |
    |  address public constant ETH = address(0x0);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(476)

[31mViolation[0m for RepeatedCall in contract 'Custodian':
    |    uint balanceBefore = Token(token).balanceOf(address(this));
    |    require(Token(token).transferFrom(msg.sender, address(this), quantity), "failure to transfer quantity from token");
  > |    uint balanceAfter = Token(token).balanceOf(address(this));
    |    require(balanceAfter - balanceBefore == quantity, "bad Token; transferFrom erroneously reported of successful transfer");
    |    deposit(msg.sender, token, quantity);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(549)

[33mWarning[0m for TODAmount in contract 'Custodian':
    |  function transfer(uint quantity, address asset, address account) internal {
    |    asset == ETH ?
  > |      require(address(uint160(account)).send(quantity), "failed to transfer ether") : // explicit casting to `address payable`
    |      require(Token(asset).transfer(account, quantity), "failed to transfer token");
    |  }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(499)

[33mWarning[0m for TODReceiver in contract 'Custodian':
    |  function transfer(uint quantity, address asset, address account) internal {
    |    asset == ETH ?
  > |      require(address(uint160(account)).send(quantity), "failed to transfer ether") : // explicit casting to `address payable`
    |      require(Token(asset).transfer(account, quantity), "failed to transfer token");
    |  }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(499)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |pragma solidity 0.5.3;
    |
  > |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/external/Token.sol
    |
    |/*
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(3)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |  function switchOff() external onlyOwner {
    |    if (isOn) {
  > |      isOn = false;
    |      emit Off();
    |    }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(141)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |  function _addOwner_(address owner) private validAddress(owner) {
    |    if (!isOwner[owner]) {
  > |      isOwner[owner] = true;
    |      owners.push(owner);
    |      emit OwnerAdded(owner);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(178)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |    if (!isOwner[owner]) {
    |      isOwner[owner] = true;
  > |      owners.push(owner);
    |      emit OwnerAdded(owner);
    |    }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(179)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |    if (isOwner[owner]) {
    |      require(owners.length > 1, "removing the last owner is not allowed");
  > |      isOwner[owner] = false;
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(188)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  > |          owners[i] = owners[owners.length - 1]; // replace map last entry
    |          delete owners[owners.length - 1];
    |          break;
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(191)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |        if (owners[i] == owner) {
    |          owners[i] = owners[owners.length - 1]; // replace map last entry
  > |          delete owners[owners.length - 1];
    |          break;
    |        }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(192)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |// File: contracts/custodian/Custodian.sol
    |
  > |contract Custodian is Stoppable, HasOwners, MerkleProof, Ledger, Depositing, Withdrawing, Versioned {
    |
    |  address public constant ETH = address(0x0);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(476)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |
    |  function deposit(address account, address asset, uint quantity) private whenOn {
  > |    uint nonce = ++nonceGenerator;
    |    uint designatedGblock = currentGblockNumber + visibilityDelay;
    |    DepositCommitmentRecord memory record = toDepositCommitmentRecord(account, asset, quantity, nonce, designatedGblock);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(555)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |    require(canExit(entryHash), "no prior claim found to withdraw OR balances are yet to be confirmed");
    |    require(proveInUnconfirmedBalances(proof, root, entryHash), "invalid balance proof");
  > |    delete exitClaims[entryHash];
    |    _exit_(claim.entry);
    |  }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(698)

[33mWarning[0m for UnrestrictedWrite in contract 'Custodian':
    |  function _exit_(Entry memory entry) private {
    |    require(!hasExited(entry.account, entry.asset), "previously exited");
  > |    exited[entry.account][entry.asset] = true;
    |    transfer(entry.balance, entry.asset, entry.account);
    |    emit Exited(entry.account, entry.asset, entry.balance);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(718)

[31mViolation[0m for LockedEther in contract 'HasOwners':
    |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/HasOwners.sol
    |
  > |contract HasOwners is Validating {
    |
    |  mapping(address => bool) public isOwner;
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(160)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |pragma solidity 0.5.3;
    |
  > |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/external/Token.sol
    |
    |/*
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(3)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/HasOwners.sol
    |
  > |contract HasOwners is Validating {
    |
    |  mapping(address => bool) public isOwner;
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(160)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |  function _addOwner_(address owner) private validAddress(owner) {
    |    if (!isOwner[owner]) {
  > |      isOwner[owner] = true;
    |      owners.push(owner);
    |      emit OwnerAdded(owner);
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(178)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |    if (!isOwner[owner]) {
    |      isOwner[owner] = true;
  > |      owners.push(owner);
    |      emit OwnerAdded(owner);
    |    }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(179)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |    if (isOwner[owner]) {
    |      require(owners.length > 1, "removing the last owner is not allowed");
  > |      isOwner[owner] = false;
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(188)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |      for (uint i = 0; i < owners.length - 1; i++) {
    |        if (owners[i] == owner) {
  > |          owners[i] = owners[owners.length - 1]; // replace map last entry
    |          delete owners[owners.length - 1];
    |          break;
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(191)

[31mViolation[0m for UnrestrictedWrite in contract 'HasOwners':
    |        if (owners[i] == owner) {
    |          owners[i] = owners[owners.length - 1]; // replace map last entry
  > |          delete owners[owners.length - 1];
    |          break;
    |        }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(192)

[33mWarning[0m for MissingInputValidation in contract 'MerkleProof':
    |   * Based on https://github.com/ameensol/merkle-tree-solidity/src/MerkleProof.sol
    |   */
  > |  function checkProof(bytes memory proof, bytes32 root, bytes32 leaf) public pure returns (bool) {
    |    if (proof.length % 32 != 0) return false; // Check if proof is made of bytes32 slices
    |
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(64)

[33mWarning[0m for MissingInputValidation in contract 'MerkleProof':
    |
    |  // from StorJ -- https://github.com/nginnever/storj-audit-verifier/contracts/MerkleVerifyv3.sol
  > |  function checkProofOrdered(bytes memory proof, bytes32 root, bytes32 leaf, uint index) public pure returns (bool) {
    |    if (proof.length % 32 != 0) return false; // Check if proof is made of bytes32 slices
    |
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(81)

[33mWarning[0m for MissingInputValidation in contract 'MerkleProof':
    |
    |  /** Verifies the inclusion of a leaf in a Merkle tree using a Merkle proof */
  > |  function verifyIncluded(bytes memory proof, bytes32 root, bytes32 leaf) public pure returns (bool) {
    |    return checkProof(proof, root, leaf);
    |  }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(115)

[33mWarning[0m for MissingInputValidation in contract 'MerkleProof':
    |
    |  /** Verifies the inclusion of a leaf is at a specific place in an ordered Merkle tree using a Merkle proof */
  > |  function verifyIncludedAtIndex(bytes memory proof, bytes32 root, bytes32 leaf, uint index) public pure returns (bool) {
    |    return checkProofOrdered(proof, root, leaf, index);
    |  }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(120)

[31mViolation[0m for UnrestrictedWrite in contract 'Stoppable':
    |  function switchOff() external onlyOwner {
    |    if (isOn) {
  > |      isOn = false;
    |      emit Off();
    |    }
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(141)

[31mViolation[0m for LockedEther in contract 'Versioned':
    |// File: /private/var/folders/2q/x2n3s2rx0d16552ynj1lx90r0000gn/T/tmp.ODkPvI0P/gluon-plasma/packages/on-chain/contracts/Versioned.sol
    |
  > |contract Versioned {
    |  string public version;
    |
  at /unique_chucks/2/0xce00901a0638d758d6f89d59dfa32120d2259b0c.sol(205)