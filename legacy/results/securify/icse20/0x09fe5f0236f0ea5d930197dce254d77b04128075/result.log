Processing contract: /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol:ERC20
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol:IERC20
Processing contract: /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol:KittyCore
Processing contract: /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol:ReentrancyGuard
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol:SafeMath
  Attempt to decompile the contract with methods...
  Success. Inlining methods...
  Propagating constants...
  Verifying patterns...
Processing contract: /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol:WrappedCK
  Attempt to decompile the contract with methods...
  Failed to decompile methods. Attempt to decompile the contract without identifying methods...
  Propagating constants...
  Verifying patterns...
[31mViolation[0m for LockedEther in contract 'WrappedCK':
    |///  no information about which kitty was originally deposited to mint WCK - this is due to the very nature of 
    |///  the ERC20 standard being fungible, and the ERC721 standard being nonfungible.
  > |contract WrappedCK is ERC20, ReentrancyGuard {
    |
    |    // OpenZeppelin's SafeMath library is used for all arithmetic operations to avoid overflows/underflows.
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(317)

[31mViolation[0m for RepeatedCall in contract 'WrappedCK':
    |        for(uint i = 0; i < _kittyIds.length; i++){
    |            uint256 kittyToDeposit = _kittyIds[i];
  > |            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');
    |            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');
    |            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(393)

[31mViolation[0m for RepeatedCall in contract 'WrappedCK':
    |            uint256 kittyToDeposit = _kittyIds[i];
    |            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');
  > |            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');
    |            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);
    |            _pushKitty(kittyToDeposit);
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(394)

[31mViolation[0m for RepeatedCall in contract 'WrappedCK':
    |            require(msg.sender == kittyCore.ownerOf(kittyToDeposit), 'you do not own this cat');
    |            require(kittyCore.kittyIndexToApproved(kittyToDeposit) == address(this), 'you must approve() this contract to give it permission to withdraw this cat before you can deposit a cat');
  > |            kittyCore.transferFrom(msg.sender, address(this), kittyToDeposit);
    |            _pushKitty(kittyToDeposit);
    |            emit DepositKittyAndMintToken(kittyToDeposit);
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(395)

[31mViolation[0m for RepeatedCall in contract 'WrappedCK':
    |            } else {
    |                require(kittyIsDepositedInContract[kittyToWithdraw] == true, 'this kitty has already been withdrawn');
  > |                require(address(this) == kittyCore.ownerOf(kittyToWithdraw), 'the contract does not own this cat');
    |                kittyIsDepositedInContract[kittyToWithdraw] = false;
    |            }
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(422)

[31mViolation[0m for RepeatedCall in contract 'WrappedCK':
    |                kittyIsDepositedInContract[kittyToWithdraw] = false;
    |            }
  > |            kittyCore.transfer(_destinationAddresses[i], kittyToWithdraw);
    |            emit BurnTokenAndWithdrawKitty(kittyToWithdraw);
    |        }
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(425)

[33mWarning[0m for UnrestrictedWrite in contract 'WrappedCK':
    |     */
    |    modifier nonReentrant() {
  > |        _guardCounter += 1;
    |        uint256 localCounter = _guardCounter;
    |        _;
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(299)

[33mWarning[0m for UnrestrictedWrite in contract 'WrappedCK':
    |///  no information about which kitty was originally deposited to mint WCK - this is due to the very nature of 
    |///  the ERC20 standard being fungible, and the ERC721 standard being nonfungible.
  > |contract WrappedCK is ERC20, ReentrancyGuard {
    |
    |    // OpenZeppelin's SafeMath library is used for all arithmetic operations to avoid overflows/underflows.
  at /unique_chucks/6/0x09fe5f0236f0ea5d930197dce254d77b04128075.sol(317)