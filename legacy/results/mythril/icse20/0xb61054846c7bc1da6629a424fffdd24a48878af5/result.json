{
  "contract": "0xb61054846c7bc1da6629a424fffdd24a48878af5",
  "tool": "mythril",
  "start": 1563549717.3277624,
  "end": 1563550013.0939457,
  "duration": 295.76618337631226,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 970,
        "code": "n ChangeItemOwnerID(uint256 _id, uint2",
        "debug": "mem_320 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Universe_4 + calldata_Universe_4)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_Universe_32 + 4: 0x38d7ea4c68000\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_21: 0x0\ncalldata_Universe_0: 0x7da14ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_Universe: 0x4\nstorage_2 + keccac_storage_20: 0x0\ncalldata_Universe_32 + 36: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AddItem(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xb61054846c7bc1da6629a424fffdd24a48878af5.sol",
        "function": "AddItem(string,uint256,uint256)",
        "lineno": 107,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2214,
        "code": "           \n          \n      ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Universe_4: 0xffffffffffffffffffffffffffff\ncalldata_Universe_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffff73fffffffffffffffffffff\nstorage_0: 0x0\nstorage_20: 0x0\ncaller: 0x0\nstorage_21: 0x0\ncalldata_Universe_0: 0x898ce10c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Universe: 0x4\nstorage_3 + keccac_calldata_Universe_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0xb61054846c7bc1da6629a424fffdd24a48878af5.sol",
        "function": "ChangeItemOwnerID(uint256,uint256)",
        "lineno": 122,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3502,
        "code": "ntract Universe{\n    // Universe contract\n    // It is possible to buy planets or other universe-objects from other accounts.\n    // If an object has an owner, fees will be paid to that owner until no owner has been found.\n    \n    struct Item{\n        uint256 id;\n        string name;\n        uint256 price;\n        uint256 id_owner;\n        address owner;\n    }\n    \n   // bool TESTMODE = true;\n    \n  //  event pushuint(uint256 push);\n //   event pushstr(string str);\n  //  event pusha(address addr);\n    \n    uint256[4] LevelLimits = [0.05 ether, 0.5 ether, 2 ether, 5 ether];\n    uint256[5] devFee = [5,4,3,2,2];\n    uint256[5] shareFee = [12,6,4,3,2];\n    uint256[5] raisePrice = [100, 35, 25, 17, 15];\n    \n    \n    mapping (uint256 => Item) public ItemList;\n    uint256 public current_item_index=1;\n    \n    address owner;\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    function Universe() public{\n        owner=msg.sender;\n        AddItem(\"Sun\", 1 finney, 0);\n        AddItem(\"Mercury\", 1 finney, 1);\n        AddItem(\"Venus\", 1 finney, 1);\n        AddItem(\"Earth\", 1 finney, 1);\n        AddItem(\"Mars\", 1 finney, 1);\n        AddItem(\"Jupiter\", 1 finney, 1);\n        AddItem(\"Saturn\", 1 finney, 1);\n        AddItem(\"Uranus\", 1 finney, 1);\n        AddItem(\"Neptune\", 1  finney, 1);\n        AddItem(\"Pluto\", 1 finney, 1);\n        AddItem(\"Moon\", 1 finney, 4);\n    }\n    \n    function CheckItemExists(uint256 _id) internal returns (bool boolean){\n        if (ItemList[_id].price == 0){\n            return false;\n        }\n        return true;\n    }\n\n    \n //   function AddItem(string _name, uint256 _price, uint256 _id_owner) public {\n    function AddItem(string _name, uint256 _price, uint256 _id_owner) public onlyOwner {\n//if (TESTMODE){\n//if (_price < (1 finney)){\n  //              _price = (1 finney);\n    //        }\n//}\n        //require(_id != 0);\n        //require(_id == current_item_index);\n        uint256 _id = current_item_index;\n\n        require(_id_owner != _id);\n        require(_id_owner < _id);\n\n        require(_price >= (1 finney));\n        require(_id_owner == 0 || CheckItemExists(_id_owner));\n        require(CheckItemExists(_id) != true);\n        \n     //   uint256 current_id_owner = _id_owner;\n        \n     //   uint256[] mem_owner;\n        \n        //pushuint(mem_owner.length);\n        \n        /*while (current_id_owner != 0){\n           \n            mem_owner[mem_owner.length-1] = current_id_owner;\n            current_id_owner = ItemList[current_id_owner].id_owner;\n            \n          \n            for(uint256 c=0; c<mem_owner.length; c++){\n               if(c != (mem_owner.length-1)){\n                   if(mem_owner[c] == current_id_owner){\n                        pushstr(\"false\");\n                        return;\n                    }\n                }\n            }\n            mem_owner.length += 1;\n        }*/\n        \n        var NewItem = Item(_id, _name, _price, _id_owner, owner);\n        ItemList[current_item_index] = NewItem;\n        current_item_index++;\n        \n    }\n    \n    function ChangeItemOwnerID(uint256 _id, uint256 _new_owner) public onlyOwner {\n        require(_new_owner != _id);\n        require(_id <= (current_item_index-1));\n        require(_id != 0);\n        require(_new_owner != 0);\n        require(_new_owner <= (current_item_index-1));\n        require(ItemList[_id].id_owner == 0);\n       \n        uint256 current_id_owner = _new_owner;\n        uint256[] mem_owner;   \n        \n         while (current_id_owner != 0){\n           \n            mem_owner[mem_owner.length-1] = current_id_owner;\n            current_id_owner = ItemList[current_id_owner].id_owner;\n            \n          \n            for(uint256 c=0; c<mem_owner.length; c++){\n               if(c != (mem_owner.length-1)){\n                   if(mem_owner[c] == current_id_owner || mem_owner[c] == _new_owner || mem_owner[c] == _id){\n//pushstr(\"false\");\n                        return;\n                    }\n                }\n            }\n            mem_owner.length += 1;\n        }  \n        \n        ItemList[_id].id_owner = _new_owner;\n        \n    }\n\n    function DoDividend(uint256 _current_index, uint256 valueShareFee, uint256 id_owner) internal returns (uint256){\n            uint256 pow = 0;\n            uint256 totalShareFee = 0;\n            uint256 current_index = _current_index;\n            while (current_index != 0){\n                pow = pow + 1;\n                current_index = ItemList[current_index].id_owner;\n            }\n        \n            uint256 total_sum = 0;\n        \n            for (uint256 c2=0; c2<pow; c2++){\n                total_sum = total_sum + 2**c2;\n            }\n        \n            if (total_sum != 0){\n               // uint256 tot_value = 2**(pow-1);\n        \n                current_index = id_owner;\n        \n                while (current_index != 0){\n                    uint256 amount = div(mul(valueShareFee, 2**(pow-1)), total_sum);\n                    totalShareFee = add(amount, totalShareFee);\n                    ItemList[current_index].owner.transfer(amount);\n                //    pusha(ItemList[current_index].owner);\n                 //   pushuint(amount);\n                    \n                    pow = sub(pow, 1);\n                    current_index = ItemList[current_index].id_owner;\n                }\n            }\n            else{\n                ItemList[current_index].owner.transfer(valueShareFee);\n            //    pusha(ItemList[current_index].owner);\n             //   pushuint(valueShareFee);\n                totalShareFee = valueShareFee;\n            }\n            return totalShareFee;\n    }    \n    \n    function BuyItem(uint256 _id) public payable{\n        require(_id > 0 && _id < current_item_index);\n        var TheItem = ItemList[_id];\n        require(TheItem.owner != msg.sender);\n        require(msg.value >= TheItem.price);\n    \n        uint256 index=0;\n        \n        for (uint256 c=0; c<LevelLimits.length; c++){\n            uint256 value = LevelLimits[c];\n            if (TheItem.price < value){\n                break;\n            }\n            index++;\n        }\n        \n        uint256 valueShareFee = div(mul(TheItem.price, shareFee[index]), 100);\n        uint256 totalShareFee = 0;\n        uint256 valueDevFee = div(mul(TheItem.price, devFee[index]), 100);\n        uint256 valueRaisePrice = div(mul(TheItem.price, 100 + raisePrice[index]), 100);\n        \n        uint256 current_index = TheItem.id_owner;\n        \n        if (current_index != 0){\n            totalShareFee = DoDividend(current_index, valueShareFee, current_index);\n        }\n        \n        owner.transfer(valueDevFee);\n        \n      //  pushstr(\"dev\");\n      //  pushuint(valueDevFee);\n        \n        \n        uint256 totalToOwner = sub(sub(TheItem.price, valueDevFee), totalShareFee);\n        \n        uint256 totalBack = sub(sub(sub(msg.value, totalToOwner), valueDevFee), totalShareFee);\n        \n        if (totalBack > 0){\n            msg.sender.transfer(totalBack);\n        }\n        \n       // pushstr(\"owner transfer\");\n       // pushuint(totalToOwner);\n        TheItem.owner.transfer(totalToOwner);\n        \n        TheItem.owner = msg.sender;\n        TheItem.price = valueRaisePrice;\n    }\n    \n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n         return 0;\n      }\n      uint256 c = a * b;\n      assert(c / a == b);\n      return c;\n   }\n\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\n      uint256 c = a / b;\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n      return c;\n   }\n\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n   }\n\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n   }\n    \n}",
        "debug": "keccac_1_+_keccac_storage_20: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 + keccac_storage_20: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_Universe_32 + 4: 0x38d7ea4c68000\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_21: 0x0\ncalldata_Universe_0: 0x7da14ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_Universe: 0x4\nstorage_2 + keccac_storage_20: 0x0\ncalldata_Universe_32 + 36: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AddItem(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xb61054846c7bc1da6629a424fffdd24a48878af5.sol",
        "function": "AddItem(string,uint256,uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3531,
        "code": "ntract Universe{\n    // Universe contract\n    // It is possible to buy planets or other universe-objects from other accounts.\n    // If an object has an owner, fees will be paid to that owner until no owner has been found.\n    \n    struct Item{\n        uint256 id;\n        string name;\n        uint256 price;\n        uint256 id_owner;\n        address owner;\n    }\n    \n   // bool TESTMODE = true;\n    \n  //  event pushuint(uint256 push);\n //   event pushstr(string str);\n  //  event pusha(address addr);\n    \n    uint256[4] LevelLimits = [0.05 ether, 0.5 ether, 2 ether, 5 ether];\n    uint256[5] devFee = [5,4,3,2,2];\n    uint256[5] shareFee = [12,6,4,3,2];\n    uint256[5] raisePrice = [100, 35, 25, 17, 15];\n    \n    \n    mapping (uint256 => Item) public ItemList;\n    uint256 public current_item_index=1;\n    \n    address owner;\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    function Universe() public{\n        owner=msg.sender;\n        AddItem(\"Sun\", 1 finney, 0);\n        AddItem(\"Mercury\", 1 finney, 1);\n        AddItem(\"Venus\", 1 finney, 1);\n        AddItem(\"Earth\", 1 finney, 1);\n        AddItem(\"Mars\", 1 finney, 1);\n        AddItem(\"Jupiter\", 1 finney, 1);\n        AddItem(\"Saturn\", 1 finney, 1);\n        AddItem(\"Uranus\", 1 finney, 1);\n        AddItem(\"Neptune\", 1  finney, 1);\n        AddItem(\"Pluto\", 1 finney, 1);\n        AddItem(\"Moon\", 1 finney, 4);\n    }\n    \n    function CheckItemExists(uint256 _id) internal returns (bool boolean){\n        if (ItemList[_id].price == 0){\n            return false;\n        }\n        return true;\n    }\n\n    \n //   function AddItem(string _name, uint256 _price, uint256 _id_owner) public {\n    function AddItem(string _name, uint256 _price, uint256 _id_owner) public onlyOwner {\n//if (TESTMODE){\n//if (_price < (1 finney)){\n  //              _price = (1 finney);\n    //        }\n//}\n        //require(_id != 0);\n        //require(_id == current_item_index);\n        uint256 _id = current_item_index;\n\n        require(_id_owner != _id);\n        require(_id_owner < _id);\n\n        require(_price >= (1 finney));\n        require(_id_owner == 0 || CheckItemExists(_id_owner));\n        require(CheckItemExists(_id) != true);\n        \n     //   uint256 current_id_owner = _id_owner;\n        \n     //   uint256[] mem_owner;\n        \n        //pushuint(mem_owner.length);\n        \n        /*while (current_id_owner != 0){\n           \n            mem_owner[mem_owner.length-1] = current_id_owner;\n            current_id_owner = ItemList[current_id_owner].id_owner;\n            \n          \n            for(uint256 c=0; c<mem_owner.length; c++){\n               if(c != (mem_owner.length-1)){\n                   if(mem_owner[c] == current_id_owner){\n                        pushstr(\"false\");\n                        return;\n                    }\n                }\n            }\n            mem_owner.length += 1;\n        }*/\n        \n        var NewItem = Item(_id, _name, _price, _id_owner, owner);\n        ItemList[current_item_index] = NewItem;\n        current_item_index++;\n        \n    }\n    \n    function ChangeItemOwnerID(uint256 _id, uint256 _new_owner) public onlyOwner {\n        require(_new_owner != _id);\n        require(_id <= (current_item_index-1));\n        require(_id != 0);\n        require(_new_owner != 0);\n        require(_new_owner <= (current_item_index-1));\n        require(ItemList[_id].id_owner == 0);\n       \n        uint256 current_id_owner = _new_owner;\n        uint256[] mem_owner;   \n        \n         while (current_id_owner != 0){\n           \n            mem_owner[mem_owner.length-1] = current_id_owner;\n            current_id_owner = ItemList[current_id_owner].id_owner;\n            \n          \n            for(uint256 c=0; c<mem_owner.length; c++){\n               if(c != (mem_owner.length-1)){\n                   if(mem_owner[c] == current_id_owner || mem_owner[c] == _new_owner || mem_owner[c] == _id){\n//pushstr(\"false\");\n                        return;\n                    }\n                }\n            }\n            mem_owner.length += 1;\n        }  \n        \n        ItemList[_id].id_owner = _new_owner;\n        \n    }\n\n    function DoDividend(uint256 _current_index, uint256 valueShareFee, uint256 id_owner) internal returns (uint256){\n            uint256 pow = 0;\n            uint256 totalShareFee = 0;\n            uint256 current_index = _current_index;\n            while (current_index != 0){\n                pow = pow + 1;\n                current_index = ItemList[current_index].id_owner;\n            }\n        \n            uint256 total_sum = 0;\n        \n            for (uint256 c2=0; c2<pow; c2++){\n                total_sum = total_sum + 2**c2;\n            }\n        \n            if (total_sum != 0){\n               // uint256 tot_value = 2**(pow-1);\n        \n                current_index = id_owner;\n        \n                while (current_index != 0){\n                    uint256 amount = div(mul(valueShareFee, 2**(pow-1)), total_sum);\n                    totalShareFee = add(amount, totalShareFee);\n                    ItemList[current_index].owner.transfer(amount);\n                //    pusha(ItemList[current_index].owner);\n                 //   pushuint(amount);\n                    \n                    pow = sub(pow, 1);\n                    current_index = ItemList[current_index].id_owner;\n                }\n            }\n            else{\n                ItemList[current_index].owner.transfer(valueShareFee);\n            //    pusha(ItemList[current_index].owner);\n             //   pushuint(valueShareFee);\n                totalShareFee = valueShareFee;\n            }\n            return totalShareFee;\n    }    \n    \n    function BuyItem(uint256 _id) public payable{\n        require(_id > 0 && _id < current_item_index);\n        var TheItem = ItemList[_id];\n        require(TheItem.owner != msg.sender);\n        require(msg.value >= TheItem.price);\n    \n        uint256 index=0;\n        \n        for (uint256 c=0; c<LevelLimits.length; c++){\n            uint256 value = LevelLimits[c];\n            if (TheItem.price < value){\n                break;\n            }\n            index++;\n        }\n        \n        uint256 valueShareFee = div(mul(TheItem.price, shareFee[index]), 100);\n        uint256 totalShareFee = 0;\n        uint256 valueDevFee = div(mul(TheItem.price, devFee[index]), 100);\n        uint256 valueRaisePrice = div(mul(TheItem.price, 100 + raisePrice[index]), 100);\n        \n        uint256 current_index = TheItem.id_owner;\n        \n        if (current_index != 0){\n            totalShareFee = DoDividend(current_index, valueShareFee, current_index);\n        }\n        \n        owner.transfer(valueDevFee);\n        \n      //  pushstr(\"dev\");\n      //  pushuint(valueDevFee);\n        \n        \n        uint256 totalToOwner = sub(sub(TheItem.price, valueDevFee), totalShareFee);\n        \n        uint256 totalBack = sub(sub(sub(msg.value, totalToOwner), valueDevFee), totalShareFee);\n        \n        if (totalBack > 0){\n            msg.sender.transfer(totalBack);\n        }\n        \n       // pushstr(\"owner transfer\");\n       // pushuint(totalToOwner);\n        TheItem.owner.transfer(totalToOwner);\n        \n        TheItem.owner = msg.sender;\n        TheItem.price = valueRaisePrice;\n    }\n    \n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n         return 0;\n      }\n      uint256 c = a * b;\n      assert(c / a == b);\n      return c;\n   }\n\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\n      uint256 c = a / b;\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n      return c;\n   }\n\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n   }\n\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n   }\n    \n}",
        "debug": "calldata_Universe_32 + 36: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_20: 0x8000000000000000000000000000000000000000000000000000000000000001\nmem_mem_320 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Universe_4 + calldata_Universe_4)) +\n32: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_2 + keccac_calldata_Universe_32_+_36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Universe_32 + 4: 0x38d7ea4c68000\ncaller: 0x0\nstorage_21: 0x0\ncalldata_Universe_0: 0x7da14ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_Universe: 0x4\nstorage_2 + keccac_storage_20: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AddItem(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xb61054846c7bc1da6629a424fffdd24a48878af5.sol",
        "function": "AddItem(string,uint256,uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3545,
        "code": "ntract Universe{\n    // Universe contract\n    // It is possible to buy planets or other universe-objects from other accounts.\n    // If an object has an owner, fees will be paid to that owner until no owner has been found.\n    \n    struct Item{\n        uint256 id;\n        string name;\n        uint256 price;\n        uint256 id_owner;\n        address owner;\n    }\n    \n   // bool TESTMODE = true;\n    \n  //  event pushuint(uint256 push);\n //   event pushstr(string str);\n  //  event pusha(address addr);\n    \n    uint256[4] LevelLimits = [0.05 ether, 0.5 ether, 2 ether, 5 ether];\n    uint256[5] devFee = [5,4,3,2,2];\n    uint256[5] shareFee = [12,6,4,3,2];\n    uint256[5] raisePrice = [100, 35, 25, 17, 15];\n    \n    \n    mapping (uint256 => Item) public ItemList;\n    uint256 public current_item_index=1;\n    \n    address owner;\n    modifier onlyOwner() {\n        require(owner == msg.sender);\n        _;\n    }\n\n    function Universe() public{\n        owner=msg.sender;\n        AddItem(\"Sun\", 1 finney, 0);\n        AddItem(\"Mercury\", 1 finney, 1);\n        AddItem(\"Venus\", 1 finney, 1);\n        AddItem(\"Earth\", 1 finney, 1);\n        AddItem(\"Mars\", 1 finney, 1);\n        AddItem(\"Jupiter\", 1 finney, 1);\n        AddItem(\"Saturn\", 1 finney, 1);\n        AddItem(\"Uranus\", 1 finney, 1);\n        AddItem(\"Neptune\", 1  finney, 1);\n        AddItem(\"Pluto\", 1 finney, 1);\n        AddItem(\"Moon\", 1 finney, 4);\n    }\n    \n    function CheckItemExists(uint256 _id) internal returns (bool boolean){\n        if (ItemList[_id].price == 0){\n            return false;\n        }\n        return true;\n    }\n\n    \n //   function AddItem(string _name, uint256 _price, uint256 _id_owner) public {\n    function AddItem(string _name, uint256 _price, uint256 _id_owner) public onlyOwner {\n//if (TESTMODE){\n//if (_price < (1 finney)){\n  //              _price = (1 finney);\n    //        }\n//}\n        //require(_id != 0);\n        //require(_id == current_item_index);\n        uint256 _id = current_item_index;\n\n        require(_id_owner != _id);\n        require(_id_owner < _id);\n\n        require(_price >= (1 finney));\n        require(_id_owner == 0 || CheckItemExists(_id_owner));\n        require(CheckItemExists(_id) != true);\n        \n     //   uint256 current_id_owner = _id_owner;\n        \n     //   uint256[] mem_owner;\n        \n        //pushuint(mem_owner.length);\n        \n        /*while (current_id_owner != 0){\n           \n            mem_owner[mem_owner.length-1] = current_id_owner;\n            current_id_owner = ItemList[current_id_owner].id_owner;\n            \n          \n            for(uint256 c=0; c<mem_owner.length; c++){\n               if(c != (mem_owner.length-1)){\n                   if(mem_owner[c] == current_id_owner){\n                        pushstr(\"false\");\n                        return;\n                    }\n                }\n            }\n            mem_owner.length += 1;\n        }*/\n        \n        var NewItem = Item(_id, _name, _price, _id_owner, owner);\n        ItemList[current_item_index] = NewItem;\n        current_item_index++;\n        \n    }\n    \n    function ChangeItemOwnerID(uint256 _id, uint256 _new_owner) public onlyOwner {\n        require(_new_owner != _id);\n        require(_id <= (current_item_index-1));\n        require(_id != 0);\n        require(_new_owner != 0);\n        require(_new_owner <= (current_item_index-1));\n        require(ItemList[_id].id_owner == 0);\n       \n        uint256 current_id_owner = _new_owner;\n        uint256[] mem_owner;   \n        \n         while (current_id_owner != 0){\n           \n            mem_owner[mem_owner.length-1] = current_id_owner;\n            current_id_owner = ItemList[current_id_owner].id_owner;\n            \n          \n            for(uint256 c=0; c<mem_owner.length; c++){\n               if(c != (mem_owner.length-1)){\n                   if(mem_owner[c] == current_id_owner || mem_owner[c] == _new_owner || mem_owner[c] == _id){\n//pushstr(\"false\");\n                        return;\n                    }\n                }\n            }\n            mem_owner.length += 1;\n        }  \n        \n        ItemList[_id].id_owner = _new_owner;\n        \n    }\n\n    function DoDividend(uint256 _current_index, uint256 valueShareFee, uint256 id_owner) internal returns (uint256){\n            uint256 pow = 0;\n            uint256 totalShareFee = 0;\n            uint256 current_index = _current_index;\n            while (current_index != 0){\n                pow = pow + 1;\n                current_index = ItemList[current_index].id_owner;\n            }\n        \n            uint256 total_sum = 0;\n        \n            for (uint256 c2=0; c2<pow; c2++){\n                total_sum = total_sum + 2**c2;\n            }\n        \n            if (total_sum != 0){\n               // uint256 tot_value = 2**(pow-1);\n        \n                current_index = id_owner;\n        \n                while (current_index != 0){\n                    uint256 amount = div(mul(valueShareFee, 2**(pow-1)), total_sum);\n                    totalShareFee = add(amount, totalShareFee);\n                    ItemList[current_index].owner.transfer(amount);\n                //    pusha(ItemList[current_index].owner);\n                 //   pushuint(amount);\n                    \n                    pow = sub(pow, 1);\n                    current_index = ItemList[current_index].id_owner;\n                }\n            }\n            else{\n                ItemList[current_index].owner.transfer(valueShareFee);\n            //    pusha(ItemList[current_index].owner);\n             //   pushuint(valueShareFee);\n                totalShareFee = valueShareFee;\n            }\n            return totalShareFee;\n    }    \n    \n    function BuyItem(uint256 _id) public payable{\n        require(_id > 0 && _id < current_item_index);\n        var TheItem = ItemList[_id];\n        require(TheItem.owner != msg.sender);\n        require(msg.value >= TheItem.price);\n    \n        uint256 index=0;\n        \n        for (uint256 c=0; c<LevelLimits.length; c++){\n            uint256 value = LevelLimits[c];\n            if (TheItem.price < value){\n                break;\n            }\n            index++;\n        }\n        \n        uint256 valueShareFee = div(mul(TheItem.price, shareFee[index]), 100);\n        uint256 totalShareFee = 0;\n        uint256 valueDevFee = div(mul(TheItem.price, devFee[index]), 100);\n        uint256 valueRaisePrice = div(mul(TheItem.price, 100 + raisePrice[index]), 100);\n        \n        uint256 current_index = TheItem.id_owner;\n        \n        if (current_index != 0){\n            totalShareFee = DoDividend(current_index, valueShareFee, current_index);\n        }\n        \n        owner.transfer(valueDevFee);\n        \n      //  pushstr(\"dev\");\n      //  pushuint(valueDevFee);\n        \n        \n        uint256 totalToOwner = sub(sub(TheItem.price, valueDevFee), totalShareFee);\n        \n        uint256 totalBack = sub(sub(sub(msg.value, totalToOwner), valueDevFee), totalShareFee);\n        \n        if (totalBack > 0){\n            msg.sender.transfer(totalBack);\n        }\n        \n       // pushstr(\"owner transfer\");\n       // pushuint(totalToOwner);\n        TheItem.owner.transfer(totalToOwner);\n        \n        TheItem.owner = msg.sender;\n        TheItem.price = valueRaisePrice;\n    }\n    \n   function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n      if (a == 0) {\n         return 0;\n      }\n      uint256 c = a * b;\n      assert(c / a == b);\n      return c;\n   }\n\n   function div(uint256 a, uint256 b) internal pure returns (uint256) {\n      // assert(b > 0); // Solidity automatically throws when dividing by 0\n      uint256 c = a / b;\n      // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n      return c;\n   }\n\n   function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n      assert(b <= a);\n      return a - b;\n   }\n\n   function add(uint256 a, uint256 b) internal pure returns (uint256) {\n      uint256 c = a + b;\n      assert(c >= a);\n      return c;\n   }\n    \n}",
        "debug": "mem_320 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Universe_4 + calldata_Universe_4)) +\n32: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_320 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Universe_4 + calldata_Universe_4)) +\n32: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\ncalldata_Universe_32 + 4: 0x38d7ea4c68000\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_21: 0x0\ncalldata_Universe_0: 0x7da14ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_Universe: 0x4\nstorage_2 + keccac_storage_20: 0x0\ncalldata_Universe_32 + 36: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AddItem(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xb61054846c7bc1da6629a424fffdd24a48878af5.sol",
        "function": "AddItem(string,uint256,uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}