{
  "contract": "0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3",
  "tool": "mythril",
  "start": 1563244185.5038824,
  "end": 1563244246.6701336,
  "duration": 61.16625118255615,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1594,
        "code": "(base)();// to dev fee sharing contract\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\n   \n}\n// 2nd div setup for refunds\n\n// legacysta",
        "debug": "calldata_Snip3dInterface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Snip3dInterface_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3dInterface: 0x4\n",
        "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "changevanity(string)",
        "lineno": 398,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4248,
        "code": " uint256 nextUp = NextI",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "P3DDivstocontract()",
        "lineno": 406,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4248,
        "code": " uint256 nextUp = NextI",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4435\n",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "P3DDivstocontract()",
        "lineno": 406,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4435,
        "code": "RefundWaitingLine(nextUp + i)",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "P3DDivstocontract()",
        "lineno": 409,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4561,
        "code": "umber);\n    }\n    function blocksT",
        "debug": "block_number: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Snip3dInterface_4: 0x1\ncalldata_Snip3dInterface_0: 0x182a7f7200000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3dInterface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `blocksTillSemiShoot(address)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "blocksTillSemiShoot(address)",
        "lineno": 172,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 6857,
        "code": "   return (RefundWaitingLine[N",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "P3DDivstocontract()",
        "lineno": 155,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 6857,
        "code": "   return (RefundWaitingLine[N",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4435\nCall at address: 4248\n",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "P3DDivstocontract()",
        "lineno": 155,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 7682,
        "code": "vidends.sub(owing);\n    \n    playerVault[account] = playe",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_22: 0x0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Snip3dInterface_4: 0x0\ncalldata_Snip3dInterface_0: 0x358fcee900000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3dInterface: 0x4\nstorage_18: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "fetchdivs(address)",
        "lineno": 206,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 15850,
        "code": "ng(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(address => uint256)public  playerVault;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 200;\n    uint256 public blocksBeforeTargetShoot = 800;\n    uint256 public NextInLineOld;\n    uint256 public lastToPayOld;\n    \n    // events\n    event death(address indexed player , uint256 indexed formation);\n    event semiShot(address indexed player);\n    event targetShot(address indexed player);\n    event newSoldiers(address indexed player , uint256 indexed amount, uint256 indexed formation);\n    //constructor\n    constructor()\n        public\n    {\n        NextInLineOld = old.NextInLine();\n        lastToPayOld = 2784;\n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\n    // interface setup\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\nSnip3dInterface public old = Snip3dInterface(0x6D534b48835701312ebc904d4b37e54D4f7D039f);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return (P3Dcontract_.myDividends(true))  ;\n    }\n    function nextonetogetpaid()\n        public\n        view\n        returns(address)\n    {\n        \n        return (RefundWaitingLine[NextInLine]);\n    }\n    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function blocksTillSemiShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\n        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\n    function blocksTillTargetShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\n        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    playerVault[account] = playerVault[account].add(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode, uint256 amount) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >=  amount.mul(100 finney));// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]=  balances[sender].add(amount);\n    // update totalSupply\n    _totalSupply= _totalSupply.add(amount);\n    // add 2 bullet per soldier\n    bullets[sender] = bullets[sender].add(amount).add(amount);\n    // add to playing field\n    for(uint i=0; i< amount; i++)\n        {\n            uint256 spot = nextFormation.add(i);\n            formation[spot] = sender;\n        }\n    nextFormation += i;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    uint256 buyamount = amount.mul( 5 finney);\n    P3Dcontract_.buy.value(buyamount)(masternode);\n    // check excess of payed \n     if(value > amount.mul(100 finney)){Refundpot += value.sub(amount.mul(100 finney)) ;}\n    // progress refundline\n    Refundpot += amount.mul(5 finney);\n    // send SPASM cut\n    uint256 spasmamount = amount.mul(2 finney);\n    SPASM_.disburse.value(spasmamount)();\n    emit newSoldiers(sender, amount, nextFormation);\n\n}\nfunction sendInSoldierReferal(address masternode, address referal, uint256 amount) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >=  amount.mul(100 finney));// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n   // add life\n    balances[sender]=  balances[sender].add(amount);\n    // update totalSupply\n    _totalSupply= _totalSupply.add(amount);\n    // add 2 bullet per soldier\n    bullets[sender] = bullets[sender].add(amount).add(amount);\n    // add to playing field\n    for(uint i=0; i< amount; i++)\n        {\n            uint256 spot = nextFormation.add(i);\n            formation[spot] = sender;\n        }\n    nextFormation += i;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    uint256 buyamount = amount.mul( 5 finney);\n    P3Dcontract_.buy.value(buyamount)(masternode);\n    // check excess of payed \n     if(value > amount.mul(100 finney)){Refundpot += value.sub(amount.mul(100 finney)) ;}\n    // progress refundline\n    Refundpot += amount.mul(5 finney);\n    // send SPASM cut\n    uint256 spasmamount = amount.mul(1 finney);\n    SPASM_.disburse.value(spasmamount)();\n    // send referal cut\n    playerVault[referal] = playerVault[referal].add(amount.mul(1 finney));\n    emit newSoldiers(sender, amount, nextFormation);\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    // update divs loser\n    fetchdivs(killed);\n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    \n    // add loser to refundline\n    fetchdivsRefund(killed);\n    balancesRefund[killed] += 0.1 ether;\n   \n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit semiShot(sender);\n    emit death(killed, shot);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target <= nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    if(target == nextFormation){target = 0;}\n    address killed = formation[target];\n    \n    // update divs loser\n    fetchdivs(killed);\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    // add loser to refundline\n    fetchdivsRefund(killed);\n    balancesRefund[killed] += 0.1 ether;\n    // fetch contracts divs\n    \n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    \n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit targetShot(sender);\n    emit death(killed, target);\n}\nfunction Payoutnextrefund ()public\n    {\n         \n        require(Refundpot > 0.00001 ether);\n        uint256 amount = Refundpot;\n    Refundpot = 0;\n    totalDividendPointsRefund = totalDividendPointsRefund.add(amount.mul(pointMultiplier).div(_totalSupplyRefund));\n    unclaimedDividendsRefund = unclaimedDividendsRefund.add(amount);\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction vaultToWallet(address toPay) public {\n        require(playerVault[toPay] > 0);\n        uint256 value = playerVault[toPay];\n        playerVault[toPay] = 0;\n        toPay.transfer(value);\n    }\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\n   \n}\n// 2nd div setup for refunds\n\n// legacystarting refunds from old contract\n    function legacyStart(uint256 amountProgress) onlyOwner public{\n        uint256 nextUp = NextInLineOld;\n        for(uint i=0; i< amountProgress; i++)\n        {\n        address torefund = old.RefundWaitingLine(nextUp + i);\n        i++;\n        balancesRefund[torefund] = balancesRefund[torefund].add(0.1 ether);\n        }\n        NextInLineOld += i;\n        _totalSupplyRefund = _totalSupplyRefund.add(i.mul(0.1 ether));\n    }\n\nmapping(address => uint256) public balancesRefund;\nuint256 public _totalSupplyRefund;\nmapping(address=>Account) public accountsRefund;\nuint public ethtotalSupplyRefund;\nuint public totalDividendPointsRefund;\nuint public unclaimedDividendsRefund;\n\nfunction dividendsOwingRefund(address account) public view returns(uint256) {\n  uint256 newDividendPointsRefund = totalDividendPointsRefund.sub(accountsRefund[account].lastDividendPoints);\n  return (balancesRefund[account] * newDividendPointsRefund) / pointMultiplier;\n}\nmodifier updateAccountRefund(address account) {\n  uint256 owing = dividendsOwingRefund(account);\n  if(owing > balancesRefund[account]){balancesRefund[account] = owing;}\n  if(owing > 0 ) {\n    unclaimedDividendsRefund = unclaimedDividendsRefund.sub(owing);\n    \n    playerVault[account] = playerVault[account].add(owing);\n    balancesRefund[account] = balancesRefund[account].sub(owing);\n    _totalSupplyRefund = _totalSupplyRefund.sub(owing);\n  }\n  accountsRefund[account].lastDividendPoints = totalDividendPointsRefund;\n  _;\n}\n//function () external payable{}\nfunction fetchdivsRefund(address toUpdate) public updateAccountRefund(toUpdate){}\n\nfunction disburseRefund() public  payable {\n    uint256 amount = msg.value;\n    \n  totalDividendPointsRefund = totalDividendPointsRefund.add(amount.mul(pointMultiplier).div(_totalSupplyRefund));\n  //ethtotalSupply = ethtotalSupply.add(amount);\n unclaimedDividendsRefund = unclaimedDividendsRefund.add(amount);\n}\n\n    //fetch P3D divs\n    function DivsToRefundpot ()public\n    {\n        //allocate p3d dividends to contract \n            uint256 dividends = P3Dcontract_.myDividends(true);\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base.mul(5))();// to dev fee sharing contract SPASM\n            Refundpot = Refundpot.add(base.mul(95));\n    }\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function dividendsOf(address _playerAddress) external view returns(uint256);\n    ",
        "debug": "calldata_Snip3dInterface_4 + calldata_Snip3dInterface_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3dInterface_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3dInterface: 0x4\n",
        "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x31cf8b6e8bb6cb16f23889f902be86775bb1d0b3.sol",
        "function": "changevanity(string)",
        "lineno": 102,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}