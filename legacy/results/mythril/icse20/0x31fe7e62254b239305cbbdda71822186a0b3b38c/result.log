{"error": null, "issues": [{"address": 453, "code": "      the pre", "debug": "callvalue: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_9: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldatasize_tokenRecipient: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "fallback", "lineno": 290, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2415, "code": "eturn site_url;\n    }\n\n    /*\n        Difficulty adjustment.\n    */\n    fu", "debug": "calldata_tokenRecipient_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_tokenRecipient_0: 0x252498a200000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "setUrl(string)", "lineno": 142, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6856, "code": "eturns (bool success)", "debug": "calldata_tokenRecipient_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_tokenRecipient_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `burn(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "burn(uint256)", "lineno": 193, "title": "Integer Underflow", "type": "Warning"}, {"address": 7549, "code": "on payInterest(addres", "debug": "calldata_tokenRecipient_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_tokenRecipient_0: 0x79cc679000000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `burnFrom(address,uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "burnFrom(address,uint256)", "lineno": 206, "title": "Integer Underflow", "type": "Warning"}, {"address": 7855, "code": " } else {\n            interest = 0;\n     ", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nblock_number: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_tokenRecipient_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_tokenRecipient_32 + 36: 0x0\ncalldata_tokenRecipient_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `transferFrom(address,address,uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "transferFrom(address,address,uint256)", "lineno": 99, "title": "Integer Underflow", "type": "Warning"}, {"address": 9281, "code": "om, _to, _value);\n        assert(", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_32_+_4: 0x8ecd2502510e6b90fed8122af8b9d53a82ffcb383034f2dd693876b2f7ad7b4b\ncalldata_tokenRecipient_32 + 36: 0x211e8500045868936021715fb01dd95aa886815191414081c047c180e88073d5\nblock_number: 0xa34d3d4342afa13970d088c8c001c13e683decbf7fb6eaea41a0e448e639f048\ncalldata_tokenRecipient_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x211e8500045868936021715fb01dd95aa886815191414081c047c180e88073d5\ncalldata_tokenRecipient_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "transferFrom(address,address,uint256)", "lineno": 129, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9668, "code": "transfer(msg.sender, _to, _value)", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_32_+_4: 0x20000000d065989040180a13810e7ef3043c0a37bfc4d2f3fc00f13cffffffff\ncalldata_tokenRecipient_32 + 36: 0x7fffffffffdc38001100003ffffffffffffffffffffff0000000000080200000\nblock_number: 0xffffffff04006281ac06f1a3f609d5bbbbbeb5beeaeaecbaacbabaae807fffff\ncalldata_tokenRecipient_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x7fffffffffdc38001100003ffffffffffffffffffffff0000000000080200000\ncalldata_tokenRecipient_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "transferFrom(address,address,uint256)", "lineno": 134, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9751, "code": "me = \"ILOT Interest-Paying Lottery Token\";\n    string public symbol = \"ILOT\";\n    \n    /*\n        We've hardcoded our official website into the blockchain!\n        Please do not send ETH to scams/clones/copies. \n        The website indicated below is the only official ILOT website.\n    */\n    string public site_url = \"https://ILOT.io/\";\n\n    bytes32 private current_jackpot_hash = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n    uint8 public decimals = 18;\n    uint public totalSupply = 0; // No pre-minted amount.\n    uint public interestRate = 15; // 1.5% fixed monthly interest = 15 / 1000\n    uint tokensPerEthereum = 147000; // 147k tokens per ETH\n    uint public jackpotDifficulty = 6;\n    address public owner;\n\n    function ILOTContract() public {\n        owner = msg.sender;\n    }\n\n    mapping (address => uint) public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint) public depositTotal; // total ETH deposited per address\n    mapping (address => uint) public lastBlockInterestPaid;\n\n    /*\n        Declare ILOT events.\n    */\n    event Transfer(address indexed from, address indexed to, uint bhtc_value);\n    event Burn(address indexed from, uint bhtc_value);\n    event GameResult(address player, uint zeroes);\n    event BonusPaid(address to, uint bhtc_value);\n    event InterestPaid(address to, uint bhtc_value);\n    event Jackpot(address winner, uint eth_amount);\n\n    uint maintenanceDebt;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /*\n        Return an addresse's current unpaid interest amount in ILOT.\n    */\n    function getInterest(address _to) public view returns (uint interest) {\n\n        if (lastBlockInterestPaid[_to] > 0) {\n            interest = ((block.number - lastBlockInterestPaid[_to]) * balanceOf[_to] * interestRate) / (86400000);\n        } else {\n            interest = 0;\n        }\n\n        return interest;\n    }\n\n    /*\n        Allows users to check their current deposit bonus amount.\n        Formula: 1% bonus over lifetime ETH deposit history\n        depositTotal is denominated in ETH\n    */\n    function getBonus(address _to) public view returns (uint interest) {\n        return ((depositTotal[_to] * tokensPerEthereum) / 100);\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        /*\n            Owed interest is paid before transfers/withdrawals.\n            Users may be able to withdraw/transfer more than they publicly see.\n            Use getInterest(ETHEREUM_ADDRESS) to check how much interests\n            will be paid before transfers or future deposits.\n        */\n        payInterest(_from);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function setUrl(string u) public onlyOwner {\n        site_url = u;\n    }\n\n    function getUrl() public view returns (string) {\n        return site_url;\n    }\n\n    /*\n        Difficulty adjustment.\n    */\n    function setDifficulty(uint z) public onlyOwner {\n        jackpotDifficulty = z;\n    }\n\n    /*\n        Get current difficulty.\n        Returns number of zeroes currently required.\n    */\n    function getDifficulty() public view returns (uint) {\n        return jackpotDifficulty;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint _value) public\n    returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint _value, bytes _extraData)\n    public\n    returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function chown(address to) public onlyOwner { owner = to; }\n\n    function burn(uint _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n\n    /*\n        Pays interest on available funds.\n    */\n    function payInterest(address _to) private {\n\n        uint interest = getInterest(_to);\n\n        if (interest > 0) {\n            require( (balanceOf[_to] + interest) > balanceOf[_to]);\n            // pay interest\n            balanceOf[msg.sender] += interest;\n            totalSupply += interest;\n            Transfer(this, msg.sender, interest);\n            InterestPaid(_to, interest);\n        }\n\n        lastBlockInterestPaid[_to] = block.number;\n\n    }\n\n    /*\n        Pays a 1% bonus over lifetime deposits made to this address.\n        Does not carry over if you change Ethereum addresses.\n    */\n    function payBonus(address _to) private {\n        if (depositTotal[_to] > 0) {\n            uint bonus = getBonus(_to);\n            if (bonus > 0) {\n                require( (balanceOf[_to] + bonus) > balanceOf[_to]);\n                balanceOf[_to] +=  bonus;\n                totalSupply += bonus;\n                Transfer(this, _to, bonus);\n                BonusPaid(_to, bonus);\n            }\n        }\n    }\n\n    function hashDifficulty(bytes32 hash) public pure returns(uint) {\n        uint diff = 0;\n\n        for (uint i=0;i<32;i++) {\n            if (hash[i] == 0) {\n                diff++;\n            } else {\n                return diff;\n            }\n        }\n\n        return diff;\n    }\n\n    /*\n        Credit to user @eth from StackExchange at:\n        https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\n        License for addressToString(): CC BY-SA 3.0\n    */\n    function addressToString(address x) private pure returns (string) {\n        bytes memory b = new bytes(20);\n        for (uint i = 0; i < 20; i++)\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n        return string(b);\n    }\n\n    /*\n        Performs token exchange and runs the lottery routine.\n\n    */\n    function () public payable {\n\n        /*\n            Owner cannot play lottery.\n        */\n        if (msg.sender == owner) {\n            return;\n        }\n\n        if (msg.value > 0) {\n\n            /*\n                Maintenance fee 2%\n            */\n            uint mfee = (2 * msg.value) / 100;\n\n            /*\n                If the contract does not have sufficient balance to pay mfee,\n                it will add mfee to maintenanceDebt and will not transfer it\n                at this time. During a later transaction, if the fee is enough,\n                the previous debt is transferred and zeroed out.\n            */\n            if (address(this).balance >= mfee) {\n                if (address(this).balance >= (mfee + maintenanceDebt) ) {\n                    // there's enough to cover previous debt\n                    owner.transfer(mfee + maintenanceDebt);\n                    maintenanceDebt = 0;\n                } else {\n                    // enough to pay fee but not previous debts\n                    owner.transfer(mfee);\n                }\n\n            } else {\n                maintenanceDebt += mfee;\n            }\n\n            /*\n                Convert ETH to ILOT at tokensPerEthereum rate.\n            */\n            uint tokenAmount = tokensPerEthereum * msg.value;\n            if (tokenAmount > 0) {\n                require( (balanceOf[msg.sender] + tokenAmount) > balanceOf[msg.sender]);\n\n                /*\n                    Pay fidelity bonus.\n                */\n                payBonus(msg.sender);\n\n                /*\n                    Pay interests on previous balance.\n                */\n                payInterest(msg.sender);\n\n                /*\n                    Update balance.\n                */\n                balanceOf[msg.sender] += tokenAmount;\n                totalSupply += tokenAmount;\n                Transfer(this, msg.sender, tokenAmount);\n\n                /*\n                    Add total after paying bonus.\n                    This deposit will count towards the next deposit bonus.\n                */\n                depositTotal[msg.sender] += msg.value;\n\n                string memory ats = addressToString(msg.sender);\n\n                /*\n                    Perform lottery routine.\n                */\n                current_jackpot_hash = keccak256(current_jackpot_hash, ats, block.coinbase, block.number, block.timestamp);\n                uint diffx = hashDifficulty(current_jackpot_hash);\n\n                if (diffx >= jackpotDifficulty) {\n                    /*\n\n                        ********************\n                        ****  JACKPOT!  ****\n                        ********************\n\n                        Winner receives the entire contract balance.\n                        Jackpot event makes the result public.\n\n                    */\n                    Jackpot(msg.sender, address(this).balance);\n                    msg.sender.transfer(address(this).balance);\n                }\n\n                /*\n                    Make the game result public for transparency.\n                */\n                GameResult(msg.sender, diffx);\n\n            }\n        }\n    }\n\n}", "debug": "calldata_tokenRecipient_4 + calldata_tokenRecipient_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_9: 0x0\ncaller: 0x0\ncalldata_tokenRecipient_0: 0x252498a200000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "setUrl(string)", "lineno": 48, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9765, "code": "me = \"ILOT Interest-Paying Lottery Token\";\n    string public symbol = \"ILOT\";\n    \n    /*\n        We've hardcoded our official website into the blockchain!\n        Please do not send ETH to scams/clones/copies. \n        The website indicated below is the only official ILOT website.\n    */\n    string public site_url = \"https://ILOT.io/\";\n\n    bytes32 private current_jackpot_hash = \"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\";\n    uint8 public decimals = 18;\n    uint public totalSupply = 0; // No pre-minted amount.\n    uint public interestRate = 15; // 1.5% fixed monthly interest = 15 / 1000\n    uint tokensPerEthereum = 147000; // 147k tokens per ETH\n    uint public jackpotDifficulty = 6;\n    address public owner;\n\n    function ILOTContract() public {\n        owner = msg.sender;\n    }\n\n    mapping (address => uint) public balanceOf;\n    mapping (address => mapping (address => uint)) public allowance;\n    mapping (address => uint) public depositTotal; // total ETH deposited per address\n    mapping (address => uint) public lastBlockInterestPaid;\n\n    /*\n        Declare ILOT events.\n    */\n    event Transfer(address indexed from, address indexed to, uint bhtc_value);\n    event Burn(address indexed from, uint bhtc_value);\n    event GameResult(address player, uint zeroes);\n    event BonusPaid(address to, uint bhtc_value);\n    event InterestPaid(address to, uint bhtc_value);\n    event Jackpot(address winner, uint eth_amount);\n\n    uint maintenanceDebt;\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /*\n        Return an addresse's current unpaid interest amount in ILOT.\n    */\n    function getInterest(address _to) public view returns (uint interest) {\n\n        if (lastBlockInterestPaid[_to] > 0) {\n            interest = ((block.number - lastBlockInterestPaid[_to]) * balanceOf[_to] * interestRate) / (86400000);\n        } else {\n            interest = 0;\n        }\n\n        return interest;\n    }\n\n    /*\n        Allows users to check their current deposit bonus amount.\n        Formula: 1% bonus over lifetime ETH deposit history\n        depositTotal is denominated in ETH\n    */\n    function getBonus(address _to) public view returns (uint interest) {\n        return ((depositTotal[_to] * tokensPerEthereum) / 100);\n    }\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        require(_to != 0x0);\n        /*\n            Owed interest is paid before transfers/withdrawals.\n            Users may be able to withdraw/transfer more than they publicly see.\n            Use getInterest(ETHEREUM_ADDRESS) to check how much interests\n            will be paid before transfers or future deposits.\n        */\n        payInterest(_from);\n        require(balanceOf[_from] >= _value);\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function setUrl(string u) public onlyOwner {\n        site_url = u;\n    }\n\n    function getUrl() public view returns (string) {\n        return site_url;\n    }\n\n    /*\n        Difficulty adjustment.\n    */\n    function setDifficulty(uint z) public onlyOwner {\n        jackpotDifficulty = z;\n    }\n\n    /*\n        Get current difficulty.\n        Returns number of zeroes currently required.\n    */\n    function getDifficulty() public view returns (uint) {\n        return jackpotDifficulty;\n    }\n\n    function transferFrom(address _from, address _to, uint _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint _value) public\n    returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint _value, bytes _extraData)\n    public\n    returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function chown(address to) public onlyOwner { owner = to; }\n\n    function burn(uint _value) public returns (bool success) {\n        require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough\n        balanceOf[msg.sender] -= _value;            // Subtract from the sender\n        totalSupply -= _value;                      // Updates totalSupply\n        Burn(msg.sender, _value);\n        return true;\n    }\n\n    function burnFrom(address _from, uint _value) public returns (bool success) {\n        require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough\n        require(_value <= allowance[_from][msg.sender]);    // Check allowance\n        balanceOf[_from] -= _value;                         // Subtract from the targeted balance\n        allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance\n        totalSupply -= _value;                              // Update totalSupply\n        Burn(_from, _value);\n        return true;\n    }\n\n    /*\n        Pays interest on available funds.\n    */\n    function payInterest(address _to) private {\n\n        uint interest = getInterest(_to);\n\n        if (interest > 0) {\n            require( (balanceOf[_to] + interest) > balanceOf[_to]);\n            // pay interest\n            balanceOf[msg.sender] += interest;\n            totalSupply += interest;\n            Transfer(this, msg.sender, interest);\n            InterestPaid(_to, interest);\n        }\n\n        lastBlockInterestPaid[_to] = block.number;\n\n    }\n\n    /*\n        Pays a 1% bonus over lifetime deposits made to this address.\n        Does not carry over if you change Ethereum addresses.\n    */\n    function payBonus(address _to) private {\n        if (depositTotal[_to] > 0) {\n            uint bonus = getBonus(_to);\n            if (bonus > 0) {\n                require( (balanceOf[_to] + bonus) > balanceOf[_to]);\n                balanceOf[_to] +=  bonus;\n                totalSupply += bonus;\n                Transfer(this, _to, bonus);\n                BonusPaid(_to, bonus);\n            }\n        }\n    }\n\n    function hashDifficulty(bytes32 hash) public pure returns(uint) {\n        uint diff = 0;\n\n        for (uint i=0;i<32;i++) {\n            if (hash[i] == 0) {\n                diff++;\n            } else {\n                return diff;\n            }\n        }\n\n        return diff;\n    }\n\n    /*\n        Credit to user @eth from StackExchange at:\n        https://ethereum.stackexchange.com/questions/8346/convert-address-to-string\n        License for addressToString(): CC BY-SA 3.0\n    */\n    function addressToString(address x) private pure returns (string) {\n        bytes memory b = new bytes(20);\n        for (uint i = 0; i < 20; i++)\n            b[i] = byte(uint8(uint(x) / (2**(8*(19 - i)))));\n        return string(b);\n    }\n\n    /*\n        Performs token exchange and runs the lottery routine.\n\n    */\n    function () public payable {\n\n        /*\n            Owner cannot play lottery.\n        */\n        if (msg.sender == owner) {\n            return;\n        }\n\n        if (msg.value > 0) {\n\n            /*\n                Maintenance fee 2%\n            */\n            uint mfee = (2 * msg.value) / 100;\n\n            /*\n                If the contract does not have sufficient balance to pay mfee,\n                it will add mfee to maintenanceDebt and will not transfer it\n                at this time. During a later transaction, if the fee is enough,\n                the previous debt is transferred and zeroed out.\n            */\n            if (address(this).balance >= mfee) {\n                if (address(this).balance >= (mfee + maintenanceDebt) ) {\n                    // there's enough to cover previous debt\n                    owner.transfer(mfee + maintenanceDebt);\n                    maintenanceDebt = 0;\n                } else {\n                    // enough to pay fee but not previous debts\n                    owner.transfer(mfee);\n                }\n\n            } else {\n                maintenanceDebt += mfee;\n            }\n\n            /*\n                Convert ETH to ILOT at tokensPerEthereum rate.\n            */\n            uint tokenAmount = tokensPerEthereum * msg.value;\n            if (tokenAmount > 0) {\n                require( (balanceOf[msg.sender] + tokenAmount) > balanceOf[msg.sender]);\n\n                /*\n                    Pay fidelity bonus.\n                */\n                payBonus(msg.sender);\n\n                /*\n                    Pay interests on previous balance.\n                */\n                payInterest(msg.sender);\n\n                /*\n                    Update balance.\n                */\n                balanceOf[msg.sender] += tokenAmount;\n                totalSupply += tokenAmount;\n                Transfer(this, msg.sender, tokenAmount);\n\n                /*\n                    Add total after paying bonus.\n                    This deposit will count towards the next deposit bonus.\n                */\n                depositTotal[msg.sender] += msg.value;\n\n                string memory ats = addressToString(msg.sender);\n\n                /*\n                    Perform lottery routine.\n                */\n                current_jackpot_hash = keccak256(current_jackpot_hash, ats, block.coinbase, block.number, block.timestamp);\n                uint diffx = hashDifficulty(current_jackpot_hash);\n\n                if (diffx >= jackpotDifficulty) {\n                    /*\n\n                        ********************\n                        ****  JACKPOT!  ****\n                        ********************\n\n                        Winner receives the entire contract balance.\n                        Jackpot event makes the result public.\n\n                    */\n                    Jackpot(msg.sender, address(this).balance);\n                    msg.sender.transfer(address(this).balance);\n                }\n\n                /*\n                    Make the game result public for transparency.\n                */\n                GameResult(msg.sender, diffx);\n\n            }\n        }\n    }\n\n}", "debug": "calldata_tokenRecipient_4 + calldata_tokenRecipient_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_9: 0x0\ncaller: 0x0\ncalldata_tokenRecipient_0: 0x252498a200000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x31fe7e62254b239305cbbdda71822186a0b3b38c.sol", "function": "setUrl(string)", "lineno": 48, "title": "Integer Overflow ", "type": "Warning"}], "success": true}