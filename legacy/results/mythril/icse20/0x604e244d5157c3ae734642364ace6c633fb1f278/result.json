{
  "contract": "0x604e244d5157c3ae734642364ace6c633fb1f278",
  "tool": "mythril",
  "start": 1563338327.3574967,
  "end": 1563340120.685246,
  "duration": 1793.3277492523193,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 387,
        "code": " }\n\n    event Request (string _coin ,",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x3\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "fallback",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 942,
        "code": "  \tif ( users[_user].callBack ) {\n    \t\t// Callback function: passive, expensive, somewhat private\n        \tCaller _caller = Caller(_user);\n        \t_caller.EFOcallBack(_result);\n    \t\t} else {\n    \t// Mapping: active, cheap, public\n        users[_user].response = _result;\n        Response( _user , _result );\n    \t}\n\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n        if (_",
        "debug": "calldata_EthernityFinancialOracle_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_EthernityFinancialOracle_0: 0x600a686e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x600a686e`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "_function_0x600a686e",
        "lineno": 139,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2976,
        "code": "_gasPrice;\n    }\n\n    function ge",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_EthernityFinancialOracle_0: 0x8cb36aef00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\nstorage_4: 0x0\nstorage_5: 0x0\ncalldata_EthernityFinancialOracle_32 + 68: 0x0\ncalldata_EthernityFinancialOracle_32 + 36: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "requestCoinToUSD(string,bool,uint256,uint256)",
        "lineno": 120,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3977,
        "code": " }\n\n    event Request (string _coin ,",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_EthernityFinancialOracle_0: 0x7e4c3b2e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\n",
        "description": "A possible integer overflow exists in the function `requestRate(string,string,bool,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "requestRate(string,string,bool,uint256,uint256)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4753,
        "code": " }\n\n    event Request (string _coin ,",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_EthernityFinancialOracle_0: 0x8cb36aef00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\n",
        "description": "A possible integer overflow exists in the function `requestCoinToUSD(string,bool,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "requestCoinToUSD(string,bool,uint256,uint256)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5824,
        "code": "anned = false;\n    }\n}",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function emergencyFlush(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "emergencyFlush()",
        "lineno": 201,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 6465,
        "code": "der].balance ",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function getRefund(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "getRefund()",
        "lineno": 104,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 8135,
        "code": "}\n\n\n    // ADMIN FUNCTIO",
        "debug": "storage_4: 0x200000000000000000000000000000000000000000000000000000000\nstorage_3: 0x508ee0000000036f12a8000000000002000000000001000118056860952911d7\nstorage_2: 0xaf769ffffffffe84200000000000000200000000000007fe0be86a7f598e9df5\ncallvalue: 0x0\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x508ee0000000036f12a8000000000002000000000001000118056860952911d7\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_EthernityFinancialOracle_0: 0x8cb36aef00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\nstorage_5: 0x0\ncalldata_EthernityFinancialOracle_32 + 68: 0x0\ncalldata_EthernityFinancialOracle_32 + 36: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestCoinToUSD(string,bool,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "requestCoinToUSD(string,bool,uint256,uint256)",
        "lineno": 167,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8377,
        "code": "ernityFinancialOracle{\n    \n    address public owner;\n    address public oracleAddress;\n    uint public collectedFee; \n    uint public feePrice = 0.0005 ether;\n    uint public gasLimit = 50000;\n    uint public gasPrice = 40000000000 wei;\n    \n    struct User {\n    \tstring response;\n    \tbool callBack;\n    \tbool asked;\n    \tuint balance;\n    \tbool banned;\n    }\n\n    mapping(address => User) public users;\n\n    \n    modifier onlyOwner{\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyOracle{\n        require(msg.sender == oracleAddress);\n        _;\n    }\n\n    modifier onlyOwnerOrOracle {\n    \trequire(msg.sender == owner || msg.sender == oracleAddress);\n    \t_;\n    }\n\n    modifier notBanned {\n        require( users[msg.sender].banned == false );\n        _;\n    }\n\n    modifier receivePayment {\n        users[msg.sender].balance = users[msg.sender].balance + msg.value;\n        _;\n    }\n\n    event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n    event Response (address _address , string _response);\n    event Error (string _error);\n    \n\n    // Main constructor\n    function EthernityFinancialOracle() {\n        owner = msg.sender;\n        oracleAddress = msg.sender; // 0xfb509f6900d0326520c8f88e8f12c83459a199ec;\n    }   \n\n    // Payable to receive payments and stores into the mapping through modifier\n    function () payable receivePayment {\n    }\n\n    // REQUESTS\n    \n    function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n        (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request ('ETH', 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n    }\n\n\n    function getRefund() {\n        if (msg.sender == owner) {\n            uint a = collectedFee;\n            collectedFee = 0; \n            require(owner.send(a));\n        } else {\n\t        uint b = users[msg.sender].balance;\n\t        users[msg.sender].balance = 0;\n\t        require(msg.sender.send(b));\n\t    \t}\n    }\n\n\n    // GETTERS\n\n    function getResponse() public constant returns(string _response){\n        return users[msg.sender].response;\n    }\n\n    function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n    \tassert(_gasLimit * _gasPrice / _gasLimit == _gasPrice); // To avoid overflow exploitation\n    \treturn feePrice + _gasLimit * _gasPrice;\n    }\n\n    function getBalance() public constant returns(uint _balance) {\n    \treturn users[msg.sender].balance;\n    }\n\n    function getBalance(address _address) public constant returns(uint _balance) {\n\t\treturn users[_address].balance;\n    }\n\n\n\n    // SET RESPONSE FROM ORACLE\n    function setResponse (address _user, string _result) onlyOracle {\n\n\t\trequire( users[_user].asked );\n\t\tusers[_user].asked = false;\n\n    \tif ( users[_user].callBack ) {\n    \t\t// Callback function: passive, expensive, somewhat private\n        \tCaller _caller = Caller(_user);\n        \t_caller.EFOcallBack(_result);\n    \t\t} else {\n    \t// Mapping: active, cheap, public\n        users[_user].response = _result;\n        Response( _user , _result );\n    \t}\n\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n\n        uint gp = getPrice(_gasPrice,_gasLimit);\n\n        require (users[msg.sender].balance >= gp );\n\n        collectedFee += feePrice;\n        users[msg.sender].balance -= gp;\n\n        require(oracleAddress.send(gp - feePrice));\n        return(_gasPrice,_gasLimit);\n    }\n\n\n    // ADMIN FUNCTIONS\n    \n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    function changeOracleAdd(address _newOracleAdd) onlyOwner {\n        oracleAddress = _newOracleAdd;\n    }\n\n    function setFeePrice(uint _feePrice) onlyOwner {\n        feePrice = _feePrice;\n    }\n\n    function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n    \tgasPrice = _gasPrice;\n    }\n\n    function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n    \tgasLimit = _gasLimit;\n    }\n\n    function emergencyFlush() onlyOwner {\n        require(owner.send(this.balance));\n    }\n\n    function ban(address _user) onlyOwner{\n        users[_user].banned = true;\n    }\n    \n    function desBan(address _user) onlyOwner{\n        users[_user].banned = false;\n    }\n}",
        "debug": "storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EthernityFinancialOracle_0: 0x600a686e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x600a686e`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "_function_0x600a686e",
        "lineno": 13,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8406,
        "code": "ernityFinancialOracle{\n    \n    address public owner;\n    address public oracleAddress;\n    uint public collectedFee; \n    uint public feePrice = 0.0005 ether;\n    uint public gasLimit = 50000;\n    uint public gasPrice = 40000000000 wei;\n    \n    struct User {\n    \tstring response;\n    \tbool callBack;\n    \tbool asked;\n    \tuint balance;\n    \tbool banned;\n    }\n\n    mapping(address => User) public users;\n\n    \n    modifier onlyOwner{\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyOracle{\n        require(msg.sender == oracleAddress);\n        _;\n    }\n\n    modifier onlyOwnerOrOracle {\n    \trequire(msg.sender == owner || msg.sender == oracleAddress);\n    \t_;\n    }\n\n    modifier notBanned {\n        require( users[msg.sender].banned == false );\n        _;\n    }\n\n    modifier receivePayment {\n        users[msg.sender].balance = users[msg.sender].balance + msg.value;\n        _;\n    }\n\n    event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n    event Response (address _address , string _response);\n    event Error (string _error);\n    \n\n    // Main constructor\n    function EthernityFinancialOracle() {\n        owner = msg.sender;\n        oracleAddress = msg.sender; // 0xfb509f6900d0326520c8f88e8f12c83459a199ec;\n    }   \n\n    // Payable to receive payments and stores into the mapping through modifier\n    function () payable receivePayment {\n    }\n\n    // REQUESTS\n    \n    function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n        (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request ('ETH', 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n    }\n\n\n    function getRefund() {\n        if (msg.sender == owner) {\n            uint a = collectedFee;\n            collectedFee = 0; \n            require(owner.send(a));\n        } else {\n\t        uint b = users[msg.sender].balance;\n\t        users[msg.sender].balance = 0;\n\t        require(msg.sender.send(b));\n\t    \t}\n    }\n\n\n    // GETTERS\n\n    function getResponse() public constant returns(string _response){\n        return users[msg.sender].response;\n    }\n\n    function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n    \tassert(_gasLimit * _gasPrice / _gasLimit == _gasPrice); // To avoid overflow exploitation\n    \treturn feePrice + _gasLimit * _gasPrice;\n    }\n\n    function getBalance() public constant returns(uint _balance) {\n    \treturn users[msg.sender].balance;\n    }\n\n    function getBalance(address _address) public constant returns(uint _balance) {\n\t\treturn users[_address].balance;\n    }\n\n\n\n    // SET RESPONSE FROM ORACLE\n    function setResponse (address _user, string _result) onlyOracle {\n\n\t\trequire( users[_user].asked );\n\t\tusers[_user].asked = false;\n\n    \tif ( users[_user].callBack ) {\n    \t\t// Callback function: passive, expensive, somewhat private\n        \tCaller _caller = Caller(_user);\n        \t_caller.EFOcallBack(_result);\n    \t\t} else {\n    \t// Mapping: active, cheap, public\n        users[_user].response = _result;\n        Response( _user , _result );\n    \t}\n\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n\n        uint gp = getPrice(_gasPrice,_gasLimit);\n\n        require (users[msg.sender].balance >= gp );\n\n        collectedFee += feePrice;\n        users[msg.sender].balance -= gp;\n\n        require(oracleAddress.send(gp - feePrice));\n        return(_gasPrice,_gasLimit);\n    }\n\n\n    // ADMIN FUNCTIONS\n    \n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    function changeOracleAdd(address _newOracleAdd) onlyOwner {\n        oracleAddress = _newOracleAdd;\n    }\n\n    function setFeePrice(uint _feePrice) onlyOwner {\n        feePrice = _feePrice;\n    }\n\n    function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n    \tgasPrice = _gasPrice;\n    }\n\n    function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n    \tgasLimit = _gasLimit;\n    }\n\n    function emergencyFlush() onlyOwner {\n        require(owner.send(this.balance));\n    }\n\n    function ban(address _user) onlyOwner{\n        users[_user].banned = true;\n    }\n    \n    function desBan(address _user) onlyOwner{\n        users[_user].banned = false;\n    }\n}",
        "debug": "calldata_EthernityFinancialOracle_4 + calldata_EthernityFinancialOracle_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EthernityFinancialOracle_0: 0x600a686e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x600a686e`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "_function_0x600a686e",
        "lineno": 13,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8420,
        "code": "ernityFinancialOracle{\n    \n    address public owner;\n    address public oracleAddress;\n    uint public collectedFee; \n    uint public feePrice = 0.0005 ether;\n    uint public gasLimit = 50000;\n    uint public gasPrice = 40000000000 wei;\n    \n    struct User {\n    \tstring response;\n    \tbool callBack;\n    \tbool asked;\n    \tuint balance;\n    \tbool banned;\n    }\n\n    mapping(address => User) public users;\n\n    \n    modifier onlyOwner{\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyOracle{\n        require(msg.sender == oracleAddress);\n        _;\n    }\n\n    modifier onlyOwnerOrOracle {\n    \trequire(msg.sender == owner || msg.sender == oracleAddress);\n    \t_;\n    }\n\n    modifier notBanned {\n        require( users[msg.sender].banned == false );\n        _;\n    }\n\n    modifier receivePayment {\n        users[msg.sender].balance = users[msg.sender].balance + msg.value;\n        _;\n    }\n\n    event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n    event Response (address _address , string _response);\n    event Error (string _error);\n    \n\n    // Main constructor\n    function EthernityFinancialOracle() {\n        owner = msg.sender;\n        oracleAddress = msg.sender; // 0xfb509f6900d0326520c8f88e8f12c83459a199ec;\n    }   \n\n    // Payable to receive payments and stores into the mapping through modifier\n    function () payable receivePayment {\n    }\n\n    // REQUESTS\n    \n    function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n        (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request ('ETH', 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n    }\n\n\n    function getRefund() {\n        if (msg.sender == owner) {\n            uint a = collectedFee;\n            collectedFee = 0; \n            require(owner.send(a));\n        } else {\n\t        uint b = users[msg.sender].balance;\n\t        users[msg.sender].balance = 0;\n\t        require(msg.sender.send(b));\n\t    \t}\n    }\n\n\n    // GETTERS\n\n    function getResponse() public constant returns(string _response){\n        return users[msg.sender].response;\n    }\n\n    function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n    \tassert(_gasLimit * _gasPrice / _gasLimit == _gasPrice); // To avoid overflow exploitation\n    \treturn feePrice + _gasLimit * _gasPrice;\n    }\n\n    function getBalance() public constant returns(uint _balance) {\n    \treturn users[msg.sender].balance;\n    }\n\n    function getBalance(address _address) public constant returns(uint _balance) {\n\t\treturn users[_address].balance;\n    }\n\n\n\n    // SET RESPONSE FROM ORACLE\n    function setResponse (address _user, string _result) onlyOracle {\n\n\t\trequire( users[_user].asked );\n\t\tusers[_user].asked = false;\n\n    \tif ( users[_user].callBack ) {\n    \t\t// Callback function: passive, expensive, somewhat private\n        \tCaller _caller = Caller(_user);\n        \t_caller.EFOcallBack(_result);\n    \t\t} else {\n    \t// Mapping: active, cheap, public\n        users[_user].response = _result;\n        Response( _user , _result );\n    \t}\n\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n\n        uint gp = getPrice(_gasPrice,_gasLimit);\n\n        require (users[msg.sender].balance >= gp );\n\n        collectedFee += feePrice;\n        users[msg.sender].balance -= gp;\n\n        require(oracleAddress.send(gp - feePrice));\n        return(_gasPrice,_gasLimit);\n    }\n\n\n    // ADMIN FUNCTIONS\n    \n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    function changeOracleAdd(address _newOracleAdd) onlyOwner {\n        oracleAddress = _newOracleAdd;\n    }\n\n    function setFeePrice(uint _feePrice) onlyOwner {\n        feePrice = _feePrice;\n    }\n\n    function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n    \tgasPrice = _gasPrice;\n    }\n\n    function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n    \tgasLimit = _gasLimit;\n    }\n\n    function emergencyFlush() onlyOwner {\n        require(owner.send(this.balance));\n    }\n\n    function ban(address _user) onlyOwner{\n        users[_user].banned = true;\n    }\n    \n    function desBan(address _user) onlyOwner{\n        users[_user].banned = false;\n    }\n}",
        "debug": "calldata_EthernityFinancialOracle_4 + calldata_EthernityFinancialOracle_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EthernityFinancialOracle_0: 0x600a686e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x600a686e`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "_function_0x600a686e",
        "lineno": 13,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8442,
        "code": "ernityFinancialOracle{\n    \n    address public owner;\n    address public oracleAddress;\n    uint public collectedFee; \n    uint public feePrice = 0.0005 ether;\n    uint public gasLimit = 50000;\n    uint public gasPrice = 40000000000 wei;\n    \n    struct User {\n    \tstring response;\n    \tbool callBack;\n    \tbool asked;\n    \tuint balance;\n    \tbool banned;\n    }\n\n    mapping(address => User) public users;\n\n    \n    modifier onlyOwner{\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyOracle{\n        require(msg.sender == oracleAddress);\n        _;\n    }\n\n    modifier onlyOwnerOrOracle {\n    \trequire(msg.sender == owner || msg.sender == oracleAddress);\n    \t_;\n    }\n\n    modifier notBanned {\n        require( users[msg.sender].banned == false );\n        _;\n    }\n\n    modifier receivePayment {\n        users[msg.sender].balance = users[msg.sender].balance + msg.value;\n        _;\n    }\n\n    event Request (string _coin , string _againstCoin , address _address , uint _gasPrice , uint _gasLimit );\n    event Response (address _address , string _response);\n    event Error (string _error);\n    \n\n    // Main constructor\n    function EthernityFinancialOracle() {\n        owner = msg.sender;\n        oracleAddress = msg.sender; // 0xfb509f6900d0326520c8f88e8f12c83459a199ec;\n    }   \n\n    // Payable to receive payments and stores into the mapping through modifier\n    function () payable receivePayment {\n    }\n\n    // REQUESTS\n    \n    function requestEtherToUSD(bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n        (_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request ('ETH', 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestCoinToUSD(string _coin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, 'USD', msg.sender , _gasPrice , _gasLimit );\n    }\n    \n    function requestRate(string _coin, string _againstCoin , bool _callBack , uint _gasPrice , uint _gasLimit) payable receivePayment notBanned {\n    \t(_gasPrice , _gasLimit) = payToOracle (_gasPrice , _gasLimit);\n        users[msg.sender].callBack = _callBack;\n        users[msg.sender].asked = true;\n        Request (_coin, _againstCoin, msg.sender , _gasPrice , _gasLimit );\n    }\n\n\n    function getRefund() {\n        if (msg.sender == owner) {\n            uint a = collectedFee;\n            collectedFee = 0; \n            require(owner.send(a));\n        } else {\n\t        uint b = users[msg.sender].balance;\n\t        users[msg.sender].balance = 0;\n\t        require(msg.sender.send(b));\n\t    \t}\n    }\n\n\n    // GETTERS\n\n    function getResponse() public constant returns(string _response){\n        return users[msg.sender].response;\n    }\n\n    function getPrice(uint _gasPrice , uint _gasLimit) public constant returns(uint _price) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n    \tassert(_gasLimit * _gasPrice / _gasLimit == _gasPrice); // To avoid overflow exploitation\n    \treturn feePrice + _gasLimit * _gasPrice;\n    }\n\n    function getBalance() public constant returns(uint _balance) {\n    \treturn users[msg.sender].balance;\n    }\n\n    function getBalance(address _address) public constant returns(uint _balance) {\n\t\treturn users[_address].balance;\n    }\n\n\n\n    // SET RESPONSE FROM ORACLE\n    function setResponse (address _user, string _result) onlyOracle {\n\n\t\trequire( users[_user].asked );\n\t\tusers[_user].asked = false;\n\n    \tif ( users[_user].callBack ) {\n    \t\t// Callback function: passive, expensive, somewhat private\n        \tCaller _caller = Caller(_user);\n        \t_caller.EFOcallBack(_result);\n    \t\t} else {\n    \t// Mapping: active, cheap, public\n        users[_user].response = _result;\n        Response( _user , _result );\n    \t}\n\n    }\n\n\n    // INTERNAL FUNCTIONS\n\n    function payToOracle (uint _gasPrice , uint _gasLimit) internal returns(uint _price , uint _limit) {\n        if (_gasPrice == 0) _gasPrice = gasPrice;\n        if (_gasLimit == 0) _gasLimit = gasLimit;\n\n        uint gp = getPrice(_gasPrice,_gasLimit);\n\n        require (users[msg.sender].balance >= gp );\n\n        collectedFee += feePrice;\n        users[msg.sender].balance -= gp;\n\n        require(oracleAddress.send(gp - feePrice));\n        return(_gasPrice,_gasLimit);\n    }\n\n\n    // ADMIN FUNCTIONS\n    \n    function changeOwner(address _newOwner) onlyOwner {\n        owner = _newOwner;\n    }\n\n    function changeOracleAdd(address _newOracleAdd) onlyOwner {\n        oracleAddress = _newOracleAdd;\n    }\n\n    function setFeePrice(uint _feePrice) onlyOwner {\n        feePrice = _feePrice;\n    }\n\n    function setGasPrice(uint _gasPrice) onlyOwnerOrOracle {\n    \tgasPrice = _gasPrice;\n    }\n\n    function setGasLimit(uint _gasLimit) onlyOwnerOrOracle {\n    \tgasLimit = _gasLimit;\n    }\n\n    function emergencyFlush() onlyOwner {\n        require(owner.send(this.balance));\n    }\n\n    function ban(address _user) onlyOwner{\n        users[_user].banned = true;\n    }\n    \n    function desBan(address _user) onlyOwner{\n        users[_user].banned = false;\n    }\n}",
        "debug": "calldata_EthernityFinancialOracle_4 + calldata_EthernityFinancialOracle_32 + 4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_0_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthernityFinancialOracle_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EthernityFinancialOracle_0: 0x600a686e00000000000000000000000000000000000000000000000000000000\ncalldatasize_EthernityFinancialOracle: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x600a686e`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x604e244d5157c3ae734642364ace6c633fb1f278.sol",
        "function": "_function_0x600a686e",
        "lineno": 13,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}