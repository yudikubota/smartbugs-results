{"error": null, "issues": [{"address": 902, "code": "Vanity[msg.sender] = van;\n        if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n        p3dContract.buy.value(msg.value)(masternode);\n    } \n    //\n     function withdraw()\n        external\n        hasEarnings\n    {\n       \n        \n        uint256 amount = playerVault[", "debug": "calldata_Spud3D_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Spud3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "changevanity(string,address)", "lineno": 129, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1981, "code": "etthismuchethforyourspud(uint256 amo", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "contractownsthismanyP3D()", "lineno": 62, "title": "Message call to external contract", "type": "Informational"}, {"address": 2699, "code": "t = dividends.div(100);\n     ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "getthismuchethforyourspud(uint256)", "lineno": 69, "title": "Message call to external contract", "type": "Informational"}, {"address": 2990, "code": "lt == 1){result = true;}\n        if(refblocknr <", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Spud3D_0: 0x6a6f03a000000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nstorage_8: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "returntrueifcurrentplayerwinsround()", "lineno": 102, "title": "Exception state", "type": "Informational"}, {"address": 3673, "code": "         SpudPot = SpudPot.ad", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "SpudToDivs(uint256)", "lineno": 236, "title": "Message call to external contract", "type": "Informational"}, {"address": 4577, "code": "     {\n       ", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Spud3D_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `GetSpud(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 163, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4592, "code": "t change state ", "debug": "storage_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `GetSpud(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 164, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4673, "code": "ayer does not win\n", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `GetSpud(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 164, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4756, "code": "esult = uint256(blockhash(refblocknr", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x7ffffbffffffffffffffffffffeffa23c00000efdddc575f57ffffffd3280000\ncallvalue: 0xdfe94be3b77fffba7cfffffd71bef607c02000bea152d220017f7afdf6d7ffff\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nstorage_0 + keccac_storage_7: 0x0\nblock_number: 0x0\n", "description": "A possible integer overflow exists in the function `GetSpud(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 172, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4770, "code": "RnG(Spudgame[", "debug": "storage_0 + keccac_storage_7: 0xff\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nblock_number: 0xff\n", "description": "A possible integer underflow exists in the function `GetSpud(address)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 173, "title": "Integer Underflow", "type": "Warning"}, {"address": 4806, "code": "1)\n        {\n            // won payout\n         ", "debug": "The exception is triggered under the following conditions:\n\nstorage_0 + keccac_storage_7: 0xbfdfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff2f\nblock_number: 0xbfc000000000000000000000000000000000000000000000000000000000002f\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nstorage_8: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 176, "title": "Exception state", "type": "Informational"}, {"address": 4940, "code": "ress rotated = R", "debug": "storage_5: 0xe478e4176c45306b5c804fbb7d7fa90a99764149d78c90b582441f2384047660\ncallvalue: 0x7696205532c32efd4306ef23c554adf281f209b2c6133fd1b76b546050877765\nstorage_0 + keccac_storage_7: 0xb2d001000104010000800d8f62efba1a2fadcffdffffffffffffffffffffff03\nblock_number: 0x5a64c040b17509814990cd8f63f3ba1eb03d5400000000000000000000000001\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `GetSpud(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 180, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5891, "code": "otator[RNGrot", "debug": "block_number: 0x0\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nstorage_0 + keccac_storage_7: 0x0\n", "description": "A possible integer underflow exists in the function `GetSpud(address)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 210, "title": "Integer Underflow", "type": "Warning"}, {"address": 5906, "code": "ed);\n           ", "debug": "callvalue: 0x8000000000000000000000000fffffffffe00004000000000000000000000001\nstorage_0 + keccac_storage_7: 0x0\nstorage_5: 0x8000000000000000000000000000000000200003e00000000000000000000000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nblock_number: 0x0\n", "description": "A possible integer overflow exists in the function `GetSpud(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 212, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5933, "code": "sfer(base.mul(5));\n            emit payout", "debug": "The exception is triggered under the following conditions:\n\nstorage_0 + keccac_storage_7: 0x0\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x74dbe5e600000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\nstorage_9: 0x0\nblock_number: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "GetSpud(address)", "lineno": 213, "title": "Exception state", "type": "Informational"}, {"address": 6886, "code": "n contractownsthismanyP3D()\n ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "harvestabledivs()", "lineno": 54, "title": "Message call to external contract", "type": "Informational"}, {"address": 7856, "code": "3D {\n    using SafeMath for uint;\n    \n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n    \n    struct State {\n        \n        uint256 blocknumber;\n        address player;\n        \n        \n    }\n    \n    mapping(uint256 =>  State) public Spudgame;\n    mapping(address => uint256) public playerVault;\n    mapping(address => uint256) public SpudCoin;\n    mapping(uint256 => address) public Rotator;\n    \n    uint256 public totalsupply;//spud totalsupply\n    uint256 public Pot; // pot that get's filled from entry mainly\n    uint256 public SpudPot; // divpot spucoins can be traded for\n    uint256 public round; //roundnumber\n    \n    uint256 public RNGdeterminator; // variable upon gameprogress\n    uint256 public nextspotnr; // next spot in rotator\n    \n    mapping(address => string) public Vanity;\n    \n    event Withdrawn(address indexed player, uint256 indexed amount);\n    event SpudRnG(address indexed player, uint256 indexed outcome);\n    event payout(address indexed player, uint256 indexed amount);\n    \n    function harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( p3dContract.myDividends(true))  ;\n    }\n    function contractownsthismanyP3D()\n        public\n        view\n        returns(uint256)\n    {\n        \n        return (p3dContract.balanceOf(address(this)));\n    }\n    function getthismuchethforyourspud(uint256 amount)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 dividends = p3dContract.myDividends(true);\n            \n            uint256 amt = dividends.div(100);\n            \n            uint256 thepot = SpudPot.add(dividends.sub(amt));\n            \n        uint256 payouts = thepot.mul(amount).div(totalsupply);\n        return (payouts);\n    }\n    function thismanyblockstillthspudholderwins()\n        public\n        view\n        returns(uint256)\n    {\n        uint256 value;\n        if(265-( block.number - Spudgame[round].blocknumber) >0){value = 265- (block.number - Spudgame[round].blocknumber);}\n        return (value);\n    }\n    function currentspudinfo()\n        public\n        view\n        returns(uint256, address)\n    {\n        \n        return (Spudgame[round].blocknumber, Spudgame[round].player);\n    }\n    function returntrueifcurrentplayerwinsround()\n        public\n        view\n        returns(bool)\n    {\n        uint256 refblocknr = Spudgame[round].blocknumber;\n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        \n        bool result;\n        if(RNGresult == 1){result = true;}\n        if(refblocknr < block.number - 256){result = true;}\n        return (result);\n    }\n    //mods\n    modifier hasEarnings()\n    {\n        require(playerVault[msg.sender] > 0);\n        _;\n    }\n    \n    function() external payable {} // needed for P3D myDividends\n    //constructor\n    constructor()\n        public\n    {\n        Spudgame[0].player = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n        Spudgame[0].blocknumber = block.number;\n        RNGdeterminator = 6;\n        Rotator[0] = 0x989eB9629225B8C06997eF0577CC08535fD789F9;//raffle3d possible MN reward\n        nextspotnr++;\n    }\n    //vanity\n    \n    function changevanity(string van , address masternode) public payable\n    {\n        require(msg.value >= 1  finney);\n        Vanity[msg.sender] = van;\n        if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n        p3dContract.buy.value(msg.value)(masternode);\n    } \n    //\n     function withdraw()\n        external\n        hasEarnings\n    {\n       \n        \n        uint256 amount = playerVault[msg.sender];\n        playerVault[msg.sender] = 0;\n        \n        emit Withdrawn(msg.sender, amount); \n        \n        msg.sender.transfer(amount);\n    }\n    // main function\n    function GetSpud(address MN) public payable\n    {\n        require(msg.value >= 1  finney);\n        address sender = msg.sender;\n        uint256 blocknr = block.number;\n        uint256 curround = round;\n        uint256 refblocknr = Spudgame[curround].blocknumber;\n        \n        SpudCoin[MN]++;\n        totalsupply +=2;\n        SpudCoin[sender]++;\n        \n        // check previous RNG\n        \n        if(blocknr == refblocknr) \n        {\n            // just change state previous player does not win\n            \n            playerVault[msg.sender] += msg.value;\n            \n        }\n        if(blocknr - 256 <= refblocknr && blocknr != refblocknr)\n        {\n        \n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        emit SpudRnG(Spudgame[curround].player , RNGresult) ;\n        \n        Pot += msg.value;\n        if(RNGresult == 1)\n        {\n            // won payout\n            uint256 RNGrotator = uint256(blockhash(refblocknr)) % nextspotnr;\n            address rotated = Rotator[RNGrotator]; \n            uint256 base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[curround].player.transfer(base.mul(5));\n            emit payout(Spudgame[curround].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            uint256 nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        if(RNGresult != 1)\n        {\n            // not won\n            \n            Spudgame[curround].player = sender;\n            Spudgame[curround].blocknumber = blocknr;\n        }\n        \n        \n        }\n        if(blocknr - 256 > refblocknr)\n        {\n            //win\n            // won payout\n            Pot += msg.value;\n            RNGrotator = uint256(blockhash(blocknr-1)) % nextspotnr;\n            rotated =Rotator[RNGrotator]; \n            base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[round].player.transfer(base.mul(5));\n            emit payout(Spudgame[round].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        \n    } \n\nfunction SpudToDivs(uint256 amount) public \n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n         uint256 dividends = p3dContract.myDividends(true);\n            require(dividends > 0);\n            uint256 amt = dividends.div(100);\n            p3dContract.withdraw();\n            SPASM_.disburse.value(amt)();// to dev fee sharing contract SPASM\n            SpudPot = SpudPot.add(dividends.sub(amt));\n        uint256 payouts = SpudPot.mul(amount).div(totalsupply);\n        SpudPot = SpudPot.sub(payouts);\n        SpudCoin[sender] = SpudCoin[sender].sub(amount);\n        totalsupply = totalsupply.sub(amount);\n        sender.transfer(payouts);\n    } \nfunction SpudToRotator(uint256 amount, address MN) public\n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n        uint256 counter;\n    for(uint i=0; i< amount; i++)\n        {\n            counter = i + nextspotnr;\n            Rotator[counter] = MN;\n        }\n    nextspotnr += i;\n    SpudCoin[sender] = SpudCoin[sender].sub(amount);\n    totalsupply = totalsupply.sub(amount);\n    }\n}\n\ninterface HourglassInterface {\n    function buy(address _playerAddress) payable external returns(uint256);\n    function withdraw() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function balanceOf(addre", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "changevanity(string,address)", "lineno": 14, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7885, "code": "3D {\n    using SafeMath for uint;\n    \n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n    \n    struct State {\n        \n        uint256 blocknumber;\n        address player;\n        \n        \n    }\n    \n    mapping(uint256 =>  State) public Spudgame;\n    mapping(address => uint256) public playerVault;\n    mapping(address => uint256) public SpudCoin;\n    mapping(uint256 => address) public Rotator;\n    \n    uint256 public totalsupply;//spud totalsupply\n    uint256 public Pot; // pot that get's filled from entry mainly\n    uint256 public SpudPot; // divpot spucoins can be traded for\n    uint256 public round; //roundnumber\n    \n    uint256 public RNGdeterminator; // variable upon gameprogress\n    uint256 public nextspotnr; // next spot in rotator\n    \n    mapping(address => string) public Vanity;\n    \n    event Withdrawn(address indexed player, uint256 indexed amount);\n    event SpudRnG(address indexed player, uint256 indexed outcome);\n    event payout(address indexed player, uint256 indexed amount);\n    \n    function harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( p3dContract.myDividends(true))  ;\n    }\n    function contractownsthismanyP3D()\n        public\n        view\n        returns(uint256)\n    {\n        \n        return (p3dContract.balanceOf(address(this)));\n    }\n    function getthismuchethforyourspud(uint256 amount)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 dividends = p3dContract.myDividends(true);\n            \n            uint256 amt = dividends.div(100);\n            \n            uint256 thepot = SpudPot.add(dividends.sub(amt));\n            \n        uint256 payouts = thepot.mul(amount).div(totalsupply);\n        return (payouts);\n    }\n    function thismanyblockstillthspudholderwins()\n        public\n        view\n        returns(uint256)\n    {\n        uint256 value;\n        if(265-( block.number - Spudgame[round].blocknumber) >0){value = 265- (block.number - Spudgame[round].blocknumber);}\n        return (value);\n    }\n    function currentspudinfo()\n        public\n        view\n        returns(uint256, address)\n    {\n        \n        return (Spudgame[round].blocknumber, Spudgame[round].player);\n    }\n    function returntrueifcurrentplayerwinsround()\n        public\n        view\n        returns(bool)\n    {\n        uint256 refblocknr = Spudgame[round].blocknumber;\n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        \n        bool result;\n        if(RNGresult == 1){result = true;}\n        if(refblocknr < block.number - 256){result = true;}\n        return (result);\n    }\n    //mods\n    modifier hasEarnings()\n    {\n        require(playerVault[msg.sender] > 0);\n        _;\n    }\n    \n    function() external payable {} // needed for P3D myDividends\n    //constructor\n    constructor()\n        public\n    {\n        Spudgame[0].player = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n        Spudgame[0].blocknumber = block.number;\n        RNGdeterminator = 6;\n        Rotator[0] = 0x989eB9629225B8C06997eF0577CC08535fD789F9;//raffle3d possible MN reward\n        nextspotnr++;\n    }\n    //vanity\n    \n    function changevanity(string van , address masternode) public payable\n    {\n        require(msg.value >= 1  finney);\n        Vanity[msg.sender] = van;\n        if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n        p3dContract.buy.value(msg.value)(masternode);\n    } \n    //\n     function withdraw()\n        external\n        hasEarnings\n    {\n       \n        \n        uint256 amount = playerVault[msg.sender];\n        playerVault[msg.sender] = 0;\n        \n        emit Withdrawn(msg.sender, amount); \n        \n        msg.sender.transfer(amount);\n    }\n    // main function\n    function GetSpud(address MN) public payable\n    {\n        require(msg.value >= 1  finney);\n        address sender = msg.sender;\n        uint256 blocknr = block.number;\n        uint256 curround = round;\n        uint256 refblocknr = Spudgame[curround].blocknumber;\n        \n        SpudCoin[MN]++;\n        totalsupply +=2;\n        SpudCoin[sender]++;\n        \n        // check previous RNG\n        \n        if(blocknr == refblocknr) \n        {\n            // just change state previous player does not win\n            \n            playerVault[msg.sender] += msg.value;\n            \n        }\n        if(blocknr - 256 <= refblocknr && blocknr != refblocknr)\n        {\n        \n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        emit SpudRnG(Spudgame[curround].player , RNGresult) ;\n        \n        Pot += msg.value;\n        if(RNGresult == 1)\n        {\n            // won payout\n            uint256 RNGrotator = uint256(blockhash(refblocknr)) % nextspotnr;\n            address rotated = Rotator[RNGrotator]; \n            uint256 base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[curround].player.transfer(base.mul(5));\n            emit payout(Spudgame[curround].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            uint256 nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        if(RNGresult != 1)\n        {\n            // not won\n            \n            Spudgame[curround].player = sender;\n            Spudgame[curround].blocknumber = blocknr;\n        }\n        \n        \n        }\n        if(blocknr - 256 > refblocknr)\n        {\n            //win\n            // won payout\n            Pot += msg.value;\n            RNGrotator = uint256(blockhash(blocknr-1)) % nextspotnr;\n            rotated =Rotator[RNGrotator]; \n            base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[round].player.transfer(base.mul(5));\n            emit payout(Spudgame[round].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        \n    } \n\nfunction SpudToDivs(uint256 amount) public \n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n         uint256 dividends = p3dContract.myDividends(true);\n            require(dividends > 0);\n            uint256 amt = dividends.div(100);\n            p3dContract.withdraw();\n            SPASM_.disburse.value(amt)();// to dev fee sharing contract SPASM\n            SpudPot = SpudPot.add(dividends.sub(amt));\n        uint256 payouts = SpudPot.mul(amount).div(totalsupply);\n        SpudPot = SpudPot.sub(payouts);\n        SpudCoin[sender] = SpudCoin[sender].sub(amount);\n        totalsupply = totalsupply.sub(amount);\n        sender.transfer(payouts);\n    } \nfunction SpudToRotator(uint256 amount, address MN) public\n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n        uint256 counter;\n    for(uint i=0; i< amount; i++)\n        {\n            counter = i + nextspotnr;\n            Rotator[counter] = MN;\n        }\n    nextspotnr += i;\n    SpudCoin[sender] = SpudCoin[sender].sub(amount);\n    totalsupply = totalsupply.sub(amount);\n    }\n}\n\ninterface HourglassInterface {\n    function buy(address _playerAddress) payable external returns(uint256);\n    function withdraw() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function balanceOf(addre", "debug": "calldata_Spud3D_4 + calldata_Spud3D_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "changevanity(string,address)", "lineno": 14, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7899, "code": "3D {\n    using SafeMath for uint;\n    \n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n    \n    struct State {\n        \n        uint256 blocknumber;\n        address player;\n        \n        \n    }\n    \n    mapping(uint256 =>  State) public Spudgame;\n    mapping(address => uint256) public playerVault;\n    mapping(address => uint256) public SpudCoin;\n    mapping(uint256 => address) public Rotator;\n    \n    uint256 public totalsupply;//spud totalsupply\n    uint256 public Pot; // pot that get's filled from entry mainly\n    uint256 public SpudPot; // divpot spucoins can be traded for\n    uint256 public round; //roundnumber\n    \n    uint256 public RNGdeterminator; // variable upon gameprogress\n    uint256 public nextspotnr; // next spot in rotator\n    \n    mapping(address => string) public Vanity;\n    \n    event Withdrawn(address indexed player, uint256 indexed amount);\n    event SpudRnG(address indexed player, uint256 indexed outcome);\n    event payout(address indexed player, uint256 indexed amount);\n    \n    function harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( p3dContract.myDividends(true))  ;\n    }\n    function contractownsthismanyP3D()\n        public\n        view\n        returns(uint256)\n    {\n        \n        return (p3dContract.balanceOf(address(this)));\n    }\n    function getthismuchethforyourspud(uint256 amount)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 dividends = p3dContract.myDividends(true);\n            \n            uint256 amt = dividends.div(100);\n            \n            uint256 thepot = SpudPot.add(dividends.sub(amt));\n            \n        uint256 payouts = thepot.mul(amount).div(totalsupply);\n        return (payouts);\n    }\n    function thismanyblockstillthspudholderwins()\n        public\n        view\n        returns(uint256)\n    {\n        uint256 value;\n        if(265-( block.number - Spudgame[round].blocknumber) >0){value = 265- (block.number - Spudgame[round].blocknumber);}\n        return (value);\n    }\n    function currentspudinfo()\n        public\n        view\n        returns(uint256, address)\n    {\n        \n        return (Spudgame[round].blocknumber, Spudgame[round].player);\n    }\n    function returntrueifcurrentplayerwinsround()\n        public\n        view\n        returns(bool)\n    {\n        uint256 refblocknr = Spudgame[round].blocknumber;\n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        \n        bool result;\n        if(RNGresult == 1){result = true;}\n        if(refblocknr < block.number - 256){result = true;}\n        return (result);\n    }\n    //mods\n    modifier hasEarnings()\n    {\n        require(playerVault[msg.sender] > 0);\n        _;\n    }\n    \n    function() external payable {} // needed for P3D myDividends\n    //constructor\n    constructor()\n        public\n    {\n        Spudgame[0].player = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n        Spudgame[0].blocknumber = block.number;\n        RNGdeterminator = 6;\n        Rotator[0] = 0x989eB9629225B8C06997eF0577CC08535fD789F9;//raffle3d possible MN reward\n        nextspotnr++;\n    }\n    //vanity\n    \n    function changevanity(string van , address masternode) public payable\n    {\n        require(msg.value >= 1  finney);\n        Vanity[msg.sender] = van;\n        if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n        p3dContract.buy.value(msg.value)(masternode);\n    } \n    //\n     function withdraw()\n        external\n        hasEarnings\n    {\n       \n        \n        uint256 amount = playerVault[msg.sender];\n        playerVault[msg.sender] = 0;\n        \n        emit Withdrawn(msg.sender, amount); \n        \n        msg.sender.transfer(amount);\n    }\n    // main function\n    function GetSpud(address MN) public payable\n    {\n        require(msg.value >= 1  finney);\n        address sender = msg.sender;\n        uint256 blocknr = block.number;\n        uint256 curround = round;\n        uint256 refblocknr = Spudgame[curround].blocknumber;\n        \n        SpudCoin[MN]++;\n        totalsupply +=2;\n        SpudCoin[sender]++;\n        \n        // check previous RNG\n        \n        if(blocknr == refblocknr) \n        {\n            // just change state previous player does not win\n            \n            playerVault[msg.sender] += msg.value;\n            \n        }\n        if(blocknr - 256 <= refblocknr && blocknr != refblocknr)\n        {\n        \n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        emit SpudRnG(Spudgame[curround].player , RNGresult) ;\n        \n        Pot += msg.value;\n        if(RNGresult == 1)\n        {\n            // won payout\n            uint256 RNGrotator = uint256(blockhash(refblocknr)) % nextspotnr;\n            address rotated = Rotator[RNGrotator]; \n            uint256 base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[curround].player.transfer(base.mul(5));\n            emit payout(Spudgame[curround].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            uint256 nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        if(RNGresult != 1)\n        {\n            // not won\n            \n            Spudgame[curround].player = sender;\n            Spudgame[curround].blocknumber = blocknr;\n        }\n        \n        \n        }\n        if(blocknr - 256 > refblocknr)\n        {\n            //win\n            // won payout\n            Pot += msg.value;\n            RNGrotator = uint256(blockhash(blocknr-1)) % nextspotnr;\n            rotated =Rotator[RNGrotator]; \n            base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[round].player.transfer(base.mul(5));\n            emit payout(Spudgame[round].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        \n    } \n\nfunction SpudToDivs(uint256 amount) public \n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n         uint256 dividends = p3dContract.myDividends(true);\n            require(dividends > 0);\n            uint256 amt = dividends.div(100);\n            p3dContract.withdraw();\n            SPASM_.disburse.value(amt)();// to dev fee sharing contract SPASM\n            SpudPot = SpudPot.add(dividends.sub(amt));\n        uint256 payouts = SpudPot.mul(amount).div(totalsupply);\n        SpudPot = SpudPot.sub(payouts);\n        SpudCoin[sender] = SpudCoin[sender].sub(amount);\n        totalsupply = totalsupply.sub(amount);\n        sender.transfer(payouts);\n    } \nfunction SpudToRotator(uint256 amount, address MN) public\n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n        uint256 counter;\n    for(uint i=0; i< amount; i++)\n        {\n            counter = i + nextspotnr;\n            Rotator[counter] = MN;\n        }\n    nextspotnr += i;\n    SpudCoin[sender] = SpudCoin[sender].sub(amount);\n    totalsupply = totalsupply.sub(amount);\n    }\n}\n\ninterface HourglassInterface {\n    function buy(address _playerAddress) payable external returns(uint256);\n    function withdraw() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function balanceOf(addre", "debug": "calldata_Spud3D_4 + calldata_Spud3D_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "changevanity(string,address)", "lineno": 14, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7921, "code": "3D {\n    using SafeMath for uint;\n    \n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n    \n    struct State {\n        \n        uint256 blocknumber;\n        address player;\n        \n        \n    }\n    \n    mapping(uint256 =>  State) public Spudgame;\n    mapping(address => uint256) public playerVault;\n    mapping(address => uint256) public SpudCoin;\n    mapping(uint256 => address) public Rotator;\n    \n    uint256 public totalsupply;//spud totalsupply\n    uint256 public Pot; // pot that get's filled from entry mainly\n    uint256 public SpudPot; // divpot spucoins can be traded for\n    uint256 public round; //roundnumber\n    \n    uint256 public RNGdeterminator; // variable upon gameprogress\n    uint256 public nextspotnr; // next spot in rotator\n    \n    mapping(address => string) public Vanity;\n    \n    event Withdrawn(address indexed player, uint256 indexed amount);\n    event SpudRnG(address indexed player, uint256 indexed outcome);\n    event payout(address indexed player, uint256 indexed amount);\n    \n    function harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( p3dContract.myDividends(true))  ;\n    }\n    function contractownsthismanyP3D()\n        public\n        view\n        returns(uint256)\n    {\n        \n        return (p3dContract.balanceOf(address(this)));\n    }\n    function getthismuchethforyourspud(uint256 amount)\n        public\n        view\n        returns(uint256)\n    {\n        uint256 dividends = p3dContract.myDividends(true);\n            \n            uint256 amt = dividends.div(100);\n            \n            uint256 thepot = SpudPot.add(dividends.sub(amt));\n            \n        uint256 payouts = thepot.mul(amount).div(totalsupply);\n        return (payouts);\n    }\n    function thismanyblockstillthspudholderwins()\n        public\n        view\n        returns(uint256)\n    {\n        uint256 value;\n        if(265-( block.number - Spudgame[round].blocknumber) >0){value = 265- (block.number - Spudgame[round].blocknumber);}\n        return (value);\n    }\n    function currentspudinfo()\n        public\n        view\n        returns(uint256, address)\n    {\n        \n        return (Spudgame[round].blocknumber, Spudgame[round].player);\n    }\n    function returntrueifcurrentplayerwinsround()\n        public\n        view\n        returns(bool)\n    {\n        uint256 refblocknr = Spudgame[round].blocknumber;\n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        \n        bool result;\n        if(RNGresult == 1){result = true;}\n        if(refblocknr < block.number - 256){result = true;}\n        return (result);\n    }\n    //mods\n    modifier hasEarnings()\n    {\n        require(playerVault[msg.sender] > 0);\n        _;\n    }\n    \n    function() external payable {} // needed for P3D myDividends\n    //constructor\n    constructor()\n        public\n    {\n        Spudgame[0].player = 0x0B0eFad4aE088a88fFDC50BCe5Fb63c6936b9220;\n        Spudgame[0].blocknumber = block.number;\n        RNGdeterminator = 6;\n        Rotator[0] = 0x989eB9629225B8C06997eF0577CC08535fD789F9;//raffle3d possible MN reward\n        nextspotnr++;\n    }\n    //vanity\n    \n    function changevanity(string van , address masternode) public payable\n    {\n        require(msg.value >= 1  finney);\n        Vanity[msg.sender] = van;\n        if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n        p3dContract.buy.value(msg.value)(masternode);\n    } \n    //\n     function withdraw()\n        external\n        hasEarnings\n    {\n       \n        \n        uint256 amount = playerVault[msg.sender];\n        playerVault[msg.sender] = 0;\n        \n        emit Withdrawn(msg.sender, amount); \n        \n        msg.sender.transfer(amount);\n    }\n    // main function\n    function GetSpud(address MN) public payable\n    {\n        require(msg.value >= 1  finney);\n        address sender = msg.sender;\n        uint256 blocknr = block.number;\n        uint256 curround = round;\n        uint256 refblocknr = Spudgame[curround].blocknumber;\n        \n        SpudCoin[MN]++;\n        totalsupply +=2;\n        SpudCoin[sender]++;\n        \n        // check previous RNG\n        \n        if(blocknr == refblocknr) \n        {\n            // just change state previous player does not win\n            \n            playerVault[msg.sender] += msg.value;\n            \n        }\n        if(blocknr - 256 <= refblocknr && blocknr != refblocknr)\n        {\n        \n        uint256 RNGresult = uint256(blockhash(refblocknr)) % RNGdeterminator;\n        emit SpudRnG(Spudgame[curround].player , RNGresult) ;\n        \n        Pot += msg.value;\n        if(RNGresult == 1)\n        {\n            // won payout\n            uint256 RNGrotator = uint256(blockhash(refblocknr)) % nextspotnr;\n            address rotated = Rotator[RNGrotator]; \n            uint256 base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[curround].player.transfer(base.mul(5));\n            emit payout(Spudgame[curround].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            uint256 nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        if(RNGresult != 1)\n        {\n            // not won\n            \n            Spudgame[curround].player = sender;\n            Spudgame[curround].blocknumber = blocknr;\n        }\n        \n        \n        }\n        if(blocknr - 256 > refblocknr)\n        {\n            //win\n            // won payout\n            Pot += msg.value;\n            RNGrotator = uint256(blockhash(blocknr-1)) % nextspotnr;\n            rotated =Rotator[RNGrotator]; \n            base = Pot.div(10);\n            p3dContract.buy.value(base)(rotated);\n            Spudgame[round].player.transfer(base.mul(5));\n            emit payout(Spudgame[round].player , base.mul(5));\n            Pot = Pot.sub(base.mul(6));\n            // ifpreviouswon => new round\n            nextround = curround+1;\n            Spudgame[nextround].player = sender;\n            Spudgame[nextround].blocknumber = blocknr;\n            \n            round++;\n            RNGdeterminator = 6;\n        }\n        \n    } \n\nfunction SpudToDivs(uint256 amount) public \n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n         uint256 dividends = p3dContract.myDividends(true);\n            require(dividends > 0);\n            uint256 amt = dividends.div(100);\n            p3dContract.withdraw();\n            SPASM_.disburse.value(amt)();// to dev fee sharing contract SPASM\n            SpudPot = SpudPot.add(dividends.sub(amt));\n        uint256 payouts = SpudPot.mul(amount).div(totalsupply);\n        SpudPot = SpudPot.sub(payouts);\n        SpudCoin[sender] = SpudCoin[sender].sub(amount);\n        totalsupply = totalsupply.sub(amount);\n        sender.transfer(payouts);\n    } \nfunction SpudToRotator(uint256 amount, address MN) public\n    {\n        address sender = msg.sender;\n        require(amount>0 && SpudCoin[sender] >= amount );\n        uint256 counter;\n    for(uint i=0; i< amount; i++)\n        {\n            counter = i + nextspotnr;\n            Rotator[counter] = MN;\n        }\n    nextspotnr += i;\n    SpudCoin[sender] = SpudCoin[sender].sub(amount);\n    totalsupply = totalsupply.sub(amount);\n    }\n}\n\ninterface HourglassInterface {\n    function buy(address _playerAddress) payable external returns(uint256);\n    function withdraw() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function balanceOf(addre", "debug": "calldata_Spud3D_4 + calldata_Spud3D_4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x38d7ea4c68000\ncalldata_Spud3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Spud3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/7/0x628a419592d62cbde91e8d584ee8dae753f973ad.sol", "function": "changevanity(string,address)", "lineno": 14, "title": "Integer Overflow ", "type": "Warning"}], "success": true}