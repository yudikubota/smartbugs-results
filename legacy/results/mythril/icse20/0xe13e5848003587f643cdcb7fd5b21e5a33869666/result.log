{"error": null, "issues": [{"address": 589, "code": "erId) {\n        xrateProviderId = uint16(xrateProviders.length);\n        xrateProviders.push(addr);\n        NewXRateProvider(addr, xrateProviderId, msg.sender);\n    }\n\n\n    ///@dev xrateP", "debug": "calldata_XRateProvider_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_XRateProvider_0: 0x140758a900000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x140758a9`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x140758a9", "lineno": 453, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1513, "code": "   if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    // *************************************************\n    // *            subscription handling              *\n    // *************************************************\n\n    ///@dev convenience getter for some subscription fields\n    function subscriptionDetails(uint subId) public constant returns (\n        address transferFrom,\n        address transferTo,\n        uint pricePerHour,\n        uint32 initialXrate_n, //nominator\n        uint32 initialXrate_d, //denominator\n        uint16 xratePr", "debug": "calldata_XRateProvider_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_XRateProvider_0: 0x3689a65100000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x3689a651`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x3689a651", "lineno": 500, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2403, "code": "\n\n\n    ///@dev register new exchange rate provider.\n    ///     XRateProvider can't be de-registered, because they could be still in use by some subscription.\n    function registerXRate", "debug": "calldata_XRateProvider_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_XRateProvider_0: 0x5fb7a64300000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x5fb7a643`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x5fb7a643", "lineno": 448, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5225, "code": "_returnSubscriptionDesposit(subId, sub);\n    }\n\n\n    ", "debug": "The exception is triggered under the following conditions:\n\nstorage_1 + keccac_calldata_XRateProvider_4: 0x0\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_XRateProvider_0: 0x1c196d7700000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "returnSubscriptionDesposit(uint256)", "lineno": 906, "title": "Exception state", "type": "Informational"}, {"address": 5241, "code": "rns subscription deposit to cu", "debug": "The exception is triggered under the following conditions:\n\ntimestamp: 0x1f7dadfefa77e00000000206050606020a000063a0001fa0ef2\nstorage_8 + keccac_calldata_XRateProvider_4: 0x200000000000000000002008200808082000008000002001000\nstorage_4 + keccac_calldata_XRateProvider_4: 0x200000000000000000002008200808082000008000002001000\nstorage_7 + keccac_calldata_XRateProvider_4: 0x1f7dadfefa77e00000000206050606020a000063a0001fa0ef2\nstorage_1 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_XRateProvider_0: 0x1c196d7700000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\nstorage_6 + keccac_calldata_XRateProvider_4: 0x0\nstorage_11 + keccac_calldata_XRateProvider_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "returnSubscriptionDesposit(uint256)", "lineno": 910, "title": "Exception state", "type": "Informational"}, {"address": 5420, "code": "nSubscriptionDesposit(uint subId, Subscription storage sub) ", "debug": "The exception is triggered under the following conditions:\n\ntimestamp: 0x1f7dadfefa77e00000000206050606020a000063a0001fa0ef2\nstorage_8 + keccac_calldata_XRateProvider_4: 0x200000000000000000002008200808082000008000002001000\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\nstorage_6 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4 + keccac_calldata_XRateProvider_4: 0x200000000000000000002008200808082000008000002001000\nstorage_7 + keccac_calldata_XRateProvider_4: 0x1f7dadfefa77e00000000206050606020a000063a0001fa0ef2\nstorage_1 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_XRateProvider_0: 0x1c196d7700000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\nstorage_11 + keccac_calldata_XRateProvider_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "returnSubscriptionDesposit(uint256)", "lineno": 911, "title": "Exception state", "type": "Informational"}, {"address": 6513, "code": "*            subscription handling              *\n    // *****", "debug": "", "description": "This contract executes a message call to an address found at storage slot 11. This storage slot can be written to by calling the function `attachToken(address)`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x3689a651", "lineno": 506, "title": "Message call to external contract", "type": "Warning"}, {"address": 6513, "code": "*            subscription handling              *\n    // *****", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6849\nCall at address: 6849\nCall at address: 6849\nCall at address: 6849\nCall at address: 6849\nCall at address: 6849\nCall at address: 6849\nCall at address: 6849\n", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x3689a651", "lineno": 506, "title": "Multiple Calls", "type": "Information"}, {"address": 6513, "code": "*            subscription handling              *\n    // *****", "debug": "", "description": "A possible transaction order independence vulnerability exists in function _function_0x3689a651. The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x3689a651", "lineno": 506, "title": "Transaction order dependence", "type": "Warning"}, {"address": 6849, "code": "tails(uint subId) public constant returns (\n        address", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x3689a651", "lineno": 510, "title": "Message call to external contract", "type": "Warning"}, {"address": 7318, "code": " disableServiceProvider(S", "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_XRateProvider_0: 0x406a6f6000000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "attachToken(address)", "lineno": 445, "title": "Exception state", "type": "Informational"}, {"address": 7575, "code": ";\n\n// ==== DISCLAI", "debug": "storage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_XRateProvider_0: 0x5275364000000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x52753640`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "_function_0x52753640", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7984, "code": "     pricePerHour    : _price", "debug": "The exception is triggered under the following conditions:\n\ncalldata_XRateProvider_32 + 164: 0x0\ncalldata_XRateProvider_32 + 68: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\nstorage_2: 0x0\ncalldata_XRateProvider_0: 0x54d734e200000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)", "lineno": 669, "title": "Exception state", "type": "Informational"}, {"address": 8000, "code": "   // price per hour in SAN (recal", "debug": "The exception is triggered under the following conditions:\n\ncalldata_XRateProvider_32 + 36: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_XRateProvider_32 + 164: 0x0\ncalldata_XRateProvider_32 + 68: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\nstorage_2: 0x0\ncalldata_XRateProvider_0: 0x54d734e200000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)", "lineno": 669, "title": "Exception state", "type": "Informational"}, {"address": 8031, "code": "SAN.\n            initialXrate_n ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_XRateProvider_32 + 36: 0x0\nstorage_8: 0x0\ncalldata_XRateProvider_32 + 164: 0x0\ncalldata_XRateProvider_32 + 4: 0x7ffe\ncalldata_XRateProvider_32 + 68: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\nstorage_2: 0x0\ncalldata_XRateProvider_0: 0x54d734e200000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)", "lineno": 670, "title": "Exception state", "type": "Informational"}, {"address": 8176, "code": " nominated in SAN.\n            initialXrate_n  : _xrate_n", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)", "lineno": 670, "title": "Message call to external contract", "type": "Warning"}, {"address": 8468, "code": ",           // fracti", "debug": "calldata_XRateProvider_32 + 36: 0xe00000\nstorage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_XRateProvider_32 + 164: 0x0\ncalldata_XRateProvider_32 + 4: 0x0\ncalldata_XRateProvider_32 + 68: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\nstorage_2: 0x0\ncalldata_XRateProvider_0: 0x54d734e200000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "createSubscriptionOffer(uint256,uint16,uint256,uint256,uint256,uint256,uint256,bytes)", "lineno": 672, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9317, "code": "le reentrancy\n            amount = amou", "debug": "", "description": "This contract executes a message call to an address found at storage slot 11. This storage slot can be written to by calling the function `attachToken(address)`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "claimDeposit(uint256)", "lineno": 967, "title": "Message call to external contract", "type": "Warning"}, {"address": 9317, "code": "le reentrancy\n            amount = amou", "debug": "", "description": "A possible transaction order independence vulnerability exists in function claimDeposit(uint256). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "claimDeposit(uint256)", "lineno": 967, "title": "Transaction order dependence", "type": "Warning"}, {"address": 9884, "code": "    return _isOffer(subOrOffe", "debug": "The exception is triggered under the following conditions:\n\nstorage_1 + keccac_calldata_XRateProvider_4: 0x0\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_XRateProvider_0: 0x646cd69b00000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "postponeDueDate(uint256,uint256)", "lineno": 589, "title": "Exception state", "type": "Informational"}, {"address": 9975, "code": "      ? OFFER_STATES[uint(_offerState", "debug": "The exception is triggered under the following conditions:\n\ncaller: 0x0\nstorage_1 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_XRateProvider_0: 0x646cd69b00000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "postponeDueDate(uint256,uint256)", "lineno": 590, "title": "Exception state", "type": "Informational"}, {"address": 15834, "code": "e return value here? If is better to return the subscription d", "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_2: 0x0\ncalldata_XRateProvider_0: 0x2123508300000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "cancelSubscription(uint256)", "lineno": 786, "title": "Exception state", "type": "Informational"}, {"address": 15851, "code": "  }\n\n\n    ///@notice place an", "debug": "The exception is triggered under the following conditions:\n\nstorage_1 + keccac_calldata_XRateProvider_4: 0x0\nstorage_3: 0x0\ncaller: 0x0\nstorage_0 + keccac_calldata_XRateProvider_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_2: 0x0\ncalldata_XRateProvider_0: 0x2123508300000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "cancelSubscription(uint256)", "lineno": 790, "title": "Exception state", "type": "Informational"}, {"address": 20902, "code": "er lookup.\n    mapping (address=>bool) public providerRegistry;\n\n    ///@dev all subscriptions and offers (incl. FINALIZED).\n    mapping (uint => Subscription) public subscriptions;\n\n    ///@dev all active simple deposits gived by depositId.\n    mapping (uint => Deposit) public deposits;\n\n    ///@dev addresses of registered exchange rate providers.\n    XRateProvider[] public xrateProviders;\n\n    ///@dev ongoing counter for subscription ids starting from 1.\n    ///     Current value represents an id of last created subscription.\n    uint public subscriptionCounter = 0;\n\n    ///@dev ongoing counter for simple deposit ids starting from 1.\n    ///     Current value represents an id of last created deposit.\n    uint public depositCounter = 0;\n\n    ///@dev Token contract with ERC20ModuleSupport addon.\n    ///     Subscription Module operates on its balances via ERC20ModuleSupport interface as trusted module.\n    ERC20ModuleSupport public san;\n\n\n\n    // *************************************************\n    // *     reject all ether sent to this contract    *\n    // *************************************************\n    function () {\n        throw;\n    }\n\n\n\n    // *************************************************\n    // *            setup and configuration            *\n    // *************************************************\n\n    ///@dev constructor\n    function SubscriptionModuleImpl() {\n        owner = msg.sender;\n        xrateProviders.push(XRateProvider(this)); //this is a default SAN:SAN (1:1) provider with default id == 0\n    }\n\n\n    ///@dev attach SAN token to work with; can be done only once.\n    function attachToken(address token) public {\n        assert(address(san) == 0); //only in new deployed state\n        san = ERC20ModuleSupport(token);\n    }\n\n\n    ///@dev register a new service provider to the platform.\n    function enableServiceProvider(ServiceProvider addr, bytes moreInfo) public only(owner) {\n        providerRegistry[addr] = true;\n        ServiceProviderEnabled(addr, moreInfo);\n    }\n\n\n    ///@dev de-register the service provider with given `addr`.\n    function disableServiceProvider(ServiceProvider addr, bytes moreInfo) public only(owner) {\n        delete providerRegistry[addr];\n        ServiceProviderDisabled(addr, moreInfo);\n    }\n\n\n    ///@dev register new exchange rate provider.\n    ///     XRateProvider can't be de-registered, because they could be still in use by some subscription.\n    function registerXRateProvider(XRateProvider addr) public only(owner) returns (uint16 xrateProviderId) {\n        xrateProviderId = uint16(xrateProviders.length);\n        xrateProviders.push(addr);\n        NewXRateProvider(addr, xrateProviderId, msg.sender);\n    }\n\n\n    ///@dev xrateProviders length accessor.\n    function getXRateProviderLength() public constant returns (uint) {\n        return xrateProviders.length;\n    }\n\n\n    // *************************************************\n    // *           single payment methods              *\n    // *************************************************\n\n    ///@notice makes single payment to service provider.\n    ///@param _value - amount of SAN token to sent\n    ///@param _paymentData - 'payment purpose' code usually issued by service provider to customer before payment.\n    ///@param _to - service provider contract\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function paymentTo(uint _value, bytes _paymentData, ServiceProvider _to) public reentrant returns (bool success) {\n        if (san._fulfillPayment(msg.sender, _to, _value, 0, msg.sender)) {\n            // a ServiceProvider (a ServiceProvider) has here an opportunity verify and reject the payment\n            assert (ServiceProvider(_to).onPayment(msg.sender, _value, _paymentData));                      // <=== possible reentrancy\n            return true;\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    ///@notice makes single preapproved payment to service provider. An amount must be already preapproved by payment sender to recepient.\n    ///@param _value - amount of SAN token to sent\n    ///@param _paymentData - 'payment purpose' code usually issued by service provider to customer before payment.\n    ///@param _from - sender of the payment (other than msg.sender)\n    ///@param _to - service provider contract\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function paymentFrom(uint _value, bytes _paymentData, address _from, ServiceProvider _to) public reentrant returns (bool success) {\n        if (san._fulfillPreapprovedPayment(_from, _to, _value, msg.sender)) {\n            // a ServiceProvider (a ServiceProvider) has here an opportunity verify and reject the payment\n            assert (ServiceProvider(_to).onPayment(_from, _value, _paymentData));                           // <=== possible reentrancy\n            return true;\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    // *************************************************\n    // *            subscription handling              *\n    // *************************************************\n\n    ///@dev convenience getter for some subscription fields\n    function subscriptionDetails(uint subId) public constant returns (\n        address transferFrom,\n        address transferTo,\n        uint pricePerHour,\n        uint32 initialXrate_n, //nominator\n        uint32 initialXrate_d, //denominator\n        uint16 xrateProviderId,\n        uint chargePeriod,\n        uint startOn,\n        bytes descriptor\n    ) {\n        Subscription sub = subscriptions[subId];\n        return (sub.transferFrom, sub.transferTo, sub.pricePerHour, sub.initialXrate_n, sub.initialXrate_d, sub.xrateProviderId, sub.chargePeriod, sub.startOn, sub.descriptor);\n    }\n\n\n    ///@dev convenience getter for some subscription fields\n    ///     a caller must know, that the subscription with given id exists, because all these fields can be 0 even the subscription with given id exists.\n    function subscriptionStatus(uint subId) public constant returns(\n        uint depositAmount,\n        uint expireOn,\n        uint execCounter,\n        uint paidUntil,\n        uint onHoldSince\n    ) {\n        Subscription sub = subscriptions[subId];\n        return (sub.depositAmount, sub.expireOn, sub.execCounter, sub.paidUntil, sub.onHoldSince);\n    }\n\n\n    ///@notice execute periodic subscription payment.\n    ///        Any of customer, service provider and platform owner can execute this function.\n    ///        This ensures, that the subscription charge doesn't become delayed.\n    ///        At least the platform owner has an incentive to get fee and thus can trigger the function.\n    ///        An execution fails if subscription is not in status `CHARGEABLE`.\n    ///@param subId - subscription to be charged.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function executeSubscription(uint subId) public noReentrancy(L00) returns (bool) {\n        Subscription storage sub = subscriptions[subId];\n        assert (msg.sender == sub.transferFrom || msg.sender == sub.transferTo || msg.sender == owner);\n        if (_subscriptionState(sub)==SubState.CHARGEABLE) {\n            var _from = sub.transferFrom;\n            var _to = sub.transferTo;\n            var _value = _amountToCharge(sub);\n            if (san._fulfillPayment(_from, _to, _value, subId, msg.sender)) {\n                sub.paidUntil  = max(sub.paidUntil, sub.startOn) + sub.chargePeriod;\n                ++sub.execCounter;\n                // a ServiceProvider (a ServiceProvider) has here an opportunity to verify and reject the payment\n                assert (ServiceProvider(_to).onSubExecuted(subId));\n                return true;\n            }\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    ///@notice move `paidUntil` forward to given `newDueDate`. It waives payments for given time.\n    ///        This function can be used by service provider to `give away` some service time for free.\n    ///@param subId - id of subscription to be postponed.\n    ///@param newDueDate - new `paidUntil` datetime; require `newDueDate > paidUntil`.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function postponeDueDate(uint subId, uint newDueDate) public returns (bool success){\n        Subscription storage sub = subscriptions[subId];\n        assert (_isSubscription(sub));\n        assert (sub.transferTo == msg.sender); //only Service Provider is allowed to postpone the DueDate\n        if (sub.paidUntil < newDueDate) {\n            sub.paidUntil = newDueDate;\n            return true;\n        } else if (isContract(msg.sender)) { return false; }\n          else { throw; }\n    }\n\n\n    ///@dev return current status as a name of a subscription (or an offer) with given id;\n    function state(uint subOrOfferId) public constant returns(string state) {\n        Subscription subOrOffer = subscriptions[subOrOfferId];\n        return _isOffer(subOrOffer)\n              ? OFFER_STATES[uint(_offerState(subOrOffer))]\n              : SUB_STATES[uint(_subscriptionState(subOrOffer))];\n    }\n\n\n    ///@dev return current status as a code of a subscription (or an offer) with given id;\n    function stateCode(uint subOrOfferId) public constant returns(uint stateCode) {\n        Subscription subOrOffer = subscriptions[subOrOfferId];\n        return _isOffer(subOrOffer)\n              ? uint(_offerState(subOrOffer))\n              : uint(_subscriptionState(subOrOffer));\n    }\n\n\n    function _offerState(Subscription storage sub) internal constant returns(OfferState status) {\n        if (!_isOffer(sub)) {\n            return OfferState.NOT_EXIST;\n        } else if (sub.startOn > now) {\n            return OfferState.BEFORE_START;\n        } else if (sub.onHoldSince > 0) {\n            return OfferState.ON_HOLD;\n        } else if (now <= sub.expireOn) {\n            return sub.execCounter > 0\n                ? OfferState.ACTIVE\n                : OfferState.SOLD_OUT;\n        } else {\n            return OfferState.EXPIRED;\n        }\n    }\n\n    function _subscriptionState(Subscription storage sub) internal constant returns(SubState status) {\n        if (!_isSubscription(sub)) {\n            return SubState.NOT_EXIST;\n        } else if (sub.startOn > now) {\n            return SubState.BEFORE_START;\n        } else if (sub.onHoldSince > 0) {\n            return SubState.ON_HOLD;\n        } else if (sub.paidUntil >= sub.expireOn) {\n            return now < sub.expireOn\n                ? SubState.CANCELED\n                : sub.depositAmount > 0\n                    ? SubState.EXPIRED\n                    : SubState.FINALIZED;\n        } else if (sub.paidUntil <= now) {\n            return SubState.CHARGEABLE;\n        } else {\n            return SubState.PAID;\n        }\n    }\n\n\n    ///@notice create a new subscription offer.\n    ///@dev only registered service provider is allowed to create offers.\n    ///@dev subscription uses SAN token for payment, but an exact amount to be paid or deposit is calculated using exchange rate from external xrateProvider (previosly registered on platform).\n    ///    This allows to create a subscription bound to another token or even fiat currency.\n    ///@param _pricePerHour - subscription price per hour in SAN\n    ///@param _xrateProviderId - id of external exchange rate provider from subscription currency to SAN; \"0\" means subscription is priced in SAN natively.\n    ///@param _chargePeriod - time period to charge; subscription can't be charged more often than this period. Time units are native ethereum time, returning by `now`, i.e. seconds.\n    ///@param _expireOn - offer can't be accepted after this time.\n    ///@param _offerLimit - how many subscription are available to created from this offer; there is no magic number for unlimited offer -- use big number instead.\n    ///@param _depositAmount - upfront deposit required for creating a subscription; this deposit becomes fully returned on subscription is over.\n    ///       currently this deposit is not subject of platform fees and will be refunded in full. Next versions of this module can use deposit in case of outstanding payments.\n    ///@param _startOn - a subscription from this offer can't be created before this time. Time units are native ethereum time, returning by `now`, i.e. seconds.\n    ///@param _descriptor - arbitrary bytes as an offer descriptor. This descriptor is copied into subscription and then service provider becomes it passed in notifications.\n    //\n    function createSubscriptionOffer(uint _pricePerHour, uint16 _xrateProviderId, uint _chargePeriod, uint _expireOn, uint _offerLimit, uint _depositAmount, uint _startOn, bytes _descriptor)\n    public\n    noReentrancy(L01)\n    onlyRegisteredProvider\n    returns (uint subId) {\n        assert (_startOn < _expireOn);\n        assert (_chargePeriod <= 10 years); //sanity check\n        var (_xrate_n, _xrate_d) = _xrateProviderId == 0\n                                 ? (1,1)\n                                 : XRateProvider(xrateProviders[_xrateProviderId]).getRate(); // <=== possible reentrancy\n        assert (_xrate_n > 0 && _xrate_d > 0);\n        subscriptions[++subscriptionCounter] = Subscription ({\n            transferFrom    : 0,                  // empty transferFrom field means we have an offer, not a subscription\n            transferTo      : msg.sender,         // service provider is a beneficiary of subscripton payments\n            pricePerHour    : _pricePerHour,      // price per hour in SAN (recalculated from base currency if needed)\n            xrateProviderId : _xrateProviderId,   // id of registered exchange rate provider or zero if an offer is nominated in SAN.\n            initialXrate_n  : _xrate_n,           // fraction nominator of the initial exchange rate\n            initialXrate_d  : _xrate_d,           // fraction denominator of the initial exchange rate\n            paidUntil       : 0,                  // service is considered to be paid until this time; no charge is possible while subscription is paid for now.\n            chargePeriod    : _chargePeriod,      // period in seconds (ethereum block time unit) to charge.\n            depositAmount   : _depositAmount,     // deposit required for subscription accept.\n            startOn         : _startOn,\n            expireOn        : _expireOn,\n            execCounter     : _offerLimit,\n            descriptor      : _descriptor,\n            onHoldSince     : 0                   // offer is not on hold by default.\n        });\n        return subscriptionCounter;               // returns an id of the new offer.\n    }\n\n\n    ///@notice updates currently available number of subscription for this offer.\n    ///        Other offer's parameter can't be updated because they are considered to be a public offer reviewed by customers.\n    ///        The service provider should recreate the offer as a new one in case of other changes.\n    //\n    function updateSubscriptionOffer(uint _offerId, uint _offerLimit) public {\n        Subscription storage offer = subscriptions[_offerId];\n        assert (_isOffer(offer));\n        assert (offer.transferTo == msg.sender); //only Provider is allowed to update the offer.\n        offer.execCounter = _offerLimit;\n    }\n\n\n    ///@notice accept given offer and create a new subscription on the base of it.\n    ///\n    ///@dev the service provider (offer.`transferTo`) becomes notified about new subscription by call `onSubNew(newSubId, _offerId)`.\n    ///     It is provider's responsibility to retrieve and store any necessary information about offer and this new subscription. Some of info is only available at this point.\n    ///     The Service Provider can also reject the new subscription by throwing an exception or returning `false` from `onSubNew(newSubId, _offerId)` event handler.\n    ///@param _offerId   - id of the offer to be accepted\n    ///@param _expireOn  - subscription expiration time; no charges are possible behind this time.\n    ///@param _startOn   - subscription start time; no charges are possible before this time.\n    ///                    If the `_startOn` is in the past or is zero, it means start the subscription ASAP.\n    //\n    function createSubscription(uint _offerId, uint _expireOn, uint _startOn) public noReentrancy(L02) returns (uint newSubId) {\n        assert (_startOn < _expireOn);\n        Subscription storage offer = subscriptions[_offerId];\n        assert (_isOffer(offer));\n        assert (offer.startOn == 0     || offer.startOn  <= now);\n        assert (offer.expireOn == 0    || offer.expireOn >= now);\n        assert (offer.onHoldSince == 0);\n        assert (offer.execCounter > 0);\n        --offer.execCounter;\n        newSubId = ++subscriptionCounter;\n        //create a clone of the offer...\n        Subscription storage newSub = subscriptions[newSubId] = offer;\n        //... and adjust some fields specific to subscription\n        newSub.transferFrom = msg.sender;\n        newSub.execCounter = 0;\n        newSub.paidUntil = newSub.startOn = max(_startOn, now);     //no debts before actual creation time!\n        newSub.expireOn = _expireOn;\n        newSub.depositAmount = _applyXchangeRate(newSub.depositAmount, newSub);                    // <=== possible reentrancy\n        //depositAmount is now stored in the sub, so burn the same amount from customer's account.\n        assert (san._burnForDeposit(msg.sender, newSub.depositAmount));\n        assert (ServiceProvider(newSub.transferTo).onSubNew(newSubId, _offerId));                  // <=== possible reentrancy; service provider can still reject the new subscription here\n\n        NewSubscription(newSub.transferFrom, newSub.transferTo, _offerId, newSubId);\n        return newSubId;\n    }\n\n\n    ///@notice cancel an offer given by `offerId`.\n    ///@dev sets offer.`expireOn` to `expireOn`.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function cancelSubscriptionOffer(uint offerId) public returns (bool) {\n        Subscription storage offer = subscriptions[offerId];\n        assert (_isOffer(offer));\n        assert (offer.transferTo == msg.sender || owner == msg.sender); //only service provider or platform owner is allowed to cancel the offer\n        if (offer.expireOn>now){\n            offer.expireOn = now;\n            OfferCanceled(offerId, msg.sender);\n            return true;\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    ///@notice cancel an subscription given by `subId` (a graceful version).\n    ///@notice IMPORTANT: a malicious service provider can consume all gas and preventing subscription from cancellation.\n    ///        If so, use `cancelSubscription(uint subId, uint gasReserve)` as the forced version.\n    ///         see `cancelSubscription(uint subId, uint gasReserve)` for more documentation.\n    //\n    function cancelSubscription(uint subId) public {\n        return cancelSubscription(subId, 0);\n    }\n\n\n    ///@notice cancel an subscription given by `subId` (a forced version).\n    ///        Cancellation means no further charges to this subscription are possible. The provided subscription deposit can be withdrawn only `paidUntil` period is over.\n    ///        Depending on nature of the service provided, the service provider can allow an immediate deposit withdrawal by `returnSubscriptionDesposit(uint subId)` call, but its on his own.\n    ///        In some business cases a deposit must remain locked until `paidUntil` period is over even, the subscription is already canceled.\n    ///@notice gasReserve is a gas amount reserved for contract execution AFTER service provider becomes `onSubCanceled(uint256,address)` notification.\n    ///        It guarantees, that cancellation becomes executed even a (malicious) service provider consumes all gas provided.\n    ///        If so, use `cancelSubscription(uint subId, uint gasReserve)` as the forced version.\n    ///        This difference is because the customer must always have a possibility to cancel his contract even the service provider disagree on cancellation.\n    ///@param subId - subscription to be cancelled\n    ///@param gasReserve - gas reserved for call finalization (minimum reservation is 10000 gas)\n    //\n    function cancelSubscription(uint subId, uint gasReserve) public noReentrancy(L03) {\n        Subscription storage sub = subscriptions[subId];\n        assert (sub.transferFrom == msg.sender || owner == msg.sender); //only subscription owner or platform owner is allowed to cancel it\n        assert (_isSubscription(sub));\n        var _to = sub.transferTo;\n        sub.expireOn = max(now, sub.paidUntil);\n        if (msg.sender != _to) {\n            //supress re-throwing of exceptions; reserve enough gas to finish this function\n            gasReserve = max(gasReserve,10000);  //reserve minimum 10000 gas\n            assert (msg.gas > gasReserve);       //sanity check\n            if (_to.call.gas(msg.gas-gasReserve)(bytes4(sha3(\"onSubCanceled(uint256,address)\")), subId, msg.sender)) {     // <=== possible reentrancy\n                //do nothing. it is notification only.\n                //Later: is it possible to evaluate return value here? If is better to return the subscription deposit here.\n            }\n        }\n        SubCanceled(subId, msg.sender);\n    }\n\n\n    ///@notice place an active offer on hold; it means no subscriptions can be created from this offer.\n    ///        Only service provider (or platform owner) is allowed to hold/unhold a subscription offer.\n    ///@param offerId - id of the offer to be placed on hold.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function holdSubscriptionOffer(uint offerId) public returns (bool success) {\n        Subscription storage offer = subscriptions[offerId];\n        assert (_isOffer(offer));\n        require (msg.sender == offer.transferTo || msg.sender == owner); //only owner or service provider can place the offer on hold.\n        if (offer.onHoldSince == 0) {\n            offer.onHoldSince = now;\n            OfferOnHold(offerId, true, msg.sender);\n            return true;\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    ///@notice resume on-hold offer; subscriptions can be created from this offer again (if other conditions are met).\n    ///        Only service provider (or platform owner) is allowed to hold/unhold a subscription offer.\n    ///@param offerId - id of the offer to be resumed.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function unholdSubscriptionOffer(uint offerId) public returns (bool success) {\n        Subscription storage offer = subscriptions[offerId];\n        assert (_isOffer(offer));\n        require (msg.sender == offer.transferTo || msg.sender == owner); //only owner or service provider can reactivate the offer.\n        if (offer.onHoldSince > 0) {\n            offer.onHoldSince = 0;\n            OfferOnHold(offerId, false, msg.sender);\n            return true;\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    ///@notice called by customer or service provider to place a subscription on hold.\n    ///        If call is originated by customer the service provider can reject the request.\n    ///        A subscription on hold will not be charged. The service is usually not provided as well.\n    ///        During hold time a subscription preserve remaining paid time period, which becomes available after unhold.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function holdSubscription(uint subId) public noReentrancy(L04) returns (bool success) {\n        Subscription storage sub = subscriptions[subId];\n        assert (_isSubscription(sub));\n        var _to = sub.transferTo;\n        require (msg.sender == _to || msg.sender == sub.transferFrom); //only customer or provider can place the subscription on hold.\n        if (sub.onHoldSince == 0) {\n            if (msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId, msg.sender, true)) {          // <=== possible reentrancy\n                sub.onHoldSince = now;\n                SubOnHold(subId, true, msg.sender);\n                return true;\n            }\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n    ///@notice called by customer or service provider to unhold subscription.\n    ///        If call is originated by customer the service provider can reject the request.\n    ///        A subscription on hold will not be charged. The service is usually not provided as well.\n    ///        During hold time a subscription preserve remaining paid time period, which becomes available after unhold.\n    ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract)\n    //\n    function unholdSubscription(uint subId) public noReentrancy(L05) returns (bool success) {\n        Subscription storage sub = subscriptions[subId];\n        assert (_isSubscription(sub));\n        var _to = sub.transferTo;\n        require (msg.sender == _to || msg.sender == sub.transferFrom); //only customer or provider can place the subscription on hold.\n        if (sub.onHoldSince > 0) {\n            if (msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId, msg.sender, false)) {         // <=== possible reentrancy\n                sub.paidUntil += now - sub.onHoldSince;\n                sub.onHoldSince = 0;\n                SubOnHold(subId, false, msg.sender);\n                return true;\n            }\n        }\n        if (isContract(msg.sender)) { return false; }\n        else { throw; }\n    }\n\n\n\n    // *************************************************\n    // *              deposit handling                 *\n    // *************************************************\n\n    ///@notice can be called by provider on CANCELED subscription to return a subscription deposit to customer immediately.\n    ///        Customer can anyway collect his deposit after `paidUntil` period is over.\n    ///@param subId - subscription holding the deposit\n    //\n    function returnSubscriptionDesposit(uint subId) public {\n        Subscription storage sub = subscriptions[subId];\n        assert (_subscriptionState(sub) == SubState.CANCELED);\n        assert (sub.depositAmount > 0); //sanity check\n        assert (sub.transferTo == msg.sender || owner == msg.sender); //only subscription owner or platform owner is allowed to release deposit.\n        sub.expireOn = now;\n        _returnSubscriptionDesposit(subId, sub);\n    }\n\n\n    ///@notice called by customer on EXPIRED subscription (`paidUntil` period is over) to collect a subscription deposit.\n    ///        Customer can anyway collect his deposit after `paidUntil` period is over.\n    ///@param subId - subscription holding the deposit\n    //\n    function claimSubscriptionDeposit(uint subId) public {\n        Subscription storage sub = subscriptions[subId];\n        assert (_subscriptionState(sub) == SubState.EXPIRED);\n        assert (sub.transferFrom == msg.sender);\n        assert (sub.depositAmount > 0);\n        _returnSubscriptionDesposit(subId, sub);\n    }\n\n\n    //@dev returns subscription deposit to customer\n    function _returnSubscriptionDesposit(uint subId, Subscription storage sub) internal {\n        uint depositAmount = sub.depositAmount;\n        sub.depositAmount = 0;\n        san._mintFromDeposit(sub.transferFrom, depositAmount);\n        SubscriptionDepositReturned(subId, depositAmount, sub.transferFrom, msg.sender);\n    }\n\n\n    ///@notice create simple unlocked deposit, required by some services. It can be considered as prove of customer's stake.\n    ///        This desposit can be claimed back by the customer at anytime.\n    ///        The service provider is responsible to check the deposit before providing the service.\n    ///@param _value - non zero deposit amount.\n    ///@param _descriptor - is a uniq key, usually given by service provider to the customer in order to make this deposit unique.\n    ///        Service Provider should reject deposit with unknown descriptor, because most probably it is in use for some another service.\n    ///@return depositId - a handle to claim back the deposit later.\n    //\n    function createDeposit(uint _value, bytes _descriptor) public returns (uint depositId) {\n        require (_value > 0);\n        assert (san._burnForDeposit(msg.sender,_value));\n        deposits[++depositCounter] = Deposit ({\n            owner : msg.sender,\n            value : _value,\n            descriptor : _descriptor\n        });\n        NewDeposit(depositCounter, _value, msg.sender);\n        return depositCounter;\n    }\n\n\n    ///@notice return previously created deposit to the user. User can collect only own deposit.\n    ///        The service provider is responsible to check the deposit before providing the service.\n    ///@param _depositId - an id of the deposit to be collected.\n    //\n    function claimDeposit(uint _depositId) public {\n        var deposit = deposits[_depositId];\n        require (deposit.owner == msg.sender);\n        var value = deposits[_depositId].value;\n        delete deposits[_depositId];\n        san._mintFromDeposit(msg.sender, value);\n        DepositReturned(_depositId, msg.sender);\n    }\n\n\n\n    // *************************************************\n    // *            some internal functions            *\n    // *************************************************\n\n    function _amountToCharge(Subscription storage sub) internal reentrant returns (uint) {\n        return _applyXchangeRate(sub.pricePerHour * sub.chargePeriod, sub) / 1 hours;       // <==== reentrant function usage\n    }\n\n    function _applyXchangeRate(uint amount, Subscription storage sub) internal reentrant returns (uint) {  // <== actually called from reentrancy guarded context only (i.e. externally secured)\n        if (sub.xrateProviderId > 0) {\n            // xrate_n: nominator\n            // xrate_d: denominator of the exchange rate fraction.\n            var (xrate_n, xrate_d) = XRateProvider(xrateProviders[sub.xrateProviderId]).getRate();        // <=== possible reentrancy\n            amount = amount * sub.initialXrate_n * xrate_d / sub.initialXrate_d / xrate_n;\n        }\n        return amount;\n    }\n\n    function _isOffer(Subscription storage sub) internal constant returns (bool){\n        return sub.transferFrom == 0 && sub.transferTo != 0;\n    }\n\n    function _isSubscription(Subscription storage sub) internal constant returns (bool){\n        return sub.transferFrom != 0 && sub.transferTo != 0;\n    }\n\n    function _exists(Subscription storage sub) internal constant returns (bool){\n        return sub.transferTo != 0;   //existing subscription or offer has always transferTo set.\n    }\n\n    modifier onlyRegisteredProvider(){\n        if (!providerRegistry[msg.sender]) throw;\n        _;\n    }\n\n} //SubscriptionModuleImpl", "debug": "keccac_keccac_calldata_XRateProvider_4_+_2: 0xfedf99ff7ffff7ffcfffffffffefffbffe7fffffff5f3fffffc069feffffc800\nstorage_keccac_calldata_XRateProvider_4 + 2: 0xbe806f1fb9a91febe830a18c9b68af7fd7defe83d2ebeeebc7db7ebfffffffc1\ncaller: 0x0\nstorage_1 + keccac_calldata_XRateProvider_4: 0x0\ncalldata_XRateProvider_0: 0x5f8534ae00000000000000000000000000000000000000000000000000000000\ncalldatasize_XRateProvider: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claimDeposit(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/40/0xe13e5848003587f643cdcb7fd5b21e5a33869666.sol", "function": "claimDeposit(uint256)", "lineno": 384, "title": "Integer Overflow ", "type": "Warning"}], "success": true}