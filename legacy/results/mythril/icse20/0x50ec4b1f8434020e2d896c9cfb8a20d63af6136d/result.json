{
  "contract": "0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d",
  "tool": "mythril",
  "start": 1563642762.206894,
  "end": 1563642888.1122122,
  "duration": 125.90531826019287,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1081,
        "code": "to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   tota",
        "debug": "calldata_Snip3D_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n",
        "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "changevanity(string)",
        "lineno": 300,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2547,
        "code": "aimedDividends.add(amt2",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "P3DDivstocontract()",
        "lineno": 305,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 2547,
        "code": "aimedDividends.add(amt2",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2734\n",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "P3DDivstocontract()",
        "lineno": 305,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 2734,
        "code": "ssInterface  {\n    function()",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "P3DDivstocontract()",
        "lineno": 313,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5358,
        "code": "balanceOf(address(this)))  ;\n}\n    //di",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "harvestabledivs()",
        "lineno": 135,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5358,
        "code": "balanceOf(address(this)))  ;\n}\n    //di",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2734\nCall at address: 2547\n",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "P3DDivstocontract()",
        "lineno": 135,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 5588,
        "code": "(owing > 0) {\n    unclaimedDividends = unclaimedDividends",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_18: 0x0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Snip3D_4: 0x0\ncalldata_Snip3D_0: 0x358fcee900000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\nstorage_14: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "fetchdivs(address)",
        "lineno": 155,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9167,
        "code": "apping(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 10;\n    uint256 public blocksBeforeTargetShoot = 40;\n    \n    //constructor\n    constructor()\n        public\n    {\n        \n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( P3Dcontract_.dividendsOf(address(this)))  ;\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    account.transfer(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 wei)(masternode);\n    // check excess of payed \n    if(value > 100 finney){uint256 toRefund = value.sub(100 finney);Refundpot.add(toRefund);}\n    // progress refundline\n    Refundpot += 5 finney;\n    // take SPASM cut\n    SPASM_.disburse.value(1 wei)();\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // update divs loser\n    fetchdivs(killed);\n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // disburse eth to survivors\n    uint256 amount = 89 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target < nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    \n    address killed = formation[target];\n    // solo soldiers self kill prevention - shoots next in line instead\n    \n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // update divs loser\n    fetchdivs(killed);\n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // fetch contracts divs\n    //allocate p3d dividends to contract \n            uint256 dividends =  harvestabledivs();\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n    // disburse eth to survivors\n    uint256 amount = 89 finney;\n    amount = amount.add(dividends.sub(base));\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n\n}\n\nfunction Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public payable{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n}\nfunction die () public onlyOwner {\n    selfdestruct(msg.sender);\n}\n\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function divid",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n",
        "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "changevanity(string)",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9196,
        "code": "apping(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 10;\n    uint256 public blocksBeforeTargetShoot = 40;\n    \n    //constructor\n    constructor()\n        public\n    {\n        \n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( P3Dcontract_.dividendsOf(address(this)))  ;\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    account.transfer(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 wei)(masternode);\n    // check excess of payed \n    if(value > 100 finney){uint256 toRefund = value.sub(100 finney);Refundpot.add(toRefund);}\n    // progress refundline\n    Refundpot += 5 finney;\n    // take SPASM cut\n    SPASM_.disburse.value(1 wei)();\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // update divs loser\n    fetchdivs(killed);\n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // disburse eth to survivors\n    uint256 amount = 89 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target < nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    \n    address killed = formation[target];\n    // solo soldiers self kill prevention - shoots next in line instead\n    \n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // update divs loser\n    fetchdivs(killed);\n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // fetch contracts divs\n    //allocate p3d dividends to contract \n            uint256 dividends =  harvestabledivs();\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n    // disburse eth to survivors\n    uint256 amount = 89 finney;\n    amount = amount.add(dividends.sub(base));\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n\n}\n\nfunction Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public payable{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n}\nfunction die () public onlyOwner {\n    selfdestruct(msg.sender);\n}\n\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function divid",
        "debug": "calldata_Snip3D_4 + calldata_Snip3D_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n",
        "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "changevanity(string)",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9210,
        "code": "apping(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 10;\n    uint256 public blocksBeforeTargetShoot = 40;\n    \n    //constructor\n    constructor()\n        public\n    {\n        \n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( P3Dcontract_.dividendsOf(address(this)))  ;\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    account.transfer(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 wei)(masternode);\n    // check excess of payed \n    if(value > 100 finney){uint256 toRefund = value.sub(100 finney);Refundpot.add(toRefund);}\n    // progress refundline\n    Refundpot += 5 finney;\n    // take SPASM cut\n    SPASM_.disburse.value(1 wei)();\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // update divs loser\n    fetchdivs(killed);\n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // disburse eth to survivors\n    uint256 amount = 89 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target < nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    \n    address killed = formation[target];\n    // solo soldiers self kill prevention - shoots next in line instead\n    \n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // update divs loser\n    fetchdivs(killed);\n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // fetch contracts divs\n    //allocate p3d dividends to contract \n            uint256 dividends =  harvestabledivs();\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n    // disburse eth to survivors\n    uint256 amount = 89 finney;\n    amount = amount.add(dividends.sub(base));\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n\n}\n\nfunction Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public payable{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n}\nfunction die () public onlyOwner {\n    selfdestruct(msg.sender);\n}\n\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function divid",
        "debug": "calldata_Snip3D_4 + calldata_Snip3D_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n",
        "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/29/0x50ec4b1f8434020e2d896c9cfb8a20d63af6136d.sol",
        "function": "changevanity(string)",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}