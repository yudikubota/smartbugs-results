{
  "contract": "0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7",
  "tool": "mythril",
  "start": 1563224848.9187632,
  "end": 1563225327.4798713,
  "duration": 478.5611081123352,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 857,
        "code": "irdroped[_from] == 0) airdroped[_from] = 1;\n\tif(airdroped[_to] == 0) airdroped[_to",
        "debug": "calldata_knf_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_knf_0: 0x5353a2d800000000000000000000000000000000000000000000000000000000\ncalldatasize_knf: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol",
        "function": "changeName(string)",
        "lineno": 211,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4331,
        "code": "n transferOwnership",
        "debug": "calldata_knf_32 + 4: 0xc290137095b13347e55005a6dc184559e0489f1233480050d0fb4bba17d34179\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_knf_4: 0x9c9efb7ae5acd378025256a3945f5859076e809243093d9ecae2636c9fd28979\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_13,_256): 0xc290137095b13347e55005a6dc184559e0489f1233480050d0fb4bba17d34179\ncalldata_knf_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_12: 0x0\ncaller: 0x0\ncalldata_knf_0: 0x473edf7300000000000000000000000000000000000000000000000000000000\ncalldatasize_knf: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `Award(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol",
        "function": "Award(address,uint256)",
        "lineno": 230,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9595,
        "code": "n c;\n",
        "debug": "calldata_knf_32 + 36: 0xe86938cd473f93f55b30667433ce7ac826aefff6ba013e0db1294942d1a99435\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_knf_4: 0xf3d71d660cff11fbd3303f4abfdbbe9317b3e0af48020092f0c5e3b733d2fff0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_knf_32_+_4: 0x8e73fddb14fe53ff4c1a74c5b38fdbcd78cc8000ba003c6a498ed50a9a7117b1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe86938cd473f93f55b30667433ce7ac826aefff6ba013e0db1294942d1a99435\ncalldata_knf_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_knf_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_knf: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 39,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9608,
        "code": "/**\n * @title ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_knf_4: 0x1\ncalldata_knf_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_knf_0: 0xd73dd62300000000000000000000000000000000000000000000000000000000\ncalldatasize_knf: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol",
        "function": "increaseApproval(address,uint256)",
        "lineno": 43,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9709,
        "code": "able-line uppercase\n  uint256 DropedThisWeek;\n  uint256 lastWeek;\n  uint256 decimate;\n  uint256 weekly_limit;\n  uint256 air_drop;\n  mapping(address => uint256) airdroped;\n  address control;\n  address public owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  function availableSupply() public view returns (uint256) {\n    return balances[owner];\n  }\n  \n  modifier onlyControl() {\n    require(msg.sender == control);\n    _;\n  }\n  \n  function changeName(string newName) onlyControl public {\n    name = newName;\n  }\n  \n  function RecordTransfer(address _from, address _to, uint256 _value) internal {\n    Transfer(_from, _to, _value);\n\tif(airdroped[_from] == 0) airdroped[_from] = 1;\n\tif(airdroped[_to] == 0) airdroped[_to] = 1;\n\tif (thisweek() > lastWeek) {\n\t  lastWeek = thisweek();\n\t  DropedThisWeek = 0;\n\t}\n  }\n  \n  /*** */\n  function Award(address _to, uint256 _v) public onlyControl {\n    require(_to != address(0));\n\trequire(_v <= balances[owner]);\n\tbalances[_to] += _v;\n\tbalances[owner] -= _v;\n\tRecordTransfer(owner, _to, _v);\n  }\n  \n  /*** @param newOwner  The address to transfer ownership to\n    owner tokens go with owner, airdrops always from owner pool */\n  function transferOwnership(address newOwner) public onlyControl {\n    require(newOwner != address(0));\n\tOwnershipTransferred(owner, newOwner);\n\towner = newOwner;\n  } /*** @param newControl  The address to transfer control to.   */\n  function transferControl(address newControl) public onlyControl {\n    require(newControl != address(0) && newControl != address(this));  \n\tcontrol =newControl;\n } /*init contract itself as owner of all its tokens, all tokens set'''''to air drop, and always comes form owner's bucket \n   .+------+     +------+     +------+     +------+     +------+.     =================== ===================\n .' |    .'|    /|     /|     |      |     |\\     |\\    |`.    | `.   */function knf(uint256 _initialAmount,/*\n+---+--+'  |   +-+----+ |     +------+     | +----+-+   |  `+--+---+  */string _tokenName, uint8 _decimalUnits,/*\n|   |  |   |   | |  K | |     |  N   |     | | F  | |   |   |  |   |  */string _tokenSymbol) public { control = msg.sender; /*\n|  ,+--+---+   | +----+-+     +------+     +-+----+ |   +---+--+   |  */owner = address(this);OwnershipTransferred(address(0), owner);/*\n|.'    | .'    |/     |/      |      |      \\|     \\|    `. |   `. |  */totalSupply_ = _initialAmount; balances[owner] = totalSupply_; /*\n+------+'      +------+       +------+       +------+      `+------+  */RecordTransfer(0x0, owner, totalSupply_);\n    symbol = _tokenSymbol;   \n\tname = _tokenName;\n    decimals = _decimalUnits;                            \n\tdecimate = (10 ** uint256(decimals));\n\tweekly_limit = 100000 * decimate;\n\tair_drop = 1018 * decimate;\t\n  } /** rescue lost erc20 kin **/\n  function transfererc20(address tokenAddress, address _to, uint256 _value) external onlyControl returns (bool) {\n    require(_to != address(0));\n\treturn ERC20(tokenAddress).transfer(_to, _value);\n  } /** token no more **/\n  function destroy() onlyControl external {\n    require(owner != address(this)); selfdestruct(control);\n  }  \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\trequire(_value <= allowed[_from][msg.sender]);\n\tif(balances[_from] == 0) { \n      uint256 qty = availableAirdrop(_from);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[_to] += qty;\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\tRecordTransfer(owner, _from, _value);\n\t\tRecordTransfer(_from, _to, _value);\n\t\tDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    require(_value <= balances[_from]);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    RecordTransfer(_from, _to, _value);\n\treturn true;\n  }  \n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\t// if no balance, see if eligible for airdrop instead\n    if(balances[msg.sender] == 0) { \n      uint256 qty = availableAirdrop(msg.sender);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[msg.sender] += qty;\n\t\tRecordTransfer(owner, _to, _value);\n\t\tairdroped[msg.sender] = 1;\n\t\tDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    // existing balance\n    if(balances[msg.sender] < _value) revert();\n\tif(balances[_to] + _value < balances[_to]) revert();\n\t\n    balances[_to] += _value;\n\tbalances[msg.sender] -= _value;\n    RecordTransfer(msg.sender, _to, _value);\n\treturn true;\n  }  \n  function balanceOf(address who) public view returns (uint256 balance) {\n    balance = balances[who];\n\tif(balance == 0) \n\t  return availableAirdrop(who);\n\t\n    return balance;\n  }  \n  /*  * check the faucet  */  \n  function availableAirdrop(address who) internal constant returns (uint256) {\n    if(balances[owner] == 0) return 0;\n\tif(airdroped[who] > 0) return 0; // already seen this\n\t\n    if (thisweek() > lastWeek || DropedThisWeek < weekly_limit) {\n\t  if(balances[owner] > air_drop) return air_drop;\n\t  else return balances[owner];\n\t}\n\treturn 0;\n  } \n  function thisweek() internal view returns (uint256) {\n    return now / 1 weeks;\n  }  \n  function transferBalance(address upContract) external onlyControl {\n    require(upContract != address(0) && upContract.send(this.balance));\n  }\n  function () payable public { }   \n}",
        "debug": "calldata_knf_4 + calldata_knf_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_12: 0x0\ncaller: 0x0\ncalldata_knf_0: 0x5353a2d800000000000000000000000000000000000000000000000000000000\ncalldatasize_knf: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol",
        "function": "changeName(string)",
        "lineno": 186,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9723,
        "code": "able-line uppercase\n  uint256 DropedThisWeek;\n  uint256 lastWeek;\n  uint256 decimate;\n  uint256 weekly_limit;\n  uint256 air_drop;\n  mapping(address => uint256) airdroped;\n  address control;\n  address public owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  function availableSupply() public view returns (uint256) {\n    return balances[owner];\n  }\n  \n  modifier onlyControl() {\n    require(msg.sender == control);\n    _;\n  }\n  \n  function changeName(string newName) onlyControl public {\n    name = newName;\n  }\n  \n  function RecordTransfer(address _from, address _to, uint256 _value) internal {\n    Transfer(_from, _to, _value);\n\tif(airdroped[_from] == 0) airdroped[_from] = 1;\n\tif(airdroped[_to] == 0) airdroped[_to] = 1;\n\tif (thisweek() > lastWeek) {\n\t  lastWeek = thisweek();\n\t  DropedThisWeek = 0;\n\t}\n  }\n  \n  /*** */\n  function Award(address _to, uint256 _v) public onlyControl {\n    require(_to != address(0));\n\trequire(_v <= balances[owner]);\n\tbalances[_to] += _v;\n\tbalances[owner] -= _v;\n\tRecordTransfer(owner, _to, _v);\n  }\n  \n  /*** @param newOwner  The address to transfer ownership to\n    owner tokens go with owner, airdrops always from owner pool */\n  function transferOwnership(address newOwner) public onlyControl {\n    require(newOwner != address(0));\n\tOwnershipTransferred(owner, newOwner);\n\towner = newOwner;\n  } /*** @param newControl  The address to transfer control to.   */\n  function transferControl(address newControl) public onlyControl {\n    require(newControl != address(0) && newControl != address(this));  \n\tcontrol =newControl;\n } /*init contract itself as owner of all its tokens, all tokens set'''''to air drop, and always comes form owner's bucket \n   .+------+     +------+     +------+     +------+     +------+.     =================== ===================\n .' |    .'|    /|     /|     |      |     |\\     |\\    |`.    | `.   */function knf(uint256 _initialAmount,/*\n+---+--+'  |   +-+----+ |     +------+     | +----+-+   |  `+--+---+  */string _tokenName, uint8 _decimalUnits,/*\n|   |  |   |   | |  K | |     |  N   |     | | F  | |   |   |  |   |  */string _tokenSymbol) public { control = msg.sender; /*\n|  ,+--+---+   | +----+-+     +------+     +-+----+ |   +---+--+   |  */owner = address(this);OwnershipTransferred(address(0), owner);/*\n|.'    | .'    |/     |/      |      |      \\|     \\|    `. |   `. |  */totalSupply_ = _initialAmount; balances[owner] = totalSupply_; /*\n+------+'      +------+       +------+       +------+      `+------+  */RecordTransfer(0x0, owner, totalSupply_);\n    symbol = _tokenSymbol;   \n\tname = _tokenName;\n    decimals = _decimalUnits;                            \n\tdecimate = (10 ** uint256(decimals));\n\tweekly_limit = 100000 * decimate;\n\tair_drop = 1018 * decimate;\t\n  } /** rescue lost erc20 kin **/\n  function transfererc20(address tokenAddress, address _to, uint256 _value) external onlyControl returns (bool) {\n    require(_to != address(0));\n\treturn ERC20(tokenAddress).transfer(_to, _value);\n  } /** token no more **/\n  function destroy() onlyControl external {\n    require(owner != address(this)); selfdestruct(control);\n  }  \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\trequire(_value <= allowed[_from][msg.sender]);\n\tif(balances[_from] == 0) { \n      uint256 qty = availableAirdrop(_from);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[_to] += qty;\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\tRecordTransfer(owner, _from, _value);\n\t\tRecordTransfer(_from, _to, _value);\n\t\tDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    require(_value <= balances[_from]);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    RecordTransfer(_from, _to, _value);\n\treturn true;\n  }  \n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\t// if no balance, see if eligible for airdrop instead\n    if(balances[msg.sender] == 0) { \n      uint256 qty = availableAirdrop(msg.sender);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[msg.sender] += qty;\n\t\tRecordTransfer(owner, _to, _value);\n\t\tairdroped[msg.sender] = 1;\n\t\tDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    // existing balance\n    if(balances[msg.sender] < _value) revert();\n\tif(balances[_to] + _value < balances[_to]) revert();\n\t\n    balances[_to] += _value;\n\tbalances[msg.sender] -= _value;\n    RecordTransfer(msg.sender, _to, _value);\n\treturn true;\n  }  \n  function balanceOf(address who) public view returns (uint256 balance) {\n    balance = balances[who];\n\tif(balance == 0) \n\t  return availableAirdrop(who);\n\t\n    return balance;\n  }  \n  /*  * check the faucet  */  \n  function availableAirdrop(address who) internal constant returns (uint256) {\n    if(balances[owner] == 0) return 0;\n\tif(airdroped[who] > 0) return 0; // already seen this\n\t\n    if (thisweek() > lastWeek || DropedThisWeek < weekly_limit) {\n\t  if(balances[owner] > air_drop) return air_drop;\n\t  else return balances[owner];\n\t}\n\treturn 0;\n  } \n  function thisweek() internal view returns (uint256) {\n    return now / 1 weeks;\n  }  \n  function transferBalance(address upContract) external onlyControl {\n    require(upContract != address(0) && upContract.send(this.balance));\n  }\n  function () payable public { }   \n}",
        "debug": "calldata_knf_4 + calldata_knf_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_12: 0x0\ncaller: 0x0\ncalldata_knf_0: 0x5353a2d800000000000000000000000000000000000000000000000000000000\ncalldatasize_knf: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x17f0badcdf99b0a94429478d2e9ddb1ff13174f7.sol",
        "function": "changeName(string)",
        "lineno": 186,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}