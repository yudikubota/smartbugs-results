{"error": null, "issues": [{"address": 3217, "code": "eturns(uint2", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x30f570200000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnAmount(uint256)", "lineno": 295, "title": "Exception state", "type": "Informational"}, {"address": 3550, "code": ";\n\n/**\n * @title S", "debug": "storage_11: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 68: 0x1800038\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3954, "code": "-1); \n    \n    return (loans.length-1);\n}\n\n\nfunction cancelLoanRequestAtIndexByLender(uint256 index) public {\n  if (l", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_lendingManager_32 + 68: 0x4\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 169, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4084, "code": "56)\t{\n\tretur", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0xcd522da00000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnStartBlock(uint256)", "lineno": 291, "title": "Exception state", "type": "Informational"}, {"address": 4133, "code": "     loans[i", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x14c0a37a00000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "stateBorrowerDefaulted(uint256)", "lineno": 206, "title": "Exception state", "type": "Informational"}, {"address": 4525, "code": "turns(bool)\t", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x17fb44c100000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnAmountPaidBackSoFar(uint256)", "lineno": 307, "title": "Exception state", "type": "Informational"}, {"address": 4567, "code": "\treturn loan", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x33decdc600000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnVolAdjuster(uint256)", "lineno": 288, "title": "Exception state", "type": "Informational"}, {"address": 4648, "code": "ndex) public", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x5b45483200000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "declareDefaultAsBorrower(uint256)", "lineno": 220, "title": "Exception state", "type": "Informational"}, {"address": 4959, "code": "tCanceledByL", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x6e6d83d200000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "cancelLoanRequestAtIndexByLender(uint256)", "lineno": 179, "title": "Exception state", "type": "Informational"}, {"address": 5223, "code": "unt,loans[in", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x81193a3000000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnRequestCancel(uint256)", "lineno": 324, "title": "Exception state", "type": "Informational"}, {"address": 5278, "code": "nt256)\t{\n\tre", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0x9493242c00000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnLender(uint256)", "lineno": 283, "title": "Exception state", "type": "Informational"}, {"address": 5364, "code": "eturns(uint2", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_11: 0x0\ncalldata_lendingManager_0: 0xad44919800000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "returnBorrower(uint256)", "lineno": 279, "title": "Exception state", "type": "Informational"}, {"address": 10007, "code": " }\n}\n", "debug": "storage_8 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_3 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_lendingManager_4: 0x0\ncaller: 0x0\nstorage_1 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0x0\nstorage_11: 0x1\ncalldata_lendingManager_0: 0x14c0a37a00000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\nstorage_1: 0x0\nstorage_6 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `stateBorrowerDefaulted(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "stateBorrowerDefaulted(uint256)", "lineno": 46, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10020, "code": "ct lendingMana", "debug": "The exception is triggered under the following conditions:\n\ncalldata_lendingManager_4: 0x0\nstorage_3 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0x1\nstorage_8 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_1 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0x0\nstorage_11: 0x1\ncalldata_lendingManager_0: 0x14c0a37a00000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\nstorage_1: 0x0\nstorage_6 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*calldata_lendingManager_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "stateBorrowerDefaulted(uint256)", "lineno": 49, "title": "Exception state", "type": "Informational"}, {"address": 10983, "code": "TED_STATUS; \nuint256 public ACTIVE_STATUS; \nuint256 public REQUEST_CANCELED_BY_BORROWER_STATUS;\nuint256 public REQUEST_CANCELED_BY_LENDER_STATUS;\nuint256 public ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\nuint256 public COMPLETION_STATUS; \nuint256 public DEFAULTED_STATUS;\n\nuint256 public MAX_LOAN_AMOUNT;\nuint256 public MAX_INTEREST_AMOUNT;\n\nuint256 public PERCENTAGE_PRECISION;\n\naddress public ELIX_ADDRESS;\n\nevent LoanRequestedAtIndex(uint256 index);\nevent LoanCanceledByBorrowerAtIndex(uint256 index); \nevent LoanCanceledByLenderAtIndex(uint256 index); \nevent Defaulted(uint256 index,address informer); \nevent LoanBegunAtIndex(uint256 index); \nevent LoanUpdatedByVolAddress(uint256 index,uint256 oldAmount,uint256 oldInterest,uint256 amount,uint256 interest);\nevent PaidBackPortionForLoanAtIndex(uint256 index,uint256 amount); \nevent LoanPaidLateAtIndex(uint256 index,uint256 amount); \nevent LoanRequestCanceledByLenderAtIndex(uint256 index);\nevent LoanCompletedWithFinalPortion(uint256 index, uint256 amount); \nevent ActiveLoanUpdatedByVolAddressToCompletion(uint256 index);\nevent LenderClaimedLoanAtIndex(address lender,uint256 index);\n\nloan[] public loans; \n\nstruct loan   {\n    address borrower;\n    address lender;\n    address volAddress;\n    uint256 startBlock;\n    uint256 amount; \n    uint256 paidBackBlock; \n    uint256 status;\n    uint256 amountPaidBackSoFar; \n    uint256 loanLength; \n    uint256 interest; \n    bool borrowerPaidLate;\n    bool requestCancel;\n    string message; \n}\n\nfunction lendingManager()  {\n    \n    REQUESTED_STATUS=1;\n    ACTIVE_STATUS=2;\n    REQUEST_CANCELED_BY_BORROWER_STATUS=3; \n    REQUEST_CANCELED_BY_LENDER_STATUS=4; \n    COMPLETION_STATUS=5;\n    ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS=6;\n    DEFAULTED_STATUS=7;\n\n    MAX_LOAN_AMOUNT = 100000000000000000000000000000;\n    MAX_INTEREST_AMOUNT = 100000000000000000000000000000;\n\n    PERCENTAGE_PRECISION = 1000000000000000000;\n\n\n    ELIX_ADDRESS = 0xc8C6A31A4A806d3710A7B38b7B296D2fABCCDBA8;\n}\n\nfunction loanCompleted(uint256 index, uint256 amount) private {\n\n    loans[index].paidBackBlock=block.number;\n    \n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)) {\n        loans[index].borrowerPaidLate=true;\n        emit LoanPaidLateAtIndex(index,amount); \n    }\n\n    loans[index].status=COMPLETION_STATUS; \n    emit LoanCompletedWithFinalPortion(index, amount); \n    if(amount > 0){ \n        if (! elixir(ELIX_ADDRESS).transferFrom(loans[index].borrower,loans[index].lender, amount)) revert();\n    }\n\n}\n\nfunction adjustLoanParams(uint256 newPrincipal, uint256 newInterest, uint256 index) public {\n    require(newPrincipal > 0);\n    require(msg.sender == loans[index].volAddress);\n    require(loans[index].status == REQUESTED_STATUS || loans[index].status == ACTIVE_STATUS);\n    require(newPrincipal <= MAX_LOAN_AMOUNT);\n    require(newInterest <= MAX_INTEREST_AMOUNT);\n\n    if (block.number==loans[index].startBlock) revert(); \n\n    if( SafeMath.add(newPrincipal,newInterest) > loans[index].amountPaidBackSoFar){  \n        \n        emit LoanUpdatedByVolAddress(index,loans[index].amount,loans[index].interest,newPrincipal,newInterest);\n        loans[index].amount = newPrincipal;\n        loans[index].interest = newInterest; \n    } else {\n        uint256 adjustedTotalRatio = SafeMath.div( SafeMath.mul(PERCENTAGE_PRECISION,loans[index].amountPaidBackSoFar), SafeMath.add(newPrincipal,newInterest) );\n        loans[index].interest = SafeMath.div( SafeMath.mul(newInterest, adjustedTotalRatio), PERCENTAGE_PRECISION);\n        loans[index].amount = SafeMath.sub(loans[index].amountPaidBackSoFar, loans[index].interest);\n\t\temit ActiveLoanUpdatedByVolAddressToCompletion(index);\n\t\tloanCompleted(index, 0);\n    }  \n}\n\n\nfunction requestLoan(address lender, address volAddress, uint256 amount,uint256 length,uint256 interest,bool requestCancel, string loanMessage) public returns(uint256)   {\n    if (msg.sender==lender) revert(); \n    \n    \n    if (amount==0 || length<4 || length>225257143) revert(); \n    \n   \n    require(amount <= MAX_LOAN_AMOUNT);\n    require(interest <= MAX_INTEREST_AMOUNT);    \n\n    loans.push(loan(msg.sender,lender, volAddress,0,amount,0,REQUESTED_STATUS,0,length,interest,false,false,loanMessage));\n    \n    emit LoanRequestedAtIndex(loans.length-1); \n    \n    return (loans.length-1);\n}\n\n\nfunction cancelLoanRequestAtIndexByLender(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].lender==msg.sender)    {\n        \n        loans[index].status=REQUEST_CANCELED_BY_LENDER_STATUS; \n        emit LoanRequestCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction cancelLoanRequestAtIndexByBorrower(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].borrower==msg.sender)    {\n       \n        loans[index].status=REQUEST_CANCELED_BY_BORROWER_STATUS; \n        emit LoanCanceledByBorrowerAtIndex(index); \n  }\n}\n\n\nfunction cancelActiveLoanAtIndex(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n\n      loans[index].status = ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\n      emit LoanCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction stateBorrowerDefaulted(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)){\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n    }\n  }\n}\n\n\nfunction declareDefaultAsBorrower(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].borrower==msg.sender)   {\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n  }\n}\n\n\nfunction attemptBeginLoanAtIndex(uint256 index) public returns(bool) {\n    if (loans[index].status==REQUESTED_STATUS)    {\n    \tif (loans[index].lender==0x000000000000000000000000000000000000dEaD)\t{\n\t\t\t\n\t\t\tif (msg.sender==loans[index].borrower) revert();\n\t\t\tloans[index].lender=msg.sender;\n\t\t\t\n\t\t\temit LenderClaimedLoanAtIndex(msg.sender,index);\n\t\t} else\t{\n\t\t\tif (!(msg.sender==loans[index].lender)) revert();\n\t\t}\n\t\t\n        \n        loans[index].status=ACTIVE_STATUS;\n        loans[index].startBlock = block.number;\n        emit LoanBegunAtIndex(index);\n        \n        if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender, loans[index].borrower, loans[index].amount) ) revert();\n        return true;\n    }\n    return false;\n}\n\n\nfunction payAmountForLoanAtIndex(uint256 amount,uint256 index) public {\n\n    if (loans[index].status==ACTIVE_STATUS && msg.sender==loans[index].borrower && amount>0)    {\n        require(amount <= SafeMath.add(MAX_LOAN_AMOUNT,MAX_INTEREST_AMOUNT));\n        require( SafeMath.add(amount, loans[index].amountPaidBackSoFar) <= SafeMath.add(loans[index].amount, loans[index].interest) );\n    \n        if (block.number==loans[index].startBlock) revert();\n    \t        \n       \n        loans[index].amountPaidBackSoFar = SafeMath.add(loans[index].amountPaidBackSoFar,amount);\n        \n        if (loans[index].amountPaidBackSoFar == SafeMath.add(loans[index].amount,loans[index].interest))    {\n            loanCompleted(index, amount);\n        } else {\n            emit PaidBackPortionForLoanAtIndex(index,amount); \n            \n            if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender,loans[index].lender, amount)) revert();\n        }\n    }\n}\n\n\n\nfunction returnBorrower(uint256 index) public returns(address)\t{\n\treturn loans[index].borrower;\n}\n\nfunction returnLender(uint256 index) public returns(address)\t{\n\treturn loans[index].lender;\n}\n\nfunction returnVolAdjuster(uint256 index) public returns(address)\t{\n\treturn loans[index].volAddress;\n}\n\nfunction returnStartBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].startBlock;\n}\n\nfunction returnAmount(uint256 index) returns(uint256)\t{\n\treturn loans[index].amount;\n}\n\nfunction returnPaidBackBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].paidBackBlock;\n}\n\nfunction returnLoanStatus(uint256 index) public returns(uint256)\t{\n\treturn loans[index].status;\n}\n\nfunction returnAmountPaidBackSoFar(uint256 index) public returns(uint256)\t{\n\treturn loans[index].amountPaidBackSoFar;\n}\n\nfunction returnLoanLength(uint256 index) public returns(uint256)\t{\n\treturn loans[index].loanLength;\n}\n\nfunction returnInterest(uint256 index) public returns(uint256)\t{\n\treturn loans[index].interest;\n}\n\nfunction returnBorrowerPaidLate(uint256 index) public returns(bool)\t{\n\treturn loans[index].borrowerPaidLate;\n}\n\nfunction returnRequestCancel(uint256 index) public returns(bool)\t{\n\treturn loans[index].requestCancel;\n}\n\nfunction returnMessage(uint256 index) public returns(string)\t{\n\treturn loans[index].message;\n}\n\nfunction getLoansCount() public returns(uint256) {\n    return loans.length;\n}\n\nfunction returnAmountPlusInterest(uint256 index) returns(uint256)\t{\n\treturn SafeMath.add(loans[index].amount,loans[index].interest);\n}\n\n}\n\ncontract elixir {\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from,address _to,uint256 _amount) returns (bool success);\n}", "debug": "storage_11 +\n660301456019777184113296434797620819555017468543624515662331739614079884729 +\n12*storage_11: 0x86f2bded8f86edffffffffffffffffffffffffffffffffffffffffffffffffc3\nkeccac_11_+\n660301456019777184113296434797620819555017468543624515662331739614079884729_+\n12*storage_11: 0xff960c4422ee1bc77f59fe7bc8bff8f914054870450922540600000021281622\ncalldata_lendingManager_32 + 68: 0x8c06d8\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 51, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11012, "code": "TED_STATUS; \nuint256 public ACTIVE_STATUS; \nuint256 public REQUEST_CANCELED_BY_BORROWER_STATUS;\nuint256 public REQUEST_CANCELED_BY_LENDER_STATUS;\nuint256 public ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\nuint256 public COMPLETION_STATUS; \nuint256 public DEFAULTED_STATUS;\n\nuint256 public MAX_LOAN_AMOUNT;\nuint256 public MAX_INTEREST_AMOUNT;\n\nuint256 public PERCENTAGE_PRECISION;\n\naddress public ELIX_ADDRESS;\n\nevent LoanRequestedAtIndex(uint256 index);\nevent LoanCanceledByBorrowerAtIndex(uint256 index); \nevent LoanCanceledByLenderAtIndex(uint256 index); \nevent Defaulted(uint256 index,address informer); \nevent LoanBegunAtIndex(uint256 index); \nevent LoanUpdatedByVolAddress(uint256 index,uint256 oldAmount,uint256 oldInterest,uint256 amount,uint256 interest);\nevent PaidBackPortionForLoanAtIndex(uint256 index,uint256 amount); \nevent LoanPaidLateAtIndex(uint256 index,uint256 amount); \nevent LoanRequestCanceledByLenderAtIndex(uint256 index);\nevent LoanCompletedWithFinalPortion(uint256 index, uint256 amount); \nevent ActiveLoanUpdatedByVolAddressToCompletion(uint256 index);\nevent LenderClaimedLoanAtIndex(address lender,uint256 index);\n\nloan[] public loans; \n\nstruct loan   {\n    address borrower;\n    address lender;\n    address volAddress;\n    uint256 startBlock;\n    uint256 amount; \n    uint256 paidBackBlock; \n    uint256 status;\n    uint256 amountPaidBackSoFar; \n    uint256 loanLength; \n    uint256 interest; \n    bool borrowerPaidLate;\n    bool requestCancel;\n    string message; \n}\n\nfunction lendingManager()  {\n    \n    REQUESTED_STATUS=1;\n    ACTIVE_STATUS=2;\n    REQUEST_CANCELED_BY_BORROWER_STATUS=3; \n    REQUEST_CANCELED_BY_LENDER_STATUS=4; \n    COMPLETION_STATUS=5;\n    ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS=6;\n    DEFAULTED_STATUS=7;\n\n    MAX_LOAN_AMOUNT = 100000000000000000000000000000;\n    MAX_INTEREST_AMOUNT = 100000000000000000000000000000;\n\n    PERCENTAGE_PRECISION = 1000000000000000000;\n\n\n    ELIX_ADDRESS = 0xc8C6A31A4A806d3710A7B38b7B296D2fABCCDBA8;\n}\n\nfunction loanCompleted(uint256 index, uint256 amount) private {\n\n    loans[index].paidBackBlock=block.number;\n    \n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)) {\n        loans[index].borrowerPaidLate=true;\n        emit LoanPaidLateAtIndex(index,amount); \n    }\n\n    loans[index].status=COMPLETION_STATUS; \n    emit LoanCompletedWithFinalPortion(index, amount); \n    if(amount > 0){ \n        if (! elixir(ELIX_ADDRESS).transferFrom(loans[index].borrower,loans[index].lender, amount)) revert();\n    }\n\n}\n\nfunction adjustLoanParams(uint256 newPrincipal, uint256 newInterest, uint256 index) public {\n    require(newPrincipal > 0);\n    require(msg.sender == loans[index].volAddress);\n    require(loans[index].status == REQUESTED_STATUS || loans[index].status == ACTIVE_STATUS);\n    require(newPrincipal <= MAX_LOAN_AMOUNT);\n    require(newInterest <= MAX_INTEREST_AMOUNT);\n\n    if (block.number==loans[index].startBlock) revert(); \n\n    if( SafeMath.add(newPrincipal,newInterest) > loans[index].amountPaidBackSoFar){  \n        \n        emit LoanUpdatedByVolAddress(index,loans[index].amount,loans[index].interest,newPrincipal,newInterest);\n        loans[index].amount = newPrincipal;\n        loans[index].interest = newInterest; \n    } else {\n        uint256 adjustedTotalRatio = SafeMath.div( SafeMath.mul(PERCENTAGE_PRECISION,loans[index].amountPaidBackSoFar), SafeMath.add(newPrincipal,newInterest) );\n        loans[index].interest = SafeMath.div( SafeMath.mul(newInterest, adjustedTotalRatio), PERCENTAGE_PRECISION);\n        loans[index].amount = SafeMath.sub(loans[index].amountPaidBackSoFar, loans[index].interest);\n\t\temit ActiveLoanUpdatedByVolAddressToCompletion(index);\n\t\tloanCompleted(index, 0);\n    }  \n}\n\n\nfunction requestLoan(address lender, address volAddress, uint256 amount,uint256 length,uint256 interest,bool requestCancel, string loanMessage) public returns(uint256)   {\n    if (msg.sender==lender) revert(); \n    \n    \n    if (amount==0 || length<4 || length>225257143) revert(); \n    \n   \n    require(amount <= MAX_LOAN_AMOUNT);\n    require(interest <= MAX_INTEREST_AMOUNT);    \n\n    loans.push(loan(msg.sender,lender, volAddress,0,amount,0,REQUESTED_STATUS,0,length,interest,false,false,loanMessage));\n    \n    emit LoanRequestedAtIndex(loans.length-1); \n    \n    return (loans.length-1);\n}\n\n\nfunction cancelLoanRequestAtIndexByLender(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].lender==msg.sender)    {\n        \n        loans[index].status=REQUEST_CANCELED_BY_LENDER_STATUS; \n        emit LoanRequestCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction cancelLoanRequestAtIndexByBorrower(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].borrower==msg.sender)    {\n       \n        loans[index].status=REQUEST_CANCELED_BY_BORROWER_STATUS; \n        emit LoanCanceledByBorrowerAtIndex(index); \n  }\n}\n\n\nfunction cancelActiveLoanAtIndex(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n\n      loans[index].status = ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\n      emit LoanCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction stateBorrowerDefaulted(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)){\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n    }\n  }\n}\n\n\nfunction declareDefaultAsBorrower(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].borrower==msg.sender)   {\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n  }\n}\n\n\nfunction attemptBeginLoanAtIndex(uint256 index) public returns(bool) {\n    if (loans[index].status==REQUESTED_STATUS)    {\n    \tif (loans[index].lender==0x000000000000000000000000000000000000dEaD)\t{\n\t\t\t\n\t\t\tif (msg.sender==loans[index].borrower) revert();\n\t\t\tloans[index].lender=msg.sender;\n\t\t\t\n\t\t\temit LenderClaimedLoanAtIndex(msg.sender,index);\n\t\t} else\t{\n\t\t\tif (!(msg.sender==loans[index].lender)) revert();\n\t\t}\n\t\t\n        \n        loans[index].status=ACTIVE_STATUS;\n        loans[index].startBlock = block.number;\n        emit LoanBegunAtIndex(index);\n        \n        if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender, loans[index].borrower, loans[index].amount) ) revert();\n        return true;\n    }\n    return false;\n}\n\n\nfunction payAmountForLoanAtIndex(uint256 amount,uint256 index) public {\n\n    if (loans[index].status==ACTIVE_STATUS && msg.sender==loans[index].borrower && amount>0)    {\n        require(amount <= SafeMath.add(MAX_LOAN_AMOUNT,MAX_INTEREST_AMOUNT));\n        require( SafeMath.add(amount, loans[index].amountPaidBackSoFar) <= SafeMath.add(loans[index].amount, loans[index].interest) );\n    \n        if (block.number==loans[index].startBlock) revert();\n    \t        \n       \n        loans[index].amountPaidBackSoFar = SafeMath.add(loans[index].amountPaidBackSoFar,amount);\n        \n        if (loans[index].amountPaidBackSoFar == SafeMath.add(loans[index].amount,loans[index].interest))    {\n            loanCompleted(index, amount);\n        } else {\n            emit PaidBackPortionForLoanAtIndex(index,amount); \n            \n            if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender,loans[index].lender, amount)) revert();\n        }\n    }\n}\n\n\n\nfunction returnBorrower(uint256 index) public returns(address)\t{\n\treturn loans[index].borrower;\n}\n\nfunction returnLender(uint256 index) public returns(address)\t{\n\treturn loans[index].lender;\n}\n\nfunction returnVolAdjuster(uint256 index) public returns(address)\t{\n\treturn loans[index].volAddress;\n}\n\nfunction returnStartBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].startBlock;\n}\n\nfunction returnAmount(uint256 index) returns(uint256)\t{\n\treturn loans[index].amount;\n}\n\nfunction returnPaidBackBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].paidBackBlock;\n}\n\nfunction returnLoanStatus(uint256 index) public returns(uint256)\t{\n\treturn loans[index].status;\n}\n\nfunction returnAmountPaidBackSoFar(uint256 index) public returns(uint256)\t{\n\treturn loans[index].amountPaidBackSoFar;\n}\n\nfunction returnLoanLength(uint256 index) public returns(uint256)\t{\n\treturn loans[index].loanLength;\n}\n\nfunction returnInterest(uint256 index) public returns(uint256)\t{\n\treturn loans[index].interest;\n}\n\nfunction returnBorrowerPaidLate(uint256 index) public returns(bool)\t{\n\treturn loans[index].borrowerPaidLate;\n}\n\nfunction returnRequestCancel(uint256 index) public returns(bool)\t{\n\treturn loans[index].requestCancel;\n}\n\nfunction returnMessage(uint256 index) public returns(string)\t{\n\treturn loans[index].message;\n}\n\nfunction getLoansCount() public returns(uint256) {\n    return loans.length;\n}\n\nfunction returnAmountPlusInterest(uint256 index) returns(uint256)\t{\n\treturn SafeMath.add(loans[index].amount,loans[index].interest);\n}\n\n}\n\ncontract elixir {\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from,address _to,uint256 _amount) returns (bool success);\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_lendingManager_32 + 68: 0x4\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 51, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11026, "code": "TED_STATUS; \nuint256 public ACTIVE_STATUS; \nuint256 public REQUEST_CANCELED_BY_BORROWER_STATUS;\nuint256 public REQUEST_CANCELED_BY_LENDER_STATUS;\nuint256 public ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\nuint256 public COMPLETION_STATUS; \nuint256 public DEFAULTED_STATUS;\n\nuint256 public MAX_LOAN_AMOUNT;\nuint256 public MAX_INTEREST_AMOUNT;\n\nuint256 public PERCENTAGE_PRECISION;\n\naddress public ELIX_ADDRESS;\n\nevent LoanRequestedAtIndex(uint256 index);\nevent LoanCanceledByBorrowerAtIndex(uint256 index); \nevent LoanCanceledByLenderAtIndex(uint256 index); \nevent Defaulted(uint256 index,address informer); \nevent LoanBegunAtIndex(uint256 index); \nevent LoanUpdatedByVolAddress(uint256 index,uint256 oldAmount,uint256 oldInterest,uint256 amount,uint256 interest);\nevent PaidBackPortionForLoanAtIndex(uint256 index,uint256 amount); \nevent LoanPaidLateAtIndex(uint256 index,uint256 amount); \nevent LoanRequestCanceledByLenderAtIndex(uint256 index);\nevent LoanCompletedWithFinalPortion(uint256 index, uint256 amount); \nevent ActiveLoanUpdatedByVolAddressToCompletion(uint256 index);\nevent LenderClaimedLoanAtIndex(address lender,uint256 index);\n\nloan[] public loans; \n\nstruct loan   {\n    address borrower;\n    address lender;\n    address volAddress;\n    uint256 startBlock;\n    uint256 amount; \n    uint256 paidBackBlock; \n    uint256 status;\n    uint256 amountPaidBackSoFar; \n    uint256 loanLength; \n    uint256 interest; \n    bool borrowerPaidLate;\n    bool requestCancel;\n    string message; \n}\n\nfunction lendingManager()  {\n    \n    REQUESTED_STATUS=1;\n    ACTIVE_STATUS=2;\n    REQUEST_CANCELED_BY_BORROWER_STATUS=3; \n    REQUEST_CANCELED_BY_LENDER_STATUS=4; \n    COMPLETION_STATUS=5;\n    ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS=6;\n    DEFAULTED_STATUS=7;\n\n    MAX_LOAN_AMOUNT = 100000000000000000000000000000;\n    MAX_INTEREST_AMOUNT = 100000000000000000000000000000;\n\n    PERCENTAGE_PRECISION = 1000000000000000000;\n\n\n    ELIX_ADDRESS = 0xc8C6A31A4A806d3710A7B38b7B296D2fABCCDBA8;\n}\n\nfunction loanCompleted(uint256 index, uint256 amount) private {\n\n    loans[index].paidBackBlock=block.number;\n    \n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)) {\n        loans[index].borrowerPaidLate=true;\n        emit LoanPaidLateAtIndex(index,amount); \n    }\n\n    loans[index].status=COMPLETION_STATUS; \n    emit LoanCompletedWithFinalPortion(index, amount); \n    if(amount > 0){ \n        if (! elixir(ELIX_ADDRESS).transferFrom(loans[index].borrower,loans[index].lender, amount)) revert();\n    }\n\n}\n\nfunction adjustLoanParams(uint256 newPrincipal, uint256 newInterest, uint256 index) public {\n    require(newPrincipal > 0);\n    require(msg.sender == loans[index].volAddress);\n    require(loans[index].status == REQUESTED_STATUS || loans[index].status == ACTIVE_STATUS);\n    require(newPrincipal <= MAX_LOAN_AMOUNT);\n    require(newInterest <= MAX_INTEREST_AMOUNT);\n\n    if (block.number==loans[index].startBlock) revert(); \n\n    if( SafeMath.add(newPrincipal,newInterest) > loans[index].amountPaidBackSoFar){  \n        \n        emit LoanUpdatedByVolAddress(index,loans[index].amount,loans[index].interest,newPrincipal,newInterest);\n        loans[index].amount = newPrincipal;\n        loans[index].interest = newInterest; \n    } else {\n        uint256 adjustedTotalRatio = SafeMath.div( SafeMath.mul(PERCENTAGE_PRECISION,loans[index].amountPaidBackSoFar), SafeMath.add(newPrincipal,newInterest) );\n        loans[index].interest = SafeMath.div( SafeMath.mul(newInterest, adjustedTotalRatio), PERCENTAGE_PRECISION);\n        loans[index].amount = SafeMath.sub(loans[index].amountPaidBackSoFar, loans[index].interest);\n\t\temit ActiveLoanUpdatedByVolAddressToCompletion(index);\n\t\tloanCompleted(index, 0);\n    }  \n}\n\n\nfunction requestLoan(address lender, address volAddress, uint256 amount,uint256 length,uint256 interest,bool requestCancel, string loanMessage) public returns(uint256)   {\n    if (msg.sender==lender) revert(); \n    \n    \n    if (amount==0 || length<4 || length>225257143) revert(); \n    \n   \n    require(amount <= MAX_LOAN_AMOUNT);\n    require(interest <= MAX_INTEREST_AMOUNT);    \n\n    loans.push(loan(msg.sender,lender, volAddress,0,amount,0,REQUESTED_STATUS,0,length,interest,false,false,loanMessage));\n    \n    emit LoanRequestedAtIndex(loans.length-1); \n    \n    return (loans.length-1);\n}\n\n\nfunction cancelLoanRequestAtIndexByLender(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].lender==msg.sender)    {\n        \n        loans[index].status=REQUEST_CANCELED_BY_LENDER_STATUS; \n        emit LoanRequestCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction cancelLoanRequestAtIndexByBorrower(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].borrower==msg.sender)    {\n       \n        loans[index].status=REQUEST_CANCELED_BY_BORROWER_STATUS; \n        emit LoanCanceledByBorrowerAtIndex(index); \n  }\n}\n\n\nfunction cancelActiveLoanAtIndex(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n\n      loans[index].status = ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\n      emit LoanCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction stateBorrowerDefaulted(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)){\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n    }\n  }\n}\n\n\nfunction declareDefaultAsBorrower(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].borrower==msg.sender)   {\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n  }\n}\n\n\nfunction attemptBeginLoanAtIndex(uint256 index) public returns(bool) {\n    if (loans[index].status==REQUESTED_STATUS)    {\n    \tif (loans[index].lender==0x000000000000000000000000000000000000dEaD)\t{\n\t\t\t\n\t\t\tif (msg.sender==loans[index].borrower) revert();\n\t\t\tloans[index].lender=msg.sender;\n\t\t\t\n\t\t\temit LenderClaimedLoanAtIndex(msg.sender,index);\n\t\t} else\t{\n\t\t\tif (!(msg.sender==loans[index].lender)) revert();\n\t\t}\n\t\t\n        \n        loans[index].status=ACTIVE_STATUS;\n        loans[index].startBlock = block.number;\n        emit LoanBegunAtIndex(index);\n        \n        if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender, loans[index].borrower, loans[index].amount) ) revert();\n        return true;\n    }\n    return false;\n}\n\n\nfunction payAmountForLoanAtIndex(uint256 amount,uint256 index) public {\n\n    if (loans[index].status==ACTIVE_STATUS && msg.sender==loans[index].borrower && amount>0)    {\n        require(amount <= SafeMath.add(MAX_LOAN_AMOUNT,MAX_INTEREST_AMOUNT));\n        require( SafeMath.add(amount, loans[index].amountPaidBackSoFar) <= SafeMath.add(loans[index].amount, loans[index].interest) );\n    \n        if (block.number==loans[index].startBlock) revert();\n    \t        \n       \n        loans[index].amountPaidBackSoFar = SafeMath.add(loans[index].amountPaidBackSoFar,amount);\n        \n        if (loans[index].amountPaidBackSoFar == SafeMath.add(loans[index].amount,loans[index].interest))    {\n            loanCompleted(index, amount);\n        } else {\n            emit PaidBackPortionForLoanAtIndex(index,amount); \n            \n            if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender,loans[index].lender, amount)) revert();\n        }\n    }\n}\n\n\n\nfunction returnBorrower(uint256 index) public returns(address)\t{\n\treturn loans[index].borrower;\n}\n\nfunction returnLender(uint256 index) public returns(address)\t{\n\treturn loans[index].lender;\n}\n\nfunction returnVolAdjuster(uint256 index) public returns(address)\t{\n\treturn loans[index].volAddress;\n}\n\nfunction returnStartBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].startBlock;\n}\n\nfunction returnAmount(uint256 index) returns(uint256)\t{\n\treturn loans[index].amount;\n}\n\nfunction returnPaidBackBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].paidBackBlock;\n}\n\nfunction returnLoanStatus(uint256 index) public returns(uint256)\t{\n\treturn loans[index].status;\n}\n\nfunction returnAmountPaidBackSoFar(uint256 index) public returns(uint256)\t{\n\treturn loans[index].amountPaidBackSoFar;\n}\n\nfunction returnLoanLength(uint256 index) public returns(uint256)\t{\n\treturn loans[index].loanLength;\n}\n\nfunction returnInterest(uint256 index) public returns(uint256)\t{\n\treturn loans[index].interest;\n}\n\nfunction returnBorrowerPaidLate(uint256 index) public returns(bool)\t{\n\treturn loans[index].borrowerPaidLate;\n}\n\nfunction returnRequestCancel(uint256 index) public returns(bool)\t{\n\treturn loans[index].requestCancel;\n}\n\nfunction returnMessage(uint256 index) public returns(string)\t{\n\treturn loans[index].message;\n}\n\nfunction getLoansCount() public returns(uint256) {\n    return loans.length;\n}\n\nfunction returnAmountPlusInterest(uint256 index) returns(uint256)\t{\n\treturn SafeMath.add(loans[index].amount,loans[index].interest);\n}\n\n}\n\ncontract elixir {\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from,address _to,uint256 _amount) returns (bool success);\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0x8e10b66c2bfffffffefac23fff2142221e7e1841020385a8fffffffffffffffd\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0x8c0e478883fffffffffffdffff9ebddde181e7befdfc7a56fffffffffffffff1\ncalldata_lendingManager_32 + 68: 0x1802738\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 51, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11043, "code": "TED_STATUS; \nuint256 public ACTIVE_STATUS; \nuint256 public REQUEST_CANCELED_BY_BORROWER_STATUS;\nuint256 public REQUEST_CANCELED_BY_LENDER_STATUS;\nuint256 public ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\nuint256 public COMPLETION_STATUS; \nuint256 public DEFAULTED_STATUS;\n\nuint256 public MAX_LOAN_AMOUNT;\nuint256 public MAX_INTEREST_AMOUNT;\n\nuint256 public PERCENTAGE_PRECISION;\n\naddress public ELIX_ADDRESS;\n\nevent LoanRequestedAtIndex(uint256 index);\nevent LoanCanceledByBorrowerAtIndex(uint256 index); \nevent LoanCanceledByLenderAtIndex(uint256 index); \nevent Defaulted(uint256 index,address informer); \nevent LoanBegunAtIndex(uint256 index); \nevent LoanUpdatedByVolAddress(uint256 index,uint256 oldAmount,uint256 oldInterest,uint256 amount,uint256 interest);\nevent PaidBackPortionForLoanAtIndex(uint256 index,uint256 amount); \nevent LoanPaidLateAtIndex(uint256 index,uint256 amount); \nevent LoanRequestCanceledByLenderAtIndex(uint256 index);\nevent LoanCompletedWithFinalPortion(uint256 index, uint256 amount); \nevent ActiveLoanUpdatedByVolAddressToCompletion(uint256 index);\nevent LenderClaimedLoanAtIndex(address lender,uint256 index);\n\nloan[] public loans; \n\nstruct loan   {\n    address borrower;\n    address lender;\n    address volAddress;\n    uint256 startBlock;\n    uint256 amount; \n    uint256 paidBackBlock; \n    uint256 status;\n    uint256 amountPaidBackSoFar; \n    uint256 loanLength; \n    uint256 interest; \n    bool borrowerPaidLate;\n    bool requestCancel;\n    string message; \n}\n\nfunction lendingManager()  {\n    \n    REQUESTED_STATUS=1;\n    ACTIVE_STATUS=2;\n    REQUEST_CANCELED_BY_BORROWER_STATUS=3; \n    REQUEST_CANCELED_BY_LENDER_STATUS=4; \n    COMPLETION_STATUS=5;\n    ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS=6;\n    DEFAULTED_STATUS=7;\n\n    MAX_LOAN_AMOUNT = 100000000000000000000000000000;\n    MAX_INTEREST_AMOUNT = 100000000000000000000000000000;\n\n    PERCENTAGE_PRECISION = 1000000000000000000;\n\n\n    ELIX_ADDRESS = 0xc8C6A31A4A806d3710A7B38b7B296D2fABCCDBA8;\n}\n\nfunction loanCompleted(uint256 index, uint256 amount) private {\n\n    loans[index].paidBackBlock=block.number;\n    \n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)) {\n        loans[index].borrowerPaidLate=true;\n        emit LoanPaidLateAtIndex(index,amount); \n    }\n\n    loans[index].status=COMPLETION_STATUS; \n    emit LoanCompletedWithFinalPortion(index, amount); \n    if(amount > 0){ \n        if (! elixir(ELIX_ADDRESS).transferFrom(loans[index].borrower,loans[index].lender, amount)) revert();\n    }\n\n}\n\nfunction adjustLoanParams(uint256 newPrincipal, uint256 newInterest, uint256 index) public {\n    require(newPrincipal > 0);\n    require(msg.sender == loans[index].volAddress);\n    require(loans[index].status == REQUESTED_STATUS || loans[index].status == ACTIVE_STATUS);\n    require(newPrincipal <= MAX_LOAN_AMOUNT);\n    require(newInterest <= MAX_INTEREST_AMOUNT);\n\n    if (block.number==loans[index].startBlock) revert(); \n\n    if( SafeMath.add(newPrincipal,newInterest) > loans[index].amountPaidBackSoFar){  \n        \n        emit LoanUpdatedByVolAddress(index,loans[index].amount,loans[index].interest,newPrincipal,newInterest);\n        loans[index].amount = newPrincipal;\n        loans[index].interest = newInterest; \n    } else {\n        uint256 adjustedTotalRatio = SafeMath.div( SafeMath.mul(PERCENTAGE_PRECISION,loans[index].amountPaidBackSoFar), SafeMath.add(newPrincipal,newInterest) );\n        loans[index].interest = SafeMath.div( SafeMath.mul(newInterest, adjustedTotalRatio), PERCENTAGE_PRECISION);\n        loans[index].amount = SafeMath.sub(loans[index].amountPaidBackSoFar, loans[index].interest);\n\t\temit ActiveLoanUpdatedByVolAddressToCompletion(index);\n\t\tloanCompleted(index, 0);\n    }  \n}\n\n\nfunction requestLoan(address lender, address volAddress, uint256 amount,uint256 length,uint256 interest,bool requestCancel, string loanMessage) public returns(uint256)   {\n    if (msg.sender==lender) revert(); \n    \n    \n    if (amount==0 || length<4 || length>225257143) revert(); \n    \n   \n    require(amount <= MAX_LOAN_AMOUNT);\n    require(interest <= MAX_INTEREST_AMOUNT);    \n\n    loans.push(loan(msg.sender,lender, volAddress,0,amount,0,REQUESTED_STATUS,0,length,interest,false,false,loanMessage));\n    \n    emit LoanRequestedAtIndex(loans.length-1); \n    \n    return (loans.length-1);\n}\n\n\nfunction cancelLoanRequestAtIndexByLender(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].lender==msg.sender)    {\n        \n        loans[index].status=REQUEST_CANCELED_BY_LENDER_STATUS; \n        emit LoanRequestCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction cancelLoanRequestAtIndexByBorrower(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].borrower==msg.sender)    {\n       \n        loans[index].status=REQUEST_CANCELED_BY_BORROWER_STATUS; \n        emit LoanCanceledByBorrowerAtIndex(index); \n  }\n}\n\n\nfunction cancelActiveLoanAtIndex(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n\n      loans[index].status = ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\n      emit LoanCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction stateBorrowerDefaulted(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)){\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n    }\n  }\n}\n\n\nfunction declareDefaultAsBorrower(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].borrower==msg.sender)   {\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n  }\n}\n\n\nfunction attemptBeginLoanAtIndex(uint256 index) public returns(bool) {\n    if (loans[index].status==REQUESTED_STATUS)    {\n    \tif (loans[index].lender==0x000000000000000000000000000000000000dEaD)\t{\n\t\t\t\n\t\t\tif (msg.sender==loans[index].borrower) revert();\n\t\t\tloans[index].lender=msg.sender;\n\t\t\t\n\t\t\temit LenderClaimedLoanAtIndex(msg.sender,index);\n\t\t} else\t{\n\t\t\tif (!(msg.sender==loans[index].lender)) revert();\n\t\t}\n\t\t\n        \n        loans[index].status=ACTIVE_STATUS;\n        loans[index].startBlock = block.number;\n        emit LoanBegunAtIndex(index);\n        \n        if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender, loans[index].borrower, loans[index].amount) ) revert();\n        return true;\n    }\n    return false;\n}\n\n\nfunction payAmountForLoanAtIndex(uint256 amount,uint256 index) public {\n\n    if (loans[index].status==ACTIVE_STATUS && msg.sender==loans[index].borrower && amount>0)    {\n        require(amount <= SafeMath.add(MAX_LOAN_AMOUNT,MAX_INTEREST_AMOUNT));\n        require( SafeMath.add(amount, loans[index].amountPaidBackSoFar) <= SafeMath.add(loans[index].amount, loans[index].interest) );\n    \n        if (block.number==loans[index].startBlock) revert();\n    \t        \n       \n        loans[index].amountPaidBackSoFar = SafeMath.add(loans[index].amountPaidBackSoFar,amount);\n        \n        if (loans[index].amountPaidBackSoFar == SafeMath.add(loans[index].amount,loans[index].interest))    {\n            loanCompleted(index, amount);\n        } else {\n            emit PaidBackPortionForLoanAtIndex(index,amount); \n            \n            if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender,loans[index].lender, amount)) revert();\n        }\n    }\n}\n\n\n\nfunction returnBorrower(uint256 index) public returns(address)\t{\n\treturn loans[index].borrower;\n}\n\nfunction returnLender(uint256 index) public returns(address)\t{\n\treturn loans[index].lender;\n}\n\nfunction returnVolAdjuster(uint256 index) public returns(address)\t{\n\treturn loans[index].volAddress;\n}\n\nfunction returnStartBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].startBlock;\n}\n\nfunction returnAmount(uint256 index) returns(uint256)\t{\n\treturn loans[index].amount;\n}\n\nfunction returnPaidBackBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].paidBackBlock;\n}\n\nfunction returnLoanStatus(uint256 index) public returns(uint256)\t{\n\treturn loans[index].status;\n}\n\nfunction returnAmountPaidBackSoFar(uint256 index) public returns(uint256)\t{\n\treturn loans[index].amountPaidBackSoFar;\n}\n\nfunction returnLoanLength(uint256 index) public returns(uint256)\t{\n\treturn loans[index].loanLength;\n}\n\nfunction returnInterest(uint256 index) public returns(uint256)\t{\n\treturn loans[index].interest;\n}\n\nfunction returnBorrowerPaidLate(uint256 index) public returns(bool)\t{\n\treturn loans[index].borrowerPaidLate;\n}\n\nfunction returnRequestCancel(uint256 index) public returns(bool)\t{\n\treturn loans[index].requestCancel;\n}\n\nfunction returnMessage(uint256 index) public returns(string)\t{\n\treturn loans[index].message;\n}\n\nfunction getLoansCount() public returns(uint256) {\n    return loans.length;\n}\n\nfunction returnAmountPlusInterest(uint256 index) returns(uint256)\t{\n\treturn SafeMath.add(loans[index].amount,loans[index].interest);\n}\n\n}\n\ncontract elixir {\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from,address _to,uint256 _amount) returns (bool success);\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0x30\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa8\ncalldata_lendingManager_32 + 68: 0x10\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 51, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11048, "code": "TED_STATUS; \nuint256 public ACTIVE_STATUS; \nuint256 public REQUEST_CANCELED_BY_BORROWER_STATUS;\nuint256 public REQUEST_CANCELED_BY_LENDER_STATUS;\nuint256 public ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\nuint256 public COMPLETION_STATUS; \nuint256 public DEFAULTED_STATUS;\n\nuint256 public MAX_LOAN_AMOUNT;\nuint256 public MAX_INTEREST_AMOUNT;\n\nuint256 public PERCENTAGE_PRECISION;\n\naddress public ELIX_ADDRESS;\n\nevent LoanRequestedAtIndex(uint256 index);\nevent LoanCanceledByBorrowerAtIndex(uint256 index); \nevent LoanCanceledByLenderAtIndex(uint256 index); \nevent Defaulted(uint256 index,address informer); \nevent LoanBegunAtIndex(uint256 index); \nevent LoanUpdatedByVolAddress(uint256 index,uint256 oldAmount,uint256 oldInterest,uint256 amount,uint256 interest);\nevent PaidBackPortionForLoanAtIndex(uint256 index,uint256 amount); \nevent LoanPaidLateAtIndex(uint256 index,uint256 amount); \nevent LoanRequestCanceledByLenderAtIndex(uint256 index);\nevent LoanCompletedWithFinalPortion(uint256 index, uint256 amount); \nevent ActiveLoanUpdatedByVolAddressToCompletion(uint256 index);\nevent LenderClaimedLoanAtIndex(address lender,uint256 index);\n\nloan[] public loans; \n\nstruct loan   {\n    address borrower;\n    address lender;\n    address volAddress;\n    uint256 startBlock;\n    uint256 amount; \n    uint256 paidBackBlock; \n    uint256 status;\n    uint256 amountPaidBackSoFar; \n    uint256 loanLength; \n    uint256 interest; \n    bool borrowerPaidLate;\n    bool requestCancel;\n    string message; \n}\n\nfunction lendingManager()  {\n    \n    REQUESTED_STATUS=1;\n    ACTIVE_STATUS=2;\n    REQUEST_CANCELED_BY_BORROWER_STATUS=3; \n    REQUEST_CANCELED_BY_LENDER_STATUS=4; \n    COMPLETION_STATUS=5;\n    ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS=6;\n    DEFAULTED_STATUS=7;\n\n    MAX_LOAN_AMOUNT = 100000000000000000000000000000;\n    MAX_INTEREST_AMOUNT = 100000000000000000000000000000;\n\n    PERCENTAGE_PRECISION = 1000000000000000000;\n\n\n    ELIX_ADDRESS = 0xc8C6A31A4A806d3710A7B38b7B296D2fABCCDBA8;\n}\n\nfunction loanCompleted(uint256 index, uint256 amount) private {\n\n    loans[index].paidBackBlock=block.number;\n    \n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)) {\n        loans[index].borrowerPaidLate=true;\n        emit LoanPaidLateAtIndex(index,amount); \n    }\n\n    loans[index].status=COMPLETION_STATUS; \n    emit LoanCompletedWithFinalPortion(index, amount); \n    if(amount > 0){ \n        if (! elixir(ELIX_ADDRESS).transferFrom(loans[index].borrower,loans[index].lender, amount)) revert();\n    }\n\n}\n\nfunction adjustLoanParams(uint256 newPrincipal, uint256 newInterest, uint256 index) public {\n    require(newPrincipal > 0);\n    require(msg.sender == loans[index].volAddress);\n    require(loans[index].status == REQUESTED_STATUS || loans[index].status == ACTIVE_STATUS);\n    require(newPrincipal <= MAX_LOAN_AMOUNT);\n    require(newInterest <= MAX_INTEREST_AMOUNT);\n\n    if (block.number==loans[index].startBlock) revert(); \n\n    if( SafeMath.add(newPrincipal,newInterest) > loans[index].amountPaidBackSoFar){  \n        \n        emit LoanUpdatedByVolAddress(index,loans[index].amount,loans[index].interest,newPrincipal,newInterest);\n        loans[index].amount = newPrincipal;\n        loans[index].interest = newInterest; \n    } else {\n        uint256 adjustedTotalRatio = SafeMath.div( SafeMath.mul(PERCENTAGE_PRECISION,loans[index].amountPaidBackSoFar), SafeMath.add(newPrincipal,newInterest) );\n        loans[index].interest = SafeMath.div( SafeMath.mul(newInterest, adjustedTotalRatio), PERCENTAGE_PRECISION);\n        loans[index].amount = SafeMath.sub(loans[index].amountPaidBackSoFar, loans[index].interest);\n\t\temit ActiveLoanUpdatedByVolAddressToCompletion(index);\n\t\tloanCompleted(index, 0);\n    }  \n}\n\n\nfunction requestLoan(address lender, address volAddress, uint256 amount,uint256 length,uint256 interest,bool requestCancel, string loanMessage) public returns(uint256)   {\n    if (msg.sender==lender) revert(); \n    \n    \n    if (amount==0 || length<4 || length>225257143) revert(); \n    \n   \n    require(amount <= MAX_LOAN_AMOUNT);\n    require(interest <= MAX_INTEREST_AMOUNT);    \n\n    loans.push(loan(msg.sender,lender, volAddress,0,amount,0,REQUESTED_STATUS,0,length,interest,false,false,loanMessage));\n    \n    emit LoanRequestedAtIndex(loans.length-1); \n    \n    return (loans.length-1);\n}\n\n\nfunction cancelLoanRequestAtIndexByLender(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].lender==msg.sender)    {\n        \n        loans[index].status=REQUEST_CANCELED_BY_LENDER_STATUS; \n        emit LoanRequestCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction cancelLoanRequestAtIndexByBorrower(uint256 index) public {\n  if (loans[index].status==REQUESTED_STATUS && loans[index].borrower==msg.sender)    {\n       \n        loans[index].status=REQUEST_CANCELED_BY_BORROWER_STATUS; \n        emit LoanCanceledByBorrowerAtIndex(index); \n  }\n}\n\n\nfunction cancelActiveLoanAtIndex(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n\n      loans[index].status = ACTIVE_LOAN_CANCELED_BY_LENDER_STATUS;\n      emit LoanCanceledByLenderAtIndex(index); \n  }\n}\n\n\nfunction stateBorrowerDefaulted(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].lender==msg.sender)   {\n    if (block.number>SafeMath.add(loans[index].startBlock,loans[index].loanLength)){\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n    }\n  }\n}\n\n\nfunction declareDefaultAsBorrower(uint256 index) public  {\n  if (loans[index].status==ACTIVE_STATUS && loans[index].borrower==msg.sender)   {\n      emit Defaulted(index,msg.sender); \n      loans[index].status=DEFAULTED_STATUS;\n  }\n}\n\n\nfunction attemptBeginLoanAtIndex(uint256 index) public returns(bool) {\n    if (loans[index].status==REQUESTED_STATUS)    {\n    \tif (loans[index].lender==0x000000000000000000000000000000000000dEaD)\t{\n\t\t\t\n\t\t\tif (msg.sender==loans[index].borrower) revert();\n\t\t\tloans[index].lender=msg.sender;\n\t\t\t\n\t\t\temit LenderClaimedLoanAtIndex(msg.sender,index);\n\t\t} else\t{\n\t\t\tif (!(msg.sender==loans[index].lender)) revert();\n\t\t}\n\t\t\n        \n        loans[index].status=ACTIVE_STATUS;\n        loans[index].startBlock = block.number;\n        emit LoanBegunAtIndex(index);\n        \n        if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender, loans[index].borrower, loans[index].amount) ) revert();\n        return true;\n    }\n    return false;\n}\n\n\nfunction payAmountForLoanAtIndex(uint256 amount,uint256 index) public {\n\n    if (loans[index].status==ACTIVE_STATUS && msg.sender==loans[index].borrower && amount>0)    {\n        require(amount <= SafeMath.add(MAX_LOAN_AMOUNT,MAX_INTEREST_AMOUNT));\n        require( SafeMath.add(amount, loans[index].amountPaidBackSoFar) <= SafeMath.add(loans[index].amount, loans[index].interest) );\n    \n        if (block.number==loans[index].startBlock) revert();\n    \t        \n       \n        loans[index].amountPaidBackSoFar = SafeMath.add(loans[index].amountPaidBackSoFar,amount);\n        \n        if (loans[index].amountPaidBackSoFar == SafeMath.add(loans[index].amount,loans[index].interest))    {\n            loanCompleted(index, amount);\n        } else {\n            emit PaidBackPortionForLoanAtIndex(index,amount); \n            \n            if (! elixir(ELIX_ADDRESS).transferFrom(msg.sender,loans[index].lender, amount)) revert();\n        }\n    }\n}\n\n\n\nfunction returnBorrower(uint256 index) public returns(address)\t{\n\treturn loans[index].borrower;\n}\n\nfunction returnLender(uint256 index) public returns(address)\t{\n\treturn loans[index].lender;\n}\n\nfunction returnVolAdjuster(uint256 index) public returns(address)\t{\n\treturn loans[index].volAddress;\n}\n\nfunction returnStartBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].startBlock;\n}\n\nfunction returnAmount(uint256 index) returns(uint256)\t{\n\treturn loans[index].amount;\n}\n\nfunction returnPaidBackBlock(uint256 index) returns(uint256)\t{\n\treturn loans[index].paidBackBlock;\n}\n\nfunction returnLoanStatus(uint256 index) public returns(uint256)\t{\n\treturn loans[index].status;\n}\n\nfunction returnAmountPaidBackSoFar(uint256 index) public returns(uint256)\t{\n\treturn loans[index].amountPaidBackSoFar;\n}\n\nfunction returnLoanLength(uint256 index) public returns(uint256)\t{\n\treturn loans[index].loanLength;\n}\n\nfunction returnInterest(uint256 index) public returns(uint256)\t{\n\treturn loans[index].interest;\n}\n\nfunction returnBorrowerPaidLate(uint256 index) public returns(bool)\t{\n\treturn loans[index].borrowerPaidLate;\n}\n\nfunction returnRequestCancel(uint256 index) public returns(bool)\t{\n\treturn loans[index].requestCancel;\n}\n\nfunction returnMessage(uint256 index) public returns(string)\t{\n\treturn loans[index].message;\n}\n\nfunction getLoansCount() public returns(uint256) {\n    return loans.length;\n}\n\nfunction returnAmountPlusInterest(uint256 index) returns(uint256)\t{\n\treturn SafeMath.add(loans[index].amount,loans[index].interest);\n}\n\n}\n\ncontract elixir {\n    function transfer(address _to, uint256 _amount) returns (bool success);\n    function transferFrom(address _from,address _to,uint256 _amount) returns (bool success);\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0x1fffffffffffffffbffffffffffffffffffffffffffffffffffffffeffffd\nkeccac_11_+\n660301456019777184113296434797620819555017468543624515662331739614079884729_+\n12*storage_11: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_lendingManager_4 + calldata_lendingManager_32 + 164)) +\n384: 0x87f9ffff7fbf876fa8d16eaeff9bffffe7e76dfffbffbf48fffffffff82fffe3\ncalldata_lendingManager_32 + 68: 0x200\nstorage_8: 0x0\ncalldata_lendingManager_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_32 + 100: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_lendingManager_0: 0x84ab6f500000000000000000000000000000000000000000000000000000000\ncalldatasize_lendingManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `requestLoan(address,address,uint256,uint256,uint256,bool,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0x966f969125802bfb677f036a4d41fcbdccc29edd.sol", "function": "requestLoan(address,address,uint256,uint256,uint256,bool,string)", "lineno": 51, "title": "Integer Overflow ", "type": "Warning"}], "success": true}