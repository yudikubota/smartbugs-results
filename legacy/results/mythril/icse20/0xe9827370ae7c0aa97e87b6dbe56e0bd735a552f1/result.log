{"error": null, "issues": [{"address": 1033, "code": "       _loveStory.data = _data;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function transferCost(bytes16 _id, uint256 _lockDurationInHours)\n        public\n        view\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n        returns (uint256)\n    {\n        return loveStories[_id].transferCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function transferLoveStory(", "debug": "calldata_WillAlwaysLove_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_WillAlwaysLove_0: 0x6999769600000000000000000000000000000000000000000000000000000000\ncalldatasize_WillAlwaysLove: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateLoveStoryWithData(bytes16,bytes32,bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0xe9827370ae7c0aa97e87b6dbe56e0bd735a552f1.sol", "function": "updateLoveStoryWithData(bytes16,bytes32,bytes32,string)", "lineno": 316, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9776, "code": "----------------\n\n    uint256 public constant DEFAULT_INITIAL_COST = 0.025 ether;\n    uint256 public constant DEFAULT_LOCK_COST_PER_HOUR = 0.0006 ether; // 10 szabo per minute\n    uint256 public constant DEFAULT_MAX_LOCK_DURATION = 1 weeks;\n\n    uint256 public constant DEVELOPER_CUT = 25; // %\n\n    // ------------------------------------------------------------\n\n    struct LoveStory {\n        address owner;\n        bytes32 loverName;\n        bytes32 lovedOneName;\n        uint256 transferCost;\n        uint256 lockedUntil;\n        string data;\n    }\n\n    // ------------------------------------------------------------\n\n    uint256 public initialCost;\n    uint256 public lockCostPerHour;\n    uint256 public maxLockDuration;\n\n    mapping(bytes16 => LoveStory) private loveStories;\n    uint256 public loveStoriesCount;\n\n    mapping (address => uint256) private pendingWithdrawals;\n\n    // ------------------------------------------------------------\n\n    event LoveStoryCreated(\n        bytes16 id,\n        address owner,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        uint256 transferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event LoveStoryUpdated(\n        bytes16 id,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        string data\n    );\n\n    event LoveStoryTransferred(\n        bytes16 id,\n        address oldOwner,\n        address newOwner,\n        bytes32 newLoverName,\n        bytes32 newLovedOneName,\n        uint256 newtransferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event Withdrawal(\n        address withdrawer,\n        uint256 amount\n    );\n\n    // ------------------------------------------------------------\n\n    modifier onlyForUnregisteredId(bytes16 _id) {\n        require(!isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForRegisteredId(bytes16 _id) {\n        require(isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForValidId(bytes16 _id) {\n        require(isIdValid(_id));\n        _;\n    }\n\n    modifier onlyWithPendingWithdrawal() {\n        require(withdrawableAmount() != 0);\n        _;\n    }\n\n    modifier onlyLoveStoryOwner(bytes16 _id) {\n        require(loveStories[_id].owner == msg.sender);\n        _;\n    }\n\n    // ------------------------------------------------------------\n\n    constructor ()\n        public\n    {\n        initialCost = DEFAULT_INITIAL_COST;\n        lockCostPerHour = DEFAULT_LOCK_COST_PER_HOUR;\n        maxLockDuration = DEFAULT_MAX_LOCK_DURATION;\n    }\n\n    function ()\n        public\n        payable\n    {\n    }\n\n    function createCost(uint256 _lockDurationInHours)\n        public\n        view\n        returns (uint256)\n    {\n        return initialCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function createLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n    {\n        createLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, \"\");\n    }\n\n    function createLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForUnregisteredId(_id)\n    {\n        require(msg.value >= createCost(_lockDurationInHours));\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n        loveStoriesCount = loveStoriesCount.add(1);\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(msg.value);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        emit LoveStoryCreated (\n            _id,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, string _data)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.data = _data;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function transferCost(bytes16 _id, uint256 _lockDurationInHours)\n        public\n        view\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n        returns (uint256)\n    {\n        return loveStories[_id].transferCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function transferLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        transferLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, _loveStory.data);\n    }\n\n    function transferLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        address _oldOwner = _loveStory.owner;\n\n        require(_oldOwner != msg.sender);\n        require(msg.value >= transferCost(_id, _lockDurationInHours));\n        require(now >= _loveStory.lockedUntil);\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n\n        uint256 _developerPayment = msg.value.mul(DEVELOPER_CUT).div(100);\n        uint256 _oldOwnerPayment = msg.value.sub(_developerPayment);\n\n        require(msg.value == _developerPayment.add(_oldOwnerPayment));\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(_developerPayment);\n        pendingWithdrawals[_oldOwner] = pendingWithdrawals[_oldOwner].add(_oldOwnerPayment);\n\n        emit LoveStoryTransferred (\n            _id,\n            _oldOwner,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function readLoveStory(bytes16 _id)\n        public\n        view\n        returns (address _loveStoryOwner, bytes32 _loverName, bytes32 _lovedOneName, uint256 _transferCost, uint256 _lockedUntil, string _data)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStoryOwner = _loveStory.owner;\n        _loverName = _loveStory.loverName;\n        _lovedOneName = _loveStory.lovedOneName;\n        _transferCost = _loveStory.transferCost;\n        _lockedUntil = _loveStory.lockedUntil;\n        _data = _loveStory.data;\n    }\n\n    function isIdRegistered(bytes16 _id)\n        public\n        view\n        returns (bool)\n    {\n        return loveStories[_id].owner != 0x0;\n    }\n\n    function isIdValid(bytes16 _id)\n        public\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < 16; i = i.add(1))\n        {\n            if (i == 0)\n            {\n                // First char must be between 'a' and 'z'. It CAN'T be NULL.\n                if ( ! _isLowercaseLetter(_id[i]) )\n                {\n                    return false;\n                }\n            }\n            else if (i == 15)\n            {\n                // Last char must between 'a' and 'z'. It can also be a terminating NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || _id[i] == 0) )\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                // In-between chars must between 'a' and 'z' or '-'. Otherwise, they should be the unset bytes.\n                // The last part is verifiied by requiring that an in-bewteen char that is NULL\n                // must *also* be follwed by a NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || (_id[i] == 0x2D && _id[i+1] != 0) || (_id[i] == _id[i+1] && _id[i] == 0)) )\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function withdrawableAmount()\n        public\n        view\n        returns (uint256)\n    {\n        return pendingWithdrawals[msg.sender];\n    }\n\n    function withdraw()\n        external\n        nonReentrant\n        onlyWithPendingWithdrawal\n    {\n        uint256 amount = pendingWithdrawals[msg.sender];\n\n        pendingWithdrawals[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n\n        emit Withdrawal (\n            msg.sender,\n            amount\n        );\n    }\n\n    function withdrawableAmountFor(address _withdrawer)\n        public\n        view\n        onlyOwner\n        returns (uint256)\n    {\n        return pendingWithdrawals[_withdrawer];\n    }\n\n    function changeInitialCost(uint256 _initialCost)\n        external\n        onlyOwner\n    {\n        initialCost = _initialCost;\n    }\n\n    function changeLockCostPerHour(uint256 _lockCostPerHour)\n        external\n        onlyOwner\n    {\n        lockCostPerHour = _lockCostPerHour;\n    }\n\n    function changeMaxLockDuration(uint256 _maxLockDuration)\n        external\n        onlyOwner\n    {\n        maxLockDuration = _maxLockDuration;\n    }\n\n    // ------------------------------------------------------------\n\n    function _updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        private\n    {\n        require(_lockDurationInHours * 1 hours <= maxLockDuration);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.owner = msg.sender;\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.transferCost = msg.value.mul(2);\n        _loveStory.lockedUntil = now.add(_lockDurationInHours.mul(1 hours));\n        _loveStory.data = _data;\n    }\n\n    function _isLowercaseLetter(byte _char)\n        private\n        pure\n        returns (bool)\n    {\n        // Char must be a small case letter: [a-z]\n        return _char >= 0x61 && _char <= 0x7A;\n    }\n}", "debug": "storage_5 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_5_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncaller: 0x0\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0x0\ncalldata_WillAlwaysLove_0: 0x6999769600000000000000000000000000000000000000000000000000000000\ncalldatasize_WillAlwaysLove: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateLoveStoryWithData(bytes16,bytes32,bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0xe9827370ae7c0aa97e87b6dbe56e0bd735a552f1.sol", "function": "updateLoveStoryWithData(bytes16,bytes32,bytes32,string)", "lineno": 142, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9805, "code": "----------------\n\n    uint256 public constant DEFAULT_INITIAL_COST = 0.025 ether;\n    uint256 public constant DEFAULT_LOCK_COST_PER_HOUR = 0.0006 ether; // 10 szabo per minute\n    uint256 public constant DEFAULT_MAX_LOCK_DURATION = 1 weeks;\n\n    uint256 public constant DEVELOPER_CUT = 25; // %\n\n    // ------------------------------------------------------------\n\n    struct LoveStory {\n        address owner;\n        bytes32 loverName;\n        bytes32 lovedOneName;\n        uint256 transferCost;\n        uint256 lockedUntil;\n        string data;\n    }\n\n    // ------------------------------------------------------------\n\n    uint256 public initialCost;\n    uint256 public lockCostPerHour;\n    uint256 public maxLockDuration;\n\n    mapping(bytes16 => LoveStory) private loveStories;\n    uint256 public loveStoriesCount;\n\n    mapping (address => uint256) private pendingWithdrawals;\n\n    // ------------------------------------------------------------\n\n    event LoveStoryCreated(\n        bytes16 id,\n        address owner,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        uint256 transferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event LoveStoryUpdated(\n        bytes16 id,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        string data\n    );\n\n    event LoveStoryTransferred(\n        bytes16 id,\n        address oldOwner,\n        address newOwner,\n        bytes32 newLoverName,\n        bytes32 newLovedOneName,\n        uint256 newtransferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event Withdrawal(\n        address withdrawer,\n        uint256 amount\n    );\n\n    // ------------------------------------------------------------\n\n    modifier onlyForUnregisteredId(bytes16 _id) {\n        require(!isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForRegisteredId(bytes16 _id) {\n        require(isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForValidId(bytes16 _id) {\n        require(isIdValid(_id));\n        _;\n    }\n\n    modifier onlyWithPendingWithdrawal() {\n        require(withdrawableAmount() != 0);\n        _;\n    }\n\n    modifier onlyLoveStoryOwner(bytes16 _id) {\n        require(loveStories[_id].owner == msg.sender);\n        _;\n    }\n\n    // ------------------------------------------------------------\n\n    constructor ()\n        public\n    {\n        initialCost = DEFAULT_INITIAL_COST;\n        lockCostPerHour = DEFAULT_LOCK_COST_PER_HOUR;\n        maxLockDuration = DEFAULT_MAX_LOCK_DURATION;\n    }\n\n    function ()\n        public\n        payable\n    {\n    }\n\n    function createCost(uint256 _lockDurationInHours)\n        public\n        view\n        returns (uint256)\n    {\n        return initialCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function createLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n    {\n        createLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, \"\");\n    }\n\n    function createLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForUnregisteredId(_id)\n    {\n        require(msg.value >= createCost(_lockDurationInHours));\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n        loveStoriesCount = loveStoriesCount.add(1);\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(msg.value);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        emit LoveStoryCreated (\n            _id,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, string _data)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.data = _data;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function transferCost(bytes16 _id, uint256 _lockDurationInHours)\n        public\n        view\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n        returns (uint256)\n    {\n        return loveStories[_id].transferCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function transferLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        transferLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, _loveStory.data);\n    }\n\n    function transferLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        address _oldOwner = _loveStory.owner;\n\n        require(_oldOwner != msg.sender);\n        require(msg.value >= transferCost(_id, _lockDurationInHours));\n        require(now >= _loveStory.lockedUntil);\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n\n        uint256 _developerPayment = msg.value.mul(DEVELOPER_CUT).div(100);\n        uint256 _oldOwnerPayment = msg.value.sub(_developerPayment);\n\n        require(msg.value == _developerPayment.add(_oldOwnerPayment));\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(_developerPayment);\n        pendingWithdrawals[_oldOwner] = pendingWithdrawals[_oldOwner].add(_oldOwnerPayment);\n\n        emit LoveStoryTransferred (\n            _id,\n            _oldOwner,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function readLoveStory(bytes16 _id)\n        public\n        view\n        returns (address _loveStoryOwner, bytes32 _loverName, bytes32 _lovedOneName, uint256 _transferCost, uint256 _lockedUntil, string _data)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStoryOwner = _loveStory.owner;\n        _loverName = _loveStory.loverName;\n        _lovedOneName = _loveStory.lovedOneName;\n        _transferCost = _loveStory.transferCost;\n        _lockedUntil = _loveStory.lockedUntil;\n        _data = _loveStory.data;\n    }\n\n    function isIdRegistered(bytes16 _id)\n        public\n        view\n        returns (bool)\n    {\n        return loveStories[_id].owner != 0x0;\n    }\n\n    function isIdValid(bytes16 _id)\n        public\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < 16; i = i.add(1))\n        {\n            if (i == 0)\n            {\n                // First char must be between 'a' and 'z'. It CAN'T be NULL.\n                if ( ! _isLowercaseLetter(_id[i]) )\n                {\n                    return false;\n                }\n            }\n            else if (i == 15)\n            {\n                // Last char must between 'a' and 'z'. It can also be a terminating NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || _id[i] == 0) )\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                // In-between chars must between 'a' and 'z' or '-'. Otherwise, they should be the unset bytes.\n                // The last part is verifiied by requiring that an in-bewteen char that is NULL\n                // must *also* be follwed by a NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || (_id[i] == 0x2D && _id[i+1] != 0) || (_id[i] == _id[i+1] && _id[i] == 0)) )\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function withdrawableAmount()\n        public\n        view\n        returns (uint256)\n    {\n        return pendingWithdrawals[msg.sender];\n    }\n\n    function withdraw()\n        external\n        nonReentrant\n        onlyWithPendingWithdrawal\n    {\n        uint256 amount = pendingWithdrawals[msg.sender];\n\n        pendingWithdrawals[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n\n        emit Withdrawal (\n            msg.sender,\n            amount\n        );\n    }\n\n    function withdrawableAmountFor(address _withdrawer)\n        public\n        view\n        onlyOwner\n        returns (uint256)\n    {\n        return pendingWithdrawals[_withdrawer];\n    }\n\n    function changeInitialCost(uint256 _initialCost)\n        external\n        onlyOwner\n    {\n        initialCost = _initialCost;\n    }\n\n    function changeLockCostPerHour(uint256 _lockCostPerHour)\n        external\n        onlyOwner\n    {\n        lockCostPerHour = _lockCostPerHour;\n    }\n\n    function changeMaxLockDuration(uint256 _maxLockDuration)\n        external\n        onlyOwner\n    {\n        maxLockDuration = _maxLockDuration;\n    }\n\n    // ------------------------------------------------------------\n\n    function _updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        private\n    {\n        require(_lockDurationInHours * 1 hours <= maxLockDuration);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.owner = msg.sender;\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.transferCost = msg.value.mul(2);\n        _loveStory.lockedUntil = now.add(_lockDurationInHours.mul(1 hours));\n        _loveStory.data = _data;\n    }\n\n    function _isLowercaseLetter(byte _char)\n        private\n        pure\n        returns (bool)\n    {\n        // Char must be a small case letter: [a-z]\n        return _char >= 0x61 && _char <= 0x7A;\n    }\n}", "debug": "calldata_WillAlwaysLove_4 + calldata_WillAlwaysLove_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0x0\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0x0\ncalldata_WillAlwaysLove_0: 0x6999769600000000000000000000000000000000000000000000000000000000\ncalldatasize_WillAlwaysLove: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateLoveStoryWithData(bytes16,bytes32,bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0xe9827370ae7c0aa97e87b6dbe56e0bd735a552f1.sol", "function": "updateLoveStoryWithData(bytes16,bytes32,bytes32,string)", "lineno": 142, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9819, "code": "----------------\n\n    uint256 public constant DEFAULT_INITIAL_COST = 0.025 ether;\n    uint256 public constant DEFAULT_LOCK_COST_PER_HOUR = 0.0006 ether; // 10 szabo per minute\n    uint256 public constant DEFAULT_MAX_LOCK_DURATION = 1 weeks;\n\n    uint256 public constant DEVELOPER_CUT = 25; // %\n\n    // ------------------------------------------------------------\n\n    struct LoveStory {\n        address owner;\n        bytes32 loverName;\n        bytes32 lovedOneName;\n        uint256 transferCost;\n        uint256 lockedUntil;\n        string data;\n    }\n\n    // ------------------------------------------------------------\n\n    uint256 public initialCost;\n    uint256 public lockCostPerHour;\n    uint256 public maxLockDuration;\n\n    mapping(bytes16 => LoveStory) private loveStories;\n    uint256 public loveStoriesCount;\n\n    mapping (address => uint256) private pendingWithdrawals;\n\n    // ------------------------------------------------------------\n\n    event LoveStoryCreated(\n        bytes16 id,\n        address owner,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        uint256 transferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event LoveStoryUpdated(\n        bytes16 id,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        string data\n    );\n\n    event LoveStoryTransferred(\n        bytes16 id,\n        address oldOwner,\n        address newOwner,\n        bytes32 newLoverName,\n        bytes32 newLovedOneName,\n        uint256 newtransferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event Withdrawal(\n        address withdrawer,\n        uint256 amount\n    );\n\n    // ------------------------------------------------------------\n\n    modifier onlyForUnregisteredId(bytes16 _id) {\n        require(!isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForRegisteredId(bytes16 _id) {\n        require(isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForValidId(bytes16 _id) {\n        require(isIdValid(_id));\n        _;\n    }\n\n    modifier onlyWithPendingWithdrawal() {\n        require(withdrawableAmount() != 0);\n        _;\n    }\n\n    modifier onlyLoveStoryOwner(bytes16 _id) {\n        require(loveStories[_id].owner == msg.sender);\n        _;\n    }\n\n    // ------------------------------------------------------------\n\n    constructor ()\n        public\n    {\n        initialCost = DEFAULT_INITIAL_COST;\n        lockCostPerHour = DEFAULT_LOCK_COST_PER_HOUR;\n        maxLockDuration = DEFAULT_MAX_LOCK_DURATION;\n    }\n\n    function ()\n        public\n        payable\n    {\n    }\n\n    function createCost(uint256 _lockDurationInHours)\n        public\n        view\n        returns (uint256)\n    {\n        return initialCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function createLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n    {\n        createLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, \"\");\n    }\n\n    function createLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForUnregisteredId(_id)\n    {\n        require(msg.value >= createCost(_lockDurationInHours));\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n        loveStoriesCount = loveStoriesCount.add(1);\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(msg.value);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        emit LoveStoryCreated (\n            _id,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, string _data)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.data = _data;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function transferCost(bytes16 _id, uint256 _lockDurationInHours)\n        public\n        view\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n        returns (uint256)\n    {\n        return loveStories[_id].transferCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function transferLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        transferLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, _loveStory.data);\n    }\n\n    function transferLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        address _oldOwner = _loveStory.owner;\n\n        require(_oldOwner != msg.sender);\n        require(msg.value >= transferCost(_id, _lockDurationInHours));\n        require(now >= _loveStory.lockedUntil);\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n\n        uint256 _developerPayment = msg.value.mul(DEVELOPER_CUT).div(100);\n        uint256 _oldOwnerPayment = msg.value.sub(_developerPayment);\n\n        require(msg.value == _developerPayment.add(_oldOwnerPayment));\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(_developerPayment);\n        pendingWithdrawals[_oldOwner] = pendingWithdrawals[_oldOwner].add(_oldOwnerPayment);\n\n        emit LoveStoryTransferred (\n            _id,\n            _oldOwner,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function readLoveStory(bytes16 _id)\n        public\n        view\n        returns (address _loveStoryOwner, bytes32 _loverName, bytes32 _lovedOneName, uint256 _transferCost, uint256 _lockedUntil, string _data)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStoryOwner = _loveStory.owner;\n        _loverName = _loveStory.loverName;\n        _lovedOneName = _loveStory.lovedOneName;\n        _transferCost = _loveStory.transferCost;\n        _lockedUntil = _loveStory.lockedUntil;\n        _data = _loveStory.data;\n    }\n\n    function isIdRegistered(bytes16 _id)\n        public\n        view\n        returns (bool)\n    {\n        return loveStories[_id].owner != 0x0;\n    }\n\n    function isIdValid(bytes16 _id)\n        public\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < 16; i = i.add(1))\n        {\n            if (i == 0)\n            {\n                // First char must be between 'a' and 'z'. It CAN'T be NULL.\n                if ( ! _isLowercaseLetter(_id[i]) )\n                {\n                    return false;\n                }\n            }\n            else if (i == 15)\n            {\n                // Last char must between 'a' and 'z'. It can also be a terminating NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || _id[i] == 0) )\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                // In-between chars must between 'a' and 'z' or '-'. Otherwise, they should be the unset bytes.\n                // The last part is verifiied by requiring that an in-bewteen char that is NULL\n                // must *also* be follwed by a NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || (_id[i] == 0x2D && _id[i+1] != 0) || (_id[i] == _id[i+1] && _id[i] == 0)) )\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function withdrawableAmount()\n        public\n        view\n        returns (uint256)\n    {\n        return pendingWithdrawals[msg.sender];\n    }\n\n    function withdraw()\n        external\n        nonReentrant\n        onlyWithPendingWithdrawal\n    {\n        uint256 amount = pendingWithdrawals[msg.sender];\n\n        pendingWithdrawals[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n\n        emit Withdrawal (\n            msg.sender,\n            amount\n        );\n    }\n\n    function withdrawableAmountFor(address _withdrawer)\n        public\n        view\n        onlyOwner\n        returns (uint256)\n    {\n        return pendingWithdrawals[_withdrawer];\n    }\n\n    function changeInitialCost(uint256 _initialCost)\n        external\n        onlyOwner\n    {\n        initialCost = _initialCost;\n    }\n\n    function changeLockCostPerHour(uint256 _lockCostPerHour)\n        external\n        onlyOwner\n    {\n        lockCostPerHour = _lockCostPerHour;\n    }\n\n    function changeMaxLockDuration(uint256 _maxLockDuration)\n        external\n        onlyOwner\n    {\n        maxLockDuration = _maxLockDuration;\n    }\n\n    // ------------------------------------------------------------\n\n    function _updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        private\n    {\n        require(_lockDurationInHours * 1 hours <= maxLockDuration);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.owner = msg.sender;\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.transferCost = msg.value.mul(2);\n        _loveStory.lockedUntil = now.add(_lockDurationInHours.mul(1 hours));\n        _loveStory.data = _data;\n    }\n\n    function _isLowercaseLetter(byte _char)\n        private\n        pure\n        returns (bool)\n    {\n        // Char must be a small case letter: [a-z]\n        return _char >= 0x61 && _char <= 0x7A;\n    }\n}", "debug": "calldata_WillAlwaysLove_4 + calldata_WillAlwaysLove_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0x0\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0x0\ncalldata_WillAlwaysLove_0: 0x6999769600000000000000000000000000000000000000000000000000000000\ncalldatasize_WillAlwaysLove: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateLoveStoryWithData(bytes16,bytes32,bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0xe9827370ae7c0aa97e87b6dbe56e0bd735a552f1.sol", "function": "updateLoveStoryWithData(bytes16,bytes32,bytes32,string)", "lineno": 142, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9841, "code": "----------------\n\n    uint256 public constant DEFAULT_INITIAL_COST = 0.025 ether;\n    uint256 public constant DEFAULT_LOCK_COST_PER_HOUR = 0.0006 ether; // 10 szabo per minute\n    uint256 public constant DEFAULT_MAX_LOCK_DURATION = 1 weeks;\n\n    uint256 public constant DEVELOPER_CUT = 25; // %\n\n    // ------------------------------------------------------------\n\n    struct LoveStory {\n        address owner;\n        bytes32 loverName;\n        bytes32 lovedOneName;\n        uint256 transferCost;\n        uint256 lockedUntil;\n        string data;\n    }\n\n    // ------------------------------------------------------------\n\n    uint256 public initialCost;\n    uint256 public lockCostPerHour;\n    uint256 public maxLockDuration;\n\n    mapping(bytes16 => LoveStory) private loveStories;\n    uint256 public loveStoriesCount;\n\n    mapping (address => uint256) private pendingWithdrawals;\n\n    // ------------------------------------------------------------\n\n    event LoveStoryCreated(\n        bytes16 id,\n        address owner,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        uint256 transferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event LoveStoryUpdated(\n        bytes16 id,\n        bytes32 loverName,\n        bytes32 lovedOneName,\n        string data\n    );\n\n    event LoveStoryTransferred(\n        bytes16 id,\n        address oldOwner,\n        address newOwner,\n        bytes32 newLoverName,\n        bytes32 newLovedOneName,\n        uint256 newtransferCost,\n        uint256 lockedUntil,\n        string data\n    );\n\n    event Withdrawal(\n        address withdrawer,\n        uint256 amount\n    );\n\n    // ------------------------------------------------------------\n\n    modifier onlyForUnregisteredId(bytes16 _id) {\n        require(!isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForRegisteredId(bytes16 _id) {\n        require(isIdRegistered(_id));\n        _;\n    }\n\n    modifier onlyForValidId(bytes16 _id) {\n        require(isIdValid(_id));\n        _;\n    }\n\n    modifier onlyWithPendingWithdrawal() {\n        require(withdrawableAmount() != 0);\n        _;\n    }\n\n    modifier onlyLoveStoryOwner(bytes16 _id) {\n        require(loveStories[_id].owner == msg.sender);\n        _;\n    }\n\n    // ------------------------------------------------------------\n\n    constructor ()\n        public\n    {\n        initialCost = DEFAULT_INITIAL_COST;\n        lockCostPerHour = DEFAULT_LOCK_COST_PER_HOUR;\n        maxLockDuration = DEFAULT_MAX_LOCK_DURATION;\n    }\n\n    function ()\n        public\n        payable\n    {\n    }\n\n    function createCost(uint256 _lockDurationInHours)\n        public\n        view\n        returns (uint256)\n    {\n        return initialCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function createLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n    {\n        createLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, \"\");\n    }\n\n    function createLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForUnregisteredId(_id)\n    {\n        require(msg.value >= createCost(_lockDurationInHours));\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n        loveStoriesCount = loveStoriesCount.add(1);\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(msg.value);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        emit LoveStoryCreated (\n            _id,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function updateLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, string _data)\n        public\n        onlyLoveStoryOwner(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.data = _data;\n\n        emit LoveStoryUpdated (\n            _id,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.data\n        );\n    }\n\n    function transferCost(bytes16 _id, uint256 _lockDurationInHours)\n        public\n        view\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n        returns (uint256)\n    {\n        return loveStories[_id].transferCost.add(lockCostPerHour.mul(_lockDurationInHours));\n    }\n\n    function transferLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        transferLoveStoryWithData(_id, _loverName, _lovedOneName, _lockDurationInHours, _loveStory.data);\n    }\n\n    function transferLoveStoryWithData(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        public\n        payable\n        onlyForValidId(_id)\n        onlyForRegisteredId(_id)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n        address _oldOwner = _loveStory.owner;\n\n        require(_oldOwner != msg.sender);\n        require(msg.value >= transferCost(_id, _lockDurationInHours));\n        require(now >= _loveStory.lockedUntil);\n\n        _updateLoveStory(_id, _loverName, _lovedOneName, _lockDurationInHours, _data);\n\n        uint256 _developerPayment = msg.value.mul(DEVELOPER_CUT).div(100);\n        uint256 _oldOwnerPayment = msg.value.sub(_developerPayment);\n\n        require(msg.value == _developerPayment.add(_oldOwnerPayment));\n\n        pendingWithdrawals[owner] = pendingWithdrawals[owner].add(_developerPayment);\n        pendingWithdrawals[_oldOwner] = pendingWithdrawals[_oldOwner].add(_oldOwnerPayment);\n\n        emit LoveStoryTransferred (\n            _id,\n            _oldOwner,\n            _loveStory.owner,\n            _loveStory.loverName,\n            _loveStory.lovedOneName,\n            _loveStory.transferCost,\n            _loveStory.lockedUntil,\n            _loveStory.data\n        );\n    }\n\n    function readLoveStory(bytes16 _id)\n        public\n        view\n        returns (address _loveStoryOwner, bytes32 _loverName, bytes32 _lovedOneName, uint256 _transferCost, uint256 _lockedUntil, string _data)\n    {\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStoryOwner = _loveStory.owner;\n        _loverName = _loveStory.loverName;\n        _lovedOneName = _loveStory.lovedOneName;\n        _transferCost = _loveStory.transferCost;\n        _lockedUntil = _loveStory.lockedUntil;\n        _data = _loveStory.data;\n    }\n\n    function isIdRegistered(bytes16 _id)\n        public\n        view\n        returns (bool)\n    {\n        return loveStories[_id].owner != 0x0;\n    }\n\n    function isIdValid(bytes16 _id)\n        public\n        pure\n        returns (bool)\n    {\n        for (uint256 i = 0; i < 16; i = i.add(1))\n        {\n            if (i == 0)\n            {\n                // First char must be between 'a' and 'z'. It CAN'T be NULL.\n                if ( ! _isLowercaseLetter(_id[i]) )\n                {\n                    return false;\n                }\n            }\n            else if (i == 15)\n            {\n                // Last char must between 'a' and 'z'. It can also be a terminating NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || _id[i] == 0) )\n                {\n                    return false;\n                }\n            }\n            else\n            {\n                // In-between chars must between 'a' and 'z' or '-'. Otherwise, they should be the unset bytes.\n                // The last part is verifiied by requiring that an in-bewteen char that is NULL\n                // must *also* be follwed by a NULL.\n                if ( !(_isLowercaseLetter(_id[i]) || (_id[i] == 0x2D && _id[i+1] != 0) || (_id[i] == _id[i+1] && _id[i] == 0)) )\n                {\n                    return false;\n                }\n            }\n        }\n\n        return true;\n    }\n\n    function withdrawableAmount()\n        public\n        view\n        returns (uint256)\n    {\n        return pendingWithdrawals[msg.sender];\n    }\n\n    function withdraw()\n        external\n        nonReentrant\n        onlyWithPendingWithdrawal\n    {\n        uint256 amount = pendingWithdrawals[msg.sender];\n\n        pendingWithdrawals[msg.sender] = 0;\n\n        msg.sender.transfer(amount);\n\n        emit Withdrawal (\n            msg.sender,\n            amount\n        );\n    }\n\n    function withdrawableAmountFor(address _withdrawer)\n        public\n        view\n        onlyOwner\n        returns (uint256)\n    {\n        return pendingWithdrawals[_withdrawer];\n    }\n\n    function changeInitialCost(uint256 _initialCost)\n        external\n        onlyOwner\n    {\n        initialCost = _initialCost;\n    }\n\n    function changeLockCostPerHour(uint256 _lockCostPerHour)\n        external\n        onlyOwner\n    {\n        lockCostPerHour = _lockCostPerHour;\n    }\n\n    function changeMaxLockDuration(uint256 _maxLockDuration)\n        external\n        onlyOwner\n    {\n        maxLockDuration = _maxLockDuration;\n    }\n\n    // ------------------------------------------------------------\n\n    function _updateLoveStory(bytes16 _id, bytes32 _loverName, bytes32 _lovedOneName, uint256 _lockDurationInHours, string _data)\n        private\n    {\n        require(_lockDurationInHours * 1 hours <= maxLockDuration);\n\n        LoveStory storage _loveStory = loveStories[_id];\n\n        _loveStory.owner = msg.sender;\n        _loveStory.loverName = _loverName;\n        _loveStory.lovedOneName = _lovedOneName;\n        _loveStory.transferCost = msg.value.mul(2);\n        _loveStory.lockedUntil = now.add(_lockDurationInHours.mul(1 hours));\n        _loveStory.data = _data;\n    }\n\n    function _isLowercaseLetter(byte _char)\n        private\n        pure\n        returns (bool)\n    {\n        // Char must be a small case letter: [a-z]\n        return _char >= 0x61 && _char <= 0x7A;\n    }\n}", "debug": "calldata_WillAlwaysLove_4 + calldata_WillAlwaysLove_32 + 68: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_5_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n340282366920938463463374607431768211455_&\ncalldata_WillAlwaysLove_4: 0x0\ncalldata_WillAlwaysLove_0: 0x6999769600000000000000000000000000000000000000000000000000000000\ncalldatasize_WillAlwaysLove: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateLoveStoryWithData(bytes16,bytes32,bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0xe9827370ae7c0aa97e87b6dbe56e0bd735a552f1.sol", "function": "updateLoveStoryWithData(bytes16,bytes32,bytes32,string)", "lineno": 142, "title": "Integer Overflow ", "type": "Warning"}], "success": true}