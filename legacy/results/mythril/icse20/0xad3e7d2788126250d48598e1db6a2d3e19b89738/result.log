{"error": null, "issues": [{"address": 1534, "code": "[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tartworksFactory[_contract] = msg.sender;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContra", "debug": "calldata_Registrar_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x21cb1568", "lineno": 299, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6095, "code": "\n\t\t\tInterface c = Interface(_contract);\n\t\t", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x02581ab3", "lineno": 431, "title": "Message call to external contract", "type": "Warning"}, {"address": 6281, "code": "onSupply += msg.value * ", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_Registrar_32 + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x2917f4a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x02917f4a`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x02917f4a", "lineno": 293, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6296, "code": "onMultiplier;\n\t\t}\n\n\tfunction ", "debug": "storage_0: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_Registrar_32 + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x2917f4a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x02917f4a`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x02917f4a", "lineno": 293, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7002, "code": "\t\tc.approve(_spender, _a", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x0ff244b2", "lineno": 367, "title": "Message call to external contract", "type": "Warning"}, {"address": 7330, "code": ";\n\t\t\tc.approveIndexed(_spender", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x14a3b19a", "lineno": 372, "title": "Message call to external contract", "type": "Warning"}, {"address": 9989, "code": "er] -= _amount;\n\t\t\t\t\tba", "debug": "calldata_Registrar_32 + 36: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_32_+_4: 0x800000000000000000008eb2e34648ee0801030820000000000000000000a000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\ncalldata_Registrar_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "transferFrom(address,address,uint256)", "lineno": 163, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10738, "code": "n offerPieceForSaleByAddres", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x23c1236a", "lineno": 400, "title": "Message call to external contract", "type": "Warning"}, {"address": 11162, "code": "e registrar\n\t\t", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x3d6e87c1", "lineno": 424, "title": "Message call to external contract", "type": "Warning"}, {"address": 11347, "code": "alances[_from] >= _value && a", "debug": "calldata_Registrar_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Registrar_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `burn(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "burn(uint256)", "lineno": 197, "title": "Integer Underflow", "type": "Warning"}, {"address": 17817, "code": ";\n\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\n \t// Owner of account approves the transfer of an amount of Patron tokens to another account\n \tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n    function totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorized the sender of the message via some mechanism; we propose\n \t// these standardized APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// Ethart variables\n    mapping (bytes32 => address) public SHA256HashRegister;\t\t// Register of all SHA256 Hashes\n\tmapping (address => bool) public approvedFactories;\t\t\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedContracts;\t\t\t// Register of all approved artwork contracts\n\tmapping (address => address) public referred;\t\t\t\t// Register of all referrers (referree => referrer) used for the affiliate program\n\tmapping (address => bool) public cantSetReferrer;\t\t\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\t\t// Register of all artworks and their details\n\n\t// An indexed register of all of an artist's artworks\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\t// Enter artist address and a running number to get the artist's artwork addresses.\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t// A running number counting an artist's artworks\n\tmapping(address => address) public artworksFactory;\t\t\t\t\t\t\t// Maps all artworks to their respective factory contracts\n\n\tuint256 artworkCount;\t\t\t\t\t\t\t\t\t\t// Keeps track of the number of artwork contracts in the network\n\t\n\tmapping (uint256 => address) public artworkIndex;\t\t\t// An index of all the artwork contracts in the network\n\n\taddress public owner;\t\t\t\t\t\t\t\t\t\t// The address of the contract owner\n\t\n\tuint256 public donationMultiplier;\n\n    // Functions with this modifier can only be executed by a specific address\n    modifier onlyBy (address _account)\n    {\n        require(msg.sender == _account);\n        _;\n    }\n\n    // Functions with this modifier can only be executed by approved factory contracts\n    modifier registerdFactoriesOnly ()\n    {\n        require(approvedFactories[msg.sender]);\n        _;\n    }\n\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender])\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\tdonationMultiplier = 100;\n\t}\n\n\t// allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount;\n\t\t\t_totalPatronSupply += _amount;\n\t\t}\n\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registerdFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tartworksFactory[_contract] = msg.sender;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\n\tfunction isFactoryApproved (address _factory) returns (bool _approved)\n\t\t{\n\t\t\tif (approvedFactories[_factory])\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {return false;}\n\t\t}\n\n\tfunction withdrawFunds (uint256 _ETHAmount, address _to) onlyBy (owner)\n\t\t{\n\t\t\tif (this.balance >= _ETHAmount)\n\t\t\t{\n\t\t\t\t_to.transfer(_ETHAmount);\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Fill a bid with an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\t\t\t// Sell an indexed piece owned by the registrar.\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\t\t\t\t// Fill a bid with an indexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\t\t\t\t\t\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\t\t}\n\n\t// Semi uinversal call function for unforseen future Ethart network contract types and use cases. String format: \"<functionName>(address,address,uint256,uint256,bool,string,bytes32)\"\n\tfunction callContractFunctionByAddress(address _contract, string functionNameAndTypes, address _address1, address _address2, uint256 _value1, uint256 _value2, bool _bool, string _string, bytes32 _bytes32) onlyBy (owner)\n\t{\n\t\tif(!_contract.call(bytes4(sha3(functionNameAndTypes)),_address1, _address2, _value1, _value2, _bool, _string, _bytes32)) {throw;}\n\t}\n}", "debug": "keccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x21cb1568", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}, {"address": 17846, "code": ";\n\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\n \t// Owner of account approves the transfer of an amount of Patron tokens to another account\n \tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n    function totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorized the sender of the message via some mechanism; we propose\n \t// these standardized APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// Ethart variables\n    mapping (bytes32 => address) public SHA256HashRegister;\t\t// Register of all SHA256 Hashes\n\tmapping (address => bool) public approvedFactories;\t\t\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedContracts;\t\t\t// Register of all approved artwork contracts\n\tmapping (address => address) public referred;\t\t\t\t// Register of all referrers (referree => referrer) used for the affiliate program\n\tmapping (address => bool) public cantSetReferrer;\t\t\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\t\t// Register of all artworks and their details\n\n\t// An indexed register of all of an artist's artworks\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\t// Enter artist address and a running number to get the artist's artwork addresses.\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t// A running number counting an artist's artworks\n\tmapping(address => address) public artworksFactory;\t\t\t\t\t\t\t// Maps all artworks to their respective factory contracts\n\n\tuint256 artworkCount;\t\t\t\t\t\t\t\t\t\t// Keeps track of the number of artwork contracts in the network\n\t\n\tmapping (uint256 => address) public artworkIndex;\t\t\t// An index of all the artwork contracts in the network\n\n\taddress public owner;\t\t\t\t\t\t\t\t\t\t// The address of the contract owner\n\t\n\tuint256 public donationMultiplier;\n\n    // Functions with this modifier can only be executed by a specific address\n    modifier onlyBy (address _account)\n    {\n        require(msg.sender == _account);\n        _;\n    }\n\n    // Functions with this modifier can only be executed by approved factory contracts\n    modifier registerdFactoriesOnly ()\n    {\n        require(approvedFactories[msg.sender]);\n        _;\n    }\n\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender])\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\tdonationMultiplier = 100;\n\t}\n\n\t// allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount;\n\t\t\t_totalPatronSupply += _amount;\n\t\t}\n\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registerdFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tartworksFactory[_contract] = msg.sender;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\n\tfunction isFactoryApproved (address _factory) returns (bool _approved)\n\t\t{\n\t\t\tif (approvedFactories[_factory])\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {return false;}\n\t\t}\n\n\tfunction withdrawFunds (uint256 _ETHAmount, address _to) onlyBy (owner)\n\t\t{\n\t\t\tif (this.balance >= _ETHAmount)\n\t\t\t{\n\t\t\t\t_to.transfer(_ETHAmount);\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Fill a bid with an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\t\t\t// Sell an indexed piece owned by the registrar.\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\t\t\t\t// Fill a bid with an indexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\t\t\t\t\t\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\t\t}\n\n\t// Semi uinversal call function for unforseen future Ethart network contract types and use cases. String format: \"<functionName>(address,address,uint256,uint256,bool,string,bytes32)\"\n\tfunction callContractFunctionByAddress(address _contract, string functionNameAndTypes, address _address1, address _address2, uint256 _value1, uint256 _value2, bool _bool, string _string, bytes32 _bytes32) onlyBy (owner)\n\t{\n\t\tif(!_contract.call(bytes4(sha3(functionNameAndTypes)),_address1, _address2, _value1, _value2, _bool, _string, _bytes32)) {throw;}\n\t}\n}", "debug": "calldata_Registrar_4 + calldata_Registrar_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x21cb1568", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}, {"address": 17860, "code": ";\n\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\n \t// Owner of account approves the transfer of an amount of Patron tokens to another account\n \tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n    function totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorized the sender of the message via some mechanism; we propose\n \t// these standardized APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// Ethart variables\n    mapping (bytes32 => address) public SHA256HashRegister;\t\t// Register of all SHA256 Hashes\n\tmapping (address => bool) public approvedFactories;\t\t\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedContracts;\t\t\t// Register of all approved artwork contracts\n\tmapping (address => address) public referred;\t\t\t\t// Register of all referrers (referree => referrer) used for the affiliate program\n\tmapping (address => bool) public cantSetReferrer;\t\t\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\t\t// Register of all artworks and their details\n\n\t// An indexed register of all of an artist's artworks\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\t// Enter artist address and a running number to get the artist's artwork addresses.\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t// A running number counting an artist's artworks\n\tmapping(address => address) public artworksFactory;\t\t\t\t\t\t\t// Maps all artworks to their respective factory contracts\n\n\tuint256 artworkCount;\t\t\t\t\t\t\t\t\t\t// Keeps track of the number of artwork contracts in the network\n\t\n\tmapping (uint256 => address) public artworkIndex;\t\t\t// An index of all the artwork contracts in the network\n\n\taddress public owner;\t\t\t\t\t\t\t\t\t\t// The address of the contract owner\n\t\n\tuint256 public donationMultiplier;\n\n    // Functions with this modifier can only be executed by a specific address\n    modifier onlyBy (address _account)\n    {\n        require(msg.sender == _account);\n        _;\n    }\n\n    // Functions with this modifier can only be executed by approved factory contracts\n    modifier registerdFactoriesOnly ()\n    {\n        require(approvedFactories[msg.sender]);\n        _;\n    }\n\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender])\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\tdonationMultiplier = 100;\n\t}\n\n\t// allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount;\n\t\t\t_totalPatronSupply += _amount;\n\t\t}\n\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registerdFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tartworksFactory[_contract] = msg.sender;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\n\tfunction isFactoryApproved (address _factory) returns (bool _approved)\n\t\t{\n\t\t\tif (approvedFactories[_factory])\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {return false;}\n\t\t}\n\n\tfunction withdrawFunds (uint256 _ETHAmount, address _to) onlyBy (owner)\n\t\t{\n\t\t\tif (this.balance >= _ETHAmount)\n\t\t\t{\n\t\t\t\t_to.transfer(_ETHAmount);\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Fill a bid with an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\t\t\t// Sell an indexed piece owned by the registrar.\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\t\t\t\t// Fill a bid with an indexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\t\t\t\t\t\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\t\t}\n\n\t// Semi uinversal call function for unforseen future Ethart network contract types and use cases. String format: \"<functionName>(address,address,uint256,uint256,bool,string,bytes32)\"\n\tfunction callContractFunctionByAddress(address _contract, string functionNameAndTypes, address _address1, address _address2, uint256 _value1, uint256 _value2, bool _bool, string _string, bytes32 _bytes32) onlyBy (owner)\n\t{\n\t\tif(!_contract.call(bytes4(sha3(functionNameAndTypes)),_address1, _address2, _value1, _value2, _bool, _string, _bytes32)) {throw;}\n\t}\n}", "debug": "calldata_Registrar_4 + calldata_Registrar_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x21cb1568", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}, {"address": 17882, "code": ";\n\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\n \t// Owner of account approves the transfer of an amount of Patron tokens to another account\n \tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n    function totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorized the sender of the message via some mechanism; we propose\n \t// these standardized APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// Ethart variables\n    mapping (bytes32 => address) public SHA256HashRegister;\t\t// Register of all SHA256 Hashes\n\tmapping (address => bool) public approvedFactories;\t\t\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedContracts;\t\t\t// Register of all approved artwork contracts\n\tmapping (address => address) public referred;\t\t\t\t// Register of all referrers (referree => referrer) used for the affiliate program\n\tmapping (address => bool) public cantSetReferrer;\t\t\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\t\t// Register of all artworks and their details\n\n\t// An indexed register of all of an artist's artworks\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\t// Enter artist address and a running number to get the artist's artwork addresses.\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t// A running number counting an artist's artworks\n\tmapping(address => address) public artworksFactory;\t\t\t\t\t\t\t// Maps all artworks to their respective factory contracts\n\n\tuint256 artworkCount;\t\t\t\t\t\t\t\t\t\t// Keeps track of the number of artwork contracts in the network\n\t\n\tmapping (uint256 => address) public artworkIndex;\t\t\t// An index of all the artwork contracts in the network\n\n\taddress public owner;\t\t\t\t\t\t\t\t\t\t// The address of the contract owner\n\t\n\tuint256 public donationMultiplier;\n\n    // Functions with this modifier can only be executed by a specific address\n    modifier onlyBy (address _account)\n    {\n        require(msg.sender == _account);\n        _;\n    }\n\n    // Functions with this modifier can only be executed by approved factory contracts\n    modifier registerdFactoriesOnly ()\n    {\n        require(approvedFactories[msg.sender]);\n        _;\n    }\n\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender])\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\tdonationMultiplier = 100;\n\t}\n\n\t// allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount;\n\t\t\t_totalPatronSupply += _amount;\n\t\t}\n\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registerdFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tartworksFactory[_contract] = msg.sender;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\n\tfunction isFactoryApproved (address _factory) returns (bool _approved)\n\t\t{\n\t\t\tif (approvedFactories[_factory])\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {return false;}\n\t\t}\n\n\tfunction withdrawFunds (uint256 _ETHAmount, address _to) onlyBy (owner)\n\t\t{\n\t\t\tif (this.balance >= _ETHAmount)\n\t\t\t{\n\t\t\t\t_to.transfer(_ETHAmount);\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Fill a bid with an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\t\t\t// Sell an indexed piece owned by the registrar.\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\t\t\t\t// Fill a bid with an indexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\t\t\t\t\t\t\t\t// Cancel the sale of an unindexed piece owned by the registrar\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\t\t\t\t\t\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\t\t}\n\n\t// Semi uinversal call function for unforseen future Ethart network contract types and use cases. String format: \"<functionName>(address,address,uint256,uint256,bool,string,bytes32)\"\n\tfunction callContractFunctionByAddress(address _contract, string functionNameAndTypes, address _address1, address _address2, uint256 _value1, uint256 _value2, bool _bool, string _string, bytes32 _bytes32) onlyBy (owner)\n\t{\n\t\tif(!_contract.call(bytes4(sha3(functionNameAndTypes)),_address1, _address2, _value1, _value2, _bool, _string, _bytes32)) {throw;}\n\t}\n}", "debug": "keccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Registrar_4 + calldata_Registrar_32 + 68: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/42/0xad3e7d2788126250d48598e1db6a2d3e19b89738.sol", "function": "_function_0x21cb1568", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}], "success": true}