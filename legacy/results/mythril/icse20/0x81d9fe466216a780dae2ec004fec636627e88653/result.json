{
  "contract": "0x81d9fe466216a780dae2ec004fec636627e88653",
  "tool": "mythril",
  "start": 1563604060.0495908,
  "end": 1563604189.8621273,
  "duration": 129.8125364780426,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 248,
        "code": "ticipants < participants) throw;\n        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;\n\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        withdraw.sender = msg.sender;\n        withdraw.Ix = _Ix;\n        withdraw.Iy = _Iy;\n        withdraw.signature = _signature;\n\n        withdraw.ring1.length = 0;\n        withdraw.ring2.length = 0;\n        withdraw.ring1.push(_x0);\n        withdraw.ring2.push(uint(sha3(_x0)));\n        \n        withdraw.step = 1;\n        withdraw.prevStep = 0;\n    }\n\n    function withdrawStep() {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        //throw",
        "debug": "calldata_Laundromat_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Laundromat_0: 0x1a6c9c0d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x1a6c9c0d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x1a6c9c0d",
        "lineno": 93,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1174,
        "code": "age);\n\n    //create ne",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Laundromat_4: 0x0\nstorage_8: 0x0\ncalldata_Laundromat_0: 0x1a7fae4700000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x1a7fae47",
        "lineno": 58,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1215,
        "code": "   event LogDebug(stri",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Laundromat_4: 0x0\nstorage_7: 0x0\ncalldata_Laundromat_0: 0x444e8b4300000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x444e8b43",
        "lineno": 58,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1635,
        "code": "w.step % participants],\n            pubkeys2[withdra",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_4: 0xebc400002009000704071e82637020158200001006c2038800000000004303c2\nstorage_6 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x2a440000080800010001448031102010010000100400000000000000004303c3\nstorage_7 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0xfbf5a00020090006d400190255701c15717c000c0040e30700000000003f03c1\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x10319fffffffffffcff8fa7ff1fffbffef7bfffbf97edf7efffffffffffbffff\nstorage_keccac_UDiv(keccac_storage_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller,\n_____1): 0x0\ncalldata_Laundromat_0: 0x990e1c9b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "withdrawStep()",
        "lineno": 132,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1753,
        "code": "Contract.jmul(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "withdrawStep()",
        "lineno": 131,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4901,
        "code": ".ring2[0]) {\n    ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_UDiv(keccac_storage_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller,\n_____1): 0x0\ncalldata_Laundromat_0: 0x9ebb125000000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x0\nstorage_4: 0x0\nstorage_6 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x1\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "withdrawFinal()",
        "lineno": 168,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4931,
        "code": ".ring2[participants] != with",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_UDiv(keccac_storage_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller,\n_____1): 0x0\ncalldata_Laundromat_0: 0x9ebb125000000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\nstorage_6 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "withdrawFinal()",
        "lineno": 168,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5080,
        "code": "sha3([withdraw.Ix",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_UDiv(keccac_storage_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller,\n_____1): 0x0\ncalldata_Laundromat_0: 0x9ebb125000000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\nstorage_5 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x0\nstorage_keccac_4_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller +\n0: 0x0\nstorage_keccac_4_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller +\nstorage_4: 0x0\nstorage_6 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "withdrawFinal()",
        "lineno": 175,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5484,
        "code": "xeb5fa6cbf2aca03a0",
        "debug": "storage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6: 0x0\nstorage_4: 0x1\ncalldata_Laundromat_0: 0xe2bbb15800000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\n",
        "description": "A possible integer overflow exists in the function `deposit(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "deposit(uint256,uint256)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5528,
        "code": "xeb5fa6cbf2aca03a0",
        "debug": "storage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6: 0x0\nstorage_4: 0x1\ncalldata_Laundromat_0: 0xe2bbb15800000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\n",
        "description": "A possible integer overflow exists in the function `deposit(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "deposit(uint256,uint256)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5770,
        "code": "    struct WithdrawInfo {\n\n        address sender;\n        uint Ix;\n        uint Iy;\n        uint[] signature;\n        uint[] ring1;\n        uint[] ring2;\n        \n        uint step;\n        uint prevStep;\n    }\n\n    uint constant internal safeGas = 25000;\n    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;\n    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;\n    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;\n\n    address private owner;\n    bool private atomicLock;\n    \n    address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6;\n    ArithLib private arithContract;\n    mapping (uint => WithdrawInfo) private withdraws;\n    mapping (uint => bool) private consumed;\n\n    uint public participants = 0;\n    uint public payment = 0;\n    uint public gotParticipants = 0;\n    uint[] public pubkeys1;\n    uint[] public pubkeys2;\n\n    event LogDebug(string message);\n\n    //create new mixing contract with _participants amount of mixing participants,\n    //_payment - expected payment from each participant.\n    function Laundromat(uint _participants, uint _payment) {\n        owner = msg.sender;\n        arithContract = ArithLib(arithAddress);\n\n        participants = _participants;\n        payment = _payment;\n    }\n    \n    function safeSend(address addr, uint value) internal {\n\n        if(atomicLock) throw;\n        atomicLock = true;\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            atomicLock = false;\n            throw;\n        }\n        atomicLock = false;\n    }\n\n    //add new participant to the mixing\n    function deposit(uint _pubkey1, uint _pubkey2) payable {\n        //if(msg.value != payment) throw;\n        if(gotParticipants >= participants) throw;\n\n        pubkeys1.push(_pubkey1);\n        pubkeys2.push(_pubkey2);\n        gotParticipants++;\n    }\n\n    //get funds from the mixer. Requires valid signature.\n    function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) {\n        if(gotParticipants < participants) throw;\n        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;\n\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        withdraw.sender = msg.sender;\n        withdraw.Ix = _Ix;\n        withdraw.Iy = _Iy;\n        withdraw.signature = _signature;\n\n        withdraw.ring1.length = 0;\n        withdraw.ring2.length = 0;\n        withdraw.ring1.push(_x0);\n        withdraw.ring2.push(uint(sha3(_x0)));\n        \n        withdraw.step = 1;\n        withdraw.prevStep = 0;\n    }\n\n    function withdrawStep() {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        //throw if existing witdhraw not started\n        if(withdraw.step < 1) throw;\n        if(withdraw.step > participants) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n\n        uint k1x;\n        uint k1y;\n        uint k1z;\n        uint k2x;\n        uint k2y;\n        uint k2z;\n        uint pub1x;\n        uint pub1y;\n        \n        (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        (k2x, k2y, k2z) = arithContract.jmul(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants], 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub1\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        //k3\n        (k1x, k1y) = arithContract.hash_pubkey_to_pubkey(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants]);\n        //k4 = ecmul(k3, s[prev_i])\n        (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        //k5 = ecmul(I, e[prev_i].right)\n        (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub2\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        //pub2x, pub2y\n        (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])));\n        withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])))));\n        withdraw.step++;\n        withdraw.prevStep++;\n    }\n    \n    function withdrawFinal() returns (bool) {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n        \n        if(withdraw.step != (participants + 1)) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n        if(withdraw.ring1[participants] != withdraw.ring1[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        if(withdraw.ring2[participants] != withdraw.ring2[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        \n        withdraw.step++;\n        consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true;\n        safeSend(withdraw.sender, payment);\n        return true;\n    }\n\n    function () {\n        throw;\n    }\n}",
        "debug": "keccac_3_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_6: 0x0\nstorage_keccac_UDiv(KECCAC_mem_160_+_32*calldata_Laundromat_4_+_calldata_Laundromat_4_+_64),\n_____1): 0x0\nstorage_4: 0x0\ncalldata_Laundromat_0: 0x1a6c9c0d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x1a6c9c0d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x1a6c9c0d",
        "lineno": 26,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5781,
        "code": "    struct WithdrawInfo {\n\n        address sender;\n        uint Ix;\n        uint Iy;\n        uint[] signature;\n        uint[] ring1;\n        uint[] ring2;\n        \n        uint step;\n        uint prevStep;\n    }\n\n    uint constant internal safeGas = 25000;\n    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;\n    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;\n    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;\n\n    address private owner;\n    bool private atomicLock;\n    \n    address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6;\n    ArithLib private arithContract;\n    mapping (uint => WithdrawInfo) private withdraws;\n    mapping (uint => bool) private consumed;\n\n    uint public participants = 0;\n    uint public payment = 0;\n    uint public gotParticipants = 0;\n    uint[] public pubkeys1;\n    uint[] public pubkeys2;\n\n    event LogDebug(string message);\n\n    //create new mixing contract with _participants amount of mixing participants,\n    //_payment - expected payment from each participant.\n    function Laundromat(uint _participants, uint _payment) {\n        owner = msg.sender;\n        arithContract = ArithLib(arithAddress);\n\n        participants = _participants;\n        payment = _payment;\n    }\n    \n    function safeSend(address addr, uint value) internal {\n\n        if(atomicLock) throw;\n        atomicLock = true;\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            atomicLock = false;\n            throw;\n        }\n        atomicLock = false;\n    }\n\n    //add new participant to the mixing\n    function deposit(uint _pubkey1, uint _pubkey2) payable {\n        //if(msg.value != payment) throw;\n        if(gotParticipants >= participants) throw;\n\n        pubkeys1.push(_pubkey1);\n        pubkeys2.push(_pubkey2);\n        gotParticipants++;\n    }\n\n    //get funds from the mixer. Requires valid signature.\n    function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) {\n        if(gotParticipants < participants) throw;\n        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;\n\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        withdraw.sender = msg.sender;\n        withdraw.Ix = _Ix;\n        withdraw.Iy = _Iy;\n        withdraw.signature = _signature;\n\n        withdraw.ring1.length = 0;\n        withdraw.ring2.length = 0;\n        withdraw.ring1.push(_x0);\n        withdraw.ring2.push(uint(sha3(_x0)));\n        \n        withdraw.step = 1;\n        withdraw.prevStep = 0;\n    }\n\n    function withdrawStep() {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        //throw if existing witdhraw not started\n        if(withdraw.step < 1) throw;\n        if(withdraw.step > participants) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n\n        uint k1x;\n        uint k1y;\n        uint k1z;\n        uint k2x;\n        uint k2y;\n        uint k2z;\n        uint pub1x;\n        uint pub1y;\n        \n        (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        (k2x, k2y, k2z) = arithContract.jmul(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants], 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub1\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        //k3\n        (k1x, k1y) = arithContract.hash_pubkey_to_pubkey(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants]);\n        //k4 = ecmul(k3, s[prev_i])\n        (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        //k5 = ecmul(I, e[prev_i].right)\n        (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub2\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        //pub2x, pub2y\n        (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])));\n        withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])))));\n        withdraw.step++;\n        withdraw.prevStep++;\n    }\n    \n    function withdrawFinal() returns (bool) {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n        \n        if(withdraw.step != (participants + 1)) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n        if(withdraw.ring1[participants] != withdraw.ring1[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        if(withdraw.ring2[participants] != withdraw.ring2[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        \n        withdraw.step++;\n        consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true;\n        safeSend(withdraw.sender, payment);\n        return true;\n    }\n\n    function () {\n        throw;\n    }\n}",
        "debug": "calldata_Laundromat_4 + calldata_Laundromat_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_6: 0x0\nstorage_keccac_UDiv(KECCAC_mem_160_+_32*calldata_Laundromat_4_+_calldata_Laundromat_4_+_64),\n_____1): 0x0\nstorage_4: 0x0\ncalldata_Laundromat_0: 0x1a6c9c0d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x1a6c9c0d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x1a6c9c0d",
        "lineno": 26,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5783,
        "code": "    struct WithdrawInfo {\n\n        address sender;\n        uint Ix;\n        uint Iy;\n        uint[] signature;\n        uint[] ring1;\n        uint[] ring2;\n        \n        uint step;\n        uint prevStep;\n    }\n\n    uint constant internal safeGas = 25000;\n    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;\n    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;\n    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;\n\n    address private owner;\n    bool private atomicLock;\n    \n    address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6;\n    ArithLib private arithContract;\n    mapping (uint => WithdrawInfo) private withdraws;\n    mapping (uint => bool) private consumed;\n\n    uint public participants = 0;\n    uint public payment = 0;\n    uint public gotParticipants = 0;\n    uint[] public pubkeys1;\n    uint[] public pubkeys2;\n\n    event LogDebug(string message);\n\n    //create new mixing contract with _participants amount of mixing participants,\n    //_payment - expected payment from each participant.\n    function Laundromat(uint _participants, uint _payment) {\n        owner = msg.sender;\n        arithContract = ArithLib(arithAddress);\n\n        participants = _participants;\n        payment = _payment;\n    }\n    \n    function safeSend(address addr, uint value) internal {\n\n        if(atomicLock) throw;\n        atomicLock = true;\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            atomicLock = false;\n            throw;\n        }\n        atomicLock = false;\n    }\n\n    //add new participant to the mixing\n    function deposit(uint _pubkey1, uint _pubkey2) payable {\n        //if(msg.value != payment) throw;\n        if(gotParticipants >= participants) throw;\n\n        pubkeys1.push(_pubkey1);\n        pubkeys2.push(_pubkey2);\n        gotParticipants++;\n    }\n\n    //get funds from the mixer. Requires valid signature.\n    function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) {\n        if(gotParticipants < participants) throw;\n        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;\n\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        withdraw.sender = msg.sender;\n        withdraw.Ix = _Ix;\n        withdraw.Iy = _Iy;\n        withdraw.signature = _signature;\n\n        withdraw.ring1.length = 0;\n        withdraw.ring2.length = 0;\n        withdraw.ring1.push(_x0);\n        withdraw.ring2.push(uint(sha3(_x0)));\n        \n        withdraw.step = 1;\n        withdraw.prevStep = 0;\n    }\n\n    function withdrawStep() {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        //throw if existing witdhraw not started\n        if(withdraw.step < 1) throw;\n        if(withdraw.step > participants) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n\n        uint k1x;\n        uint k1y;\n        uint k1z;\n        uint k2x;\n        uint k2y;\n        uint k2z;\n        uint pub1x;\n        uint pub1y;\n        \n        (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        (k2x, k2y, k2z) = arithContract.jmul(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants], 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub1\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        //k3\n        (k1x, k1y) = arithContract.hash_pubkey_to_pubkey(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants]);\n        //k4 = ecmul(k3, s[prev_i])\n        (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        //k5 = ecmul(I, e[prev_i].right)\n        (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub2\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        //pub2x, pub2y\n        (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])));\n        withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])))));\n        withdraw.step++;\n        withdraw.prevStep++;\n    }\n    \n    function withdrawFinal() returns (bool) {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n        \n        if(withdraw.step != (participants + 1)) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n        if(withdraw.ring1[participants] != withdraw.ring1[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        if(withdraw.ring2[participants] != withdraw.ring2[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        \n        withdraw.step++;\n        consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true;\n        safeSend(withdraw.sender, payment);\n        return true;\n    }\n\n    function () {\n        throw;\n    }\n}",
        "debug": "calldata_Laundromat_4 + calldata_Laundromat_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_6: 0x0\nstorage_keccac_UDiv(KECCAC_mem_160_+_32*calldata_Laundromat_4_+_calldata_Laundromat_4_+_64),\n_____1): 0x0\nstorage_4: 0x0\ncalldata_Laundromat_0: 0x1a6c9c0d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x1a6c9c0d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x1a6c9c0d",
        "lineno": 26,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5805,
        "code": "    struct WithdrawInfo {\n\n        address sender;\n        uint Ix;\n        uint Iy;\n        uint[] signature;\n        uint[] ring1;\n        uint[] ring2;\n        \n        uint step;\n        uint prevStep;\n    }\n\n    uint constant internal safeGas = 25000;\n    uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663;\n    uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240;\n    uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424;\n\n    address private owner;\n    bool private atomicLock;\n    \n    address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6;\n    ArithLib private arithContract;\n    mapping (uint => WithdrawInfo) private withdraws;\n    mapping (uint => bool) private consumed;\n\n    uint public participants = 0;\n    uint public payment = 0;\n    uint public gotParticipants = 0;\n    uint[] public pubkeys1;\n    uint[] public pubkeys2;\n\n    event LogDebug(string message);\n\n    //create new mixing contract with _participants amount of mixing participants,\n    //_payment - expected payment from each participant.\n    function Laundromat(uint _participants, uint _payment) {\n        owner = msg.sender;\n        arithContract = ArithLib(arithAddress);\n\n        participants = _participants;\n        payment = _payment;\n    }\n    \n    function safeSend(address addr, uint value) internal {\n\n        if(atomicLock) throw;\n        atomicLock = true;\n        if (!(addr.call.gas(safeGas).value(value)())) {\n            atomicLock = false;\n            throw;\n        }\n        atomicLock = false;\n    }\n\n    //add new participant to the mixing\n    function deposit(uint _pubkey1, uint _pubkey2) payable {\n        //if(msg.value != payment) throw;\n        if(gotParticipants >= participants) throw;\n\n        pubkeys1.push(_pubkey1);\n        pubkeys2.push(_pubkey2);\n        gotParticipants++;\n    }\n\n    //get funds from the mixer. Requires valid signature.\n    function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) {\n        if(gotParticipants < participants) throw;\n        if(consumed[uint(sha3([_Ix, _Iy]))]) throw;\n\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        withdraw.sender = msg.sender;\n        withdraw.Ix = _Ix;\n        withdraw.Iy = _Iy;\n        withdraw.signature = _signature;\n\n        withdraw.ring1.length = 0;\n        withdraw.ring2.length = 0;\n        withdraw.ring1.push(_x0);\n        withdraw.ring2.push(uint(sha3(_x0)));\n        \n        withdraw.step = 1;\n        withdraw.prevStep = 0;\n    }\n\n    function withdrawStep() {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n\n        //throw if existing witdhraw not started\n        if(withdraw.step < 1) throw;\n        if(withdraw.step > participants) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n\n        uint k1x;\n        uint k1y;\n        uint k1z;\n        uint k2x;\n        uint k2y;\n        uint k2z;\n        uint pub1x;\n        uint pub1y;\n        \n        (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        (k2x, k2y, k2z) = arithContract.jmul(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants], 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub1\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        //k3\n        (k1x, k1y) = arithContract.hash_pubkey_to_pubkey(\n            pubkeys1[withdraw.step % participants],\n            pubkeys2[withdraw.step % participants]);\n        //k4 = ecmul(k3, s[prev_i])\n        (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1,\n            withdraw.signature[withdraw.prevStep % participants]);\n        //k5 = ecmul(I, e[prev_i].right)\n        (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1,\n            withdraw.ring2[withdraw.prevStep % participants]);\n        //ksub2\n        (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z);\n        //pub2x, pub2y\n        (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z);\n        withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])));\n        withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y])))));\n        withdraw.step++;\n        withdraw.prevStep++;\n    }\n    \n    function withdrawFinal() returns (bool) {\n        WithdrawInfo withdraw = withdraws[uint(msg.sender)];\n        \n        if(withdraw.step != (participants + 1)) throw;\n        if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw;\n        if(withdraw.ring1[participants] != withdraw.ring1[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        if(withdraw.ring2[participants] != withdraw.ring2[0]) {\n            \n            LogDebug(\"Wrong signature\");\n            return false;\n        }\n        \n        withdraw.step++;\n        consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true;\n        safeSend(withdraw.sender, payment);\n        return true;\n    }\n\n    function () {\n        throw;\n    }\n}",
        "debug": "keccac_3_+\nkeccac_1461501637330902918203684832716283019655932542975_&_caller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Laundromat_4 + calldata_Laundromat_4: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nstorage_6: 0x0\nstorage_keccac_UDiv(KECCAC_mem_160_+_32*calldata_Laundromat_4_+_calldata_Laundromat_4_+_64),\n_____1): 0x0\nstorage_4: 0x0\ncalldata_Laundromat_0: 0x1a6c9c0d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Laundromat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x1a6c9c0d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x81d9fe466216a780dae2ec004fec636627e88653.sol",
        "function": "_function_0x1a6c9c0d",
        "lineno": 26,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}