{
  "contract": "0x7acbbd35d59c112071fa627e5f64d9cf79755f20",
  "tool": "mythril",
  "start": 1563561619.4446654,
  "end": 1563562420.0971692,
  "duration": 800.6525037288666,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 363,
        "code": "   private\n      returns (string)\n    {\n      bytes memory bStr = bytes(str);\n      bytes memory bLower = new bytes(bStr.length);\n      for (uint i = 0; i < bStr.length; i++) {\n        // lower",
        "debug": "calldata_LIMITED_42_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_LIMITED_42_0: 0x1946595300000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeInfo(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "changeInfo(string)",
        "lineno": 249,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 854,
        "code": "uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address oldowner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check that newowner is not no one\n      require(newowner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        oldowner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash2(newowner);\n        //check if eveything adds up.\n        require(ecrecover(h, v, r, s) == Pattern[patternid].owner);\n        oldowner = Pattern[patternid].owner;\n      }\n\n      //remove reference from old owner mapping\n      removePatternUserIndex(oldowner,patternid);\n\n      //update pattern owner and message\n      Pattern[patternid].owner = newowner;\n      Pattern[patternid].message = message;\n      //add reference to owner map\n      addPatternUserIndex(newowner,patternid);\n\n      return \"ok\";\n\n    }\n\n    function changeMessage(bytes32 patternid,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      r",
        "debug": "calldata_LIMITED_42_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_LIMITED_42_0: 0x94ccbc1f00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferPattern(bytes32,address,string,uint8,bytes32,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "transferPattern(bytes32,address,string,uint8,bytes32,bytes32)",
        "lineno": 77,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1135,
        "code": "tring)\n    {\n      // just so we have somthing\n      address owner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        owner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash(message);\n        owner = ecrecover(h, v, r, s);\n      }\n\n      require(Pattern[patternid].owner == owner);\n\n      Pattern[patternid].message = message;\n\n      return \"ok\";\n\n    }\n\n    function verifyOwner(bytes32 patternid, address owner, uint8 v, bytes32 r, bytes32 s)\n      public\n      view\n      returns(bool)\n    {\n  ",
        "debug": "calldata_LIMITED_42_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_LIMITED_42_0: 0x977af81c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeMessage(bytes32,string,uint8,bytes32,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "changeMessage(bytes32,string,uint8,bytes32,bytes32)",
        "lineno": 119,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1562,
        "code": "tring dataMixed, address newowner, string message)\n        onlyAdmin\n        public\n        returns(string)\n    {\n      //CONVERT DATA to UPPERCASE\n      string memory data = toUpper(dataMixed);\n\n      //FIRST CHECK IF PATTERNID AND DATA HASH MATCH!!!\n      require(keccak256(abi.encodePacked(data)) == patternid);\n\n      //no ownerless Pattern // also possible to gift Pattern\n      require(newowner != address(0));\n\n      //check EXISTANCE\n      if(Pattern[patternid].owner == address(0)){\n          //IF DOENST EXIST\n\n          //create pattern at coresponding id\n          Pattern[patternid].owner = newowner;\n          Pattern[patternid].message = message;\n          Pattern[patternid].data = data;\n\n          addPatternUserIndex(newowner,patternid);\n\n          return \"ok\";\n\n      }else{\n          //must be for sale\n          return \"error:exists\";\n      }\n\n    }\n    function transferPattern(bytes32 patternid,address newowner,string mes",
        "debug": "calldata_LIMITED_42_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_LIMITED_42_0: 0xdbaec0fd00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPattern(bytes32,string,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "createPattern(bytes32,string,address,string)",
        "lineno": 44,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2430,
        "code": "in can call this.\n   ",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "emergency(address,uint8,bytes32,bytes32,uint8,bytes32,bytes32)",
        "lineno": 240,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 2636,
        "code": "= admin); used modifier\n",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "emergency(address,uint8,bytes32,bytes32,uint8,bytes32,bytes32)",
        "lineno": 241,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 3170,
        "code": "dress => bytes32[]) public Patterns;\n    mapp",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_LIMITED_42_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\ncalldata_LIMITED_42_4: 0x0\ncalldata_LIMITED_42_0: 0x58b81ea000000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "_function_0x58b81ea0",
        "lineno": 11,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5001,
        "code": "\n        return true;",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "verifyOwner(bytes32,address,uint8,bytes32,bytes32)",
        "lineno": 162,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 8867,
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_LIMITED_42_cpy: 0x6300000000000000000000000000000000000000000000000000000000000000\ncalldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_LIMITED_42_0: 0xdbaec0fd00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4)) +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 68)): 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "createPattern(bytes32,string,address,string)",
        "lineno": 266,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9023,
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_LIMITED_42_cpy: 0xe200000000000000000000000000000000000000000000000000000000000000\ncalldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_LIMITED_42_0: 0xdbaec0fd00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4)) +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 68)): 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "createPattern(bytes32,string,address,string)",
        "lineno": 266,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9136,
        "code": "ntract LIMITED_42 {\n\n    struct PatternOBJ {\n        address owner;\n        string message;\n        string data;\n    }\n\n    mapping(address => bytes32[]) public Patterns;\n    mapping(bytes32 => PatternOBJ) public Pattern;\n\n    string public info = \"\";\n\n    address private constant emergency_admin = 0x59ab67D9BA5a748591bB79Ce223606A8C2892E6d;\n    address private constant first_admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n    address private admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n\n\n    /**************************************************************************\n    * modifiers\n    ***************************************************************************/\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /**************************************************************************\n    * functionS\n    ***************************************************************************/\n\n    function checkPatternExistance (bytes32 patternid) public view\n    returns(bool)\n    {\n      if(Pattern[patternid].owner == address(0)){\n        return false;\n      }else{\n        return true;\n      }\n    }\n\n    function createPattern(bytes32 patternid, string dataMixed, address newowner, string message)\n        onlyAdmin\n        public\n        returns(string)\n    {\n      //CONVERT DATA to UPPERCASE\n      string memory data = toUpper(dataMixed);\n\n      //FIRST CHECK IF PATTERNID AND DATA HASH MATCH!!!\n      require(keccak256(abi.encodePacked(data)) == patternid);\n\n      //no ownerless Pattern // also possible to gift Pattern\n      require(newowner != address(0));\n\n      //check EXISTANCE\n      if(Pattern[patternid].owner == address(0)){\n          //IF DOENST EXIST\n\n          //create pattern at coresponding id\n          Pattern[patternid].owner = newowner;\n          Pattern[patternid].message = message;\n          Pattern[patternid].data = data;\n\n          addPatternUserIndex(newowner,patternid);\n\n          return \"ok\";\n\n      }else{\n          //must be for sale\n          return \"error:exists\";\n      }\n\n    }\n    function transferPattern(bytes32 patternid,address newowner,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address oldowner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check that newowner is not no one\n      require(newowner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        oldowner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash2(newowner);\n        //check if eveything adds up.\n        require(ecrecover(h, v, r, s) == Pattern[patternid].owner);\n        oldowner = Pattern[patternid].owner;\n      }\n\n      //remove reference from old owner mapping\n      removePatternUserIndex(oldowner,patternid);\n\n      //update pattern owner and message\n      Pattern[patternid].owner = newowner;\n      Pattern[patternid].message = message;\n      //add reference to owner map\n      addPatternUserIndex(newowner,patternid);\n\n      return \"ok\";\n\n    }\n\n    function changeMessage(bytes32 patternid,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address owner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        owner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash(message);\n        owner = ecrecover(h, v, r, s);\n      }\n\n      require(Pattern[patternid].owner == owner);\n\n      Pattern[patternid].message = message;\n\n      return \"ok\";\n\n    }\n\n    function verifyOwner(bytes32 patternid, address owner, uint8 v, bytes32 r, bytes32 s)\n      public\n      view\n      returns(bool)\n    {\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //resolve owner address from signature\n      bytes32 h = prefixedHash2(owner);\n      address owner2 = ecrecover(h, v, r, s);\n\n      require(owner2 == owner);\n\n      //check if owner actually owns item in question\n      if(Pattern[patternid].owner == owner2){\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function prefixedHash(string message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n    function prefixedHash2(address message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n\n    function addPatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n        Patterns[account].push(patternid);\n    }\n\n    function removePatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n      require(Pattern[patternid].owner == account);\n      for (uint i = 0; i<Patterns[account].length; i++){\n          if(Patterns[account][i] == patternid){\n              //replace with last entry\n              Patterns[account][i] = Patterns[account][Patterns[account].length-1];\n              //delete last\n              delete Patterns[account][Patterns[account].length-1];\n              //shorten array\n              Patterns[account].length--;\n          }\n      }\n    }\n\n    function userHasPattern(address account)\n      public\n      view\n      returns(bool)\n    {\n      if(Patterns[account].length >=1 )\n      {\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function emergency(address newa, uint8 v, bytes32 r, bytes32 s, uint8 v2, bytes32 r2, bytes32 s2)\n      public\n    {\n      //generate hashes\n      bytes32 h = prefixedHash2(newa);\n\n      //check if admin and emergency_admin signed the messages\n      require(ecrecover(h, v, r, s)==admin);\n      require(ecrecover(h, v2, r2, s2)==emergency_admin);\n      //set new admin\n      admin = newa;\n    }\n\n    function changeInfo(string newinfo)\n      public\n      onlyAdmin\n    {\n      //only admin can call this.\n      //require(msg.sender == admin); used modifier\n\n      info = newinfo;\n    }\n\n\n    function toUpper(string str)\n      pure\n      private\n      returns (string)\n    {\n      bytes memory bStr = bytes(str);\n      bytes memory bLower = new bytes(bStr.length);\n      for (uint i = 0; i < bStr.length; i++) {\n        // lowercase character...\n        if ((bStr[i] >= 65+32) && (bStr[i] <= 90+32)) {\n          // So we remove 32 to make it uppercase\n          bLower[i] = bytes1(int(bStr[i]) - 32);\n        } else {\n          bLower[i] = bStr[i];\n        }\n      }\n      return string(bLower);\n    }\n\n}",
        "debug": "keccac_1_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_LIMITED_42_0: 0x977af81c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeMessage(bytes32,string,uint8,bytes32,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "changeMessage(bytes32,string,uint8,bytes32,bytes32)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9165,
        "code": "ntract LIMITED_42 {\n\n    struct PatternOBJ {\n        address owner;\n        string message;\n        string data;\n    }\n\n    mapping(address => bytes32[]) public Patterns;\n    mapping(bytes32 => PatternOBJ) public Pattern;\n\n    string public info = \"\";\n\n    address private constant emergency_admin = 0x59ab67D9BA5a748591bB79Ce223606A8C2892E6d;\n    address private constant first_admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n    address private admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n\n\n    /**************************************************************************\n    * modifiers\n    ***************************************************************************/\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /**************************************************************************\n    * functionS\n    ***************************************************************************/\n\n    function checkPatternExistance (bytes32 patternid) public view\n    returns(bool)\n    {\n      if(Pattern[patternid].owner == address(0)){\n        return false;\n      }else{\n        return true;\n      }\n    }\n\n    function createPattern(bytes32 patternid, string dataMixed, address newowner, string message)\n        onlyAdmin\n        public\n        returns(string)\n    {\n      //CONVERT DATA to UPPERCASE\n      string memory data = toUpper(dataMixed);\n\n      //FIRST CHECK IF PATTERNID AND DATA HASH MATCH!!!\n      require(keccak256(abi.encodePacked(data)) == patternid);\n\n      //no ownerless Pattern // also possible to gift Pattern\n      require(newowner != address(0));\n\n      //check EXISTANCE\n      if(Pattern[patternid].owner == address(0)){\n          //IF DOENST EXIST\n\n          //create pattern at coresponding id\n          Pattern[patternid].owner = newowner;\n          Pattern[patternid].message = message;\n          Pattern[patternid].data = data;\n\n          addPatternUserIndex(newowner,patternid);\n\n          return \"ok\";\n\n      }else{\n          //must be for sale\n          return \"error:exists\";\n      }\n\n    }\n    function transferPattern(bytes32 patternid,address newowner,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address oldowner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check that newowner is not no one\n      require(newowner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        oldowner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash2(newowner);\n        //check if eveything adds up.\n        require(ecrecover(h, v, r, s) == Pattern[patternid].owner);\n        oldowner = Pattern[patternid].owner;\n      }\n\n      //remove reference from old owner mapping\n      removePatternUserIndex(oldowner,patternid);\n\n      //update pattern owner and message\n      Pattern[patternid].owner = newowner;\n      Pattern[patternid].message = message;\n      //add reference to owner map\n      addPatternUserIndex(newowner,patternid);\n\n      return \"ok\";\n\n    }\n\n    function changeMessage(bytes32 patternid,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address owner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        owner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash(message);\n        owner = ecrecover(h, v, r, s);\n      }\n\n      require(Pattern[patternid].owner == owner);\n\n      Pattern[patternid].message = message;\n\n      return \"ok\";\n\n    }\n\n    function verifyOwner(bytes32 patternid, address owner, uint8 v, bytes32 r, bytes32 s)\n      public\n      view\n      returns(bool)\n    {\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //resolve owner address from signature\n      bytes32 h = prefixedHash2(owner);\n      address owner2 = ecrecover(h, v, r, s);\n\n      require(owner2 == owner);\n\n      //check if owner actually owns item in question\n      if(Pattern[patternid].owner == owner2){\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function prefixedHash(string message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n    function prefixedHash2(address message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n\n    function addPatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n        Patterns[account].push(patternid);\n    }\n\n    function removePatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n      require(Pattern[patternid].owner == account);\n      for (uint i = 0; i<Patterns[account].length; i++){\n          if(Patterns[account][i] == patternid){\n              //replace with last entry\n              Patterns[account][i] = Patterns[account][Patterns[account].length-1];\n              //delete last\n              delete Patterns[account][Patterns[account].length-1];\n              //shorten array\n              Patterns[account].length--;\n          }\n      }\n    }\n\n    function userHasPattern(address account)\n      public\n      view\n      returns(bool)\n    {\n      if(Patterns[account].length >=1 )\n      {\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function emergency(address newa, uint8 v, bytes32 r, bytes32 s, uint8 v2, bytes32 r2, bytes32 s2)\n      public\n    {\n      //generate hashes\n      bytes32 h = prefixedHash2(newa);\n\n      //check if admin and emergency_admin signed the messages\n      require(ecrecover(h, v, r, s)==admin);\n      require(ecrecover(h, v2, r2, s2)==emergency_admin);\n      //set new admin\n      admin = newa;\n    }\n\n    function changeInfo(string newinfo)\n      public\n      onlyAdmin\n    {\n      //only admin can call this.\n      //require(msg.sender == admin); used modifier\n\n      info = newinfo;\n    }\n\n\n    function toUpper(string str)\n      pure\n      private\n      returns (string)\n    {\n      bytes memory bStr = bytes(str);\n      bytes memory bLower = new bytes(bStr.length);\n      for (uint i = 0; i < bStr.length; i++) {\n        // lowercase character...\n        if ((bStr[i] >= 65+32) && (bStr[i] <= 90+32)) {\n          // So we remove 32 to make it uppercase\n          bLower[i] = bytes1(int(bStr[i]) - 32);\n        } else {\n          bLower[i] = bStr[i];\n        }\n      }\n      return string(bLower);\n    }\n\n}",
        "debug": "calldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_LIMITED_42_0: 0x977af81c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeMessage(bytes32,string,uint8,bytes32,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "changeMessage(bytes32,string,uint8,bytes32,bytes32)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9179,
        "code": "ntract LIMITED_42 {\n\n    struct PatternOBJ {\n        address owner;\n        string message;\n        string data;\n    }\n\n    mapping(address => bytes32[]) public Patterns;\n    mapping(bytes32 => PatternOBJ) public Pattern;\n\n    string public info = \"\";\n\n    address private constant emergency_admin = 0x59ab67D9BA5a748591bB79Ce223606A8C2892E6d;\n    address private constant first_admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n    address private admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n\n\n    /**************************************************************************\n    * modifiers\n    ***************************************************************************/\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /**************************************************************************\n    * functionS\n    ***************************************************************************/\n\n    function checkPatternExistance (bytes32 patternid) public view\n    returns(bool)\n    {\n      if(Pattern[patternid].owner == address(0)){\n        return false;\n      }else{\n        return true;\n      }\n    }\n\n    function createPattern(bytes32 patternid, string dataMixed, address newowner, string message)\n        onlyAdmin\n        public\n        returns(string)\n    {\n      //CONVERT DATA to UPPERCASE\n      string memory data = toUpper(dataMixed);\n\n      //FIRST CHECK IF PATTERNID AND DATA HASH MATCH!!!\n      require(keccak256(abi.encodePacked(data)) == patternid);\n\n      //no ownerless Pattern // also possible to gift Pattern\n      require(newowner != address(0));\n\n      //check EXISTANCE\n      if(Pattern[patternid].owner == address(0)){\n          //IF DOENST EXIST\n\n          //create pattern at coresponding id\n          Pattern[patternid].owner = newowner;\n          Pattern[patternid].message = message;\n          Pattern[patternid].data = data;\n\n          addPatternUserIndex(newowner,patternid);\n\n          return \"ok\";\n\n      }else{\n          //must be for sale\n          return \"error:exists\";\n      }\n\n    }\n    function transferPattern(bytes32 patternid,address newowner,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address oldowner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check that newowner is not no one\n      require(newowner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        oldowner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash2(newowner);\n        //check if eveything adds up.\n        require(ecrecover(h, v, r, s) == Pattern[patternid].owner);\n        oldowner = Pattern[patternid].owner;\n      }\n\n      //remove reference from old owner mapping\n      removePatternUserIndex(oldowner,patternid);\n\n      //update pattern owner and message\n      Pattern[patternid].owner = newowner;\n      Pattern[patternid].message = message;\n      //add reference to owner map\n      addPatternUserIndex(newowner,patternid);\n\n      return \"ok\";\n\n    }\n\n    function changeMessage(bytes32 patternid,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address owner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        owner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash(message);\n        owner = ecrecover(h, v, r, s);\n      }\n\n      require(Pattern[patternid].owner == owner);\n\n      Pattern[patternid].message = message;\n\n      return \"ok\";\n\n    }\n\n    function verifyOwner(bytes32 patternid, address owner, uint8 v, bytes32 r, bytes32 s)\n      public\n      view\n      returns(bool)\n    {\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //resolve owner address from signature\n      bytes32 h = prefixedHash2(owner);\n      address owner2 = ecrecover(h, v, r, s);\n\n      require(owner2 == owner);\n\n      //check if owner actually owns item in question\n      if(Pattern[patternid].owner == owner2){\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function prefixedHash(string message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n    function prefixedHash2(address message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n\n    function addPatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n        Patterns[account].push(patternid);\n    }\n\n    function removePatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n      require(Pattern[patternid].owner == account);\n      for (uint i = 0; i<Patterns[account].length; i++){\n          if(Patterns[account][i] == patternid){\n              //replace with last entry\n              Patterns[account][i] = Patterns[account][Patterns[account].length-1];\n              //delete last\n              delete Patterns[account][Patterns[account].length-1];\n              //shorten array\n              Patterns[account].length--;\n          }\n      }\n    }\n\n    function userHasPattern(address account)\n      public\n      view\n      returns(bool)\n    {\n      if(Patterns[account].length >=1 )\n      {\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function emergency(address newa, uint8 v, bytes32 r, bytes32 s, uint8 v2, bytes32 r2, bytes32 s2)\n      public\n    {\n      //generate hashes\n      bytes32 h = prefixedHash2(newa);\n\n      //check if admin and emergency_admin signed the messages\n      require(ecrecover(h, v, r, s)==admin);\n      require(ecrecover(h, v2, r2, s2)==emergency_admin);\n      //set new admin\n      admin = newa;\n    }\n\n    function changeInfo(string newinfo)\n      public\n      onlyAdmin\n    {\n      //only admin can call this.\n      //require(msg.sender == admin); used modifier\n\n      info = newinfo;\n    }\n\n\n    function toUpper(string str)\n      pure\n      private\n      returns (string)\n    {\n      bytes memory bStr = bytes(str);\n      bytes memory bLower = new bytes(bStr.length);\n      for (uint i = 0; i < bStr.length; i++) {\n        // lowercase character...\n        if ((bStr[i] >= 65+32) && (bStr[i] <= 90+32)) {\n          // So we remove 32 to make it uppercase\n          bLower[i] = bytes1(int(bStr[i]) - 32);\n        } else {\n          bLower[i] = bStr[i];\n        }\n      }\n      return string(bLower);\n    }\n\n}",
        "debug": "calldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_LIMITED_42_0: 0x977af81c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeMessage(bytes32,string,uint8,bytes32,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "changeMessage(bytes32,string,uint8,bytes32,bytes32)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9201,
        "code": "ntract LIMITED_42 {\n\n    struct PatternOBJ {\n        address owner;\n        string message;\n        string data;\n    }\n\n    mapping(address => bytes32[]) public Patterns;\n    mapping(bytes32 => PatternOBJ) public Pattern;\n\n    string public info = \"\";\n\n    address private constant emergency_admin = 0x59ab67D9BA5a748591bB79Ce223606A8C2892E6d;\n    address private constant first_admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n    address private admin = 0x9a203e2E251849a26566EBF94043D74FEeb0011c;\n\n\n    /**************************************************************************\n    * modifiers\n    ***************************************************************************/\n\n    modifier onlyAdmin {\n        require(msg.sender == admin);\n        _;\n    }\n\n    /**************************************************************************\n    * functionS\n    ***************************************************************************/\n\n    function checkPatternExistance (bytes32 patternid) public view\n    returns(bool)\n    {\n      if(Pattern[patternid].owner == address(0)){\n        return false;\n      }else{\n        return true;\n      }\n    }\n\n    function createPattern(bytes32 patternid, string dataMixed, address newowner, string message)\n        onlyAdmin\n        public\n        returns(string)\n    {\n      //CONVERT DATA to UPPERCASE\n      string memory data = toUpper(dataMixed);\n\n      //FIRST CHECK IF PATTERNID AND DATA HASH MATCH!!!\n      require(keccak256(abi.encodePacked(data)) == patternid);\n\n      //no ownerless Pattern // also possible to gift Pattern\n      require(newowner != address(0));\n\n      //check EXISTANCE\n      if(Pattern[patternid].owner == address(0)){\n          //IF DOENST EXIST\n\n          //create pattern at coresponding id\n          Pattern[patternid].owner = newowner;\n          Pattern[patternid].message = message;\n          Pattern[patternid].data = data;\n\n          addPatternUserIndex(newowner,patternid);\n\n          return \"ok\";\n\n      }else{\n          //must be for sale\n          return \"error:exists\";\n      }\n\n    }\n    function transferPattern(bytes32 patternid,address newowner,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address oldowner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check that newowner is not no one\n      require(newowner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        oldowner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash2(newowner);\n        //check if eveything adds up.\n        require(ecrecover(h, v, r, s) == Pattern[patternid].owner);\n        oldowner = Pattern[patternid].owner;\n      }\n\n      //remove reference from old owner mapping\n      removePatternUserIndex(oldowner,patternid);\n\n      //update pattern owner and message\n      Pattern[patternid].owner = newowner;\n      Pattern[patternid].message = message;\n      //add reference to owner map\n      addPatternUserIndex(newowner,patternid);\n\n      return \"ok\";\n\n    }\n\n    function changeMessage(bytes32 patternid,string message, uint8 v, bytes32 r, bytes32 s)\n      public\n      returns(string)\n    {\n      // just so we have somthing\n      address owner = admin;\n\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //check if sender iis owner\n      if(Pattern[patternid].owner == msg.sender){\n        //if sender iiis owner\n        owner = msg.sender;\n      }else{\n        // anyone else need to supply a new address signed by the old owner\n\n        //generate the h for the new address\n        bytes32 h = prefixedHash(message);\n        owner = ecrecover(h, v, r, s);\n      }\n\n      require(Pattern[patternid].owner == owner);\n\n      Pattern[patternid].message = message;\n\n      return \"ok\";\n\n    }\n\n    function verifyOwner(bytes32 patternid, address owner, uint8 v, bytes32 r, bytes32 s)\n      public\n      view\n      returns(bool)\n    {\n      //check that pattern in question has an owner\n      require(Pattern[patternid].owner != address(0));\n\n      //resolve owner address from signature\n      bytes32 h = prefixedHash2(owner);\n      address owner2 = ecrecover(h, v, r, s);\n\n      require(owner2 == owner);\n\n      //check if owner actually owns item in question\n      if(Pattern[patternid].owner == owner2){\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function prefixedHash(string message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n    function prefixedHash2(address message)\n      private\n      pure\n      returns (bytes32)\n    {\n        bytes32 h = keccak256(abi.encodePacked(message));\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", h));\n    }\n\n\n    function addPatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n        Patterns[account].push(patternid);\n    }\n\n    function removePatternUserIndex(address account, bytes32 patternid)\n      private\n    {\n      require(Pattern[patternid].owner == account);\n      for (uint i = 0; i<Patterns[account].length; i++){\n          if(Patterns[account][i] == patternid){\n              //replace with last entry\n              Patterns[account][i] = Patterns[account][Patterns[account].length-1];\n              //delete last\n              delete Patterns[account][Patterns[account].length-1];\n              //shorten array\n              Patterns[account].length--;\n          }\n      }\n    }\n\n    function userHasPattern(address account)\n      public\n      view\n      returns(bool)\n    {\n      if(Patterns[account].length >=1 )\n      {\n        return true;\n      }else{\n        return false;\n      }\n    }\n\n    function emergency(address newa, uint8 v, bytes32 r, bytes32 s, uint8 v2, bytes32 r2, bytes32 s2)\n      public\n    {\n      //generate hashes\n      bytes32 h = prefixedHash2(newa);\n\n      //check if admin and emergency_admin signed the messages\n      require(ecrecover(h, v, r, s)==admin);\n      require(ecrecover(h, v2, r2, s2)==emergency_admin);\n      //set new admin\n      admin = newa;\n    }\n\n    function changeInfo(string newinfo)\n      public\n      onlyAdmin\n    {\n      //only admin can call this.\n      //require(msg.sender == admin); used modifier\n\n      info = newinfo;\n    }\n\n\n    function toUpper(string str)\n      pure\n      private\n      returns (string)\n    {\n      bytes memory bStr = bytes(str);\n      bytes memory bLower = new bytes(bStr.length);\n      for (uint i = 0; i < bStr.length; i++) {\n        // lowercase character...\n        if ((bStr[i] >= 65+32) && (bStr[i] <= 90+32)) {\n          // So we remove 32 to make it uppercase\n          bLower[i] = bytes1(int(bStr[i]) - 32);\n        } else {\n          bLower[i] = bStr[i];\n        }\n      }\n      return string(bLower);\n    }\n\n}",
        "debug": "keccac_1_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_LIMITED_42_4 + calldata_LIMITED_42_32 + 4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_LIMITED_42_4: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_LIMITED_42_0: 0x977af81c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LIMITED_42: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeMessage(bytes32,string,uint8,bytes32,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0x7acbbd35d59c112071fa627e5f64d9cf79755f20.sol",
        "function": "changeMessage(bytes32,string,uint8,bytes32,bytes32)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}