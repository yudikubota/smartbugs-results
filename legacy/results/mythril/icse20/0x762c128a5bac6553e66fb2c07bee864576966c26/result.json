{
  "contract": "0x762c128a5bac6553e66fb2c07bee864576966c26",
  "tool": "mythril",
  "start": 1563534097.1886425,
  "end": 1563534207.856952,
  "duration": 110.66830945014954,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1086,
        "code": " public applications;\n    Applicant[] public applic",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\ncalldata_BlockFoodPreSale_4: 0x8000\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\ncalldata_BlockFoodPreSale_4: 0x20\ncalldata_BlockFoodPreSale_0: 0x7c3bf42d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "_function_0x7c3bf42d",
        "lineno": 32,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2453,
        "code": "{\n        return ap",
        "debug": "storage_10: 0xefeffdf37a867f96606e7b17ebf65b011a6ffdf29f95dc63fffeeffefdfe075f\nstorage_11: 0x614a5da11d15fa1f04c59c566eec2c278464a23610b2cda8fa97d81955b8dc4b\ncalldata_BlockFoodPreSale_4: 0xd25869ff1d3506fb46cdd9a74cc82e77258abbb729aae79efeb21721e01c1894\nstorage_4: 0xefeffdf37a867f96606e7b17ebf65b011a6ffdf29f95dc63fffeeffefdfe075f\nstorage_0: 0x0\ncaller: 0x0\ncalldata_BlockFoodPreSale_0: 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `withdraw(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "withdraw(uint256)",
        "lineno": 217,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2933,
        "code": "    sendContractUpdateEvent\n ",
        "debug": "",
        "description": "In the function `failsafe()` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "failsafe()",
        "lineno": 252,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 3107,
        "code": "erTwoMonthsAfterTheEnd() {\n        require(now > (endDate ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8000\ntimestamp: 0x0\nstorage_4: 0x1\nstorage_8: 0x0\nstorage_10: 0x0\nstorage_2: 0x0\ncalldata_BlockFoodPreSale_0: 0x590e1ae300000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "refund()",
        "lineno": 104,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3334,
        "code": "d functions (owner only)\n    */\n\n    function reject(addre",
        "debug": "",
        "description": "In the function `refund()` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "refund()",
        "lineno": 164,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 3334,
        "code": "d functions (owner only)\n    */\n\n    function reject(addre",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function refund(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "refund()",
        "lineno": 164,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 3691,
        "code": "  }\n\n    modifier onlyPendingApplication(address applica",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8000\ncallvalue: 0x0\nstorage_2: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ntimestamp: 0x0\ncalldata_BlockFoodPreSale_0: 0x5a18ae3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "apply(string)",
        "lineno": 75,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3833,
        "code": "ibutionPending += msg.value;\n        PendingApplication(msg.sender, msg.value, ",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_BlockFoodPreSale_4 + calldata_BlockFoodPreSale_4)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncallvalue: 0x0\nstorage_2: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ntimestamp: 0x0\ncalldata_BlockFoodPreSale_0: 0x5a18ae3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\n",
        "description": "A possible integer overflow exists in the function `apply(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "apply(string)",
        "lineno": 149,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4330,
        "code": "   uint public contributionPe",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_BlockFoodPreSale_4: 0x0\nstorage_7: 0x0\ncalldata_BlockFoodPreSale_0: 0x63de532300000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "_function_0x63de5323",
        "lineno": 34,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5426,
        "code": "    modifier onlyMinCapReached() {\n        require(contri",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_BlockFoodPreSale_4: 0x8000\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_BlockFoodPreSale_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_BlockFoodPreSale_0: 0x9f00592000000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "accept(address)",
        "lineno": 83,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8323,
        "code": "tract BlockFoodPreSale {\n\n    enum ApplicationState {Unset, Pending, Rejected, Accepted, Refunded}\n\n    struct Application {\n        uint contribution;\n        string id;\n        ApplicationState state;\n    }\n\n    struct Applicant {\n        address applicant;\n        string id;\n    }\n\n    /*\n        Set by constructor\n    */\n    address public owner;\n    address public target;\n    uint public endDate;\n    uint public minContribution;\n    uint public minCap;\n    uint public maxCap;\n\n    /*\n        Set by functions\n    */\n    mapping(address => Application) public applications;\n    Applicant[] public applicants;\n    uint public contributionPending;\n    uint public contributionRejected;\n    uint public contributionAccepted;\n    uint public withdrawn;\n\n    /*\n        Events\n    */\n    event PendingApplication(address applicant, uint contribution, string id);\n    event RejectedApplication(address applicant, uint contribution, string id);\n    event AcceptedApplication(address applicant, uint contribution, string id);\n    event Withdrawn(address target, uint amount);\n    event Refund(address target, uint amount);\n    event ContractUpdate(address owner, address target, uint minContribution, uint minCap, uint maxCap);\n\n    /*\n        Modifiers\n    */\n    modifier onlyBeforeEnd() {\n        require(now <= endDate);\n        _;\n    }\n\n    modifier onlyMoreThanMinContribution() {\n        require(msg.value >= minContribution);\n        _;\n    }\n\n    modifier onlyMaxCapNotReached() {\n        require((contributionAccepted + msg.value) <= maxCap);\n        _;\n    }\n\n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyNewApplicant () {\n        require(applications[msg.sender].state == ApplicationState.Unset);\n        _;\n    }\n\n    modifier onlyPendingApplication(address applicant) {\n        require(applications[applicant].contribution > 0);\n        require(applications[applicant].state == ApplicationState.Pending);\n        _;\n    }\n\n    modifier onlyMinCapReached() {\n        require(contributionAccepted >= minCap);\n        _;\n    }\n\n    modifier onlyNotWithdrawn(uint amount) {\n        require(withdrawn + amount <= contributionAccepted);\n        _;\n    }\n\n    modifier onlyFailedPreSale() {\n        require(now >= endDate);\n        require(contributionAccepted + contributionPending < minCap);\n        _;\n    }\n\n    modifier onlyAcceptedApplication(address applicant) {\n        require(applications[applicant].state == ApplicationState.Accepted);\n        _;\n    }\n\n    modifier onlyAfterTwoMonthsAfterTheEnd() {\n        require(now > (endDate + 60 days));\n        _;\n    }\n\n    modifier sendContractUpdateEvent() {\n        _;\n        ContractUpdate(owner, target, minContribution, minCap, maxCap);\n    }\n\n    /*\n        Constructor\n    */\n    function BlockFoodPreSale(\n        address target_,\n        uint endDate_,\n        uint minContribution_,\n        uint minCap_,\n        uint maxCap_\n    )\n    public\n    {\n        owner = msg.sender;\n\n        target = target_;\n        endDate = endDate_;\n        minContribution = minContribution_;\n        minCap = minCap_;\n        maxCap = maxCap_;\n    }\n\n    /*\n       Public functions\n    */\n\n    function apply(string id)\n    payable\n    public\n    onlyBeforeEnd\n    onlyMoreThanMinContribution\n    onlyMaxCapNotReached\n    onlyNewApplicant\n    {\n        applications[msg.sender] = Application(msg.value, id, ApplicationState.Pending);\n        applicants.push(Applicant(msg.sender, id));\n        contributionPending += msg.value;\n        PendingApplication(msg.sender, msg.value, id);\n    }\n\n    function refund()\n    public\n    onlyFailedPreSale\n    onlyAcceptedApplication(msg.sender)\n    {\n        applications[msg.sender].state = ApplicationState.Refunded;\n        msg.sender.transfer(applications[msg.sender].contribution);\n        Refund(msg.sender, applications[msg.sender].contribution);\n    }\n\n    /*\n        Restricted functions (owner only)\n    */\n\n    function reject(address applicant)\n    public\n    onlyOwner\n    onlyPendingApplication(applicant)\n    {\n        applications[applicant].state = ApplicationState.Rejected;\n\n        // protection against function reentry on an overriden transfer() function\n        uint contribution = applications[applicant].contribution;\n        applications[applicant].contribution = 0;\n        applicant.transfer(contribution);\n\n        contributionPending -= contribution;\n        contributionRejected += contribution;\n\n        RejectedApplication(applicant, contribution, applications[applicant].id);\n    }\n\n    function accept(address applicant)\n    public\n    onlyOwner\n    onlyPendingApplication(applicant)\n    {\n        applications[applicant].state = ApplicationState.Accepted;\n\n        contributionPending -= applications[applicant].contribution;\n        contributionAccepted += applications[applicant].contribution;\n\n        AcceptedApplication(applicant, applications[applicant].contribution, applications[applicant].id);\n    }\n\n    function withdraw(uint amount)\n    public\n    onlyOwner\n    onlyMinCapReached\n    onlyNotWithdrawn(amount)\n    {\n        withdrawn += amount;\n        target.transfer(amount);\n        Withdrawn(target, amount);\n    }\n\n    /*\n        Views\n    */\n\n    function getApplicantsLength()\n    view\n    public\n    returns (uint)\n    {\n        return applicants.length;\n    }\n\n    function getMaximumContributionPossible()\n    view\n    public\n    returns (uint)\n    {\n        return maxCap - contributionAccepted;\n    }\n\n    /*\n        Maintenance functions\n    */\n\n    function failsafe()\n    public\n    onlyOwner\n    onlyAfterTwoMonthsAfterTheEnd\n    {\n        target.transfer(this.balance);\n    }\n\n    function changeOwner(address owner_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        owner = owner_;\n    }\n\n    function changeTarget(address target_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        target = target_;\n    }\n\n    function changeMinCap(uint minCap_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        minCap = minCap_;\n    }\n\n    function changeMaxCap(uint maxCap_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        maxCap = maxCap_;\n    }\n\n    function changeMinContribution(uint minContribution_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        minContribution = minContribution_;\n    }\n\n}",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nkeccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncallvalue: 0x0\nstorage_2: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ntimestamp: 0x0\ncalldata_BlockFoodPreSale_0: 0x5a18ae3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\n",
        "description": "A possible integer overflow exists in the function `apply(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "apply(string)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8352,
        "code": "tract BlockFoodPreSale {\n\n    enum ApplicationState {Unset, Pending, Rejected, Accepted, Refunded}\n\n    struct Application {\n        uint contribution;\n        string id;\n        ApplicationState state;\n    }\n\n    struct Applicant {\n        address applicant;\n        string id;\n    }\n\n    /*\n        Set by constructor\n    */\n    address public owner;\n    address public target;\n    uint public endDate;\n    uint public minContribution;\n    uint public minCap;\n    uint public maxCap;\n\n    /*\n        Set by functions\n    */\n    mapping(address => Application) public applications;\n    Applicant[] public applicants;\n    uint public contributionPending;\n    uint public contributionRejected;\n    uint public contributionAccepted;\n    uint public withdrawn;\n\n    /*\n        Events\n    */\n    event PendingApplication(address applicant, uint contribution, string id);\n    event RejectedApplication(address applicant, uint contribution, string id);\n    event AcceptedApplication(address applicant, uint contribution, string id);\n    event Withdrawn(address target, uint amount);\n    event Refund(address target, uint amount);\n    event ContractUpdate(address owner, address target, uint minContribution, uint minCap, uint maxCap);\n\n    /*\n        Modifiers\n    */\n    modifier onlyBeforeEnd() {\n        require(now <= endDate);\n        _;\n    }\n\n    modifier onlyMoreThanMinContribution() {\n        require(msg.value >= minContribution);\n        _;\n    }\n\n    modifier onlyMaxCapNotReached() {\n        require((contributionAccepted + msg.value) <= maxCap);\n        _;\n    }\n\n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyNewApplicant () {\n        require(applications[msg.sender].state == ApplicationState.Unset);\n        _;\n    }\n\n    modifier onlyPendingApplication(address applicant) {\n        require(applications[applicant].contribution > 0);\n        require(applications[applicant].state == ApplicationState.Pending);\n        _;\n    }\n\n    modifier onlyMinCapReached() {\n        require(contributionAccepted >= minCap);\n        _;\n    }\n\n    modifier onlyNotWithdrawn(uint amount) {\n        require(withdrawn + amount <= contributionAccepted);\n        _;\n    }\n\n    modifier onlyFailedPreSale() {\n        require(now >= endDate);\n        require(contributionAccepted + contributionPending < minCap);\n        _;\n    }\n\n    modifier onlyAcceptedApplication(address applicant) {\n        require(applications[applicant].state == ApplicationState.Accepted);\n        _;\n    }\n\n    modifier onlyAfterTwoMonthsAfterTheEnd() {\n        require(now > (endDate + 60 days));\n        _;\n    }\n\n    modifier sendContractUpdateEvent() {\n        _;\n        ContractUpdate(owner, target, minContribution, minCap, maxCap);\n    }\n\n    /*\n        Constructor\n    */\n    function BlockFoodPreSale(\n        address target_,\n        uint endDate_,\n        uint minContribution_,\n        uint minCap_,\n        uint maxCap_\n    )\n    public\n    {\n        owner = msg.sender;\n\n        target = target_;\n        endDate = endDate_;\n        minContribution = minContribution_;\n        minCap = minCap_;\n        maxCap = maxCap_;\n    }\n\n    /*\n       Public functions\n    */\n\n    function apply(string id)\n    payable\n    public\n    onlyBeforeEnd\n    onlyMoreThanMinContribution\n    onlyMaxCapNotReached\n    onlyNewApplicant\n    {\n        applications[msg.sender] = Application(msg.value, id, ApplicationState.Pending);\n        applicants.push(Applicant(msg.sender, id));\n        contributionPending += msg.value;\n        PendingApplication(msg.sender, msg.value, id);\n    }\n\n    function refund()\n    public\n    onlyFailedPreSale\n    onlyAcceptedApplication(msg.sender)\n    {\n        applications[msg.sender].state = ApplicationState.Refunded;\n        msg.sender.transfer(applications[msg.sender].contribution);\n        Refund(msg.sender, applications[msg.sender].contribution);\n    }\n\n    /*\n        Restricted functions (owner only)\n    */\n\n    function reject(address applicant)\n    public\n    onlyOwner\n    onlyPendingApplication(applicant)\n    {\n        applications[applicant].state = ApplicationState.Rejected;\n\n        // protection against function reentry on an overriden transfer() function\n        uint contribution = applications[applicant].contribution;\n        applications[applicant].contribution = 0;\n        applicant.transfer(contribution);\n\n        contributionPending -= contribution;\n        contributionRejected += contribution;\n\n        RejectedApplication(applicant, contribution, applications[applicant].id);\n    }\n\n    function accept(address applicant)\n    public\n    onlyOwner\n    onlyPendingApplication(applicant)\n    {\n        applications[applicant].state = ApplicationState.Accepted;\n\n        contributionPending -= applications[applicant].contribution;\n        contributionAccepted += applications[applicant].contribution;\n\n        AcceptedApplication(applicant, applications[applicant].contribution, applications[applicant].id);\n    }\n\n    function withdraw(uint amount)\n    public\n    onlyOwner\n    onlyMinCapReached\n    onlyNotWithdrawn(amount)\n    {\n        withdrawn += amount;\n        target.transfer(amount);\n        Withdrawn(target, amount);\n    }\n\n    /*\n        Views\n    */\n\n    function getApplicantsLength()\n    view\n    public\n    returns (uint)\n    {\n        return applicants.length;\n    }\n\n    function getMaximumContributionPossible()\n    view\n    public\n    returns (uint)\n    {\n        return maxCap - contributionAccepted;\n    }\n\n    /*\n        Maintenance functions\n    */\n\n    function failsafe()\n    public\n    onlyOwner\n    onlyAfterTwoMonthsAfterTheEnd\n    {\n        target.transfer(this.balance);\n    }\n\n    function changeOwner(address owner_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        owner = owner_;\n    }\n\n    function changeTarget(address target_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        target = target_;\n    }\n\n    function changeMinCap(uint minCap_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        minCap = minCap_;\n    }\n\n    function changeMaxCap(uint maxCap_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        maxCap = maxCap_;\n    }\n\n    function changeMinContribution(uint minContribution_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        minContribution = minContribution_;\n    }\n\n}",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_BlockFoodPreSale_4 + calldata_BlockFoodPreSale_4)) +\n32: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\nstorage_2: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ntimestamp: 0x0\ncalldata_BlockFoodPreSale_0: 0x5a18ae3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\n",
        "description": "A possible integer overflow exists in the function `apply(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "apply(string)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8366,
        "code": "tract BlockFoodPreSale {\n\n    enum ApplicationState {Unset, Pending, Rejected, Accepted, Refunded}\n\n    struct Application {\n        uint contribution;\n        string id;\n        ApplicationState state;\n    }\n\n    struct Applicant {\n        address applicant;\n        string id;\n    }\n\n    /*\n        Set by constructor\n    */\n    address public owner;\n    address public target;\n    uint public endDate;\n    uint public minContribution;\n    uint public minCap;\n    uint public maxCap;\n\n    /*\n        Set by functions\n    */\n    mapping(address => Application) public applications;\n    Applicant[] public applicants;\n    uint public contributionPending;\n    uint public contributionRejected;\n    uint public contributionAccepted;\n    uint public withdrawn;\n\n    /*\n        Events\n    */\n    event PendingApplication(address applicant, uint contribution, string id);\n    event RejectedApplication(address applicant, uint contribution, string id);\n    event AcceptedApplication(address applicant, uint contribution, string id);\n    event Withdrawn(address target, uint amount);\n    event Refund(address target, uint amount);\n    event ContractUpdate(address owner, address target, uint minContribution, uint minCap, uint maxCap);\n\n    /*\n        Modifiers\n    */\n    modifier onlyBeforeEnd() {\n        require(now <= endDate);\n        _;\n    }\n\n    modifier onlyMoreThanMinContribution() {\n        require(msg.value >= minContribution);\n        _;\n    }\n\n    modifier onlyMaxCapNotReached() {\n        require((contributionAccepted + msg.value) <= maxCap);\n        _;\n    }\n\n    modifier onlyOwner () {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier onlyNewApplicant () {\n        require(applications[msg.sender].state == ApplicationState.Unset);\n        _;\n    }\n\n    modifier onlyPendingApplication(address applicant) {\n        require(applications[applicant].contribution > 0);\n        require(applications[applicant].state == ApplicationState.Pending);\n        _;\n    }\n\n    modifier onlyMinCapReached() {\n        require(contributionAccepted >= minCap);\n        _;\n    }\n\n    modifier onlyNotWithdrawn(uint amount) {\n        require(withdrawn + amount <= contributionAccepted);\n        _;\n    }\n\n    modifier onlyFailedPreSale() {\n        require(now >= endDate);\n        require(contributionAccepted + contributionPending < minCap);\n        _;\n    }\n\n    modifier onlyAcceptedApplication(address applicant) {\n        require(applications[applicant].state == ApplicationState.Accepted);\n        _;\n    }\n\n    modifier onlyAfterTwoMonthsAfterTheEnd() {\n        require(now > (endDate + 60 days));\n        _;\n    }\n\n    modifier sendContractUpdateEvent() {\n        _;\n        ContractUpdate(owner, target, minContribution, minCap, maxCap);\n    }\n\n    /*\n        Constructor\n    */\n    function BlockFoodPreSale(\n        address target_,\n        uint endDate_,\n        uint minContribution_,\n        uint minCap_,\n        uint maxCap_\n    )\n    public\n    {\n        owner = msg.sender;\n\n        target = target_;\n        endDate = endDate_;\n        minContribution = minContribution_;\n        minCap = minCap_;\n        maxCap = maxCap_;\n    }\n\n    /*\n       Public functions\n    */\n\n    function apply(string id)\n    payable\n    public\n    onlyBeforeEnd\n    onlyMoreThanMinContribution\n    onlyMaxCapNotReached\n    onlyNewApplicant\n    {\n        applications[msg.sender] = Application(msg.value, id, ApplicationState.Pending);\n        applicants.push(Applicant(msg.sender, id));\n        contributionPending += msg.value;\n        PendingApplication(msg.sender, msg.value, id);\n    }\n\n    function refund()\n    public\n    onlyFailedPreSale\n    onlyAcceptedApplication(msg.sender)\n    {\n        applications[msg.sender].state = ApplicationState.Refunded;\n        msg.sender.transfer(applications[msg.sender].contribution);\n        Refund(msg.sender, applications[msg.sender].contribution);\n    }\n\n    /*\n        Restricted functions (owner only)\n    */\n\n    function reject(address applicant)\n    public\n    onlyOwner\n    onlyPendingApplication(applicant)\n    {\n        applications[applicant].state = ApplicationState.Rejected;\n\n        // protection against function reentry on an overriden transfer() function\n        uint contribution = applications[applicant].contribution;\n        applications[applicant].contribution = 0;\n        applicant.transfer(contribution);\n\n        contributionPending -= contribution;\n        contributionRejected += contribution;\n\n        RejectedApplication(applicant, contribution, applications[applicant].id);\n    }\n\n    function accept(address applicant)\n    public\n    onlyOwner\n    onlyPendingApplication(applicant)\n    {\n        applications[applicant].state = ApplicationState.Accepted;\n\n        contributionPending -= applications[applicant].contribution;\n        contributionAccepted += applications[applicant].contribution;\n\n        AcceptedApplication(applicant, applications[applicant].contribution, applications[applicant].id);\n    }\n\n    function withdraw(uint amount)\n    public\n    onlyOwner\n    onlyMinCapReached\n    onlyNotWithdrawn(amount)\n    {\n        withdrawn += amount;\n        target.transfer(amount);\n        Withdrawn(target, amount);\n    }\n\n    /*\n        Views\n    */\n\n    function getApplicantsLength()\n    view\n    public\n    returns (uint)\n    {\n        return applicants.length;\n    }\n\n    function getMaximumContributionPossible()\n    view\n    public\n    returns (uint)\n    {\n        return maxCap - contributionAccepted;\n    }\n\n    /*\n        Maintenance functions\n    */\n\n    function failsafe()\n    public\n    onlyOwner\n    onlyAfterTwoMonthsAfterTheEnd\n    {\n        target.transfer(this.balance);\n    }\n\n    function changeOwner(address owner_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        owner = owner_;\n    }\n\n    function changeTarget(address target_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        target = target_;\n    }\n\n    function changeMinCap(uint minCap_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        minCap = minCap_;\n    }\n\n    function changeMaxCap(uint maxCap_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        maxCap = maxCap_;\n    }\n\n    function changeMinContribution(uint minContribution_)\n    public\n    onlyOwner\n    sendContractUpdateEvent\n    {\n        minContribution = minContribution_;\n    }\n\n}",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_BlockFoodPreSale_4 + calldata_BlockFoodPreSale_4)) +\n32: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_BlockFoodPreSale_4 + calldata_BlockFoodPreSale_4)) +\n32: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\ncallvalue: 0x0\nstorage_2: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ntimestamp: 0x0\ncalldata_BlockFoodPreSale_0: 0x5a18ae3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_BlockFoodPreSale: 0x4\n",
        "description": "A possible integer overflow exists in the function `apply(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/14/0x762c128a5bac6553e66fb2c07bee864576966c26.sol",
        "function": "apply(string)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}