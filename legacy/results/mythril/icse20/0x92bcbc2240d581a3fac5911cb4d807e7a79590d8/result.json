{
  "contract": "0x92bcbc2240d581a3fac5911cb4d807e7a79590d8",
  "tool": "mythril",
  "start": 1563518854.0141637,
  "end": 1563519250.2577775,
  "duration": 396.2436137199402,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 653,
        "code": "is to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            ethBalance[msg.sender] = 0;\n            WithdrawEvent(\"Reset Sender\");\n            msg.sender.transfer(amount);\n        }\n        return true;\n    }\n\n    /// Deposit ethereum into the sender's ethBalance. Not recommended.\n    function deposit() payable\n    {\n        et",
        "debug": "calldata_Pixel_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Pixel_0: 0x12bd2cea00000000000000000000000000000000000000000000000000000000\ncalldatasize_Pixel: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setImageDataCloud(uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0x92bcbc2240d581a3fac5911cb4d807e7a79590d8.sol",
        "function": "setImageDataCloud(uint256,uint256,string)",
        "lineno": 643,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4151,
        "code": "ctions;\n    uint256 public poo",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Pixel_4: 0x2710\ncalldata_Pixel_0: 0x3560344000000000000000000000000000000000000000000000000000000000\ncalldatasize_Pixel: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/9/0x92bcbc2240d581a3fac5911cb4d807e7a79590d8.sol",
        "function": "_function_0x35603440",
        "lineno": 25,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 12924,
        "code": "ntract Pixel {\n    /* This creates an array with all balances */\n    struct Section {\n        address owner;\n        uint256 price;\n        bool for_sale;\n        bool initial_purchase_done;\n        uint image_id;\n        string md5;\n        uint last_update;\n        address sell_only_to;\n        uint16 index;\n        //bytes32[10] image_data;\n    }\n    string public standard = \"IPO 0.9\";\n    string public constant name = \"Initial Pixel Offering\";\n    string public constant symbol = \"IPO\";\n    uint8 public constant decimals = 0;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public ethBalance;\n    address owner;\n    uint256 public ipo_price;\n    Section[10000] public sections;\n    uint256 public pool;\n    uint public mapWidth;\n    uint public mapHeight;\n    uint256 tokenTotalSupply = 10000;\n\n    event Buy(uint section_id);\n    event NewListing(uint section_id, uint price);\n    event Delisted(uint section_id);\n    event NewImage(uint section_id);\n    event AreaPrice(uint start_section_index, uint end_section_index, uint area_price);\n    event SentValue(uint value);\n    event PriceUpdate(uint256 price);\n    event WithdrawEvent(string msg);\n\n    function Pixel() {\n        pool = tokenTotalSupply; //Number of token / spaces\n        ipo_price = 100000000000000000; // 0.1\n        mapWidth = 1000;\n        mapHeight = 1000;\n        owner = msg.sender;\n    }\n\n    function totalSupply() constant returns (uint totalSupply)\n    {\n        totalSupply = tokenTotalSupply;\n    }\n\n    /// Updates a pixel section's index number\n    /// Not to be called by anyone but the contract owner\n    function updatePixelIndex(\n        uint16 _start,\n        uint16 _end\n    ) {\n        if(msg.sender != owner) throw; \n        if(_end < _start) throw;\n        while(_start < _end)\n        {\n            sections[_start].index = _start;\n            _start++;\n        }\n    }\n\n    /// Update the current IPO price\n    function updateIPOPrice(\n        uint256 _new_price\n    ) {\n        if(msg.sender != owner) throw;\n        ipo_price = _new_price;\n        PriceUpdate(ipo_price);\n    }\n\n    /* Get the index to access a section object from the provided raw x,y */\n    /// Convert from a pixel's x, y coordinates to its section index\n    /// This is a helper function\n    function getSectionIndexFromRaw(\n        uint _x,\n        uint _y\n    ) returns (uint) {\n        if (_x >= mapWidth) throw;\n        if (_y >= mapHeight) throw;\n        // Convert raw x, y to section identifer x y\n        _x = _x / 10;\n        _y = _y / 10;\n        //Get section_identifier from coords\n        return _x + (_y * 100);\n    }\n\n    /* Get the index to access a section object from its section identifier */\n    /// Get Section index based on its upper left x,y coordinates or \"identifier\"\n    /// coordinates\n    /// This is a helper function\n    function getSectionIndexFromIdentifier (\n        uint _x_section_identifier,\n        uint _y_section_identifier\n    ) returns (uint) {\n        if (_x_section_identifier >= (mapWidth / 10)) throw;\n        if (_y_section_identifier >= (mapHeight / 10)) throw;\n        uint index = _x_section_identifier + (_y_section_identifier * 100);\n        return index;\n    }\n\n    /* Get x,y section_identifier from a section index */\n    /// Get Section upper left x,y coordinates or \"identifier\" coordinates\n    /// based on its index number\n    /// This is a helper function\n    function getIdentifierFromSectionIndex(\n        uint _index\n    ) returns (uint x, uint y) {\n        if (_index > (mapWidth * mapHeight)) throw;\n        x = _index % 100;\n        y = (_index - (_index % 100)) / 100;\n    }\n\n    /* Check to see if Section is available for first purchase */\n    /// Returns whether a section is available for purchase at IPO price\n    function sectionAvailable(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // The section has not been puchased previously\n        return !s.initial_purchase_done;\n    }\n\n    /* Check to see if Section is available for purchase */\n    /// Returns whether a section is available for purchase as a market sale\n    function sectionForSale(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // Has the user set the section as for_sale\n        if(s.for_sale)\n        {\n            // Has the owner set a \"sell only to\" address?\n            if(s.sell_only_to == 0x0) return true;\n            if(s.sell_only_to == msg.sender) return true;\n            return false;\n        }\n        else\n        {\n            // Not for sale\n            return false;\n        }\n    }\n\n    /* Get the price of the Section */\n    /// Returns the price of a section at market price.\n    /// This is a helper function, it is more efficient to just access the\n    /// contract's sections attribute directly\n    function sectionPrice(\n        uint _section_index\n    ) returns (uint) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        return s.price;\n    }\n\n    /*\n    Check to see if a region is available provided the\n    top-left (start) section and the bottom-right (end)\n    section.\n    */\n    /// Returns if a section is available for purchase, it returns the following:\n    /// bool: if the region is available for purchase\n    /// uint256: the extended price, sum of all of the market prices of the sections\n    ///   in the region\n    /// uint256: the number of sections available in the region at the IPO price\n    function regionAvailable(\n        uint _start_section_index,\n        uint _end_section_index\n    ) returns (bool available, uint extended_price, uint ipo_count) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        available = false;\n        extended_price = 0;\n        ipo_count = 0;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                // Is this section available for first (IPO) purchase?\n                if(sectionAvailable(identifier))\n                {\n                    // The section is available as an IPO\n                    ipo_count = ipo_count + 1;\n                } else\n                {\n                    // The section has been purchased, it can only be available\n                    // as a market sale.\n                    if(sectionForSale(identifier))\n                    {\n                        extended_price = extended_price + sectionPrice(identifier);\n                    } else\n                    {\n                        available = false;\n                        //Don't return a price if there is an unavailable section\n                        //to reduce confusion\n                        extended_price = 0;\n                        ipo_count = 0;\n                        return;\n                    }\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        available = true;\n        return;\n    }\n\n    /// Buy a section based on its index and set its cloud image_id and md5\n    /// This function is payable, any over payment will be withdraw-able\n    function buySection (\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) payable {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(!section.for_sale && section.initial_purchase_done)\n        {\n            //Section not for sale\n            throw;\n        }\n        // Process payment\n        // Is this Section on the open market?\n        if(section.initial_purchase_done)\n        {\n            // Section sold, sell for market price\n            if(msg.value < section.price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Calculate Fee\n                // We only need to change the balance if the section price is non-zero\n                if (section.price != 0)\n                {\n                    uint fee = section.price / 100;\n                    // Pay contract owner the fee\n                    ethBalance[owner] += fee;\n                    // Pay the section owner the price minus the fee\n                    ethBalance[section.owner] += (msg.value - fee);\n                }\n                // Refund any overpayment\n                //require(msg.value > (msg.value - section.price));\n                ethBalance[msg.sender] += (msg.value - section.price);\n                // Owner loses a token\n                balanceOf[section.owner]--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        } else\n        {\n            // Initial sale, sell for IPO price\n            if(msg.value < ipo_price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Pay the contract owner\n                ethBalance[owner] += msg.value;\n                // Refund any overpayment\n                //require(msg.value > (msg.value - ipo_price));\n                ethBalance[msg.sender] += (msg.value - ipo_price);\n                // Reduce token pool\n                pool--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        }\n        //Payment and token transfer complete\n        //Transfer ownership and set not for sale by default\n        section.owner = msg.sender;\n        section.md5 = _md5;\n        section.image_id = _image_id;\n        section.last_update = block.timestamp;\n        section.for_sale = false;\n        section.initial_purchase_done = true; // even if not the first, we can pretend it is\n    }\n\n    /* Buy an entire region */\n    /// Buy a region of sections starting and including the top left section index\n    /// ending at and including the bottom left section index. And set its cloud\n    /// image_id and md5. This function is payable, if the value sent is less\n    /// than the price of the region, the function will throw.\n    function buyRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) payable returns (uint start_section_y, uint start_section_x,\n    uint end_section_y, uint end_section_x){\n        if (_end_section_index < _start_section_index) throw;\n        if (_start_section_index >= sections.length) throw;\n        if (_end_section_index >= sections.length) throw;\n        // ico_ammount reffers to the number of sections that are available\n        // at ICO price\n        var (available, ext_price, ico_amount) = regionAvailable(_start_section_index, _end_section_index);\n        if (!available) throw;\n\n        // Calculate price\n        uint area_price =  ico_amount * ipo_price;\n        area_price = area_price + ext_price;\n        AreaPrice(_start_section_index, _end_section_index, area_price);\n        SentValue(msg.value);\n        if (area_price > msg.value) throw;\n\n        // ico_ammount reffers to the amount in wei that the contract owner\n        // is owed\n        ico_amount = 0;\n        // ext_price reffers to the amount in wei that the contract owner is\n        // owed in fees from market sales\n        ext_price = 0;\n\n        // User sent enough funds, let's go\n        start_section_x = _start_section_index % 100;\n        end_section_x = _end_section_index % 100;\n        start_section_y = _start_section_index - (_start_section_index % 100);\n        start_section_y = start_section_y / 100;\n        end_section_y = _end_section_index - (_end_section_index % 100);\n        end_section_y = end_section_y / 100;\n        uint x_pos = start_section_x;\n        while (x_pos <= end_section_x)\n        {\n            uint y_pos = start_section_y;\n            while (y_pos <= end_section_y)\n            {\n                // Is this an IPO section?\n                Section s = sections[x_pos + (y_pos * 100)];\n                if (s.initial_purchase_done)\n                {\n                    // Sale, we need to transfer balance\n                    // We only need to modify balances if the section's price\n                    // is non-zero\n                    if(s.price != 0)\n                    {\n                        // Pay the contract owner the price\n                        ethBalance[owner] += (s.price / 100);\n                        // Pay the owner the price minus the fee\n                        ethBalance[s.owner] += (s.price - (s.price / 100));\n                    }\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - s.price)) throw;\n                    ext_price += s.price;\n                    // Owner loses a token\n                    balanceOf[s.owner]--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                } else\n                {\n                    // IPO we get to keep the value\n                    // Pay the contract owner\n                    ethBalance[owner] += ipo_price;\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - ipo_price)) throw;\n                    // TODO Decrease the value\n                    ico_amount += ipo_price;\n                    // Reduce token pool\n                    pool--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                }\n\n                // Payment and token transfer complete\n                // Transfer ownership and set not for sale by default\n                s.owner = msg.sender;\n                s.md5 = _md5;\n                s.image_id = _image_id;\n                //s.last_update = block.timestamp;\n                s.for_sale = false;\n                s.initial_purchase_done = true; // even if not the first, we can pretend it is\n\n                Buy(x_pos + (y_pos * 100));\n                // Done\n                y_pos = y_pos + 1;\n            }\n            x_pos = x_pos + 1;\n        }\n        ethBalance[msg.sender] += msg.value - (ext_price + ico_amount);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section */\n    /// Set an inidividual section as for sale at the provided price in wei.\n    /// The section will be available for purchase by any address.\n    function setSectionForSale(\n        uint _section_index,\n        uint256 _price\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = 0x0;\n        NewListing(_section_index, _price);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region for sale at the provided price in wei.\n    /// The sections in the region will be available for purchase by any address.\n    function setRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = 0x0;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region starting in the top left at the supplied start section\n    /// index to and including the supplied bottom right end section index\n    /// for sale at the provided price in wei, to the provided address.\n    /// The sections in the region will be available for purchase only by the\n    /// provided address.\n    function setRegionForSaleToAddress(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price,\n        address _only_sell_to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = _only_sell_to;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /*\n    Set an entire region's cloud image data\n    */\n    /// Update a region of sections' cloud image_id and md5 to be redrawn on the\n    /// map starting at the top left start section index to and including the\n    /// bottom right section index. Fires a NewImage event with the top left\n    /// section index. If any sections not owned by the sender are in the region\n    /// they are ignored.\n    function setRegionImageDataCloud(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                Section s = sections[identifier];\n                if(s.owner == msg.sender)\n                {\n                    s.image_id = _image_id;\n                    s.md5 = _md5;\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        NewImage(_start_section_index);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section to a specific address */\n    /// Set a single section as for sale at the provided price in wei only\n    /// to the supplied address.\n    function setSectionForSaleToAddress(\n        uint _section_index,\n        uint256 _price,\n        address _to\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = _to;\n        NewListing(_section_index, _price);\n    }\n\n    /* Remove the for sale flag from a section */\n    /// Delist a section for sale. Making it no longer available on the market.\n    function unsetSectionForSale(\n        uint _section_index\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.for_sale = false;\n        section.price = 0;\n        section.sell_only_to = 0x0;\n        Delisted(_section_index);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Delist a region of sections for sale. Making the sections no longer\n    /// no longer available on the market.\n    function unsetRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.for_sale = false;\n                    section.price = 0;\n                    Delisted(x_pos + (y_pos * 100));\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /// Depreciated. Store the raw image data in the contract.\n    function setImageData(\n        uint _section_index\n        // bytes32 _row_zero,\n        // bytes32 _row_one,\n        // bytes32 _row_two,\n        // bytes32 _row_three,\n        // bytes32 _row_four,\n        // bytes32 _row_five,\n        // bytes32 _row_six,\n        // bytes32 _row_seven,\n        // bytes32 _row_eight,\n        // bytes32 _row_nine\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        // section.image_data[0] = _row_zero;\n        // section.image_data[1] = _row_one;\n        // section.image_data[2] = _row_two;\n        // section.image_data[3] = _row_three;\n        // section.image_data[4] = _row_four;\n        // section.image_data[5] = _row_five;\n        // section.image_data[6] = _row_six;\n        // section.image_data[7] = _row_seven;\n        // section.image_data[8] = _row_eight;\n        // section.image_data[9] = _row_nine;\n        section.image_id = 0;\n        section.md5 = \"\";\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Set a section's image data to be redrawn on the map. Fires a NewImage\n    /// event.\n    function setImageDataCloud(\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.image_id = _image_id;\n        section.md5 = _md5;\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Withdraw ethereum from the sender's ethBalance.\n    function withdraw() returns (bool) {\n        var amount = ethBalance[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            ethBalance[msg.sender] = 0;\n            WithdrawEvent(\"Reset Sender\");\n            msg.sender.transfer(amount);\n        }\n        return true;\n    }\n\n    /// Deposit ethereum into the sender's ethBalance. Not recommended.\n    function deposit() payable\n    {\n        ethBalance[msg.sender] += msg.value;\n    }\n\n    /// Transfer a section and an IPO token to the supplied address.\n    function transfer(\n      address _to,\n      uint _section_index\n    ) {\n        if (_section_index > 9999) throw;\n        if (sections[_section_index].owner != msg.sender) throw;\n        if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n        sections[_section_index].owner = _to;\n        sections[_section_index].for_sale = false;\n        balanceOf[msg.sender] -= 1;\n        balanceOf[_to] += 1;\n    }\n\n\n\n    /// Transfer a region of sections and IPO tokens to the supplied address.\n    function transferRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        address _to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                  if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n                  section.owner = _to;\n                  section.for_sale = false;\n                  balanceOf[msg.sender] -= 1;\n                  balanceOf[_to] += 1;\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n}",
        "debug": "keccac_4_+_5_+_7*calldata_Pixel_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_4 + 5 + 7*calldata_Pixel_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncaller: 0x0\nstorage_0 + 5 + 7*calldata_Pixel_4: 0x0\ncalldata_Pixel_4: 0x270f\ncalldata_Pixel_0: 0x27836f7700000000000000000000000000000000000000000000000000000000\ncalldatasize_Pixel: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x27836f77`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0x92bcbc2240d581a3fac5911cb4d807e7a79590d8.sol",
        "function": "_function_0x27836f77",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 12953,
        "code": "ntract Pixel {\n    /* This creates an array with all balances */\n    struct Section {\n        address owner;\n        uint256 price;\n        bool for_sale;\n        bool initial_purchase_done;\n        uint image_id;\n        string md5;\n        uint last_update;\n        address sell_only_to;\n        uint16 index;\n        //bytes32[10] image_data;\n    }\n    string public standard = \"IPO 0.9\";\n    string public constant name = \"Initial Pixel Offering\";\n    string public constant symbol = \"IPO\";\n    uint8 public constant decimals = 0;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public ethBalance;\n    address owner;\n    uint256 public ipo_price;\n    Section[10000] public sections;\n    uint256 public pool;\n    uint public mapWidth;\n    uint public mapHeight;\n    uint256 tokenTotalSupply = 10000;\n\n    event Buy(uint section_id);\n    event NewListing(uint section_id, uint price);\n    event Delisted(uint section_id);\n    event NewImage(uint section_id);\n    event AreaPrice(uint start_section_index, uint end_section_index, uint area_price);\n    event SentValue(uint value);\n    event PriceUpdate(uint256 price);\n    event WithdrawEvent(string msg);\n\n    function Pixel() {\n        pool = tokenTotalSupply; //Number of token / spaces\n        ipo_price = 100000000000000000; // 0.1\n        mapWidth = 1000;\n        mapHeight = 1000;\n        owner = msg.sender;\n    }\n\n    function totalSupply() constant returns (uint totalSupply)\n    {\n        totalSupply = tokenTotalSupply;\n    }\n\n    /// Updates a pixel section's index number\n    /// Not to be called by anyone but the contract owner\n    function updatePixelIndex(\n        uint16 _start,\n        uint16 _end\n    ) {\n        if(msg.sender != owner) throw; \n        if(_end < _start) throw;\n        while(_start < _end)\n        {\n            sections[_start].index = _start;\n            _start++;\n        }\n    }\n\n    /// Update the current IPO price\n    function updateIPOPrice(\n        uint256 _new_price\n    ) {\n        if(msg.sender != owner) throw;\n        ipo_price = _new_price;\n        PriceUpdate(ipo_price);\n    }\n\n    /* Get the index to access a section object from the provided raw x,y */\n    /// Convert from a pixel's x, y coordinates to its section index\n    /// This is a helper function\n    function getSectionIndexFromRaw(\n        uint _x,\n        uint _y\n    ) returns (uint) {\n        if (_x >= mapWidth) throw;\n        if (_y >= mapHeight) throw;\n        // Convert raw x, y to section identifer x y\n        _x = _x / 10;\n        _y = _y / 10;\n        //Get section_identifier from coords\n        return _x + (_y * 100);\n    }\n\n    /* Get the index to access a section object from its section identifier */\n    /// Get Section index based on its upper left x,y coordinates or \"identifier\"\n    /// coordinates\n    /// This is a helper function\n    function getSectionIndexFromIdentifier (\n        uint _x_section_identifier,\n        uint _y_section_identifier\n    ) returns (uint) {\n        if (_x_section_identifier >= (mapWidth / 10)) throw;\n        if (_y_section_identifier >= (mapHeight / 10)) throw;\n        uint index = _x_section_identifier + (_y_section_identifier * 100);\n        return index;\n    }\n\n    /* Get x,y section_identifier from a section index */\n    /// Get Section upper left x,y coordinates or \"identifier\" coordinates\n    /// based on its index number\n    /// This is a helper function\n    function getIdentifierFromSectionIndex(\n        uint _index\n    ) returns (uint x, uint y) {\n        if (_index > (mapWidth * mapHeight)) throw;\n        x = _index % 100;\n        y = (_index - (_index % 100)) / 100;\n    }\n\n    /* Check to see if Section is available for first purchase */\n    /// Returns whether a section is available for purchase at IPO price\n    function sectionAvailable(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // The section has not been puchased previously\n        return !s.initial_purchase_done;\n    }\n\n    /* Check to see if Section is available for purchase */\n    /// Returns whether a section is available for purchase as a market sale\n    function sectionForSale(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // Has the user set the section as for_sale\n        if(s.for_sale)\n        {\n            // Has the owner set a \"sell only to\" address?\n            if(s.sell_only_to == 0x0) return true;\n            if(s.sell_only_to == msg.sender) return true;\n            return false;\n        }\n        else\n        {\n            // Not for sale\n            return false;\n        }\n    }\n\n    /* Get the price of the Section */\n    /// Returns the price of a section at market price.\n    /// This is a helper function, it is more efficient to just access the\n    /// contract's sections attribute directly\n    function sectionPrice(\n        uint _section_index\n    ) returns (uint) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        return s.price;\n    }\n\n    /*\n    Check to see if a region is available provided the\n    top-left (start) section and the bottom-right (end)\n    section.\n    */\n    /// Returns if a section is available for purchase, it returns the following:\n    /// bool: if the region is available for purchase\n    /// uint256: the extended price, sum of all of the market prices of the sections\n    ///   in the region\n    /// uint256: the number of sections available in the region at the IPO price\n    function regionAvailable(\n        uint _start_section_index,\n        uint _end_section_index\n    ) returns (bool available, uint extended_price, uint ipo_count) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        available = false;\n        extended_price = 0;\n        ipo_count = 0;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                // Is this section available for first (IPO) purchase?\n                if(sectionAvailable(identifier))\n                {\n                    // The section is available as an IPO\n                    ipo_count = ipo_count + 1;\n                } else\n                {\n                    // The section has been purchased, it can only be available\n                    // as a market sale.\n                    if(sectionForSale(identifier))\n                    {\n                        extended_price = extended_price + sectionPrice(identifier);\n                    } else\n                    {\n                        available = false;\n                        //Don't return a price if there is an unavailable section\n                        //to reduce confusion\n                        extended_price = 0;\n                        ipo_count = 0;\n                        return;\n                    }\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        available = true;\n        return;\n    }\n\n    /// Buy a section based on its index and set its cloud image_id and md5\n    /// This function is payable, any over payment will be withdraw-able\n    function buySection (\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) payable {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(!section.for_sale && section.initial_purchase_done)\n        {\n            //Section not for sale\n            throw;\n        }\n        // Process payment\n        // Is this Section on the open market?\n        if(section.initial_purchase_done)\n        {\n            // Section sold, sell for market price\n            if(msg.value < section.price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Calculate Fee\n                // We only need to change the balance if the section price is non-zero\n                if (section.price != 0)\n                {\n                    uint fee = section.price / 100;\n                    // Pay contract owner the fee\n                    ethBalance[owner] += fee;\n                    // Pay the section owner the price minus the fee\n                    ethBalance[section.owner] += (msg.value - fee);\n                }\n                // Refund any overpayment\n                //require(msg.value > (msg.value - section.price));\n                ethBalance[msg.sender] += (msg.value - section.price);\n                // Owner loses a token\n                balanceOf[section.owner]--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        } else\n        {\n            // Initial sale, sell for IPO price\n            if(msg.value < ipo_price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Pay the contract owner\n                ethBalance[owner] += msg.value;\n                // Refund any overpayment\n                //require(msg.value > (msg.value - ipo_price));\n                ethBalance[msg.sender] += (msg.value - ipo_price);\n                // Reduce token pool\n                pool--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        }\n        //Payment and token transfer complete\n        //Transfer ownership and set not for sale by default\n        section.owner = msg.sender;\n        section.md5 = _md5;\n        section.image_id = _image_id;\n        section.last_update = block.timestamp;\n        section.for_sale = false;\n        section.initial_purchase_done = true; // even if not the first, we can pretend it is\n    }\n\n    /* Buy an entire region */\n    /// Buy a region of sections starting and including the top left section index\n    /// ending at and including the bottom left section index. And set its cloud\n    /// image_id and md5. This function is payable, if the value sent is less\n    /// than the price of the region, the function will throw.\n    function buyRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) payable returns (uint start_section_y, uint start_section_x,\n    uint end_section_y, uint end_section_x){\n        if (_end_section_index < _start_section_index) throw;\n        if (_start_section_index >= sections.length) throw;\n        if (_end_section_index >= sections.length) throw;\n        // ico_ammount reffers to the number of sections that are available\n        // at ICO price\n        var (available, ext_price, ico_amount) = regionAvailable(_start_section_index, _end_section_index);\n        if (!available) throw;\n\n        // Calculate price\n        uint area_price =  ico_amount * ipo_price;\n        area_price = area_price + ext_price;\n        AreaPrice(_start_section_index, _end_section_index, area_price);\n        SentValue(msg.value);\n        if (area_price > msg.value) throw;\n\n        // ico_ammount reffers to the amount in wei that the contract owner\n        // is owed\n        ico_amount = 0;\n        // ext_price reffers to the amount in wei that the contract owner is\n        // owed in fees from market sales\n        ext_price = 0;\n\n        // User sent enough funds, let's go\n        start_section_x = _start_section_index % 100;\n        end_section_x = _end_section_index % 100;\n        start_section_y = _start_section_index - (_start_section_index % 100);\n        start_section_y = start_section_y / 100;\n        end_section_y = _end_section_index - (_end_section_index % 100);\n        end_section_y = end_section_y / 100;\n        uint x_pos = start_section_x;\n        while (x_pos <= end_section_x)\n        {\n            uint y_pos = start_section_y;\n            while (y_pos <= end_section_y)\n            {\n                // Is this an IPO section?\n                Section s = sections[x_pos + (y_pos * 100)];\n                if (s.initial_purchase_done)\n                {\n                    // Sale, we need to transfer balance\n                    // We only need to modify balances if the section's price\n                    // is non-zero\n                    if(s.price != 0)\n                    {\n                        // Pay the contract owner the price\n                        ethBalance[owner] += (s.price / 100);\n                        // Pay the owner the price minus the fee\n                        ethBalance[s.owner] += (s.price - (s.price / 100));\n                    }\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - s.price)) throw;\n                    ext_price += s.price;\n                    // Owner loses a token\n                    balanceOf[s.owner]--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                } else\n                {\n                    // IPO we get to keep the value\n                    // Pay the contract owner\n                    ethBalance[owner] += ipo_price;\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - ipo_price)) throw;\n                    // TODO Decrease the value\n                    ico_amount += ipo_price;\n                    // Reduce token pool\n                    pool--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                }\n\n                // Payment and token transfer complete\n                // Transfer ownership and set not for sale by default\n                s.owner = msg.sender;\n                s.md5 = _md5;\n                s.image_id = _image_id;\n                //s.last_update = block.timestamp;\n                s.for_sale = false;\n                s.initial_purchase_done = true; // even if not the first, we can pretend it is\n\n                Buy(x_pos + (y_pos * 100));\n                // Done\n                y_pos = y_pos + 1;\n            }\n            x_pos = x_pos + 1;\n        }\n        ethBalance[msg.sender] += msg.value - (ext_price + ico_amount);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section */\n    /// Set an inidividual section as for sale at the provided price in wei.\n    /// The section will be available for purchase by any address.\n    function setSectionForSale(\n        uint _section_index,\n        uint256 _price\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = 0x0;\n        NewListing(_section_index, _price);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region for sale at the provided price in wei.\n    /// The sections in the region will be available for purchase by any address.\n    function setRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = 0x0;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region starting in the top left at the supplied start section\n    /// index to and including the supplied bottom right end section index\n    /// for sale at the provided price in wei, to the provided address.\n    /// The sections in the region will be available for purchase only by the\n    /// provided address.\n    function setRegionForSaleToAddress(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price,\n        address _only_sell_to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = _only_sell_to;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /*\n    Set an entire region's cloud image data\n    */\n    /// Update a region of sections' cloud image_id and md5 to be redrawn on the\n    /// map starting at the top left start section index to and including the\n    /// bottom right section index. Fires a NewImage event with the top left\n    /// section index. If any sections not owned by the sender are in the region\n    /// they are ignored.\n    function setRegionImageDataCloud(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                Section s = sections[identifier];\n                if(s.owner == msg.sender)\n                {\n                    s.image_id = _image_id;\n                    s.md5 = _md5;\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        NewImage(_start_section_index);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section to a specific address */\n    /// Set a single section as for sale at the provided price in wei only\n    /// to the supplied address.\n    function setSectionForSaleToAddress(\n        uint _section_index,\n        uint256 _price,\n        address _to\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = _to;\n        NewListing(_section_index, _price);\n    }\n\n    /* Remove the for sale flag from a section */\n    /// Delist a section for sale. Making it no longer available on the market.\n    function unsetSectionForSale(\n        uint _section_index\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.for_sale = false;\n        section.price = 0;\n        section.sell_only_to = 0x0;\n        Delisted(_section_index);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Delist a region of sections for sale. Making the sections no longer\n    /// no longer available on the market.\n    function unsetRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.for_sale = false;\n                    section.price = 0;\n                    Delisted(x_pos + (y_pos * 100));\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /// Depreciated. Store the raw image data in the contract.\n    function setImageData(\n        uint _section_index\n        // bytes32 _row_zero,\n        // bytes32 _row_one,\n        // bytes32 _row_two,\n        // bytes32 _row_three,\n        // bytes32 _row_four,\n        // bytes32 _row_five,\n        // bytes32 _row_six,\n        // bytes32 _row_seven,\n        // bytes32 _row_eight,\n        // bytes32 _row_nine\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        // section.image_data[0] = _row_zero;\n        // section.image_data[1] = _row_one;\n        // section.image_data[2] = _row_two;\n        // section.image_data[3] = _row_three;\n        // section.image_data[4] = _row_four;\n        // section.image_data[5] = _row_five;\n        // section.image_data[6] = _row_six;\n        // section.image_data[7] = _row_seven;\n        // section.image_data[8] = _row_eight;\n        // section.image_data[9] = _row_nine;\n        section.image_id = 0;\n        section.md5 = \"\";\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Set a section's image data to be redrawn on the map. Fires a NewImage\n    /// event.\n    function setImageDataCloud(\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.image_id = _image_id;\n        section.md5 = _md5;\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Withdraw ethereum from the sender's ethBalance.\n    function withdraw() returns (bool) {\n        var amount = ethBalance[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            ethBalance[msg.sender] = 0;\n            WithdrawEvent(\"Reset Sender\");\n            msg.sender.transfer(amount);\n        }\n        return true;\n    }\n\n    /// Deposit ethereum into the sender's ethBalance. Not recommended.\n    function deposit() payable\n    {\n        ethBalance[msg.sender] += msg.value;\n    }\n\n    /// Transfer a section and an IPO token to the supplied address.\n    function transfer(\n      address _to,\n      uint _section_index\n    ) {\n        if (_section_index > 9999) throw;\n        if (sections[_section_index].owner != msg.sender) throw;\n        if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n        sections[_section_index].owner = _to;\n        sections[_section_index].for_sale = false;\n        balanceOf[msg.sender] -= 1;\n        balanceOf[_to] += 1;\n    }\n\n\n\n    /// Transfer a region of sections and IPO tokens to the supplied address.\n    function transferRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        address _to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                  if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n                  section.owner = _to;\n                  section.for_sale = false;\n                  balanceOf[msg.sender] -= 1;\n                  balanceOf[_to] += 1;\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n}",
        "debug": "calldata_Pixel_4 + calldata_Pixel_32 + 36: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0x0\nstorage_0 + 5 + 7*calldata_Pixel_4: 0x0\ncalldata_Pixel_4: 0x270f\ncalldata_Pixel_0: 0x12bd2cea00000000000000000000000000000000000000000000000000000000\ncalldatasize_Pixel: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setImageDataCloud(uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0x92bcbc2240d581a3fac5911cb4d807e7a79590d8.sol",
        "function": "setImageDataCloud(uint256,uint256,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 12967,
        "code": "ntract Pixel {\n    /* This creates an array with all balances */\n    struct Section {\n        address owner;\n        uint256 price;\n        bool for_sale;\n        bool initial_purchase_done;\n        uint image_id;\n        string md5;\n        uint last_update;\n        address sell_only_to;\n        uint16 index;\n        //bytes32[10] image_data;\n    }\n    string public standard = \"IPO 0.9\";\n    string public constant name = \"Initial Pixel Offering\";\n    string public constant symbol = \"IPO\";\n    uint8 public constant decimals = 0;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public ethBalance;\n    address owner;\n    uint256 public ipo_price;\n    Section[10000] public sections;\n    uint256 public pool;\n    uint public mapWidth;\n    uint public mapHeight;\n    uint256 tokenTotalSupply = 10000;\n\n    event Buy(uint section_id);\n    event NewListing(uint section_id, uint price);\n    event Delisted(uint section_id);\n    event NewImage(uint section_id);\n    event AreaPrice(uint start_section_index, uint end_section_index, uint area_price);\n    event SentValue(uint value);\n    event PriceUpdate(uint256 price);\n    event WithdrawEvent(string msg);\n\n    function Pixel() {\n        pool = tokenTotalSupply; //Number of token / spaces\n        ipo_price = 100000000000000000; // 0.1\n        mapWidth = 1000;\n        mapHeight = 1000;\n        owner = msg.sender;\n    }\n\n    function totalSupply() constant returns (uint totalSupply)\n    {\n        totalSupply = tokenTotalSupply;\n    }\n\n    /// Updates a pixel section's index number\n    /// Not to be called by anyone but the contract owner\n    function updatePixelIndex(\n        uint16 _start,\n        uint16 _end\n    ) {\n        if(msg.sender != owner) throw; \n        if(_end < _start) throw;\n        while(_start < _end)\n        {\n            sections[_start].index = _start;\n            _start++;\n        }\n    }\n\n    /// Update the current IPO price\n    function updateIPOPrice(\n        uint256 _new_price\n    ) {\n        if(msg.sender != owner) throw;\n        ipo_price = _new_price;\n        PriceUpdate(ipo_price);\n    }\n\n    /* Get the index to access a section object from the provided raw x,y */\n    /// Convert from a pixel's x, y coordinates to its section index\n    /// This is a helper function\n    function getSectionIndexFromRaw(\n        uint _x,\n        uint _y\n    ) returns (uint) {\n        if (_x >= mapWidth) throw;\n        if (_y >= mapHeight) throw;\n        // Convert raw x, y to section identifer x y\n        _x = _x / 10;\n        _y = _y / 10;\n        //Get section_identifier from coords\n        return _x + (_y * 100);\n    }\n\n    /* Get the index to access a section object from its section identifier */\n    /// Get Section index based on its upper left x,y coordinates or \"identifier\"\n    /// coordinates\n    /// This is a helper function\n    function getSectionIndexFromIdentifier (\n        uint _x_section_identifier,\n        uint _y_section_identifier\n    ) returns (uint) {\n        if (_x_section_identifier >= (mapWidth / 10)) throw;\n        if (_y_section_identifier >= (mapHeight / 10)) throw;\n        uint index = _x_section_identifier + (_y_section_identifier * 100);\n        return index;\n    }\n\n    /* Get x,y section_identifier from a section index */\n    /// Get Section upper left x,y coordinates or \"identifier\" coordinates\n    /// based on its index number\n    /// This is a helper function\n    function getIdentifierFromSectionIndex(\n        uint _index\n    ) returns (uint x, uint y) {\n        if (_index > (mapWidth * mapHeight)) throw;\n        x = _index % 100;\n        y = (_index - (_index % 100)) / 100;\n    }\n\n    /* Check to see if Section is available for first purchase */\n    /// Returns whether a section is available for purchase at IPO price\n    function sectionAvailable(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // The section has not been puchased previously\n        return !s.initial_purchase_done;\n    }\n\n    /* Check to see if Section is available for purchase */\n    /// Returns whether a section is available for purchase as a market sale\n    function sectionForSale(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // Has the user set the section as for_sale\n        if(s.for_sale)\n        {\n            // Has the owner set a \"sell only to\" address?\n            if(s.sell_only_to == 0x0) return true;\n            if(s.sell_only_to == msg.sender) return true;\n            return false;\n        }\n        else\n        {\n            // Not for sale\n            return false;\n        }\n    }\n\n    /* Get the price of the Section */\n    /// Returns the price of a section at market price.\n    /// This is a helper function, it is more efficient to just access the\n    /// contract's sections attribute directly\n    function sectionPrice(\n        uint _section_index\n    ) returns (uint) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        return s.price;\n    }\n\n    /*\n    Check to see if a region is available provided the\n    top-left (start) section and the bottom-right (end)\n    section.\n    */\n    /// Returns if a section is available for purchase, it returns the following:\n    /// bool: if the region is available for purchase\n    /// uint256: the extended price, sum of all of the market prices of the sections\n    ///   in the region\n    /// uint256: the number of sections available in the region at the IPO price\n    function regionAvailable(\n        uint _start_section_index,\n        uint _end_section_index\n    ) returns (bool available, uint extended_price, uint ipo_count) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        available = false;\n        extended_price = 0;\n        ipo_count = 0;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                // Is this section available for first (IPO) purchase?\n                if(sectionAvailable(identifier))\n                {\n                    // The section is available as an IPO\n                    ipo_count = ipo_count + 1;\n                } else\n                {\n                    // The section has been purchased, it can only be available\n                    // as a market sale.\n                    if(sectionForSale(identifier))\n                    {\n                        extended_price = extended_price + sectionPrice(identifier);\n                    } else\n                    {\n                        available = false;\n                        //Don't return a price if there is an unavailable section\n                        //to reduce confusion\n                        extended_price = 0;\n                        ipo_count = 0;\n                        return;\n                    }\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        available = true;\n        return;\n    }\n\n    /// Buy a section based on its index and set its cloud image_id and md5\n    /// This function is payable, any over payment will be withdraw-able\n    function buySection (\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) payable {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(!section.for_sale && section.initial_purchase_done)\n        {\n            //Section not for sale\n            throw;\n        }\n        // Process payment\n        // Is this Section on the open market?\n        if(section.initial_purchase_done)\n        {\n            // Section sold, sell for market price\n            if(msg.value < section.price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Calculate Fee\n                // We only need to change the balance if the section price is non-zero\n                if (section.price != 0)\n                {\n                    uint fee = section.price / 100;\n                    // Pay contract owner the fee\n                    ethBalance[owner] += fee;\n                    // Pay the section owner the price minus the fee\n                    ethBalance[section.owner] += (msg.value - fee);\n                }\n                // Refund any overpayment\n                //require(msg.value > (msg.value - section.price));\n                ethBalance[msg.sender] += (msg.value - section.price);\n                // Owner loses a token\n                balanceOf[section.owner]--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        } else\n        {\n            // Initial sale, sell for IPO price\n            if(msg.value < ipo_price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Pay the contract owner\n                ethBalance[owner] += msg.value;\n                // Refund any overpayment\n                //require(msg.value > (msg.value - ipo_price));\n                ethBalance[msg.sender] += (msg.value - ipo_price);\n                // Reduce token pool\n                pool--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        }\n        //Payment and token transfer complete\n        //Transfer ownership and set not for sale by default\n        section.owner = msg.sender;\n        section.md5 = _md5;\n        section.image_id = _image_id;\n        section.last_update = block.timestamp;\n        section.for_sale = false;\n        section.initial_purchase_done = true; // even if not the first, we can pretend it is\n    }\n\n    /* Buy an entire region */\n    /// Buy a region of sections starting and including the top left section index\n    /// ending at and including the bottom left section index. And set its cloud\n    /// image_id and md5. This function is payable, if the value sent is less\n    /// than the price of the region, the function will throw.\n    function buyRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) payable returns (uint start_section_y, uint start_section_x,\n    uint end_section_y, uint end_section_x){\n        if (_end_section_index < _start_section_index) throw;\n        if (_start_section_index >= sections.length) throw;\n        if (_end_section_index >= sections.length) throw;\n        // ico_ammount reffers to the number of sections that are available\n        // at ICO price\n        var (available, ext_price, ico_amount) = regionAvailable(_start_section_index, _end_section_index);\n        if (!available) throw;\n\n        // Calculate price\n        uint area_price =  ico_amount * ipo_price;\n        area_price = area_price + ext_price;\n        AreaPrice(_start_section_index, _end_section_index, area_price);\n        SentValue(msg.value);\n        if (area_price > msg.value) throw;\n\n        // ico_ammount reffers to the amount in wei that the contract owner\n        // is owed\n        ico_amount = 0;\n        // ext_price reffers to the amount in wei that the contract owner is\n        // owed in fees from market sales\n        ext_price = 0;\n\n        // User sent enough funds, let's go\n        start_section_x = _start_section_index % 100;\n        end_section_x = _end_section_index % 100;\n        start_section_y = _start_section_index - (_start_section_index % 100);\n        start_section_y = start_section_y / 100;\n        end_section_y = _end_section_index - (_end_section_index % 100);\n        end_section_y = end_section_y / 100;\n        uint x_pos = start_section_x;\n        while (x_pos <= end_section_x)\n        {\n            uint y_pos = start_section_y;\n            while (y_pos <= end_section_y)\n            {\n                // Is this an IPO section?\n                Section s = sections[x_pos + (y_pos * 100)];\n                if (s.initial_purchase_done)\n                {\n                    // Sale, we need to transfer balance\n                    // We only need to modify balances if the section's price\n                    // is non-zero\n                    if(s.price != 0)\n                    {\n                        // Pay the contract owner the price\n                        ethBalance[owner] += (s.price / 100);\n                        // Pay the owner the price minus the fee\n                        ethBalance[s.owner] += (s.price - (s.price / 100));\n                    }\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - s.price)) throw;\n                    ext_price += s.price;\n                    // Owner loses a token\n                    balanceOf[s.owner]--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                } else\n                {\n                    // IPO we get to keep the value\n                    // Pay the contract owner\n                    ethBalance[owner] += ipo_price;\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - ipo_price)) throw;\n                    // TODO Decrease the value\n                    ico_amount += ipo_price;\n                    // Reduce token pool\n                    pool--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                }\n\n                // Payment and token transfer complete\n                // Transfer ownership and set not for sale by default\n                s.owner = msg.sender;\n                s.md5 = _md5;\n                s.image_id = _image_id;\n                //s.last_update = block.timestamp;\n                s.for_sale = false;\n                s.initial_purchase_done = true; // even if not the first, we can pretend it is\n\n                Buy(x_pos + (y_pos * 100));\n                // Done\n                y_pos = y_pos + 1;\n            }\n            x_pos = x_pos + 1;\n        }\n        ethBalance[msg.sender] += msg.value - (ext_price + ico_amount);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section */\n    /// Set an inidividual section as for sale at the provided price in wei.\n    /// The section will be available for purchase by any address.\n    function setSectionForSale(\n        uint _section_index,\n        uint256 _price\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = 0x0;\n        NewListing(_section_index, _price);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region for sale at the provided price in wei.\n    /// The sections in the region will be available for purchase by any address.\n    function setRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = 0x0;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region starting in the top left at the supplied start section\n    /// index to and including the supplied bottom right end section index\n    /// for sale at the provided price in wei, to the provided address.\n    /// The sections in the region will be available for purchase only by the\n    /// provided address.\n    function setRegionForSaleToAddress(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price,\n        address _only_sell_to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = _only_sell_to;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /*\n    Set an entire region's cloud image data\n    */\n    /// Update a region of sections' cloud image_id and md5 to be redrawn on the\n    /// map starting at the top left start section index to and including the\n    /// bottom right section index. Fires a NewImage event with the top left\n    /// section index. If any sections not owned by the sender are in the region\n    /// they are ignored.\n    function setRegionImageDataCloud(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                Section s = sections[identifier];\n                if(s.owner == msg.sender)\n                {\n                    s.image_id = _image_id;\n                    s.md5 = _md5;\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        NewImage(_start_section_index);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section to a specific address */\n    /// Set a single section as for sale at the provided price in wei only\n    /// to the supplied address.\n    function setSectionForSaleToAddress(\n        uint _section_index,\n        uint256 _price,\n        address _to\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = _to;\n        NewListing(_section_index, _price);\n    }\n\n    /* Remove the for sale flag from a section */\n    /// Delist a section for sale. Making it no longer available on the market.\n    function unsetSectionForSale(\n        uint _section_index\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.for_sale = false;\n        section.price = 0;\n        section.sell_only_to = 0x0;\n        Delisted(_section_index);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Delist a region of sections for sale. Making the sections no longer\n    /// no longer available on the market.\n    function unsetRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.for_sale = false;\n                    section.price = 0;\n                    Delisted(x_pos + (y_pos * 100));\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /// Depreciated. Store the raw image data in the contract.\n    function setImageData(\n        uint _section_index\n        // bytes32 _row_zero,\n        // bytes32 _row_one,\n        // bytes32 _row_two,\n        // bytes32 _row_three,\n        // bytes32 _row_four,\n        // bytes32 _row_five,\n        // bytes32 _row_six,\n        // bytes32 _row_seven,\n        // bytes32 _row_eight,\n        // bytes32 _row_nine\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        // section.image_data[0] = _row_zero;\n        // section.image_data[1] = _row_one;\n        // section.image_data[2] = _row_two;\n        // section.image_data[3] = _row_three;\n        // section.image_data[4] = _row_four;\n        // section.image_data[5] = _row_five;\n        // section.image_data[6] = _row_six;\n        // section.image_data[7] = _row_seven;\n        // section.image_data[8] = _row_eight;\n        // section.image_data[9] = _row_nine;\n        section.image_id = 0;\n        section.md5 = \"\";\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Set a section's image data to be redrawn on the map. Fires a NewImage\n    /// event.\n    function setImageDataCloud(\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.image_id = _image_id;\n        section.md5 = _md5;\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Withdraw ethereum from the sender's ethBalance.\n    function withdraw() returns (bool) {\n        var amount = ethBalance[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            ethBalance[msg.sender] = 0;\n            WithdrawEvent(\"Reset Sender\");\n            msg.sender.transfer(amount);\n        }\n        return true;\n    }\n\n    /// Deposit ethereum into the sender's ethBalance. Not recommended.\n    function deposit() payable\n    {\n        ethBalance[msg.sender] += msg.value;\n    }\n\n    /// Transfer a section and an IPO token to the supplied address.\n    function transfer(\n      address _to,\n      uint _section_index\n    ) {\n        if (_section_index > 9999) throw;\n        if (sections[_section_index].owner != msg.sender) throw;\n        if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n        sections[_section_index].owner = _to;\n        sections[_section_index].for_sale = false;\n        balanceOf[msg.sender] -= 1;\n        balanceOf[_to] += 1;\n    }\n\n\n\n    /// Transfer a region of sections and IPO tokens to the supplied address.\n    function transferRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        address _to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                  if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n                  section.owner = _to;\n                  section.for_sale = false;\n                  balanceOf[msg.sender] -= 1;\n                  balanceOf[_to] += 1;\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n}",
        "debug": "calldata_Pixel_4 + calldata_Pixel_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0x0\nstorage_0 + 5 + 7*calldata_Pixel_4: 0x0\ncalldata_Pixel_4: 0x270f\ncalldata_Pixel_0: 0x12bd2cea00000000000000000000000000000000000000000000000000000000\ncalldatasize_Pixel: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setImageDataCloud(uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0x92bcbc2240d581a3fac5911cb4d807e7a79590d8.sol",
        "function": "setImageDataCloud(uint256,uint256,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 12989,
        "code": "ntract Pixel {\n    /* This creates an array with all balances */\n    struct Section {\n        address owner;\n        uint256 price;\n        bool for_sale;\n        bool initial_purchase_done;\n        uint image_id;\n        string md5;\n        uint last_update;\n        address sell_only_to;\n        uint16 index;\n        //bytes32[10] image_data;\n    }\n    string public standard = \"IPO 0.9\";\n    string public constant name = \"Initial Pixel Offering\";\n    string public constant symbol = \"IPO\";\n    uint8 public constant decimals = 0;\n    mapping (address => uint256) public balanceOf;\n    mapping (address => uint256) public ethBalance;\n    address owner;\n    uint256 public ipo_price;\n    Section[10000] public sections;\n    uint256 public pool;\n    uint public mapWidth;\n    uint public mapHeight;\n    uint256 tokenTotalSupply = 10000;\n\n    event Buy(uint section_id);\n    event NewListing(uint section_id, uint price);\n    event Delisted(uint section_id);\n    event NewImage(uint section_id);\n    event AreaPrice(uint start_section_index, uint end_section_index, uint area_price);\n    event SentValue(uint value);\n    event PriceUpdate(uint256 price);\n    event WithdrawEvent(string msg);\n\n    function Pixel() {\n        pool = tokenTotalSupply; //Number of token / spaces\n        ipo_price = 100000000000000000; // 0.1\n        mapWidth = 1000;\n        mapHeight = 1000;\n        owner = msg.sender;\n    }\n\n    function totalSupply() constant returns (uint totalSupply)\n    {\n        totalSupply = tokenTotalSupply;\n    }\n\n    /// Updates a pixel section's index number\n    /// Not to be called by anyone but the contract owner\n    function updatePixelIndex(\n        uint16 _start,\n        uint16 _end\n    ) {\n        if(msg.sender != owner) throw; \n        if(_end < _start) throw;\n        while(_start < _end)\n        {\n            sections[_start].index = _start;\n            _start++;\n        }\n    }\n\n    /// Update the current IPO price\n    function updateIPOPrice(\n        uint256 _new_price\n    ) {\n        if(msg.sender != owner) throw;\n        ipo_price = _new_price;\n        PriceUpdate(ipo_price);\n    }\n\n    /* Get the index to access a section object from the provided raw x,y */\n    /// Convert from a pixel's x, y coordinates to its section index\n    /// This is a helper function\n    function getSectionIndexFromRaw(\n        uint _x,\n        uint _y\n    ) returns (uint) {\n        if (_x >= mapWidth) throw;\n        if (_y >= mapHeight) throw;\n        // Convert raw x, y to section identifer x y\n        _x = _x / 10;\n        _y = _y / 10;\n        //Get section_identifier from coords\n        return _x + (_y * 100);\n    }\n\n    /* Get the index to access a section object from its section identifier */\n    /// Get Section index based on its upper left x,y coordinates or \"identifier\"\n    /// coordinates\n    /// This is a helper function\n    function getSectionIndexFromIdentifier (\n        uint _x_section_identifier,\n        uint _y_section_identifier\n    ) returns (uint) {\n        if (_x_section_identifier >= (mapWidth / 10)) throw;\n        if (_y_section_identifier >= (mapHeight / 10)) throw;\n        uint index = _x_section_identifier + (_y_section_identifier * 100);\n        return index;\n    }\n\n    /* Get x,y section_identifier from a section index */\n    /// Get Section upper left x,y coordinates or \"identifier\" coordinates\n    /// based on its index number\n    /// This is a helper function\n    function getIdentifierFromSectionIndex(\n        uint _index\n    ) returns (uint x, uint y) {\n        if (_index > (mapWidth * mapHeight)) throw;\n        x = _index % 100;\n        y = (_index - (_index % 100)) / 100;\n    }\n\n    /* Check to see if Section is available for first purchase */\n    /// Returns whether a section is available for purchase at IPO price\n    function sectionAvailable(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // The section has not been puchased previously\n        return !s.initial_purchase_done;\n    }\n\n    /* Check to see if Section is available for purchase */\n    /// Returns whether a section is available for purchase as a market sale\n    function sectionForSale(\n        uint _section_index\n    ) returns (bool) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        // Has the user set the section as for_sale\n        if(s.for_sale)\n        {\n            // Has the owner set a \"sell only to\" address?\n            if(s.sell_only_to == 0x0) return true;\n            if(s.sell_only_to == msg.sender) return true;\n            return false;\n        }\n        else\n        {\n            // Not for sale\n            return false;\n        }\n    }\n\n    /* Get the price of the Section */\n    /// Returns the price of a section at market price.\n    /// This is a helper function, it is more efficient to just access the\n    /// contract's sections attribute directly\n    function sectionPrice(\n        uint _section_index\n    ) returns (uint) {\n        if (_section_index >= sections.length) throw;\n        Section s = sections[_section_index];\n        return s.price;\n    }\n\n    /*\n    Check to see if a region is available provided the\n    top-left (start) section and the bottom-right (end)\n    section.\n    */\n    /// Returns if a section is available for purchase, it returns the following:\n    /// bool: if the region is available for purchase\n    /// uint256: the extended price, sum of all of the market prices of the sections\n    ///   in the region\n    /// uint256: the number of sections available in the region at the IPO price\n    function regionAvailable(\n        uint _start_section_index,\n        uint _end_section_index\n    ) returns (bool available, uint extended_price, uint ipo_count) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        available = false;\n        extended_price = 0;\n        ipo_count = 0;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                // Is this section available for first (IPO) purchase?\n                if(sectionAvailable(identifier))\n                {\n                    // The section is available as an IPO\n                    ipo_count = ipo_count + 1;\n                } else\n                {\n                    // The section has been purchased, it can only be available\n                    // as a market sale.\n                    if(sectionForSale(identifier))\n                    {\n                        extended_price = extended_price + sectionPrice(identifier);\n                    } else\n                    {\n                        available = false;\n                        //Don't return a price if there is an unavailable section\n                        //to reduce confusion\n                        extended_price = 0;\n                        ipo_count = 0;\n                        return;\n                    }\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        available = true;\n        return;\n    }\n\n    /// Buy a section based on its index and set its cloud image_id and md5\n    /// This function is payable, any over payment will be withdraw-able\n    function buySection (\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) payable {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(!section.for_sale && section.initial_purchase_done)\n        {\n            //Section not for sale\n            throw;\n        }\n        // Process payment\n        // Is this Section on the open market?\n        if(section.initial_purchase_done)\n        {\n            // Section sold, sell for market price\n            if(msg.value < section.price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Calculate Fee\n                // We only need to change the balance if the section price is non-zero\n                if (section.price != 0)\n                {\n                    uint fee = section.price / 100;\n                    // Pay contract owner the fee\n                    ethBalance[owner] += fee;\n                    // Pay the section owner the price minus the fee\n                    ethBalance[section.owner] += (msg.value - fee);\n                }\n                // Refund any overpayment\n                //require(msg.value > (msg.value - section.price));\n                ethBalance[msg.sender] += (msg.value - section.price);\n                // Owner loses a token\n                balanceOf[section.owner]--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        } else\n        {\n            // Initial sale, sell for IPO price\n            if(msg.value < ipo_price)\n            {\n                // Not enough funds were sent\n                throw;\n            } else\n            {\n                // Pay the contract owner\n                ethBalance[owner] += msg.value;\n                // Refund any overpayment\n                //require(msg.value > (msg.value - ipo_price));\n                ethBalance[msg.sender] += (msg.value - ipo_price);\n                // Reduce token pool\n                pool--;\n                // Buyer gets a token\n                balanceOf[msg.sender]++;\n            }\n        }\n        //Payment and token transfer complete\n        //Transfer ownership and set not for sale by default\n        section.owner = msg.sender;\n        section.md5 = _md5;\n        section.image_id = _image_id;\n        section.last_update = block.timestamp;\n        section.for_sale = false;\n        section.initial_purchase_done = true; // even if not the first, we can pretend it is\n    }\n\n    /* Buy an entire region */\n    /// Buy a region of sections starting and including the top left section index\n    /// ending at and including the bottom left section index. And set its cloud\n    /// image_id and md5. This function is payable, if the value sent is less\n    /// than the price of the region, the function will throw.\n    function buyRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) payable returns (uint start_section_y, uint start_section_x,\n    uint end_section_y, uint end_section_x){\n        if (_end_section_index < _start_section_index) throw;\n        if (_start_section_index >= sections.length) throw;\n        if (_end_section_index >= sections.length) throw;\n        // ico_ammount reffers to the number of sections that are available\n        // at ICO price\n        var (available, ext_price, ico_amount) = regionAvailable(_start_section_index, _end_section_index);\n        if (!available) throw;\n\n        // Calculate price\n        uint area_price =  ico_amount * ipo_price;\n        area_price = area_price + ext_price;\n        AreaPrice(_start_section_index, _end_section_index, area_price);\n        SentValue(msg.value);\n        if (area_price > msg.value) throw;\n\n        // ico_ammount reffers to the amount in wei that the contract owner\n        // is owed\n        ico_amount = 0;\n        // ext_price reffers to the amount in wei that the contract owner is\n        // owed in fees from market sales\n        ext_price = 0;\n\n        // User sent enough funds, let's go\n        start_section_x = _start_section_index % 100;\n        end_section_x = _end_section_index % 100;\n        start_section_y = _start_section_index - (_start_section_index % 100);\n        start_section_y = start_section_y / 100;\n        end_section_y = _end_section_index - (_end_section_index % 100);\n        end_section_y = end_section_y / 100;\n        uint x_pos = start_section_x;\n        while (x_pos <= end_section_x)\n        {\n            uint y_pos = start_section_y;\n            while (y_pos <= end_section_y)\n            {\n                // Is this an IPO section?\n                Section s = sections[x_pos + (y_pos * 100)];\n                if (s.initial_purchase_done)\n                {\n                    // Sale, we need to transfer balance\n                    // We only need to modify balances if the section's price\n                    // is non-zero\n                    if(s.price != 0)\n                    {\n                        // Pay the contract owner the price\n                        ethBalance[owner] += (s.price / 100);\n                        // Pay the owner the price minus the fee\n                        ethBalance[s.owner] += (s.price - (s.price / 100));\n                    }\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - s.price)) throw;\n                    ext_price += s.price;\n                    // Owner loses a token\n                    balanceOf[s.owner]--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                } else\n                {\n                    // IPO we get to keep the value\n                    // Pay the contract owner\n                    ethBalance[owner] += ipo_price;\n                    // Refund any overpayment\n                    //if(msg.value > (msg.value - ipo_price)) throw;\n                    // TODO Decrease the value\n                    ico_amount += ipo_price;\n                    // Reduce token pool\n                    pool--;\n                    // Buyer gets a token\n                    balanceOf[msg.sender]++;\n                }\n\n                // Payment and token transfer complete\n                // Transfer ownership and set not for sale by default\n                s.owner = msg.sender;\n                s.md5 = _md5;\n                s.image_id = _image_id;\n                //s.last_update = block.timestamp;\n                s.for_sale = false;\n                s.initial_purchase_done = true; // even if not the first, we can pretend it is\n\n                Buy(x_pos + (y_pos * 100));\n                // Done\n                y_pos = y_pos + 1;\n            }\n            x_pos = x_pos + 1;\n        }\n        ethBalance[msg.sender] += msg.value - (ext_price + ico_amount);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section */\n    /// Set an inidividual section as for sale at the provided price in wei.\n    /// The section will be available for purchase by any address.\n    function setSectionForSale(\n        uint _section_index,\n        uint256 _price\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = 0x0;\n        NewListing(_section_index, _price);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region for sale at the provided price in wei.\n    /// The sections in the region will be available for purchase by any address.\n    function setRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = 0x0;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Set a section region starting in the top left at the supplied start section\n    /// index to and including the supplied bottom right end section index\n    /// for sale at the provided price in wei, to the provided address.\n    /// The sections in the region will be available for purchase only by the\n    /// provided address.\n    function setRegionForSaleToAddress(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _price,\n        address _only_sell_to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.price = _price;\n                    section.for_sale = true;\n                    section.sell_only_to = _only_sell_to;\n                    NewListing(x_pos + (y_pos * 100), _price);\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /*\n    Set an entire region's cloud image data\n    */\n    /// Update a region of sections' cloud image_id and md5 to be redrawn on the\n    /// map starting at the top left start section index to and including the\n    /// bottom right section index. Fires a NewImage event with the top left\n    /// section index. If any sections not owned by the sender are in the region\n    /// they are ignored.\n    function setRegionImageDataCloud(\n        uint _start_section_index,\n        uint _end_section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_end_section_index < _start_section_index) throw;\n        var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index);\n        var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index);\n        if (start_x >= mapWidth) throw;\n        if (start_y >= mapHeight) throw;\n        if (end_x >= mapWidth) throw;\n        if (end_y >= mapHeight) throw;\n        uint y_pos = start_y;\n        while (y_pos <= end_y)\n        {\n            uint x_pos = start_x;\n            while (x_pos <= end_x)\n            {\n                uint identifier = (x_pos + (y_pos * 100));\n                Section s = sections[identifier];\n                if(s.owner == msg.sender)\n                {\n                    s.image_id = _image_id;\n                    s.md5 = _md5;\n                }\n                x_pos = x_pos + 1;\n            }\n            y_pos = y_pos + 1;\n        }\n        NewImage(_start_section_index);\n        return;\n    }\n\n    /* Set the for sale flag and a price for a section to a specific address */\n    /// Set a single section as for sale at the provided price in wei only\n    /// to the supplied address.\n    function setSectionForSaleToAddress(\n        uint _section_index,\n        uint256 _price,\n        address _to\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.price = _price;\n        section.for_sale = true;\n        section.sell_only_to = _to;\n        NewListing(_section_index, _price);\n    }\n\n    /* Remove the for sale flag from a section */\n    /// Delist a section for sale. Making it no longer available on the market.\n    function unsetSectionForSale(\n        uint _section_index\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.for_sale = false;\n        section.price = 0;\n        section.sell_only_to = 0x0;\n        Delisted(_section_index);\n    }\n\n    /* Set the for sale flag and price for a region */\n    /// Delist a region of sections for sale. Making the sections no longer\n    /// no longer available on the market.\n    function unsetRegionForSale(\n        uint _start_section_index,\n        uint _end_section_index\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                    section.for_sale = false;\n                    section.price = 0;\n                    Delisted(x_pos + (y_pos * 100));\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n\n    /// Depreciated. Store the raw image data in the contract.\n    function setImageData(\n        uint _section_index\n        // bytes32 _row_zero,\n        // bytes32 _row_one,\n        // bytes32 _row_two,\n        // bytes32 _row_three,\n        // bytes32 _row_four,\n        // bytes32 _row_five,\n        // bytes32 _row_six,\n        // bytes32 _row_seven,\n        // bytes32 _row_eight,\n        // bytes32 _row_nine\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        // section.image_data[0] = _row_zero;\n        // section.image_data[1] = _row_one;\n        // section.image_data[2] = _row_two;\n        // section.image_data[3] = _row_three;\n        // section.image_data[4] = _row_four;\n        // section.image_data[5] = _row_five;\n        // section.image_data[6] = _row_six;\n        // section.image_data[7] = _row_seven;\n        // section.image_data[8] = _row_eight;\n        // section.image_data[9] = _row_nine;\n        section.image_id = 0;\n        section.md5 = \"\";\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Set a section's image data to be redrawn on the map. Fires a NewImage\n    /// event.\n    function setImageDataCloud(\n        uint _section_index,\n        uint _image_id,\n        string _md5\n    ) {\n        if (_section_index >= sections.length) throw;\n        Section section = sections[_section_index];\n        if(section.owner != msg.sender) throw;\n        section.image_id = _image_id;\n        section.md5 = _md5;\n        section.last_update = block.timestamp;\n        NewImage(_section_index);\n    }\n\n    /// Withdraw ethereum from the sender's ethBalance.\n    function withdraw() returns (bool) {\n        var amount = ethBalance[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            ethBalance[msg.sender] = 0;\n            WithdrawEvent(\"Reset Sender\");\n            msg.sender.transfer(amount);\n        }\n        return true;\n    }\n\n    /// Deposit ethereum into the sender's ethBalance. Not recommended.\n    function deposit() payable\n    {\n        ethBalance[msg.sender] += msg.value;\n    }\n\n    /// Transfer a section and an IPO token to the supplied address.\n    function transfer(\n      address _to,\n      uint _section_index\n    ) {\n        if (_section_index > 9999) throw;\n        if (sections[_section_index].owner != msg.sender) throw;\n        if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n        sections[_section_index].owner = _to;\n        sections[_section_index].for_sale = false;\n        balanceOf[msg.sender] -= 1;\n        balanceOf[_to] += 1;\n    }\n\n\n\n    /// Transfer a region of sections and IPO tokens to the supplied address.\n    function transferRegion(\n        uint _start_section_index,\n        uint _end_section_index,\n        address _to\n    ) {\n        if(_start_section_index > _end_section_index) throw;\n        if(_end_section_index > 9999) throw;\n        uint x_pos = _start_section_index % 100;\n        uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100;\n        uint x_max = _end_section_index % 100;\n        uint y_max = (_end_section_index - (_end_section_index % 100)) / 100;\n        while(x_pos <= x_max)\n        {\n            uint y_pos = base_y_pos;\n            while(y_pos <= y_max)\n            {\n                Section section = sections[x_pos + (y_pos * 100)];\n                if(section.owner == msg.sender)\n                {\n                  if (balanceOf[_to] + 1 < balanceOf[_to]) throw;\n                  section.owner = _to;\n                  section.for_sale = false;\n                  balanceOf[msg.sender] -= 1;\n                  balanceOf[_to] += 1;\n                }\n                y_pos++;\n            }\n            x_pos++;\n        }\n    }\n}",
        "debug": "keccac_4_+_5_+_7*calldata_Pixel_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Pixel_4 + calldata_Pixel_32 + 36: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\ncaller: 0x0\nstorage_0 + 5 + 7*calldata_Pixel_4: 0x0\ncalldata_Pixel_4: 0x270f\ncalldata_Pixel_0: 0x12bd2cea00000000000000000000000000000000000000000000000000000000\ncalldatasize_Pixel: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setImageDataCloud(uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0x92bcbc2240d581a3fac5911cb4d807e7a79590d8.sol",
        "function": "setImageDataCloud(uint256,uint256,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}