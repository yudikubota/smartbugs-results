{"error": null, "issues": [{"address": 377, "code": "ed(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwn", "debug": "calldata_NoteChain_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_NoteChain_0: 0x43c09e7700000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNote(uint64,uint16,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNote(uint64,uint16,bytes12,bytes)", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}, {"address": 383, "code": "ed(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwn", "debug": "calldata_NoteChain_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_NoteChain_0: 0x43c09e7700000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNote(uint64,uint16,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNote(uint64,uint16,bytes12,bytes)", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}, {"address": 850, "code": "e payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) p", "debug": "calldata_NoteChain_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 116, "title": "Integer Overflow ", "type": "Warning"}, {"address": 856, "code": "e payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) p", "debug": "calldata_NoteChain_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 116, "title": "Integer Overflow ", "type": "Warning"}, {"address": 986, "code": "ernal payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) p", "debug": "calldata_NoteChain_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 93, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2245, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0x43c09e7700000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNote(uint64,uint16,bytes12,bytes)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 2636, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0x5928e80c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteTitle(uint64,bytes12)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 2976, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0x645e175c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "publicGetNote(uint64,bytes2)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 3762, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 4201, "code": ";\n\n/**\n * @title N", "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4434, "code": "Owner[id] = msg.sender;\n                ownerNotes[msg.sender].push(i", "debug": "storage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*storage_2: 0x80\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*storage_2: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 68: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer underflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 95, "title": "Integer Underflow", "type": "Warning"}, {"address": 4609, "code": ";\n\n/**\n * @title N", "debug": "storage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*storage_2: 0x80\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*storage_2: 0x11ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 68: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4621, "code": "       function deleteNote(uint", "debug": "storage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*storage_2: 0x80\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*storage_2: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 68: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer underflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 100, "title": "Integer Underflow", "type": "Warning"}, {"address": 4933, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0x9acbdcab00000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteButContent(uint64,uint16,bytes12)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 5300, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0xaedbbf3600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "deleteNote(uint64)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 5676, "code": "[] memory metada", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffe\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0xbc2bbad700000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `getMyNotes(uint64,uint64)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "getMyNotes(uint64,uint64)", "lineno": 146, "title": "Integer Underflow", "type": "Warning"}, {"address": 5694, "code": "oop);\n          ", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x47fa0ea0\ncalldata_NoteChain_32 + 4: 0xffffffffbff9ee80\ncalldata_NoteChain_4: 0x88002020\ncalldata_NoteChain_0: 0xbc2bbad700000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `getMyNotes(uint64,uint64)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "getMyNotes(uint64,uint64)", "lineno": 146, "title": "Integer Underflow", "type": "Warning"}, {"address": 6804, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0xc62cfa1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "getMyNote(uint64)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 7361, "code": "        }\n\n   ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffff\ncalldata_NoteChain_4: 0xffffffffffffffff\ncalldata_NoteChain_0: 0xcc2f502900000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteMetadata(uint64,uint16)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 8254, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "storage_2: 0x100000000000\nstorage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*Concat(0, Extract(63, 0, calldata_NoteChain_4)): 0xb9745601800000000001843000002e1ffbf7b7f7ece8400f6f00001ff717f9d1\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*Concat(0,_Extract(63,_0,_calldata_NoteChain_4)): 0xfe01fbfff8fffffffffffffffffffffec00f10df183390403930003fffd1df08\ncallvalue: 0x0\nstorage_1: 0x0\nstorage_keccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_NoteChain_4: 0x0\ncaller: 0x0\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*Concat(0, Extract(63, 0, calldata_NoteChain_4)): 0xfe00\ncalldata_NoteChain_4: 0xfffffffffff\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8283, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "storage_2: 0x8000000000000000\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\nstorage_1: 0x0\nstorage_keccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_NoteChain_4: 0x0\ncaller: 0x0\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*Concat(0, Extract(63, 0, calldata_NoteChain_4)): 0xfe00\ncalldata_NoteChain_4: 0x7fffffffffffffff\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8297, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "calldata_NoteChain_32 + 4: 0x7ff7ff77e7fdf9ffffd40017febf774ff67ffffffffffffffffffdffffffffd9\nstorage_2: 0x8000000000000000\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 4: 0xebf90058ac8205ffffebffe7ff4088b00980000000000000000002000000001e\ncallvalue: 0x0\nstorage_1: 0x0\nstorage_keccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_NoteChain_4: 0x0\ncaller: 0x0\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*Concat(0, Extract(63, 0, calldata_NoteChain_4)): 0xfe00\ncalldata_NoteChain_4: 0x7fffffffffffffff\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8314, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "calldata_NoteChain_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c\nstorage_2: 0x10000000000000000000000000000000000000000000000000000\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 4: 0x32\ncallvalue: 0x0\nstorage_1: 0x0\nstorage_keccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_NoteChain_4: 0x0\ncaller: 0x0\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*Concat(0, Extract(63, 0, calldata_NoteChain_4)): 0xfe00\ncalldata_NoteChain_4: 0x0\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8319, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "calldata_NoteChain_32 + 4: 0x57bcff7ffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\nstorage_2: 0x100000\ncalldata_NoteChain_4 + calldata_NoteChain_32 + 4: 0x4343008000000000000000000000000000000000000000000000000000000005\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*Concat(0,_Extract(63,_0,_calldata_NoteChain_4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\nstorage_1: 0x0\nstorage_keccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_NoteChain_4: 0x0\ncaller: 0x0\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*Concat(0, Extract(63, 0, calldata_NoteChain_4)): 0xfe00\ncalldata_NoteChain_4: 0xfffff\ncalldata_NoteChain_0: 0x6d33f5a600000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `updateNoteContent(uint64,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "updateNoteContent(uint64,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8382, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "storage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*storage_2: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*storage_2: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncallvalue: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8411, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "calldata_NoteChain_4 + calldata_NoteChain_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8425, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "calldata_NoteChain_4 + calldata_NoteChain_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee0\ncallvalue: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8447, "code": "t NoteChain {\n\n        // EVENTS\n        event NoteCreated(uint64 id, bytes2 publicKey);\n        event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n        // CONSTANTS\n        uint8 constant Deleted = 1;\n        uint8 constant IsPrivateBitPosition = 1;\n\n        address public owner;\n        uint public noteChainFee = 0.0002 ether; // fee for using noteChain\n\n        struct Note {\n                uint16 metadata;\n                bytes2 publicKey; \n                // publicKey: generated client-side, \n                // it will create a code for share URL-> publicKey + hex(_noteId)\n\n                bytes12 title;\n                bytes content;\n        }\n\n        Note[] private notes;\n\n        mapping (uint64 => address) private noteToOwner;\n        mapping (address => uint64[]) private ownerNotes;\n\n        // PURE FUNCTIONS\n        function isPosBitOne(uint data, uint pos) internal pure returns (bool) {\n                return data % (2**(pos+1)) >= (2**pos);\n        }\n\n        // MODIFIERS\n        modifier onlyOwner() {\n                require(msg.sender == owner);\n                _;\n        }\n\n        modifier onlyOwnerOf(uint64 _noteId) {\n                require(msg.sender == noteToOwner[_noteId]);\n                _;\n        }\n\n        modifier payFee() {\n                require(msg.value >= noteChainFee);\n                _;\n        }\n\n        modifier notDeleted(uint64 _noteId) {\n                require(uint8(notes[_noteId].metadata) != Deleted);\n                _;\n        }\n\n        modifier notPrivate(uint64 _noteId) {\n                require(isPosBitOne( uint( notes[_noteId].metadata), uint(IsPrivateBitPosition) ) == false );\n                _;\n        }\n\n        // constructor\n        constructor() public {\n                owner = msg.sender;\n        }\n\n        function setFee(uint _fee) external onlyOwner {\n                noteChainFee = _fee;\n        }\n\n        function withdraw(address _address, uint _amount) external onlyOwner {\n                require(_amount <= address(this).balance);\n                address(_address).transfer(_amount);\n        }\n\n        function getBalance() external constant returns(uint){\n                return address(this).balance;\n        }\n\n        function transferOwnership(address newOwner) external onlyOwner {\n                require(newOwner != address(0));\n                emit OwnershipTransferred(owner, newOwner);\n                owner = newOwner;\n        }\n\n        // NOTES related functions\n        // payable functions\n        function createNote(uint16 _metadata, bytes2 _publicKey, bytes12 _title, bytes _content) external payable payFee {\n                uint64 id = uint64(notes.push(Note(_metadata, _publicKey, _title, _content))) - 1;\n                noteToOwner[id] = msg.sender;\n                ownerNotes[msg.sender].push(id);\n                emit NoteCreated(id, _publicKey);\n        }\n\n        function deleteNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                notes[_noteId].metadata = Deleted;\n        }\n\n        function updateNote(uint64 _noteId, uint16 _metadata, bytes12 _title, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n                myNote.metadata = _metadata;\n                myNote.content = _content;\n        }\n\n        function updateNoteMetadata(uint64 _noteId, uint16 _metadata) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n        }\n\n        function updateNoteContent(uint64 _noteId, bytes _content) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.content = _content;\n        }\n\n        function updateNoteTitle(uint64 _noteId, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.title = _title;\n        }\n\n        function updateNoteButContent(uint64 _noteId, uint16 _metadata, bytes12 _title) external notDeleted(_noteId) onlyOwnerOf(_noteId) payable payFee {\n                Note storage myNote = notes[_noteId];\n                myNote.metadata = _metadata;\n                myNote.title = _title;\n        }\n\n        // view functions\n        function getNotesCount() external view returns (uint64) {\n                return uint64(notes.length);\n        }\n\n        function getMyNote(uint64 _noteId) external notDeleted(_noteId) onlyOwnerOf(_noteId) view returns (uint16, bytes12, bytes) {\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n        function getMyNotes(uint64 _startFrom, uint64 _limit) external view returns (uint64[], uint16[], bytes2[], bytes12[], uint64) {\n                uint64 len = uint64(ownerNotes[msg.sender].length);\n                uint64 maxLoop = (len - _startFrom) > _limit ? _limit : (len - _startFrom);\n\n                uint64[] memory ids = new uint64[](maxLoop);\n                uint16[] memory metadatas = new uint16[](maxLoop);\n                bytes2[] memory publicKeys = new bytes2[](maxLoop);\n                bytes12[] memory titles = new bytes12[](maxLoop);\n\n                for (uint64 i = 0; i < maxLoop; i++) {\n                        ids[i] = ownerNotes[msg.sender][i+_startFrom];\n                        metadatas[i] = notes[ ids[i] ].metadata;\n                        publicKeys[i] = notes[ ids[i] ].publicKey;\n                        titles[i] = notes[ ids[i] ].title;\n                }\n                return (ids, metadatas, publicKeys, titles, len);\n        }\n\n        function publicGetNote(uint64 _noteId, bytes2 _publicKey) external notDeleted(_noteId) notPrivate(_noteId) view returns (uint16, bytes12, bytes) {\n                require(notes[_noteId].publicKey == _publicKey); // for public to get the note's data, knowing the publicKey is needed\n                return (notes[_noteId].metadata, notes[_noteId].title, notes[_noteId].content);\n        }\n\n}", "debug": "calldata_NoteChain_4 + calldata_NoteChain_32 + 68: 0x3e0fffffffffffffffffffffffffffffffffffffffffffffffffffffffffee0\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\nstorage_1: 0x0\ncalldata_NoteChain_0: 0x72b59c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_NoteChain: 0x4\n", "description": "A possible integer overflow exists in the function `createNote(uint16,bytes2,bytes12,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xd4737858dd8eb9842cd0696171b781525b56086f.sol", "function": "createNote(uint16,bytes2,bytes12,bytes)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}], "success": true}