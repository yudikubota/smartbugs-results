{
  "contract": "0x3419e34959a9818b60cc83fe73dff426d4c34a8a",
  "tool": "mythril",
  "start": 1563589190.4945138,
  "end": 1563589586.4338949,
  "duration": 395.9393811225891,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1429,
        "code": "unction setBeneficiary(address _beneficiary, uint _decimals, uint _tokenPrice, uint _tokensRemaining) public own",
        "debug": "calldata_iERC20Token_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_iERC20Token_0: 0x5c707f0700000000000000000000000000000000000000000000000000000000\ncalldatasize_iERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setName(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "setName(string,string)",
        "lineno": 219,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2427,
        "code": "    }\n\n    /**\n",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_4: 0xffffffff7f\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0xffffffff7f000000000000000000000000000000000000000000000000000000\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_iERC20Token: 0x3\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "fallback",
        "lineno": 38,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2618,
        "code": "= msg.sender;\n    beneficiary = msg",
        "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_iERC20Token: 0x4\ncalldata_iERC20Token_0: 0x95ea7b300000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "approve(address,uint256)",
        "lineno": 132,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2896,
        "code": "= msg.sender;\n    beneficiary = msg",
        "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_iERC20Token: 0x60\ncalldata_iERC20Token_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 132,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3237,
        "code": "ansferEvent(_from, _to",
        "debug": "calldatasize_iERC20Token: 0x64\ncalldata_iERC20Token_32 + 36: 0x9351db6e0b21734731ae9cfc13143e8338c6dcf4a783a60c06e0d1d708004801\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_iERC20Token_32_+_4: 0xa8511371907d295662825497115ba082b6a492f6b7f433cff7fbddd4ebff6ff5\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x9351db6e0b21734731ae9cfc13143e8338c6dcf4a783a60c06e0d1d708004801\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_iERC20Token_4: 0x9351db6e0b21734731ae9cfc13143e8338c6dcf4a783a60c06e0d1d708004801\ncalldata_iERC20Token_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 165,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3929,
        "code": "available before the contract is locked\n  function haraKiri",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "endSale()",
        "lineno": 244,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 3929,
        "code": "available before the contract is locked\n  function haraKiri",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function endSale(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "endSale()",
        "lineno": 244,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 3952,
        "code": "ckedOnly {\n    self",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "endSale()",
        "lineno": 245,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 4663,
        "code": "= msg.sender;\n    beneficiary = msg",
        "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_iERC20Token: 0x4\ncalldata_iERC20Token_0: 0xa9059cbb00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "transfer(address,uint256)",
        "lineno": 132,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4868,
        "code": " _value);\n      return",
        "debug": "calldatasize_iERC20Token: 0x1000000000000000000000000000000000000000000000000000000000000044\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_iERC20Token_4: 0xf1592bedbbff7fd743ed18b69e49c6a2d5afe5b9c6df6bd8868438480103db39\ncalldata_iERC20Token_32 + 4: 0x6173538839847ecb1c051d3958c52c0d15261637901c038184c1b94b3d5bd9a5\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x6173538839847ecb1c051d3958c52c0d15261637901c038184c1b94b3d5bd9a5\ncalldata_iERC20Token_0: 0xa9059cbb00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transfer(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "transfer(address,uint256)",
        "lineno": 151,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5849,
        "code": "exed from, uint amount);\n  event TransferEvent(address indexed from, address indexed to, uint amount);\n  event ApprovalEvent(address indexed from, address indexed to, uint amount);\n\n  string  public symbol;\n  string  public name;\n  bool    public isLocked;\n  uint    public decimals;\n  uint    public tokenPrice;\n  uint           tokenSupply;\n  uint           tokensRemaining;\n  uint    public contractSendGas = 100000;\n  address public owner;\n  address public beneficiary;\n  mapping (address => uint) balances;\n  mapping (address => mapping (address => uint)) approvals;  //transfer approvals, from -> to\n\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier unlockedOnly {\n    require(!isLocked);\n    _;\n  }\n\n  modifier duringSale {\n    require(tokenPrice != 0 && tokensRemaining > 0);\n    _;\n  }\n\n  //this is to protect from short-address attack. use this to verify size of args, especially when an address arg preceeds\n  //a value arg. see: https://www.reddit.com/r/ethereum/comments/63s917/worrysome_bug_exploit_with_erc20_token/dfwmhc3/\n  modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length >= size + 4);\n    _;\n  }\n\n  //\n  //constructor\n  //\n  function SimpleSaleToken() public {\n    owner = msg.sender;\n    beneficiary = msg.sender;\n  }\n\n\n  //\n  // ERC-20\n  //\n\n  function totalSupply() public constant returns (uint supply) {\n    //if tokenSupply was not limited then we would use safeAdd...\n    supply = tokenSupply + tokensRemaining;\n  }\n\n  function transfer(address _to, uint _value) public onlyPayloadSize(2*32) returns (bool success) {\n    //prevent wrap\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      TransferEvent(msg.sender, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3*32) public returns (bool success) {\n    //prevent wrap:\n    if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n      balances[_from] -= _value;\n      balances[_to] += _value;\n      approvals[_from][msg.sender] -= _value;\n      TransferEvent(_from, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n\n  function balanceOf(address _owner) public constant returns (uint balance) {\n    balance = balances[_owner];\n  }\n\n\n  function approve(address _spender, uint _value) public onlyPayloadSize(2*32) returns (bool success) {\n    approvals[msg.sender][_spender] = _value;\n    ApprovalEvent(msg.sender, _spender, _value);\n    return true;\n  }\n\n\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n    return approvals[_owner][_spender];\n  }\n\n  //\n  // END ERC20\n  //\n\n\n  //\n  // default payable function.\n  //\n  function () public payable duringSale {\n    uint _quantity = msg.value / tokenPrice;\n    if (_quantity > tokensRemaining)\n       _quantity = tokensRemaining;\n    require(_quantity >= 1);\n    uint _cost = safeMul(_quantity, tokenPrice);\n    uint _refund = safeSub(msg.value, _cost);\n    balances[msg.sender] = safeAdd(balances[msg.sender], _quantity);\n    tokenSupply = safeAdd(tokenSupply, _quantity);\n    tokensRemaining = safeSub(tokensRemaining, _quantity);\n    if (_refund > 0)\n        msg.sender.transfer(_refund);\n    PaymentEvent(msg.sender, msg.value);\n  }\n\n  function setName(string _name, string _symbol) public ownerOnly {\n    name = _name;\n    symbol = _symbol;\n  }\n\n\n  //if decimals = 3, and you want 1 ETH/token, then pass in _tokenPrice = 0.001 * (wei / ether)\n  function setBeneficiary(address _beneficiary, uint _decimals, uint _tokenPrice, uint _tokensRemaining) public ownerOnly unlockedOnly {\n    beneficiary = _beneficiary;\n    decimals = _decimals;\n    tokenPrice = _tokenPrice;\n    tokensRemaining = _tokensRemaining;\n  }\n\n  function lock() public ownerOnly {\n    require(beneficiary != 0 && tokenPrice != 0);\n    isLocked = true;\n  }\n\n  function endSale() public ownerOnly {\n    require(beneficiary != 0);\n    //beneficiary is most likely a contract...\n    if (!beneficiary.call.gas(contractSendGas).value(this.balance)())\n      revert();\n    tokensRemaining = 0;\n  }\n\n  function tune(uint _contractSendGas) public ownerOnly {\n    contractSendGas = _contractSendGas;\n  }\n\n  //for debug\n  //only available before the contract is locked\n  function haraKiri() public ownerOnly unlockedOnly {\n    selfdestruct(owner);\n  }\n\n}",
        "debug": "calldata_iERC20Token_4 + calldata_iERC20Token_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_8: 0x0\ncaller: 0x0\ncalldata_iERC20Token_0: 0x5c707f0700000000000000000000000000000000000000000000000000000000\ncalldatasize_iERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setName(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "setName(string,string)",
        "lineno": 88,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5863,
        "code": "exed from, uint amount);\n  event TransferEvent(address indexed from, address indexed to, uint amount);\n  event ApprovalEvent(address indexed from, address indexed to, uint amount);\n\n  string  public symbol;\n  string  public name;\n  bool    public isLocked;\n  uint    public decimals;\n  uint    public tokenPrice;\n  uint           tokenSupply;\n  uint           tokensRemaining;\n  uint    public contractSendGas = 100000;\n  address public owner;\n  address public beneficiary;\n  mapping (address => uint) balances;\n  mapping (address => mapping (address => uint)) approvals;  //transfer approvals, from -> to\n\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier unlockedOnly {\n    require(!isLocked);\n    _;\n  }\n\n  modifier duringSale {\n    require(tokenPrice != 0 && tokensRemaining > 0);\n    _;\n  }\n\n  //this is to protect from short-address attack. use this to verify size of args, especially when an address arg preceeds\n  //a value arg. see: https://www.reddit.com/r/ethereum/comments/63s917/worrysome_bug_exploit_with_erc20_token/dfwmhc3/\n  modifier onlyPayloadSize(uint size) {\n    assert(msg.data.length >= size + 4);\n    _;\n  }\n\n  //\n  //constructor\n  //\n  function SimpleSaleToken() public {\n    owner = msg.sender;\n    beneficiary = msg.sender;\n  }\n\n\n  //\n  // ERC-20\n  //\n\n  function totalSupply() public constant returns (uint supply) {\n    //if tokenSupply was not limited then we would use safeAdd...\n    supply = tokenSupply + tokensRemaining;\n  }\n\n  function transfer(address _to, uint _value) public onlyPayloadSize(2*32) returns (bool success) {\n    //prevent wrap\n    if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n      balances[msg.sender] -= _value;\n      balances[_to] += _value;\n      TransferEvent(msg.sender, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n\n  function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3*32) public returns (bool success) {\n    //prevent wrap:\n    if (balances[_from] >= _value && approvals[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) {\n      balances[_from] -= _value;\n      balances[_to] += _value;\n      approvals[_from][msg.sender] -= _value;\n      TransferEvent(_from, _to, _value);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n\n  function balanceOf(address _owner) public constant returns (uint balance) {\n    balance = balances[_owner];\n  }\n\n\n  function approve(address _spender, uint _value) public onlyPayloadSize(2*32) returns (bool success) {\n    approvals[msg.sender][_spender] = _value;\n    ApprovalEvent(msg.sender, _spender, _value);\n    return true;\n  }\n\n\n  function allowance(address _owner, address _spender) public constant returns (uint remaining) {\n    return approvals[_owner][_spender];\n  }\n\n  //\n  // END ERC20\n  //\n\n\n  //\n  // default payable function.\n  //\n  function () public payable duringSale {\n    uint _quantity = msg.value / tokenPrice;\n    if (_quantity > tokensRemaining)\n       _quantity = tokensRemaining;\n    require(_quantity >= 1);\n    uint _cost = safeMul(_quantity, tokenPrice);\n    uint _refund = safeSub(msg.value, _cost);\n    balances[msg.sender] = safeAdd(balances[msg.sender], _quantity);\n    tokenSupply = safeAdd(tokenSupply, _quantity);\n    tokensRemaining = safeSub(tokensRemaining, _quantity);\n    if (_refund > 0)\n        msg.sender.transfer(_refund);\n    PaymentEvent(msg.sender, msg.value);\n  }\n\n  function setName(string _name, string _symbol) public ownerOnly {\n    name = _name;\n    symbol = _symbol;\n  }\n\n\n  //if decimals = 3, and you want 1 ETH/token, then pass in _tokenPrice = 0.001 * (wei / ether)\n  function setBeneficiary(address _beneficiary, uint _decimals, uint _tokenPrice, uint _tokensRemaining) public ownerOnly unlockedOnly {\n    beneficiary = _beneficiary;\n    decimals = _decimals;\n    tokenPrice = _tokenPrice;\n    tokensRemaining = _tokensRemaining;\n  }\n\n  function lock() public ownerOnly {\n    require(beneficiary != 0 && tokenPrice != 0);\n    isLocked = true;\n  }\n\n  function endSale() public ownerOnly {\n    require(beneficiary != 0);\n    //beneficiary is most likely a contract...\n    if (!beneficiary.call.gas(contractSendGas).value(this.balance)())\n      revert();\n    tokensRemaining = 0;\n  }\n\n  function tune(uint _contractSendGas) public ownerOnly {\n    contractSendGas = _contractSendGas;\n  }\n\n  //for debug\n  //only available before the contract is locked\n  function haraKiri() public ownerOnly unlockedOnly {\n    selfdestruct(owner);\n  }\n\n}",
        "debug": "calldata_iERC20Token_4 + calldata_iERC20Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_8: 0x0\ncaller: 0x0\ncalldata_iERC20Token_0: 0x5c707f0700000000000000000000000000000000000000000000000000000000\ncalldatasize_iERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setName(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x3419e34959a9818b60cc83fe73dff426d4c34a8a.sol",
        "function": "setName(string,string)",
        "lineno": 88,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}