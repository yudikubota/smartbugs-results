{
  "contract": "0x386d51a52b36ff03602798418d4d5eec49939c5b",
  "tool": "mythril",
  "start": 1563580043.4467533,
  "end": 1563580440.8179543,
  "duration": 397.3712010383606,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 679,
        "code": "    \n    function displayNick(address _owner) public constant returns(string)\n    {\n        return nick",
        "debug": "calldata_CryptoNumismat_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoNumismat_0: 0x20e98bf400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoNumismat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setNick(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "setNick(string)",
        "lineno": 106,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2349,
        "code": "nt256 _value, address _",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function withdrawAmount(uint256). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "withdrawAmount(uint256)",
        "lineno": 76,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 3689,
        "code": "uint256 _amount) onlyOwner()",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function withdrawAll(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "withdrawAll()",
        "lineno": 69,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 6274,
        "code": "ontract CryptoNumismat \n{\n    address owner;\n\n    string public standard = 'CryptoNumismat';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    struct Buy \n    {\n        uint cardIndex;\n        address seller;\n        uint minValue;  // in wei\n    }\n\n    mapping (uint => Buy) public cardsForSale;\n    mapping (address => bool) public admins;\n    mapping (address => string) public nicknames;\n\n    event Assign(uint indexed _cardIndex, address indexed _seller, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint _cardIndex, uint256 _value);\n    \n    function CryptoNumismat() public payable \n    {\n        owner = msg.sender;\n        admins[owner] = true;\n        \n        totalSupply = 1000;                         // Update total supply\n        name = \"cryptonumismat\";                    // Set the name for display purposes\n        symbol = \"$\";                               // Set the symbol for display purposes\n        decimals = 0;                               // Amount of decimals for display purposes\n    }\n    \n    modifier onlyOwner() \n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyAdmins() \n    {\n        require(admins[msg.sender]);\n        _;\n    }\n    \n    function setOwner(address _owner) onlyOwner() public \n    {\n        owner = _owner;\n    }\n    \n    function addAdmin(address _admin) onlyOwner() public\n    {\n        admins[_admin] = true;\n    }\n    \n    function removeAdmin(address _admin) onlyOwner() public\n    {\n        delete admins[_admin];\n    }\n    \n    function withdrawAll() onlyOwner() public \n    {\n        owner.transfer(this.balance);\n    }\n\n    function withdrawAmount(uint256 _amount) onlyOwner() public \n    {\n        require(_amount <= this.balance);\n        \n        owner.transfer(_amount);\n    }\n\n    function addCard(uint _cardIndex, uint256 _value, address _ownAddress) public onlyAdmins()\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require(cardsForSale[_cardIndex].cardIndex != _cardIndex);\n        \n        address seller = _ownAddress;\n        uint256 _value2 = (_value * 1000000000);\n        \n        cardsForSale[_cardIndex] = Buy(_cardIndex, seller, _value2);\n        Assign(_cardIndex, seller, _value2);\n    }\n    \n    function displayCard(uint _cardIndex) public constant returns(uint, address, uint256) \n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require (cardsForSale[_cardIndex].cardIndex == _cardIndex);\n            \n        return(cardsForSale[_cardIndex].cardIndex, \n        cardsForSale[_cardIndex].seller,\n        cardsForSale[_cardIndex].minValue);\n    }\n    \n    function setNick(string _newNick) public\n    {\n        nicknames[msg.sender] = _newNick;      \n    }\n    \n    function displayNick(address _owner) public constant returns(string)\n    {\n        return nicknames[_owner];\n    }\n    \n    \n    uint256 private limit1 = 0.05 ether;\n    uint256 private limit2 = 0.5 ether;\n    uint256 private limit3 = 5 ether;\n    uint256 private limit4 = 50 ether;\n    \n    function calculateNextPrice(uint256 _startPrice) public constant returns (uint256 _finalPrice)\n    {\n        if (_startPrice < limit1)\n            _startPrice =  _startPrice * 10 / 4;\n        else if (_startPrice < limit2)\n            _startPrice =  _startPrice * 10 / 5;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 10 / 6;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 10 / 7;\n        else\n            _startPrice =  _startPrice * 10 / 8;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function calculateDevCut(uint256 _startPrice) public constant returns (uint256 _cut)\n    {\n        if (_startPrice < limit2)\n            _startPrice =  _startPrice * 5 / 100;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 4 / 100;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 3 / 100;\n        else\n            _startPrice =  _startPrice * 2 / 100;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function buy(uint _cardIndex) public payable\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        require(cardsForSale[_cardIndex].cardIndex == _cardIndex);\n        require(cardsForSale[_cardIndex].seller != msg.sender);\n        require(msg.sender != address(0));\n        require(msg.sender != owner);\n        require(cardsForSale[_cardIndex].minValue > 0);\n        require(msg.value >= cardsForSale[_cardIndex].minValue);\n        \n        address _buyer = msg.sender;\n        address _seller = cardsForSale[_cardIndex].seller;\n        uint256 _price = cardsForSale[_cardIndex].minValue;\n        uint256 _nextPrice = calculateNextPrice(_price);\n        uint256 _totalPrice = _price - calculateDevCut(_price);\n        uint256 _extra = msg.value - _price;\n        \n        cardsForSale[_cardIndex].seller = _buyer;\n        cardsForSale[_cardIndex].minValue = _nextPrice;\n        \n        Transfer(_buyer, _seller, _cardIndex, _totalPrice);\n        Assign(_cardIndex, _buyer, _nextPrice);////////////////////////////////\n        \n        _seller.transfer(_totalPrice);\n        \n        if (_extra > 0)\n        {\n            Transfer(_buyer, _buyer, _cardIndex, _extra);\n            \n            _buyer.transfer(_extra);\n        }\n    }\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_CryptoNumismat_0: 0x20e98bf400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoNumismat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setNick(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "setNick(string)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6303,
        "code": "ontract CryptoNumismat \n{\n    address owner;\n\n    string public standard = 'CryptoNumismat';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    struct Buy \n    {\n        uint cardIndex;\n        address seller;\n        uint minValue;  // in wei\n    }\n\n    mapping (uint => Buy) public cardsForSale;\n    mapping (address => bool) public admins;\n    mapping (address => string) public nicknames;\n\n    event Assign(uint indexed _cardIndex, address indexed _seller, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint _cardIndex, uint256 _value);\n    \n    function CryptoNumismat() public payable \n    {\n        owner = msg.sender;\n        admins[owner] = true;\n        \n        totalSupply = 1000;                         // Update total supply\n        name = \"cryptonumismat\";                    // Set the name for display purposes\n        symbol = \"$\";                               // Set the symbol for display purposes\n        decimals = 0;                               // Amount of decimals for display purposes\n    }\n    \n    modifier onlyOwner() \n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyAdmins() \n    {\n        require(admins[msg.sender]);\n        _;\n    }\n    \n    function setOwner(address _owner) onlyOwner() public \n    {\n        owner = _owner;\n    }\n    \n    function addAdmin(address _admin) onlyOwner() public\n    {\n        admins[_admin] = true;\n    }\n    \n    function removeAdmin(address _admin) onlyOwner() public\n    {\n        delete admins[_admin];\n    }\n    \n    function withdrawAll() onlyOwner() public \n    {\n        owner.transfer(this.balance);\n    }\n\n    function withdrawAmount(uint256 _amount) onlyOwner() public \n    {\n        require(_amount <= this.balance);\n        \n        owner.transfer(_amount);\n    }\n\n    function addCard(uint _cardIndex, uint256 _value, address _ownAddress) public onlyAdmins()\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require(cardsForSale[_cardIndex].cardIndex != _cardIndex);\n        \n        address seller = _ownAddress;\n        uint256 _value2 = (_value * 1000000000);\n        \n        cardsForSale[_cardIndex] = Buy(_cardIndex, seller, _value2);\n        Assign(_cardIndex, seller, _value2);\n    }\n    \n    function displayCard(uint _cardIndex) public constant returns(uint, address, uint256) \n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require (cardsForSale[_cardIndex].cardIndex == _cardIndex);\n            \n        return(cardsForSale[_cardIndex].cardIndex, \n        cardsForSale[_cardIndex].seller,\n        cardsForSale[_cardIndex].minValue);\n    }\n    \n    function setNick(string _newNick) public\n    {\n        nicknames[msg.sender] = _newNick;      \n    }\n    \n    function displayNick(address _owner) public constant returns(string)\n    {\n        return nicknames[_owner];\n    }\n    \n    \n    uint256 private limit1 = 0.05 ether;\n    uint256 private limit2 = 0.5 ether;\n    uint256 private limit3 = 5 ether;\n    uint256 private limit4 = 50 ether;\n    \n    function calculateNextPrice(uint256 _startPrice) public constant returns (uint256 _finalPrice)\n    {\n        if (_startPrice < limit1)\n            _startPrice =  _startPrice * 10 / 4;\n        else if (_startPrice < limit2)\n            _startPrice =  _startPrice * 10 / 5;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 10 / 6;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 10 / 7;\n        else\n            _startPrice =  _startPrice * 10 / 8;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function calculateDevCut(uint256 _startPrice) public constant returns (uint256 _cut)\n    {\n        if (_startPrice < limit2)\n            _startPrice =  _startPrice * 5 / 100;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 4 / 100;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 3 / 100;\n        else\n            _startPrice =  _startPrice * 2 / 100;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function buy(uint _cardIndex) public payable\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        require(cardsForSale[_cardIndex].cardIndex == _cardIndex);\n        require(cardsForSale[_cardIndex].seller != msg.sender);\n        require(msg.sender != address(0));\n        require(msg.sender != owner);\n        require(cardsForSale[_cardIndex].minValue > 0);\n        require(msg.value >= cardsForSale[_cardIndex].minValue);\n        \n        address _buyer = msg.sender;\n        address _seller = cardsForSale[_cardIndex].seller;\n        uint256 _price = cardsForSale[_cardIndex].minValue;\n        uint256 _nextPrice = calculateNextPrice(_price);\n        uint256 _totalPrice = _price - calculateDevCut(_price);\n        uint256 _extra = msg.value - _price;\n        \n        cardsForSale[_cardIndex].seller = _buyer;\n        cardsForSale[_cardIndex].minValue = _nextPrice;\n        \n        Transfer(_buyer, _seller, _cardIndex, _totalPrice);\n        Assign(_cardIndex, _buyer, _nextPrice);////////////////////////////////\n        \n        _seller.transfer(_totalPrice);\n        \n        if (_extra > 0)\n        {\n            Transfer(_buyer, _buyer, _cardIndex, _extra);\n            \n            _buyer.transfer(_extra);\n        }\n    }\n}",
        "debug": "calldata_CryptoNumismat_4 + calldata_CryptoNumismat_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_CryptoNumismat_0: 0x20e98bf400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoNumismat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setNick(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "setNick(string)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6317,
        "code": "ontract CryptoNumismat \n{\n    address owner;\n\n    string public standard = 'CryptoNumismat';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    struct Buy \n    {\n        uint cardIndex;\n        address seller;\n        uint minValue;  // in wei\n    }\n\n    mapping (uint => Buy) public cardsForSale;\n    mapping (address => bool) public admins;\n    mapping (address => string) public nicknames;\n\n    event Assign(uint indexed _cardIndex, address indexed _seller, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint _cardIndex, uint256 _value);\n    \n    function CryptoNumismat() public payable \n    {\n        owner = msg.sender;\n        admins[owner] = true;\n        \n        totalSupply = 1000;                         // Update total supply\n        name = \"cryptonumismat\";                    // Set the name for display purposes\n        symbol = \"$\";                               // Set the symbol for display purposes\n        decimals = 0;                               // Amount of decimals for display purposes\n    }\n    \n    modifier onlyOwner() \n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyAdmins() \n    {\n        require(admins[msg.sender]);\n        _;\n    }\n    \n    function setOwner(address _owner) onlyOwner() public \n    {\n        owner = _owner;\n    }\n    \n    function addAdmin(address _admin) onlyOwner() public\n    {\n        admins[_admin] = true;\n    }\n    \n    function removeAdmin(address _admin) onlyOwner() public\n    {\n        delete admins[_admin];\n    }\n    \n    function withdrawAll() onlyOwner() public \n    {\n        owner.transfer(this.balance);\n    }\n\n    function withdrawAmount(uint256 _amount) onlyOwner() public \n    {\n        require(_amount <= this.balance);\n        \n        owner.transfer(_amount);\n    }\n\n    function addCard(uint _cardIndex, uint256 _value, address _ownAddress) public onlyAdmins()\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require(cardsForSale[_cardIndex].cardIndex != _cardIndex);\n        \n        address seller = _ownAddress;\n        uint256 _value2 = (_value * 1000000000);\n        \n        cardsForSale[_cardIndex] = Buy(_cardIndex, seller, _value2);\n        Assign(_cardIndex, seller, _value2);\n    }\n    \n    function displayCard(uint _cardIndex) public constant returns(uint, address, uint256) \n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require (cardsForSale[_cardIndex].cardIndex == _cardIndex);\n            \n        return(cardsForSale[_cardIndex].cardIndex, \n        cardsForSale[_cardIndex].seller,\n        cardsForSale[_cardIndex].minValue);\n    }\n    \n    function setNick(string _newNick) public\n    {\n        nicknames[msg.sender] = _newNick;      \n    }\n    \n    function displayNick(address _owner) public constant returns(string)\n    {\n        return nicknames[_owner];\n    }\n    \n    \n    uint256 private limit1 = 0.05 ether;\n    uint256 private limit2 = 0.5 ether;\n    uint256 private limit3 = 5 ether;\n    uint256 private limit4 = 50 ether;\n    \n    function calculateNextPrice(uint256 _startPrice) public constant returns (uint256 _finalPrice)\n    {\n        if (_startPrice < limit1)\n            _startPrice =  _startPrice * 10 / 4;\n        else if (_startPrice < limit2)\n            _startPrice =  _startPrice * 10 / 5;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 10 / 6;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 10 / 7;\n        else\n            _startPrice =  _startPrice * 10 / 8;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function calculateDevCut(uint256 _startPrice) public constant returns (uint256 _cut)\n    {\n        if (_startPrice < limit2)\n            _startPrice =  _startPrice * 5 / 100;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 4 / 100;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 3 / 100;\n        else\n            _startPrice =  _startPrice * 2 / 100;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function buy(uint _cardIndex) public payable\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        require(cardsForSale[_cardIndex].cardIndex == _cardIndex);\n        require(cardsForSale[_cardIndex].seller != msg.sender);\n        require(msg.sender != address(0));\n        require(msg.sender != owner);\n        require(cardsForSale[_cardIndex].minValue > 0);\n        require(msg.value >= cardsForSale[_cardIndex].minValue);\n        \n        address _buyer = msg.sender;\n        address _seller = cardsForSale[_cardIndex].seller;\n        uint256 _price = cardsForSale[_cardIndex].minValue;\n        uint256 _nextPrice = calculateNextPrice(_price);\n        uint256 _totalPrice = _price - calculateDevCut(_price);\n        uint256 _extra = msg.value - _price;\n        \n        cardsForSale[_cardIndex].seller = _buyer;\n        cardsForSale[_cardIndex].minValue = _nextPrice;\n        \n        Transfer(_buyer, _seller, _cardIndex, _totalPrice);\n        Assign(_cardIndex, _buyer, _nextPrice);////////////////////////////////\n        \n        _seller.transfer(_totalPrice);\n        \n        if (_extra > 0)\n        {\n            Transfer(_buyer, _buyer, _cardIndex, _extra);\n            \n            _buyer.transfer(_extra);\n        }\n    }\n}",
        "debug": "calldata_CryptoNumismat_4 + calldata_CryptoNumismat_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_CryptoNumismat_0: 0x20e98bf400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoNumismat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setNick(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "setNick(string)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6339,
        "code": "ontract CryptoNumismat \n{\n    address owner;\n\n    string public standard = 'CryptoNumismat';\n    string public name;\n    string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n\n    struct Buy \n    {\n        uint cardIndex;\n        address seller;\n        uint minValue;  // in wei\n    }\n\n    mapping (uint => Buy) public cardsForSale;\n    mapping (address => bool) public admins;\n    mapping (address => string) public nicknames;\n\n    event Assign(uint indexed _cardIndex, address indexed _seller, uint256 _value);\n    event Transfer(address indexed _from, address indexed _to, uint _cardIndex, uint256 _value);\n    \n    function CryptoNumismat() public payable \n    {\n        owner = msg.sender;\n        admins[owner] = true;\n        \n        totalSupply = 1000;                         // Update total supply\n        name = \"cryptonumismat\";                    // Set the name for display purposes\n        symbol = \"$\";                               // Set the symbol for display purposes\n        decimals = 0;                               // Amount of decimals for display purposes\n    }\n    \n    modifier onlyOwner() \n    {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier onlyAdmins() \n    {\n        require(admins[msg.sender]);\n        _;\n    }\n    \n    function setOwner(address _owner) onlyOwner() public \n    {\n        owner = _owner;\n    }\n    \n    function addAdmin(address _admin) onlyOwner() public\n    {\n        admins[_admin] = true;\n    }\n    \n    function removeAdmin(address _admin) onlyOwner() public\n    {\n        delete admins[_admin];\n    }\n    \n    function withdrawAll() onlyOwner() public \n    {\n        owner.transfer(this.balance);\n    }\n\n    function withdrawAmount(uint256 _amount) onlyOwner() public \n    {\n        require(_amount <= this.balance);\n        \n        owner.transfer(_amount);\n    }\n\n    function addCard(uint _cardIndex, uint256 _value, address _ownAddress) public onlyAdmins()\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require(cardsForSale[_cardIndex].cardIndex != _cardIndex);\n        \n        address seller = _ownAddress;\n        uint256 _value2 = (_value * 1000000000);\n        \n        cardsForSale[_cardIndex] = Buy(_cardIndex, seller, _value2);\n        Assign(_cardIndex, seller, _value2);\n    }\n    \n    function displayCard(uint _cardIndex) public constant returns(uint, address, uint256) \n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        \n        require (cardsForSale[_cardIndex].cardIndex == _cardIndex);\n            \n        return(cardsForSale[_cardIndex].cardIndex, \n        cardsForSale[_cardIndex].seller,\n        cardsForSale[_cardIndex].minValue);\n    }\n    \n    function setNick(string _newNick) public\n    {\n        nicknames[msg.sender] = _newNick;      \n    }\n    \n    function displayNick(address _owner) public constant returns(string)\n    {\n        return nicknames[_owner];\n    }\n    \n    \n    uint256 private limit1 = 0.05 ether;\n    uint256 private limit2 = 0.5 ether;\n    uint256 private limit3 = 5 ether;\n    uint256 private limit4 = 50 ether;\n    \n    function calculateNextPrice(uint256 _startPrice) public constant returns (uint256 _finalPrice)\n    {\n        if (_startPrice < limit1)\n            _startPrice =  _startPrice * 10 / 4;\n        else if (_startPrice < limit2)\n            _startPrice =  _startPrice * 10 / 5;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 10 / 6;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 10 / 7;\n        else\n            _startPrice =  _startPrice * 10 / 8;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function calculateDevCut(uint256 _startPrice) public constant returns (uint256 _cut)\n    {\n        if (_startPrice < limit2)\n            _startPrice =  _startPrice * 5 / 100;\n        else if (_startPrice < limit3)\n            _startPrice =  _startPrice * 4 / 100;\n        else if (_startPrice < limit4)\n            _startPrice =  _startPrice * 3 / 100;\n        else\n            _startPrice =  _startPrice * 2 / 100;\n            \n        return (_startPrice / 1000000) * 1000000;\n    }\n    \n    function buy(uint _cardIndex) public payable\n    {\n        require(_cardIndex <= 1000);\n        require(_cardIndex > 0);\n        require(cardsForSale[_cardIndex].cardIndex == _cardIndex);\n        require(cardsForSale[_cardIndex].seller != msg.sender);\n        require(msg.sender != address(0));\n        require(msg.sender != owner);\n        require(cardsForSale[_cardIndex].minValue > 0);\n        require(msg.value >= cardsForSale[_cardIndex].minValue);\n        \n        address _buyer = msg.sender;\n        address _seller = cardsForSale[_cardIndex].seller;\n        uint256 _price = cardsForSale[_cardIndex].minValue;\n        uint256 _nextPrice = calculateNextPrice(_price);\n        uint256 _totalPrice = _price - calculateDevCut(_price);\n        uint256 _extra = msg.value - _price;\n        \n        cardsForSale[_cardIndex].seller = _buyer;\n        cardsForSale[_cardIndex].minValue = _nextPrice;\n        \n        Transfer(_buyer, _seller, _cardIndex, _totalPrice);\n        Assign(_cardIndex, _buyer, _nextPrice);////////////////////////////////\n        \n        _seller.transfer(_totalPrice);\n        \n        if (_extra > 0)\n        {\n            Transfer(_buyer, _buyer, _cardIndex, _extra);\n            \n            _buyer.transfer(_extra);\n        }\n    }\n}",
        "debug": "calldata_CryptoNumismat_4 + calldata_CryptoNumismat_4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoNumismat_0: 0x20e98bf400000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoNumismat: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setNick(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0x386d51a52b36ff03602798418d4d5eec49939c5b.sol",
        "function": "setNick(string)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}