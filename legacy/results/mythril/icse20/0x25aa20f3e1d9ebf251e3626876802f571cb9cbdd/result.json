{
  "contract": "0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd",
  "tool": "mythril",
  "start": 1563718112.0511646,
  "end": 1563718528.648863,
  "duration": 416.5976984500885,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 4374,
        "code": "\n\n\n/**\n * @title E",
        "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\ncaller: 0x0\ncalldata_ivtk_0: 0x6e90025600000000000000000000000000000000000000000000000000000000\ncalldatasize_ivtk: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x6e900256`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/38/0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd.sol",
        "function": "_function_0x6e900256",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4474,
        "code": " amount owned by the p",
        "debug": "mem_544 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 68 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 100 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 132 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 164 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 196 +\n96: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_ivtk_0: 0x6e90025600000000000000000000000000000000000000000000000000000000\ncalldatasize_ivtk: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x6e900256`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/38/0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd.sol",
        "function": "_function_0x6e900256",
        "lineno": 322,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5411,
        "code": "ivInfo.aAmtInc2dec\n    ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ivtk_4: 0xffff7ff7ffffffffffffffffffffffffffffffffdfffffffffffffffffffffff\nstorage_2: 0xffff7ff7ffffffffffffffffffffffffffffffffdffffffffffffffffffffffe\ncalldata_ivtk_0: 0xa37f00f700000000000000000000000000000000000000000000000000000000\ncalldatasize_ivtk: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/38/0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd.sol",
        "function": "getItemByTokenID(uint256)",
        "lineno": 278,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 7864,
        "code": "      uint[] aQty;\n        uint[] aSalePrice2dec;\n        uint[] aAmtExc2dec;\n        uint[] aAmtInc2dec;\n    }\n    \n    invoiceInfo[] aInvoices;\n    \n\n    string public name;\n    string public symbol;\n    \n    \n    \n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n  \n    // Mapping from token ID to owner\n    mapping (uint256 => address) internal tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) internal tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) internal ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n  \n    \n    constructor() public {\n        name = \"IV TokenII\";\n        symbol = \"iv\";\n        \n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(InterfaceId_ERC721);\n        _registerInterface(InterfaceId_ERC721Exists);\n    }\n    \n    function implementsERC721() public pure returns (bool)\n    {\n        return true;\n    }\n    \n    \n    function totalSupply() public view returns (uint256) {\n        return aInvoices.length;\n    }\n    \n    function getItemByTokenID(uint256 _tokenId) public view returns (\n        bytes32 custID,\n        bytes32 docDate,\n        bytes32 invDate,\n        bytes32[] aErc20Tx,\n        uint[] aQty,\n        uint[] aSalePrice2dec,\n        uint[] aAmtExc2dec,\n        uint[] aAmtInc2dec\n        ) {\n        \n        require(_tokenId > 0);\n        \n        invoiceInfo storage ivInfo = aInvoices[_tokenId - 1];\n        \n        return (\n            ivInfo.custID,\n            ivInfo.docDate,\n            ivInfo.invDate,\n            ivInfo.aErc20Tx,\n            ivInfo.aQty,\n            ivInfo.aSalePrice2dec,\n            ivInfo.aAmtExc2dec,\n            ivInfo.aAmtInc2dec\n        );\n    }\n    \n    \n    function addData(\n        bytes32 custID,\n        bytes32 docDate,\n        bytes32 invDate,\n        bytes32[] aErc20Tx,\n        uint[] aQty,\n        uint[] aSalePrice2dec,\n        uint[] aAmtExc2dec,\n        uint[] aAmtInc2dec\n        ) \n        public \n        onlyOwner\n        {\n            \n            \n        \n        invoiceInfo memory ivInfo = invoiceInfo({\n            custID: custID,\n            docDate: docDate,\n            invDate: invDate,\n            aErc20Tx: aErc20Tx,\n            aQty: aQty,\n            aSalePrice2dec: aSalePrice2dec,\n            aAmtExc2dec: aAmtExc2dec,\n            aAmtInc2dec: aAmtInc2dec\n        });\n        \n        uint256 _tokenID = aInvoices.push(ivInfo);\n        \n        addTokenTo(msg.sender, _tokenID);\n        emit Transfer(address(0), msg.sender, _tokenID);\n    }\n    \n    \n    \n    \n    /**\n    * @dev Gets the balance of the specified address\n    * @param _owner address to query the balance of\n    * @return uint256 representing the amount owned by the passed address\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        require(_owner != address(0));\n        return ownedTokensCount[_owner];\n    }\n\n    /**\n    * @dev Gets the owner of the specified token ID\n    * @param _tokenId uint256 ID of the token to query the owner of\n    * @return owner address currently marked as the owner of the given token ID\n    */\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        address owner = tokenOwner[_tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n    * @dev Returns whether the specified token exists\n    * @param _tokenId uint256 ID of the token to query the existence of\n    * @return whether the token exists\n    */\n    function exists(uint256 _tokenId) public view returns (bool) {\n        address owner = tokenOwner[_tokenId];\n        return owner != address(0);\n    }\n    \n    /**\n    * @dev Approves another address to transfer the given token ID\n    * The zero address indicates there is no approved address.\n    * There can only be one approved address per token at a given time.\n    * Can only be called by the token owner or an approved operator.\n    * @param _to address to be approved for the given token ID\n    * @param _tokenId uint256 ID of the token to be approved\n    */\n    function approve(address _to, uint256 _tokenId) public {\n        address owner = ownerOf(_tokenId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        tokenApprovals[_tokenId] = _to;\n        emit Approval(owner, _to, _tokenId);\n    }\n    \n    /**\n    * @dev Gets the approved address for a token ID, or zero if no address set\n    * @param _tokenId uint256 ID of the token to query the approval of\n    * @return address currently approved for the given token ID\n    */\n    function getApproved(uint256 _tokenId) public view returns (address) {\n        return tokenApprovals[_tokenId];\n    }\n\n    /**\n    * @dev Sets or unsets the approval of a given operator\n    * An operator is allowed to transfer all tokens of the sender on their behalf\n    * @param _to operator address to set the approval\n    * @param _approved representing the status of the approval to be set\n    */\n    function setApprovalForAll(address _to, bool _approved) public {\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n    \n    /**\n    * @dev Tells whether an operator is approved by a given owner\n    * @param _owner owner address which you want to query the approval of\n    * @param _operator operator address which you want to query the approval of\n    * @return bool whether the given operator is approved by the given owner\n    */\n    function isApprovedForAll(\n        address _owner,\n        address _operator\n    )\n    public\n    view\n    returns (bool)\n    {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n    * @dev Transfers the ownership of a given token ID to another address\n    * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n    public\n    {\n        require(isApprovedOrOwner(msg.sender, _tokenId));\n        require(_from != address(0));\n        require(_to != address(0));\n\n        clearApproval(_from, _tokenId);\n        removeTokenFrom(_from, _tokenId);\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /**\n    * @dev Safely transfers the ownership of a given token ID to another address\n    * If the target address is a contract, it must implement `onERC721Received`,\n    * which is called upon a safe transfer, and return the magic value\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n    * the transfer is reverted.\n    *\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n    public\n    {\n        // solium-disable-next-line arg-overflow\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /**\n    * @dev Safely transfers the ownership of a given token ID to another address\n    * If the target address is a contract, it must implement `onERC721Received`,\n    * which is called upon a safe transfer, and return the magic value\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n    * the transfer is reverted.\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @param _data bytes data to send along with a safe transfer check\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes _data\n    )\n    public\n    {\n        transferFrom(_from, _to, _tokenId);\n        // solium-disable-next-line arg-overflow\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n    }\n\n    /**\n    * @dev Returns whether the given spender can transfer a given token ID\n    * @param _spender address of the spender to query\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @return bool whether the msg.sender is approved for the given token ID,\n    *  is an operator of the owner, or is the owner of the token\n    */\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    )\n    internal\n    view\n    returns (bool)\n    {\n        address owner = ownerOf(_tokenId);\n        // Disable solium check because of\n        // https://github.com/duaraghav8/Solium/issues/175\n        // solium-disable-next-line operator-whitespace\n        return (\n            _spender == owner ||\n            getApproved(_tokenId) == _spender ||\n            isApprovedForAll(owner, _spender)\n        );\n    }\n    \n    \n    /**\n    * @dev Internal function to clear current approval of a given token ID\n    * Reverts if the given address is not indeed the owner of the token\n    * @param _owner owner of the token\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function clearApproval(address _owner, uint256 _tokenId) internal {\n        require(ownerOf(_tokenId) == _owner);\n        if (tokenApprovals[_tokenId] != address(0)) {\n        tokenApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /**\n    * @dev Internal function to add a token ID to the list of a given address\n    * @param _to address representing the new owner of the given token ID\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n    */\n    function addTokenTo(address _to, uint256 _tokenId) internal {\n        require(tokenOwner[_tokenId] == address(0));\n        tokenOwner[_tokenId] = _to;\n        ownedTokensCount[_to]++;\n    }\n\n    /**\n    * @dev Internal function to remove a token ID from the list of a given address\n    * @param _from address representing the previous owner of the given token ID\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    */\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\n        require(ownerOf(_tokenId) == _from);\n        ownedTokensCount[_from]--;\n        tokenOwner[_tokenId] = address(0);\n    }\n\n    /**\n    * @dev Internal function to invoke `onERC721Received` on a target address\n    * The call is not executed if the target address is not a contract\n    * @param _from address representing the previous owner of the given token ID\n    * @param _to target address that will receive the tokens\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @param _data bytes optional data to send along with the call\n    * @return whether the call correctly returned the expected magic value\n    */\n    function checkAndCallSafeTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes _data\n    )\n    internal\n    returns (bool)\n    {\n        if (!isContract(_to)) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        msg.sender, _from, _tokenId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n    \n    \n    /**\n    * Returns whether the target address is a contract\n    * @dev This function will return false if invoked during the constructor of a contract,\n    * as the code is not actually created until after the constructor finishes.\n    * @param addr address to check\n    * @return whether the target address is a contract\n    */\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n    \n}",
        "debug": "storage_3 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n8*storage_2: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nkeccac_3_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n8*storage_2: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_1: 0x0\ncaller: 0x0\ncalldata_ivtk_0: 0x6e90025600000000000000000000000000000000000000000000000000000000\ncalldatasize_ivtk: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x6e900256`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/38/0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd.sol",
        "function": "_function_0x6e900256",
        "lineno": 205,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7875,
        "code": "      uint[] aQty;\n        uint[] aSalePrice2dec;\n        uint[] aAmtExc2dec;\n        uint[] aAmtInc2dec;\n    }\n    \n    invoiceInfo[] aInvoices;\n    \n\n    string public name;\n    string public symbol;\n    \n    \n    \n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n  \n    // Mapping from token ID to owner\n    mapping (uint256 => address) internal tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) internal tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) internal ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n  \n    \n    constructor() public {\n        name = \"IV TokenII\";\n        symbol = \"iv\";\n        \n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(InterfaceId_ERC721);\n        _registerInterface(InterfaceId_ERC721Exists);\n    }\n    \n    function implementsERC721() public pure returns (bool)\n    {\n        return true;\n    }\n    \n    \n    function totalSupply() public view returns (uint256) {\n        return aInvoices.length;\n    }\n    \n    function getItemByTokenID(uint256 _tokenId) public view returns (\n        bytes32 custID,\n        bytes32 docDate,\n        bytes32 invDate,\n        bytes32[] aErc20Tx,\n        uint[] aQty,\n        uint[] aSalePrice2dec,\n        uint[] aAmtExc2dec,\n        uint[] aAmtInc2dec\n        ) {\n        \n        require(_tokenId > 0);\n        \n        invoiceInfo storage ivInfo = aInvoices[_tokenId - 1];\n        \n        return (\n            ivInfo.custID,\n            ivInfo.docDate,\n            ivInfo.invDate,\n            ivInfo.aErc20Tx,\n            ivInfo.aQty,\n            ivInfo.aSalePrice2dec,\n            ivInfo.aAmtExc2dec,\n            ivInfo.aAmtInc2dec\n        );\n    }\n    \n    \n    function addData(\n        bytes32 custID,\n        bytes32 docDate,\n        bytes32 invDate,\n        bytes32[] aErc20Tx,\n        uint[] aQty,\n        uint[] aSalePrice2dec,\n        uint[] aAmtExc2dec,\n        uint[] aAmtInc2dec\n        ) \n        public \n        onlyOwner\n        {\n            \n            \n        \n        invoiceInfo memory ivInfo = invoiceInfo({\n            custID: custID,\n            docDate: docDate,\n            invDate: invDate,\n            aErc20Tx: aErc20Tx,\n            aQty: aQty,\n            aSalePrice2dec: aSalePrice2dec,\n            aAmtExc2dec: aAmtExc2dec,\n            aAmtInc2dec: aAmtInc2dec\n        });\n        \n        uint256 _tokenID = aInvoices.push(ivInfo);\n        \n        addTokenTo(msg.sender, _tokenID);\n        emit Transfer(address(0), msg.sender, _tokenID);\n    }\n    \n    \n    \n    \n    /**\n    * @dev Gets the balance of the specified address\n    * @param _owner address to query the balance of\n    * @return uint256 representing the amount owned by the passed address\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        require(_owner != address(0));\n        return ownedTokensCount[_owner];\n    }\n\n    /**\n    * @dev Gets the owner of the specified token ID\n    * @param _tokenId uint256 ID of the token to query the owner of\n    * @return owner address currently marked as the owner of the given token ID\n    */\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        address owner = tokenOwner[_tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n    * @dev Returns whether the specified token exists\n    * @param _tokenId uint256 ID of the token to query the existence of\n    * @return whether the token exists\n    */\n    function exists(uint256 _tokenId) public view returns (bool) {\n        address owner = tokenOwner[_tokenId];\n        return owner != address(0);\n    }\n    \n    /**\n    * @dev Approves another address to transfer the given token ID\n    * The zero address indicates there is no approved address.\n    * There can only be one approved address per token at a given time.\n    * Can only be called by the token owner or an approved operator.\n    * @param _to address to be approved for the given token ID\n    * @param _tokenId uint256 ID of the token to be approved\n    */\n    function approve(address _to, uint256 _tokenId) public {\n        address owner = ownerOf(_tokenId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        tokenApprovals[_tokenId] = _to;\n        emit Approval(owner, _to, _tokenId);\n    }\n    \n    /**\n    * @dev Gets the approved address for a token ID, or zero if no address set\n    * @param _tokenId uint256 ID of the token to query the approval of\n    * @return address currently approved for the given token ID\n    */\n    function getApproved(uint256 _tokenId) public view returns (address) {\n        return tokenApprovals[_tokenId];\n    }\n\n    /**\n    * @dev Sets or unsets the approval of a given operator\n    * An operator is allowed to transfer all tokens of the sender on their behalf\n    * @param _to operator address to set the approval\n    * @param _approved representing the status of the approval to be set\n    */\n    function setApprovalForAll(address _to, bool _approved) public {\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n    \n    /**\n    * @dev Tells whether an operator is approved by a given owner\n    * @param _owner owner address which you want to query the approval of\n    * @param _operator operator address which you want to query the approval of\n    * @return bool whether the given operator is approved by the given owner\n    */\n    function isApprovedForAll(\n        address _owner,\n        address _operator\n    )\n    public\n    view\n    returns (bool)\n    {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n    * @dev Transfers the ownership of a given token ID to another address\n    * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n    public\n    {\n        require(isApprovedOrOwner(msg.sender, _tokenId));\n        require(_from != address(0));\n        require(_to != address(0));\n\n        clearApproval(_from, _tokenId);\n        removeTokenFrom(_from, _tokenId);\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /**\n    * @dev Safely transfers the ownership of a given token ID to another address\n    * If the target address is a contract, it must implement `onERC721Received`,\n    * which is called upon a safe transfer, and return the magic value\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n    * the transfer is reverted.\n    *\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n    public\n    {\n        // solium-disable-next-line arg-overflow\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /**\n    * @dev Safely transfers the ownership of a given token ID to another address\n    * If the target address is a contract, it must implement `onERC721Received`,\n    * which is called upon a safe transfer, and return the magic value\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n    * the transfer is reverted.\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @param _data bytes data to send along with a safe transfer check\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes _data\n    )\n    public\n    {\n        transferFrom(_from, _to, _tokenId);\n        // solium-disable-next-line arg-overflow\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n    }\n\n    /**\n    * @dev Returns whether the given spender can transfer a given token ID\n    * @param _spender address of the spender to query\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @return bool whether the msg.sender is approved for the given token ID,\n    *  is an operator of the owner, or is the owner of the token\n    */\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    )\n    internal\n    view\n    returns (bool)\n    {\n        address owner = ownerOf(_tokenId);\n        // Disable solium check because of\n        // https://github.com/duaraghav8/Solium/issues/175\n        // solium-disable-next-line operator-whitespace\n        return (\n            _spender == owner ||\n            getApproved(_tokenId) == _spender ||\n            isApprovedForAll(owner, _spender)\n        );\n    }\n    \n    \n    /**\n    * @dev Internal function to clear current approval of a given token ID\n    * Reverts if the given address is not indeed the owner of the token\n    * @param _owner owner of the token\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function clearApproval(address _owner, uint256 _tokenId) internal {\n        require(ownerOf(_tokenId) == _owner);\n        if (tokenApprovals[_tokenId] != address(0)) {\n        tokenApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /**\n    * @dev Internal function to add a token ID to the list of a given address\n    * @param _to address representing the new owner of the given token ID\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n    */\n    function addTokenTo(address _to, uint256 _tokenId) internal {\n        require(tokenOwner[_tokenId] == address(0));\n        tokenOwner[_tokenId] = _to;\n        ownedTokensCount[_to]++;\n    }\n\n    /**\n    * @dev Internal function to remove a token ID from the list of a given address\n    * @param _from address representing the previous owner of the given token ID\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    */\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\n        require(ownerOf(_tokenId) == _from);\n        ownedTokensCount[_from]--;\n        tokenOwner[_tokenId] = address(0);\n    }\n\n    /**\n    * @dev Internal function to invoke `onERC721Received` on a target address\n    * The call is not executed if the target address is not a contract\n    * @param _from address representing the previous owner of the given token ID\n    * @param _to target address that will receive the tokens\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @param _data bytes optional data to send along with the call\n    * @return whether the call correctly returned the expected magic value\n    */\n    function checkAndCallSafeTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes _data\n    )\n    internal\n    returns (bool)\n    {\n        if (!isContract(_to)) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        msg.sender, _from, _tokenId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n    \n    \n    /**\n    * Returns whether the target address is a contract\n    * @dev This function will return false if invoked during the constructor of a contract,\n    * as the code is not actually created until after the constructor finishes.\n    * @param addr address to check\n    * @return whether the target address is a contract\n    */\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n    \n}",
        "debug": "mem_mem_544 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 68 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 100 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 132 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 164 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 196 +\n96: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_1: 0x0\ncaller: 0x0\ncalldata_ivtk_0: 0x6e90025600000000000000000000000000000000000000000000000000000000\ncalldatasize_ivtk: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x6e900256`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/38/0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd.sol",
        "function": "_function_0x6e900256",
        "lineno": 205,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7877,
        "code": "      uint[] aQty;\n        uint[] aSalePrice2dec;\n        uint[] aAmtExc2dec;\n        uint[] aAmtInc2dec;\n    }\n    \n    invoiceInfo[] aInvoices;\n    \n\n    string public name;\n    string public symbol;\n    \n    \n    \n    // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`\n    // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector`\n    bytes4 private constant ERC721_RECEIVED = 0x150b7a02;\n  \n    // Mapping from token ID to owner\n    mapping (uint256 => address) internal tokenOwner;\n\n    // Mapping from token ID to approved address\n    mapping (uint256 => address) internal tokenApprovals;\n\n    // Mapping from owner to number of owned token\n    mapping (address => uint256) internal ownedTokensCount;\n\n    // Mapping from owner to operator approvals\n    mapping (address => mapping (address => bool)) internal operatorApprovals;\n  \n    \n    constructor() public {\n        name = \"IV TokenII\";\n        symbol = \"iv\";\n        \n        // register the supported interfaces to conform to ERC721 via ERC165\n        _registerInterface(InterfaceId_ERC721);\n        _registerInterface(InterfaceId_ERC721Exists);\n    }\n    \n    function implementsERC721() public pure returns (bool)\n    {\n        return true;\n    }\n    \n    \n    function totalSupply() public view returns (uint256) {\n        return aInvoices.length;\n    }\n    \n    function getItemByTokenID(uint256 _tokenId) public view returns (\n        bytes32 custID,\n        bytes32 docDate,\n        bytes32 invDate,\n        bytes32[] aErc20Tx,\n        uint[] aQty,\n        uint[] aSalePrice2dec,\n        uint[] aAmtExc2dec,\n        uint[] aAmtInc2dec\n        ) {\n        \n        require(_tokenId > 0);\n        \n        invoiceInfo storage ivInfo = aInvoices[_tokenId - 1];\n        \n        return (\n            ivInfo.custID,\n            ivInfo.docDate,\n            ivInfo.invDate,\n            ivInfo.aErc20Tx,\n            ivInfo.aQty,\n            ivInfo.aSalePrice2dec,\n            ivInfo.aAmtExc2dec,\n            ivInfo.aAmtInc2dec\n        );\n    }\n    \n    \n    function addData(\n        bytes32 custID,\n        bytes32 docDate,\n        bytes32 invDate,\n        bytes32[] aErc20Tx,\n        uint[] aQty,\n        uint[] aSalePrice2dec,\n        uint[] aAmtExc2dec,\n        uint[] aAmtInc2dec\n        ) \n        public \n        onlyOwner\n        {\n            \n            \n        \n        invoiceInfo memory ivInfo = invoiceInfo({\n            custID: custID,\n            docDate: docDate,\n            invDate: invDate,\n            aErc20Tx: aErc20Tx,\n            aQty: aQty,\n            aSalePrice2dec: aSalePrice2dec,\n            aAmtExc2dec: aAmtExc2dec,\n            aAmtInc2dec: aAmtInc2dec\n        });\n        \n        uint256 _tokenID = aInvoices.push(ivInfo);\n        \n        addTokenTo(msg.sender, _tokenID);\n        emit Transfer(address(0), msg.sender, _tokenID);\n    }\n    \n    \n    \n    \n    /**\n    * @dev Gets the balance of the specified address\n    * @param _owner address to query the balance of\n    * @return uint256 representing the amount owned by the passed address\n    */\n    function balanceOf(address _owner) public view returns (uint256) {\n        require(_owner != address(0));\n        return ownedTokensCount[_owner];\n    }\n\n    /**\n    * @dev Gets the owner of the specified token ID\n    * @param _tokenId uint256 ID of the token to query the owner of\n    * @return owner address currently marked as the owner of the given token ID\n    */\n    function ownerOf(uint256 _tokenId) public view returns (address) {\n        address owner = tokenOwner[_tokenId];\n        require(owner != address(0));\n        return owner;\n    }\n\n    /**\n    * @dev Returns whether the specified token exists\n    * @param _tokenId uint256 ID of the token to query the existence of\n    * @return whether the token exists\n    */\n    function exists(uint256 _tokenId) public view returns (bool) {\n        address owner = tokenOwner[_tokenId];\n        return owner != address(0);\n    }\n    \n    /**\n    * @dev Approves another address to transfer the given token ID\n    * The zero address indicates there is no approved address.\n    * There can only be one approved address per token at a given time.\n    * Can only be called by the token owner or an approved operator.\n    * @param _to address to be approved for the given token ID\n    * @param _tokenId uint256 ID of the token to be approved\n    */\n    function approve(address _to, uint256 _tokenId) public {\n        address owner = ownerOf(_tokenId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner, msg.sender));\n\n        tokenApprovals[_tokenId] = _to;\n        emit Approval(owner, _to, _tokenId);\n    }\n    \n    /**\n    * @dev Gets the approved address for a token ID, or zero if no address set\n    * @param _tokenId uint256 ID of the token to query the approval of\n    * @return address currently approved for the given token ID\n    */\n    function getApproved(uint256 _tokenId) public view returns (address) {\n        return tokenApprovals[_tokenId];\n    }\n\n    /**\n    * @dev Sets or unsets the approval of a given operator\n    * An operator is allowed to transfer all tokens of the sender on their behalf\n    * @param _to operator address to set the approval\n    * @param _approved representing the status of the approval to be set\n    */\n    function setApprovalForAll(address _to, bool _approved) public {\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n    \n    /**\n    * @dev Tells whether an operator is approved by a given owner\n    * @param _owner owner address which you want to query the approval of\n    * @param _operator operator address which you want to query the approval of\n    * @return bool whether the given operator is approved by the given owner\n    */\n    function isApprovedForAll(\n        address _owner,\n        address _operator\n    )\n    public\n    view\n    returns (bool)\n    {\n        return operatorApprovals[_owner][_operator];\n    }\n\n    /**\n    * @dev Transfers the ownership of a given token ID to another address\n    * Usage of this method is discouraged, use `safeTransferFrom` whenever possible\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n    public\n    {\n        require(isApprovedOrOwner(msg.sender, _tokenId));\n        require(_from != address(0));\n        require(_to != address(0));\n\n        clearApproval(_from, _tokenId);\n        removeTokenFrom(_from, _tokenId);\n        addTokenTo(_to, _tokenId);\n\n        emit Transfer(_from, _to, _tokenId);\n    }\n\n    /**\n    * @dev Safely transfers the ownership of a given token ID to another address\n    * If the target address is a contract, it must implement `onERC721Received`,\n    * which is called upon a safe transfer, and return the magic value\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n    * the transfer is reverted.\n    *\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId\n    )\n    public\n    {\n        // solium-disable-next-line arg-overflow\n        safeTransferFrom(_from, _to, _tokenId, \"\");\n    }\n\n    /**\n    * @dev Safely transfers the ownership of a given token ID to another address\n    * If the target address is a contract, it must implement `onERC721Received`,\n    * which is called upon a safe transfer, and return the magic value\n    * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise,\n    * the transfer is reverted.\n    * Requires the msg sender to be the owner, approved, or operator\n    * @param _from current owner of the token\n    * @param _to address to receive the ownership of the given token ID\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @param _data bytes data to send along with a safe transfer check\n    */\n    function safeTransferFrom(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes _data\n    )\n    public\n    {\n        transferFrom(_from, _to, _tokenId);\n        // solium-disable-next-line arg-overflow\n        require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data));\n    }\n\n    /**\n    * @dev Returns whether the given spender can transfer a given token ID\n    * @param _spender address of the spender to query\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @return bool whether the msg.sender is approved for the given token ID,\n    *  is an operator of the owner, or is the owner of the token\n    */\n    function isApprovedOrOwner(\n        address _spender,\n        uint256 _tokenId\n    )\n    internal\n    view\n    returns (bool)\n    {\n        address owner = ownerOf(_tokenId);\n        // Disable solium check because of\n        // https://github.com/duaraghav8/Solium/issues/175\n        // solium-disable-next-line operator-whitespace\n        return (\n            _spender == owner ||\n            getApproved(_tokenId) == _spender ||\n            isApprovedForAll(owner, _spender)\n        );\n    }\n    \n    \n    /**\n    * @dev Internal function to clear current approval of a given token ID\n    * Reverts if the given address is not indeed the owner of the token\n    * @param _owner owner of the token\n    * @param _tokenId uint256 ID of the token to be transferred\n    */\n    function clearApproval(address _owner, uint256 _tokenId) internal {\n        require(ownerOf(_tokenId) == _owner);\n        if (tokenApprovals[_tokenId] != address(0)) {\n        tokenApprovals[_tokenId] = address(0);\n        }\n    }\n\n    /**\n    * @dev Internal function to add a token ID to the list of a given address\n    * @param _to address representing the new owner of the given token ID\n    * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address\n    */\n    function addTokenTo(address _to, uint256 _tokenId) internal {\n        require(tokenOwner[_tokenId] == address(0));\n        tokenOwner[_tokenId] = _to;\n        ownedTokensCount[_to]++;\n    }\n\n    /**\n    * @dev Internal function to remove a token ID from the list of a given address\n    * @param _from address representing the previous owner of the given token ID\n    * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address\n    */\n    function removeTokenFrom(address _from, uint256 _tokenId) internal {\n        require(ownerOf(_tokenId) == _from);\n        ownedTokensCount[_from]--;\n        tokenOwner[_tokenId] = address(0);\n    }\n\n    /**\n    * @dev Internal function to invoke `onERC721Received` on a target address\n    * The call is not executed if the target address is not a contract\n    * @param _from address representing the previous owner of the given token ID\n    * @param _to target address that will receive the tokens\n    * @param _tokenId uint256 ID of the token to be transferred\n    * @param _data bytes optional data to send along with the call\n    * @return whether the call correctly returned the expected magic value\n    */\n    function checkAndCallSafeTransfer(\n        address _from,\n        address _to,\n        uint256 _tokenId,\n        bytes _data\n    )\n    internal\n    returns (bool)\n    {\n        if (!isContract(_to)) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        msg.sender, _from, _tokenId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n    \n    \n    /**\n    * Returns whether the target address is a contract\n    * @dev This function will return false if invoked during the constructor of a contract,\n    * as the code is not actually created until after the constructor finishes.\n    * @param addr address to check\n    * @return whether the target address is a contract\n    */\n    function isContract(address addr) internal view returns (bool) {\n        uint256 size;\n        // XXX Currently there is no better way to check if there is a contract in an address\n        // than to check the size of the code at that address.\n        // See https://ethereum.stackexchange.com/a/14016/36603\n        // for more details about how this works.\n        // TODO Check this again before the Serenity release, because all addresses will be\n        // contracts then.\n        // solium-disable-next-line security/no-inline-assembly\n        assembly { size := extcodesize(addr) }\n        return size > 0;\n    }\n    \n}",
        "debug": "mem_544 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 68 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 100 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 132 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 164 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 196 +\n96: 0x7fffffffffffffffffffffffffffffffffffffdaffffffffbfff7fffffffffe0\nmem_mem_544 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 68 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 100 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 132 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 164 +\n32*calldata_ivtk_4 + calldata_ivtk_32 + 196 +\n96: 0x7f6fc32c410701432cb30000000000000000000dfffffff3fc0000000000000\nstorage_1: 0x0\ncaller: 0x0\ncalldata_ivtk_0: 0x6e90025600000000000000000000000000000000000000000000000000000000\ncalldatasize_ivtk: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x6e900256`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/38/0x25aa20f3e1d9ebf251e3626876802f571cb9cbdd.sol",
        "function": "_function_0x6e900256",
        "lineno": 205,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}