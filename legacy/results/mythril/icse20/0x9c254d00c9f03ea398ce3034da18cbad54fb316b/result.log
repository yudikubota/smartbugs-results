{"error": null, "issues": [{"address": 314, "code": "s,\n    uint    indexCategory,\n    string label)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    indexStructs[indexName].indexCategory   = indexCategory;\n    indexStructs[indexName].label   = label;\n    indexStructs[indexName].index     = indexIndex.push(indexName)-1;\n    emit LogNewIndex(\n        indexName,\n        indexStructs[indexName].index,\n        indexAddress,\n        indexCategory);\n    return indexIndex.length-1;\n  }\n\n  function deleteIndex(bytes32 indexName)\n    onlyAuthorized\n    public\n    returns(ui", "debug": "calldata_IndexManager_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_IndexManager_0: 0x1f281fc500000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `insertIndex(bytes32,address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "insertIndex(bytes32,address,uint256,string)", "lineno": 71, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1150, "code": ";\n    indexStructs[indexName].label = newLabel;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      newLabel);\n    return true;\n  }\n\n  function getIndexCount()\n    public\n    constant\n    returns(uint count)\n  {\n    return indexIndex.length;\n  }\n\n  function getIndexAtIndex(uint index)\n    public\n    co", "debug": "calldata_IndexManager_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_IndexManager_0: 0x9b75e74700000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateIndexLabel(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "updateIndexLabel(bytes32,string)", "lineno": 164, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1925, "code": ";\n\ncontract IndexM", "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0x40\nkeccac_2_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0x3900000000000000000000000000000000000000000000000000000000000000\ncalldata_IndexManager_4 + calldata_IndexManager_32 + 68: 0x0\ncalldata_IndexManager_4: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0x1f281fc500000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `insertIndex(bytes32,address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "insertIndex(bytes32,address,uint256,string)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1965, "code": "dexStructs[indexName].index,", "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0x8\nkeccac_2_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_IndexManager_4 + calldata_IndexManager_32 + 68: 0x0\ncalldata_IndexManager_4: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0x1f281fc500000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `insertIndex(bytes32,address,uint256,string)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "insertIndex(bytes32,address,uint256,string)", "lineno": 85, "title": "Integer Underflow", "type": "Warning"}, {"address": 3444, "code": "unction insertIndex(\n    bytes32 indexNam", "debug": "The exception is triggered under the following conditions:\n\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0xadbd74cb00000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "updateIndexAddress(bytes32,address)", "lineno": 69, "title": "Exception state", "type": "Informational"}, {"address": 4538, "debug": "The exception is triggered under the following conditions:\n\ncalldata_IndexManager_4: 0x0\nstorage_4: 0x0\ncalldata_IndexManager_0: 0xb07ff8eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "getIndexAtIndex(uint256)", "lineno": 195, "title": "Exception state", "type": "Informational"}, {"address": 5513, "code": "ntract IndexManager {\n\n  bytes32 managerName;\n  address owner;\n\n  struct IndexStruct {\n    address indexAddress;\n    uint indexCategory;\n    string label;\n    uint index;\n  }\n  \n  mapping(address=>bool) public delegatinglist;\n  mapping(bytes32 => IndexStruct) private indexStructs;\n  bytes32[] private indexIndex;\n\n  event LogNewIndex   (bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory);\n  event LogUpdateIndex(bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory, string label);\n  event LogDeleteIndex(bytes32 indexed indexName, uint index);\n\n  event indexInitialized(uint32 _date, bytes32 _indexName);\n  event Authorized(address authorized, uint timestamp);\n  event Revoked(address authorized, uint timestamp);\n\n  modifier onlyAuthorized(){\n      require(isdelegatinglisted(msg.sender));\n      _;\n  }\n\n  function authorize(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = true;\n      emit Authorized(authorized, now);\n  }\n\n  // also if not in the list..\n  function revoke(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = false;\n      emit Revoked(authorized, now);\n  }\n\n  function authorizeMany(address[50] authorized) public onlyAuthorized {\n      for(uint i = 0; i < authorized.length; i++) {\n          authorize(authorized[i]);\n      }\n  }\n\n  function isdelegatinglisted(address authorized) public view returns(bool) {\n    return delegatinglist[authorized];\n  }\n\n  constructor(bytes32 _name) public{        \n      owner = msg.sender;\n      delegatinglist[owner] = true;\n      owner = msg.sender;\n      managerName = _name;\n  }\n\n  function isIndex(bytes32 indexName)\n    public\n    constant\n    returns(bool isIndeed)\n  {\n    if(indexIndex.length == 0) return false;\n    return (indexIndex[indexStructs[indexName].index] == indexName);\n  }\n\n  function insertIndex(\n    bytes32 indexName,\n    address indexAddress,\n    uint    indexCategory,\n    string label)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    indexStructs[indexName].indexCategory   = indexCategory;\n    indexStructs[indexName].label   = label;\n    indexStructs[indexName].index     = indexIndex.push(indexName)-1;\n    emit LogNewIndex(\n        indexName,\n        indexStructs[indexName].index,\n        indexAddress,\n        indexCategory);\n    return indexIndex.length-1;\n  }\n\n  function deleteIndex(bytes32 indexName)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(!isIndex(indexName)) revert();\n    uint rowToDelete = indexStructs[indexName].index;\n    bytes32 keyToMove = indexIndex[indexIndex.length-1];\n    indexIndex[rowToDelete] = keyToMove;\n    indexStructs[keyToMove].index = rowToDelete;\n    indexIndex.length--;\n    emit LogDeleteIndex(\n        indexName,\n        rowToDelete);\n    emit LogUpdateIndex(\n        keyToMove,\n        rowToDelete,\n        indexStructs[keyToMove].indexAddress,\n        indexStructs[keyToMove].indexCategory,\n        indexStructs[keyToMove].label);\n    return rowToDelete;\n  }\n\n  function getIndex(bytes32 indexName)\n    public\n    constant\n    returns(address indexAddress, uint indexCategory, uint index, string label)\n  {\n    if(!isIndex(indexName)) revert();\n    return(\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].index,\n      indexStructs[indexName].label);\n  }\n\n  function updateIndexAddress(bytes32 indexName, address indexAddress)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexCategory(bytes32 indexName, uint indexCategory)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexCategory = indexCategory;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexLabel(bytes32 indexName, string newLabel)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].label = newLabel;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      newLabel);\n    return true;\n  }\n\n  function getIndexCount()\n    public\n    constant\n    returns(uint count)\n  {\n    return indexIndex.length;\n  }\n\n  function getIndexAtIndex(uint index)\n    public\n    constant\n    returns(bytes32 indexName)\n  {\n    return indexIndex[index];\n  }\n\n  function addIndexInitialization(uint32 _date, bytes32 _indexName) public onlyAuthorized {\n    emit indexInitialized(_date, _indexName);\n  }\n\n}", "debug": "storage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_2_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0x1f281fc500000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `insertIndex(bytes32,address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "insertIndex(bytes32,address,uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5542, "code": "ntract IndexManager {\n\n  bytes32 managerName;\n  address owner;\n\n  struct IndexStruct {\n    address indexAddress;\n    uint indexCategory;\n    string label;\n    uint index;\n  }\n  \n  mapping(address=>bool) public delegatinglist;\n  mapping(bytes32 => IndexStruct) private indexStructs;\n  bytes32[] private indexIndex;\n\n  event LogNewIndex   (bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory);\n  event LogUpdateIndex(bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory, string label);\n  event LogDeleteIndex(bytes32 indexed indexName, uint index);\n\n  event indexInitialized(uint32 _date, bytes32 _indexName);\n  event Authorized(address authorized, uint timestamp);\n  event Revoked(address authorized, uint timestamp);\n\n  modifier onlyAuthorized(){\n      require(isdelegatinglisted(msg.sender));\n      _;\n  }\n\n  function authorize(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = true;\n      emit Authorized(authorized, now);\n  }\n\n  // also if not in the list..\n  function revoke(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = false;\n      emit Revoked(authorized, now);\n  }\n\n  function authorizeMany(address[50] authorized) public onlyAuthorized {\n      for(uint i = 0; i < authorized.length; i++) {\n          authorize(authorized[i]);\n      }\n  }\n\n  function isdelegatinglisted(address authorized) public view returns(bool) {\n    return delegatinglist[authorized];\n  }\n\n  constructor(bytes32 _name) public{        \n      owner = msg.sender;\n      delegatinglist[owner] = true;\n      owner = msg.sender;\n      managerName = _name;\n  }\n\n  function isIndex(bytes32 indexName)\n    public\n    constant\n    returns(bool isIndeed)\n  {\n    if(indexIndex.length == 0) return false;\n    return (indexIndex[indexStructs[indexName].index] == indexName);\n  }\n\n  function insertIndex(\n    bytes32 indexName,\n    address indexAddress,\n    uint    indexCategory,\n    string label)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    indexStructs[indexName].indexCategory   = indexCategory;\n    indexStructs[indexName].label   = label;\n    indexStructs[indexName].index     = indexIndex.push(indexName)-1;\n    emit LogNewIndex(\n        indexName,\n        indexStructs[indexName].index,\n        indexAddress,\n        indexCategory);\n    return indexIndex.length-1;\n  }\n\n  function deleteIndex(bytes32 indexName)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(!isIndex(indexName)) revert();\n    uint rowToDelete = indexStructs[indexName].index;\n    bytes32 keyToMove = indexIndex[indexIndex.length-1];\n    indexIndex[rowToDelete] = keyToMove;\n    indexStructs[keyToMove].index = rowToDelete;\n    indexIndex.length--;\n    emit LogDeleteIndex(\n        indexName,\n        rowToDelete);\n    emit LogUpdateIndex(\n        keyToMove,\n        rowToDelete,\n        indexStructs[keyToMove].indexAddress,\n        indexStructs[keyToMove].indexCategory,\n        indexStructs[keyToMove].label);\n    return rowToDelete;\n  }\n\n  function getIndex(bytes32 indexName)\n    public\n    constant\n    returns(address indexAddress, uint indexCategory, uint index, string label)\n  {\n    if(!isIndex(indexName)) revert();\n    return(\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].index,\n      indexStructs[indexName].label);\n  }\n\n  function updateIndexAddress(bytes32 indexName, address indexAddress)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexCategory(bytes32 indexName, uint indexCategory)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexCategory = indexCategory;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexLabel(bytes32 indexName, string newLabel)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].label = newLabel;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      newLabel);\n    return true;\n  }\n\n  function getIndexCount()\n    public\n    constant\n    returns(uint count)\n  {\n    return indexIndex.length;\n  }\n\n  function getIndexAtIndex(uint index)\n    public\n    constant\n    returns(bytes32 indexName)\n  {\n    return indexIndex[index];\n  }\n\n  function addIndexInitialization(uint32 _date, bytes32 _indexName) public onlyAuthorized {\n    emit indexInitialized(_date, _indexName);\n  }\n\n}", "debug": "calldata_IndexManager_4 + calldata_IndexManager_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0x9b75e74700000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\ncalldata_IndexManager_4: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updateIndexLabel(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "updateIndexLabel(bytes32,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5556, "code": "ntract IndexManager {\n\n  bytes32 managerName;\n  address owner;\n\n  struct IndexStruct {\n    address indexAddress;\n    uint indexCategory;\n    string label;\n    uint index;\n  }\n  \n  mapping(address=>bool) public delegatinglist;\n  mapping(bytes32 => IndexStruct) private indexStructs;\n  bytes32[] private indexIndex;\n\n  event LogNewIndex   (bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory);\n  event LogUpdateIndex(bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory, string label);\n  event LogDeleteIndex(bytes32 indexed indexName, uint index);\n\n  event indexInitialized(uint32 _date, bytes32 _indexName);\n  event Authorized(address authorized, uint timestamp);\n  event Revoked(address authorized, uint timestamp);\n\n  modifier onlyAuthorized(){\n      require(isdelegatinglisted(msg.sender));\n      _;\n  }\n\n  function authorize(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = true;\n      emit Authorized(authorized, now);\n  }\n\n  // also if not in the list..\n  function revoke(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = false;\n      emit Revoked(authorized, now);\n  }\n\n  function authorizeMany(address[50] authorized) public onlyAuthorized {\n      for(uint i = 0; i < authorized.length; i++) {\n          authorize(authorized[i]);\n      }\n  }\n\n  function isdelegatinglisted(address authorized) public view returns(bool) {\n    return delegatinglist[authorized];\n  }\n\n  constructor(bytes32 _name) public{        \n      owner = msg.sender;\n      delegatinglist[owner] = true;\n      owner = msg.sender;\n      managerName = _name;\n  }\n\n  function isIndex(bytes32 indexName)\n    public\n    constant\n    returns(bool isIndeed)\n  {\n    if(indexIndex.length == 0) return false;\n    return (indexIndex[indexStructs[indexName].index] == indexName);\n  }\n\n  function insertIndex(\n    bytes32 indexName,\n    address indexAddress,\n    uint    indexCategory,\n    string label)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    indexStructs[indexName].indexCategory   = indexCategory;\n    indexStructs[indexName].label   = label;\n    indexStructs[indexName].index     = indexIndex.push(indexName)-1;\n    emit LogNewIndex(\n        indexName,\n        indexStructs[indexName].index,\n        indexAddress,\n        indexCategory);\n    return indexIndex.length-1;\n  }\n\n  function deleteIndex(bytes32 indexName)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(!isIndex(indexName)) revert();\n    uint rowToDelete = indexStructs[indexName].index;\n    bytes32 keyToMove = indexIndex[indexIndex.length-1];\n    indexIndex[rowToDelete] = keyToMove;\n    indexStructs[keyToMove].index = rowToDelete;\n    indexIndex.length--;\n    emit LogDeleteIndex(\n        indexName,\n        rowToDelete);\n    emit LogUpdateIndex(\n        keyToMove,\n        rowToDelete,\n        indexStructs[keyToMove].indexAddress,\n        indexStructs[keyToMove].indexCategory,\n        indexStructs[keyToMove].label);\n    return rowToDelete;\n  }\n\n  function getIndex(bytes32 indexName)\n    public\n    constant\n    returns(address indexAddress, uint indexCategory, uint index, string label)\n  {\n    if(!isIndex(indexName)) revert();\n    return(\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].index,\n      indexStructs[indexName].label);\n  }\n\n  function updateIndexAddress(bytes32 indexName, address indexAddress)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexCategory(bytes32 indexName, uint indexCategory)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexCategory = indexCategory;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexLabel(bytes32 indexName, string newLabel)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].label = newLabel;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      newLabel);\n    return true;\n  }\n\n  function getIndexCount()\n    public\n    constant\n    returns(uint count)\n  {\n    return indexIndex.length;\n  }\n\n  function getIndexAtIndex(uint index)\n    public\n    constant\n    returns(bytes32 indexName)\n  {\n    return indexIndex[index];\n  }\n\n  function addIndexInitialization(uint32 _date, bytes32 _indexName) public onlyAuthorized {\n    emit indexInitialized(_date, _indexName);\n  }\n\n}", "debug": "calldata_IndexManager_4 + calldata_IndexManager_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0x1f281fc500000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `insertIndex(bytes32,address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "insertIndex(bytes32,address,uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5578, "code": "ntract IndexManager {\n\n  bytes32 managerName;\n  address owner;\n\n  struct IndexStruct {\n    address indexAddress;\n    uint indexCategory;\n    string label;\n    uint index;\n  }\n  \n  mapping(address=>bool) public delegatinglist;\n  mapping(bytes32 => IndexStruct) private indexStructs;\n  bytes32[] private indexIndex;\n\n  event LogNewIndex   (bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory);\n  event LogUpdateIndex(bytes32 indexed indexName, uint index, address indexAddress, uint indexCategory, string label);\n  event LogDeleteIndex(bytes32 indexed indexName, uint index);\n\n  event indexInitialized(uint32 _date, bytes32 _indexName);\n  event Authorized(address authorized, uint timestamp);\n  event Revoked(address authorized, uint timestamp);\n\n  modifier onlyAuthorized(){\n      require(isdelegatinglisted(msg.sender));\n      _;\n  }\n\n  function authorize(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = true;\n      emit Authorized(authorized, now);\n  }\n\n  // also if not in the list..\n  function revoke(address authorized) public onlyAuthorized {\n      delegatinglist[authorized] = false;\n      emit Revoked(authorized, now);\n  }\n\n  function authorizeMany(address[50] authorized) public onlyAuthorized {\n      for(uint i = 0; i < authorized.length; i++) {\n          authorize(authorized[i]);\n      }\n  }\n\n  function isdelegatinglisted(address authorized) public view returns(bool) {\n    return delegatinglist[authorized];\n  }\n\n  constructor(bytes32 _name) public{        \n      owner = msg.sender;\n      delegatinglist[owner] = true;\n      owner = msg.sender;\n      managerName = _name;\n  }\n\n  function isIndex(bytes32 indexName)\n    public\n    constant\n    returns(bool isIndeed)\n  {\n    if(indexIndex.length == 0) return false;\n    return (indexIndex[indexStructs[indexName].index] == indexName);\n  }\n\n  function insertIndex(\n    bytes32 indexName,\n    address indexAddress,\n    uint    indexCategory,\n    string label)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    indexStructs[indexName].indexCategory   = indexCategory;\n    indexStructs[indexName].label   = label;\n    indexStructs[indexName].index     = indexIndex.push(indexName)-1;\n    emit LogNewIndex(\n        indexName,\n        indexStructs[indexName].index,\n        indexAddress,\n        indexCategory);\n    return indexIndex.length-1;\n  }\n\n  function deleteIndex(bytes32 indexName)\n    onlyAuthorized\n    public\n    returns(uint index)\n  {\n    if(!isIndex(indexName)) revert();\n    uint rowToDelete = indexStructs[indexName].index;\n    bytes32 keyToMove = indexIndex[indexIndex.length-1];\n    indexIndex[rowToDelete] = keyToMove;\n    indexStructs[keyToMove].index = rowToDelete;\n    indexIndex.length--;\n    emit LogDeleteIndex(\n        indexName,\n        rowToDelete);\n    emit LogUpdateIndex(\n        keyToMove,\n        rowToDelete,\n        indexStructs[keyToMove].indexAddress,\n        indexStructs[keyToMove].indexCategory,\n        indexStructs[keyToMove].label);\n    return rowToDelete;\n  }\n\n  function getIndex(bytes32 indexName)\n    public\n    constant\n    returns(address indexAddress, uint indexCategory, uint index, string label)\n  {\n    if(!isIndex(indexName)) revert();\n    return(\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].index,\n      indexStructs[indexName].label);\n  }\n\n  function updateIndexAddress(bytes32 indexName, address indexAddress)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexAddress = indexAddress;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexAddress,\n      indexStructs[indexName].indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexCategory(bytes32 indexName, uint indexCategory)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].indexCategory = indexCategory;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexCategory,\n      indexStructs[indexName].label);\n    return true;\n  }\n\n  function updateIndexLabel(bytes32 indexName, string newLabel)\n    onlyAuthorized\n    public\n    returns(bool success)\n  {\n    if(!isIndex(indexName)) revert();\n    indexStructs[indexName].label = newLabel;\n    emit LogUpdateIndex(\n      indexName,\n      indexStructs[indexName].index,\n      indexStructs[indexName].indexAddress,\n      indexStructs[indexName].indexCategory,\n      newLabel);\n    return true;\n  }\n\n  function getIndexCount()\n    public\n    constant\n    returns(uint count)\n  {\n    return indexIndex.length;\n  }\n\n  function getIndexAtIndex(uint index)\n    public\n    constant\n    returns(bytes32 indexName)\n  {\n    return indexIndex[index];\n  }\n\n  function addIndexInitialization(uint32 _date, bytes32 _indexName) public onlyAuthorized {\n    emit indexInitialized(_date, _indexName);\n  }\n\n}", "debug": "keccac_2_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_IndexManager_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_IndexManager_4 + calldata_IndexManager_32 + 68: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_IndexManager_0: 0x1f281fc500000000000000000000000000000000000000000000000000000000\ncalldatasize_IndexManager: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `insertIndex(bytes32,address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/30/0x9c254d00c9f03ea398ce3034da18cbad54fb316b.sol", "function": "insertIndex(bytes32,address,uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}