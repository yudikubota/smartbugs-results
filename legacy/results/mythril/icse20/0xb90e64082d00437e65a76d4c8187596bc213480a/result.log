{"error": null, "issues": [{"address": 591, "code": "nly the ENS owner of the nodehash may create this series\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\n\n        if (rootHash == 0x00) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        // Already exists!\n        if (series.rootHash != 0x00) { return false; }\n\n        series.name = seriesName;\n        series.rootHash = rootHash;\n        series.initialCount = initialCount;\n        series.currentCount = initialCount;\n\n        seriesCreated(nodehash);\n    }\n\n    // Allow the owner to transfer un-claimed items (they already have the\n    // redeem codes, so there is no additional trust required)\n    function be", "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x3634a1b700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createSeries(bytes32,string,bytes32,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 140, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1257, "code": "ies = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow cla", "debug": "calldata_Token_32 + 164: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 184, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1269, "code": "ies = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow cla", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 184, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1272, "code": "ies = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow cla", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 184, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1278, "code": "ies = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow cla", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 184, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1718, "code": "ame, bytes32 rootHash, uint256 initi", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "approveToken(address,uint256)", "lineno": 138, "title": "Message call to external contract", "type": "Warning"}, {"address": 2133, "code": "withdraw(address ta", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "setOwner(address)", "lineno": 125, "title": "Message call to external contract", "type": "Informational"}, {"address": 2133, "code": "withdraw(address ta", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2380\n", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "setOwner(address)", "lineno": 125, "title": "Multiple Calls", "type": "Information"}, {"address": 2380, "code": "nds\n    function withdraw(address target, uint256 a", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "setOwner(address)", "lineno": 124, "title": "Message call to external contract", "type": "Informational"}, {"address": 2621, "code": "false; }\n\n        //", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "bestow(bytes32,uint256,address)", "lineno": 167, "title": "Message call to external contract", "type": "Informational"}, {"address": 2908, "code": "Allow a user to claim", "debug": "retval_2621: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_32 + 4: 0x0\nstorage_4 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\ncalldata_Token_32 + 36: 0xdead\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x26c9e54700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `bestow(bytes32,uint256,address)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "bestow(bytes32,uint256,address)", "lineno": 182, "title": "Integer Underflow", "type": "Warning"}, {"address": 2929, "code": "their redeem code\n  ", "debug": "storage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_2621: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_32 + 4: 0x0\ncalldata_Token_32 + 36: 0xdead\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x26c9e54700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `bestow(bytes32,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "bestow(bytes32,uint256,address)", "lineno": 182, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2933, "code": "their redeem code\n  ", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "bestow(bytes32,uint256,address)", "lineno": 182, "title": "State change after external call", "type": "Warning"}, {"address": 3017, "code": "aim(bytes32 nodehash, uint256 it", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "bestow(bytes32,uint256,address)", "lineno": 183, "title": "State change after external call", "type": "Warning"}, {"address": 3351, "code": " function owner() con", "debug": "storage_4 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\ncalldata_Token_32 + 36: 0xdead\ncaller: 0x0\nstorage_keccac_calldata_Token_32_+_4: 0x0\ncalldata_Token_0: 0x2ad2a9f800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `transfer(bytes32,uint256,address)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "transfer(bytes32,uint256,address)", "lineno": 250, "title": "Integer Underflow", "type": "Warning"}, {"address": 3719, "code": "\n\n        // Already", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 145, "title": "Message call to external contract", "type": "Informational"}, {"address": 3957, "code": "    }\n\n    // Allow the ow", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 156, "title": "State change after external call", "type": "Warning"}, {"address": 3966, "code": "sfer un-claimed items (they alread", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 158, "title": "State change after external call", "type": "Warning"}, {"address": 3975, "code": "    // redeem codes, so there is n", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 159, "title": "State change after external call", "type": "Warning"}, {"address": 4604, "code": "Proof.length; i++) {\n            if ((path ", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa\ncalldata_Token_32 + 4: 0x0\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 198, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4765, "code": " node);\n            } else {\n                node ", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\ncalldata_Token_32 + 4: 0x0\nretval_4690: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 200, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4771, "code": " node);\n            } else {\n                node ", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_Token_32 + 4: 0x0\nretval_4690: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 200, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4785, "code": " node);\n            } else {\n                node ", "debug": "calldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff7\ncalldata_Token_32 + 4: 0x0\nretval_4690: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 200, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4956, "code": "he owner\n        series.owners[", "debug": "calldata_Token_32 + 4: 0x0\ncalldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9\nretval_4690: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 210, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4970, "code": "he owner\n        series.owners[", "debug": "calldata_Token_32 + 4: 0x0\ncalldata_Token_4 + calldata_Token_32 + 164: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\nretval_4690: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 210, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5142, "code": " itemIndex, address ", "debug": "calldata_Token_32 + 4: 0x0\ncalldata_Token_4 + calldata_Token_32 + 164: 0x1\nstorage_3 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_4690: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_Token_32_+_4: 0x0\nstorage_2 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x1\ncalldata_Token_0: 0xc89d606300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\nKECCAC_mem_32 + 160 + 32*calldata_Token_4 + calldata_Token_32 + 164): 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "claim(bytes32,uint256,address,uint8,bytes32,bytes32,bytes32[])", "lineno": 222, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5405, "code": "(address token, uint256 amo", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0xf3fef3a300000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nretval_5393: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "withdraw(address,uint256)", "lineno": 131, "title": "Exception state", "type": "Informational"}, {"address": 5449, "code": "ytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    event seriesCreated(bytes32 indexed nodehash);\n\n    event itemTransferred(\n        bytes32 indexed nodehash,\n        uint256 itemIndex,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n\n    struct Series {\n        // The name of the series (the namehash of this should resovle to the nodehash)\n        string name;\n\n        // The merkle root of all stikers in the series\n        bytes32 rootHash;\n\n        // The initial number of cards issued\n        uint256 initialCount;\n\n        // How many have been claimed\n        uint256 issuedCount;\n\n        // The total number in existance after taking provable burning into account\n        uint256 currentCount;\n\n        // Maps a serial number to an owner\n        mapping (uint256 => address) owners;\n    }\n\n    AbstractENS _ens;\n\n    address _owner;\n\n    mapping (bytes32 => Series) _series;\n\n\n    function StickerRegistry(address ens) {\n        _owner = msg.sender;\n        _ens = AbstractENS(ens);\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    function setOwner(address newOwner) {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    // Bailout - Just in case this contract ever receives funds\n    function withdraw(address target, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(target.send(amount));\n    }\n\n    // Bailout - Just in case this contract ever received tokens\n    function approveToken(address token, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(Token(token).approve(_owner, amount));\n    }\n\n\n    // Create a new series\n    function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) {\n\n        // Only the ENS owner of the nodehash may create this series\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\n\n        if (rootHash == 0x00) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        // Already exists!\n        if (series.rootHash != 0x00) { return false; }\n\n        series.name = seriesName;\n        series.rootHash = rootHash;\n        series.initialCount = initialCount;\n        series.currentCount = initialCount;\n\n        seriesCreated(nodehash);\n    }\n\n    // Allow the owner to transfer un-claimed items (they already have the\n    // redeem codes, so there is no additional trust required)\n    function bestow(bytes32 nodehash, uint256 itemIndex, address owner) returns (bool success) {\n\n        // Only the ENS owner of nodehash may bestow\n        if (_ens.owner(nodehash) != msg.sender) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        // Burning...\n        if (owner == 0xdead) { series.currentCount--; }\n\n        series.issuedCount++;\n\n        series.owners[itemIndex] = owner;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n    }\n\n    // Allow a user to claim an item using their redeem code\n    function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS,  bytes32[] merkleProof) returns (bool success) {\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow claiming again)\n        if (newOwner == 0) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        address currentOwner = series.owners[itemIndex];\n\n        // Only the owner can transfer a item\n        if (currentOwner != msg.sender) {\n            return false;\n        }\n\n        // Burining! Anyone may choose to destroy a sticker to provably lower\n        // its total supply\n        if (newOwner == 0xdead) { series.currentCount--; }\n\n        itemTransferred(nodehash, itemIndex, currentOwner, newOwner);\n\n        // Assign the new owner\n        series.owners[itemIndex] = newOwner;\n\n        return true;\n    }\n\n\n    // Get the contract owner\n    function owner() constant returns (address) {\n        return _owner;\n    }\n\n    // Get details about a given series\n    function seriesInfo(bytes32 nodehash) constant returns (string name, bytes32 rootHash, uint256 initialCount, uint256 issuedCount, uint256 currentCount) {\n        Series storage series = _series[nodehash];\n        return (series.name, series.rootHash, series.initialCount, series.issuedCount, series.currentCount);\n    }\n\n    // Get the owner of an item\n    function itemOwner(bytes32 nodehash, uint256 itemIndex) constant returns (address) {\n        return _series[nodehash].owners[itemIndex];\n    }\n}", "debug": "keccac_0_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_Token_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncaller: 0x0\nreturndatasize: 0x20\nretval_3719: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x3634a1b700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createSeries(bytes32,string,bytes32,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 69, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5478, "code": "ytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    event seriesCreated(bytes32 indexed nodehash);\n\n    event itemTransferred(\n        bytes32 indexed nodehash,\n        uint256 itemIndex,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n\n    struct Series {\n        // The name of the series (the namehash of this should resovle to the nodehash)\n        string name;\n\n        // The merkle root of all stikers in the series\n        bytes32 rootHash;\n\n        // The initial number of cards issued\n        uint256 initialCount;\n\n        // How many have been claimed\n        uint256 issuedCount;\n\n        // The total number in existance after taking provable burning into account\n        uint256 currentCount;\n\n        // Maps a serial number to an owner\n        mapping (uint256 => address) owners;\n    }\n\n    AbstractENS _ens;\n\n    address _owner;\n\n    mapping (bytes32 => Series) _series;\n\n\n    function StickerRegistry(address ens) {\n        _owner = msg.sender;\n        _ens = AbstractENS(ens);\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    function setOwner(address newOwner) {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    // Bailout - Just in case this contract ever receives funds\n    function withdraw(address target, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(target.send(amount));\n    }\n\n    // Bailout - Just in case this contract ever received tokens\n    function approveToken(address token, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(Token(token).approve(_owner, amount));\n    }\n\n\n    // Create a new series\n    function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) {\n\n        // Only the ENS owner of the nodehash may create this series\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\n\n        if (rootHash == 0x00) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        // Already exists!\n        if (series.rootHash != 0x00) { return false; }\n\n        series.name = seriesName;\n        series.rootHash = rootHash;\n        series.initialCount = initialCount;\n        series.currentCount = initialCount;\n\n        seriesCreated(nodehash);\n    }\n\n    // Allow the owner to transfer un-claimed items (they already have the\n    // redeem codes, so there is no additional trust required)\n    function bestow(bytes32 nodehash, uint256 itemIndex, address owner) returns (bool success) {\n\n        // Only the ENS owner of nodehash may bestow\n        if (_ens.owner(nodehash) != msg.sender) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        // Burning...\n        if (owner == 0xdead) { series.currentCount--; }\n\n        series.issuedCount++;\n\n        series.owners[itemIndex] = owner;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n    }\n\n    // Allow a user to claim an item using their redeem code\n    function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS,  bytes32[] merkleProof) returns (bool success) {\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow claiming again)\n        if (newOwner == 0) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        address currentOwner = series.owners[itemIndex];\n\n        // Only the owner can transfer a item\n        if (currentOwner != msg.sender) {\n            return false;\n        }\n\n        // Burining! Anyone may choose to destroy a sticker to provably lower\n        // its total supply\n        if (newOwner == 0xdead) { series.currentCount--; }\n\n        itemTransferred(nodehash, itemIndex, currentOwner, newOwner);\n\n        // Assign the new owner\n        series.owners[itemIndex] = newOwner;\n\n        return true;\n    }\n\n\n    // Get the contract owner\n    function owner() constant returns (address) {\n        return _owner;\n    }\n\n    // Get details about a given series\n    function seriesInfo(bytes32 nodehash) constant returns (string name, bytes32 rootHash, uint256 initialCount, uint256 issuedCount, uint256 currentCount) {\n        Series storage series = _series[nodehash];\n        return (series.name, series.rootHash, series.initialCount, series.issuedCount, series.currentCount);\n    }\n\n    // Get the owner of an item\n    function itemOwner(bytes32 nodehash, uint256 itemIndex) constant returns (address) {\n        return _series[nodehash].owners[itemIndex];\n    }\n}", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncaller: 0x0\nreturndatasize: 0x20\nretval_3719: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x3634a1b700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createSeries(bytes32,string,bytes32,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 69, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5483, "code": "ytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    event seriesCreated(bytes32 indexed nodehash);\n\n    event itemTransferred(\n        bytes32 indexed nodehash,\n        uint256 itemIndex,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n\n    struct Series {\n        // The name of the series (the namehash of this should resovle to the nodehash)\n        string name;\n\n        // The merkle root of all stikers in the series\n        bytes32 rootHash;\n\n        // The initial number of cards issued\n        uint256 initialCount;\n\n        // How many have been claimed\n        uint256 issuedCount;\n\n        // The total number in existance after taking provable burning into account\n        uint256 currentCount;\n\n        // Maps a serial number to an owner\n        mapping (uint256 => address) owners;\n    }\n\n    AbstractENS _ens;\n\n    address _owner;\n\n    mapping (bytes32 => Series) _series;\n\n\n    function StickerRegistry(address ens) {\n        _owner = msg.sender;\n        _ens = AbstractENS(ens);\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    function setOwner(address newOwner) {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    // Bailout - Just in case this contract ever receives funds\n    function withdraw(address target, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(target.send(amount));\n    }\n\n    // Bailout - Just in case this contract ever received tokens\n    function approveToken(address token, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(Token(token).approve(_owner, amount));\n    }\n\n\n    // Create a new series\n    function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) {\n\n        // Only the ENS owner of the nodehash may create this series\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\n\n        if (rootHash == 0x00) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        // Already exists!\n        if (series.rootHash != 0x00) { return false; }\n\n        series.name = seriesName;\n        series.rootHash = rootHash;\n        series.initialCount = initialCount;\n        series.currentCount = initialCount;\n\n        seriesCreated(nodehash);\n    }\n\n    // Allow the owner to transfer un-claimed items (they already have the\n    // redeem codes, so there is no additional trust required)\n    function bestow(bytes32 nodehash, uint256 itemIndex, address owner) returns (bool success) {\n\n        // Only the ENS owner of nodehash may bestow\n        if (_ens.owner(nodehash) != msg.sender) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        // Burning...\n        if (owner == 0xdead) { series.currentCount--; }\n\n        series.issuedCount++;\n\n        series.owners[itemIndex] = owner;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n    }\n\n    // Allow a user to claim an item using their redeem code\n    function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS,  bytes32[] merkleProof) returns (bool success) {\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow claiming again)\n        if (newOwner == 0) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        address currentOwner = series.owners[itemIndex];\n\n        // Only the owner can transfer a item\n        if (currentOwner != msg.sender) {\n            return false;\n        }\n\n        // Burining! Anyone may choose to destroy a sticker to provably lower\n        // its total supply\n        if (newOwner == 0xdead) { series.currentCount--; }\n\n        itemTransferred(nodehash, itemIndex, currentOwner, newOwner);\n\n        // Assign the new owner\n        series.owners[itemIndex] = newOwner;\n\n        return true;\n    }\n\n\n    // Get the contract owner\n    function owner() constant returns (address) {\n        return _owner;\n    }\n\n    // Get details about a given series\n    function seriesInfo(bytes32 nodehash) constant returns (string name, bytes32 rootHash, uint256 initialCount, uint256 issuedCount, uint256 currentCount) {\n        Series storage series = _series[nodehash];\n        return (series.name, series.rootHash, series.initialCount, series.issuedCount, series.currentCount);\n    }\n\n    // Get the owner of an item\n    function itemOwner(bytes32 nodehash, uint256 itemIndex) constant returns (address) {\n        return _series[nodehash].owners[itemIndex];\n    }\n}", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 69, "title": "State change after external call", "type": "Warning"}, {"address": 5492, "code": "ytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    event seriesCreated(bytes32 indexed nodehash);\n\n    event itemTransferred(\n        bytes32 indexed nodehash,\n        uint256 itemIndex,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n\n    struct Series {\n        // The name of the series (the namehash of this should resovle to the nodehash)\n        string name;\n\n        // The merkle root of all stikers in the series\n        bytes32 rootHash;\n\n        // The initial number of cards issued\n        uint256 initialCount;\n\n        // How many have been claimed\n        uint256 issuedCount;\n\n        // The total number in existance after taking provable burning into account\n        uint256 currentCount;\n\n        // Maps a serial number to an owner\n        mapping (uint256 => address) owners;\n    }\n\n    AbstractENS _ens;\n\n    address _owner;\n\n    mapping (bytes32 => Series) _series;\n\n\n    function StickerRegistry(address ens) {\n        _owner = msg.sender;\n        _ens = AbstractENS(ens);\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    function setOwner(address newOwner) {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    // Bailout - Just in case this contract ever receives funds\n    function withdraw(address target, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(target.send(amount));\n    }\n\n    // Bailout - Just in case this contract ever received tokens\n    function approveToken(address token, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(Token(token).approve(_owner, amount));\n    }\n\n\n    // Create a new series\n    function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) {\n\n        // Only the ENS owner of the nodehash may create this series\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\n\n        if (rootHash == 0x00) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        // Already exists!\n        if (series.rootHash != 0x00) { return false; }\n\n        series.name = seriesName;\n        series.rootHash = rootHash;\n        series.initialCount = initialCount;\n        series.currentCount = initialCount;\n\n        seriesCreated(nodehash);\n    }\n\n    // Allow the owner to transfer un-claimed items (they already have the\n    // redeem codes, so there is no additional trust required)\n    function bestow(bytes32 nodehash, uint256 itemIndex, address owner) returns (bool success) {\n\n        // Only the ENS owner of nodehash may bestow\n        if (_ens.owner(nodehash) != msg.sender) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        // Burning...\n        if (owner == 0xdead) { series.currentCount--; }\n\n        series.issuedCount++;\n\n        series.owners[itemIndex] = owner;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n    }\n\n    // Allow a user to claim an item using their redeem code\n    function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS,  bytes32[] merkleProof) returns (bool success) {\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow claiming again)\n        if (newOwner == 0) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        address currentOwner = series.owners[itemIndex];\n\n        // Only the owner can transfer a item\n        if (currentOwner != msg.sender) {\n            return false;\n        }\n\n        // Burining! Anyone may choose to destroy a sticker to provably lower\n        // its total supply\n        if (newOwner == 0xdead) { series.currentCount--; }\n\n        itemTransferred(nodehash, itemIndex, currentOwner, newOwner);\n\n        // Assign the new owner\n        series.owners[itemIndex] = newOwner;\n\n        return true;\n    }\n\n\n    // Get the contract owner\n    function owner() constant returns (address) {\n        return _owner;\n    }\n\n    // Get details about a given series\n    function seriesInfo(bytes32 nodehash) constant returns (string name, bytes32 rootHash, uint256 initialCount, uint256 issuedCount, uint256 currentCount) {\n        Series storage series = _series[nodehash];\n        return (series.name, series.rootHash, series.initialCount, series.issuedCount, series.currentCount);\n    }\n\n    // Get the owner of an item\n    function itemOwner(bytes32 nodehash, uint256 itemIndex) constant returns (address) {\n        return _series[nodehash].owners[itemIndex];\n    }\n}", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_Token_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncaller: 0x0\nreturndatasize: 0x20\nretval_3719: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x3634a1b700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createSeries(bytes32,string,bytes32,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 69, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5514, "code": "ytes32 constant RR_NODE = 0x91d1777781884d03a6757a803996e38de2a42967fb37eeaca72729271025a9e2;\n\n    event seriesCreated(bytes32 indexed nodehash);\n\n    event itemTransferred(\n        bytes32 indexed nodehash,\n        uint256 itemIndex,\n        address indexed oldOwner,\n        address indexed newOwner\n    );\n\n\n    struct Series {\n        // The name of the series (the namehash of this should resovle to the nodehash)\n        string name;\n\n        // The merkle root of all stikers in the series\n        bytes32 rootHash;\n\n        // The initial number of cards issued\n        uint256 initialCount;\n\n        // How many have been claimed\n        uint256 issuedCount;\n\n        // The total number in existance after taking provable burning into account\n        uint256 currentCount;\n\n        // Maps a serial number to an owner\n        mapping (uint256 => address) owners;\n    }\n\n    AbstractENS _ens;\n\n    address _owner;\n\n    mapping (bytes32 => Series) _series;\n\n\n    function StickerRegistry(address ens) {\n        _owner = msg.sender;\n        _ens = AbstractENS(ens);\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    function setOwner(address newOwner) {\n        require(msg.sender == _owner);\n        _owner = newOwner;\n\n        // Give the owner access to the reverse entry\n        ReverseRegistrar(_ens.owner(RR_NODE)).claim(_owner);\n    }\n\n    // Bailout - Just in case this contract ever receives funds\n    function withdraw(address target, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(target.send(amount));\n    }\n\n    // Bailout - Just in case this contract ever received tokens\n    function approveToken(address token, uint256 amount) {\n        require(msg.sender == _owner);\n        assert(Token(token).approve(_owner, amount));\n    }\n\n\n    // Create a new series\n    function createSeries(bytes32 nodehash, string seriesName, bytes32 rootHash, uint256 initialCount) returns (bool success) {\n\n        // Only the ENS owner of the nodehash may create this series\n        if (msg.sender != _ens.owner(nodehash)) { return false; }\n\n        if (rootHash == 0x00) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        // Already exists!\n        if (series.rootHash != 0x00) { return false; }\n\n        series.name = seriesName;\n        series.rootHash = rootHash;\n        series.initialCount = initialCount;\n        series.currentCount = initialCount;\n\n        seriesCreated(nodehash);\n    }\n\n    // Allow the owner to transfer un-claimed items (they already have the\n    // redeem codes, so there is no additional trust required)\n    function bestow(bytes32 nodehash, uint256 itemIndex, address owner) returns (bool success) {\n\n        // Only the ENS owner of nodehash may bestow\n        if (_ens.owner(nodehash) != msg.sender) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        // Burning...\n        if (owner == 0xdead) { series.currentCount--; }\n\n        series.issuedCount++;\n\n        series.owners[itemIndex] = owner;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n    }\n\n    // Allow a user to claim an item using their redeem code\n    function claim(bytes32 nodehash, uint256 itemIndex, address owner, uint8 sigV, bytes32 sigR, bytes32 sigS,  bytes32[] merkleProof) returns (bool success) {\n        Series storage series = _series[nodehash];\n\n        if (itemIndex >= series.initialCount) { return false; }\n\n        // Already claimed\n        if (series.owners[itemIndex] != 0) { return false; }\n\n        uint256 path = itemIndex;\n\n        // Compute the redeem code address from the provided proof\n        address fauxOwner = ecrecover(bytes32(owner), sigV, sigR, sigS);\n\n        // Verify the merkle proof\n        bytes32 node = keccak256(nodehash, itemIndex, bytes32(fauxOwner));\n        for (uint16 i = 0; i < merkleProof.length; i++) {\n            if ((path & 0x01) == 1) {\n                node = keccak256(merkleProof[i], node);\n            } else {\n                node = keccak256(node, merkleProof[i]);\n            }\n            path /= 2;\n        }\n\n        // Failed merkle proof\n        if (node != series.rootHash) { return false; }\n\n        // Assign the caller as the owner\n        series.owners[itemIndex] = owner;\n\n        // One more has been issued\n        series.issuedCount++;\n\n        itemTransferred(nodehash, itemIndex, 0x0, owner);\n\n        return true;\n    }\n\n    // Allow item owners to transfer to another account\n    function transfer(bytes32 nodehash, uint256 itemIndex, address newOwner) returns (bool success) {\n\n        // Do not allow transfering to 0 (would allow claiming again)\n        if (newOwner == 0) { return false; }\n\n        Series storage series = _series[nodehash];\n\n        address currentOwner = series.owners[itemIndex];\n\n        // Only the owner can transfer a item\n        if (currentOwner != msg.sender) {\n            return false;\n        }\n\n        // Burining! Anyone may choose to destroy a sticker to provably lower\n        // its total supply\n        if (newOwner == 0xdead) { series.currentCount--; }\n\n        itemTransferred(nodehash, itemIndex, currentOwner, newOwner);\n\n        // Assign the new owner\n        series.owners[itemIndex] = newOwner;\n\n        return true;\n    }\n\n\n    // Get the contract owner\n    function owner() constant returns (address) {\n        return _owner;\n    }\n\n    // Get details about a given series\n    function seriesInfo(bytes32 nodehash) constant returns (string name, bytes32 rootHash, uint256 initialCount, uint256 issuedCount, uint256 currentCount) {\n        Series storage series = _series[nodehash];\n        return (series.name, series.rootHash, series.initialCount, series.issuedCount, series.currentCount);\n    }\n\n    // Get the owner of an item\n    function itemOwner(bytes32 nodehash, uint256 itemIndex) constant returns (address) {\n        return _series[nodehash].owners[itemIndex];\n    }\n}", "debug": "keccac_0_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_4 + calldata_Token_32 + 4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\ncalldata_Token_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncaller: 0x0\nreturndatasize: 0x20\nretval_3719: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x3634a1b700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Token_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createSeries(bytes32,string,bytes32,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0xb90e64082d00437e65a76d4c8187596bc213480a.sol", "function": "createSeries(bytes32,string,bytes32,uint256)", "lineno": 69, "title": "Integer Overflow ", "type": "Warning"}], "success": true}