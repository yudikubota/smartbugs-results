{"error": null, "issues": [{"address": 1510, "debug": "SOLVER OUTPUT:\nstorage_2: 0x0\ncaller: 0x0\ncalldata_CryptoBetOn_0: 0x1c02708d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\ncallvalue: 0x0\n", "description": "The function `_function_0x1c02708d` executes the SUICIDE instruction. The remaining Ether is sent to a stored address.\n\nThere is a check on storage index 2. This storage index can be written to by calling the function `acceptBet(uint256,uint8)`.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "_function_0x1c02708d", "lineno": 329, "title": "Unchecked SUICIDE", "type": "Warning"}, {"address": 4257, "code": "ount = msg.value;\n", "debug": "storage_5 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_32 + 4: 0x0\ncallvalue: 0x2386f26fc10000\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 298, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4382, "code": " m.gamersD[m.gamersD.l", "debug": "storage_2 + keccac_calldata_CryptoBetOn_4: 0x7e8000000000028500e000034f3d74f06ad379ff88600168c0b41ea800000575\nstorage_5 + keccac_calldata_CryptoBetOn_4: 0xbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x8c00000000018cb424400107647947753e0753c0837eec69933dd0a3908001e5\ncalldata_CryptoBetOn_32 + 4: 0x0\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 301, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4422, "code": "= msg.value;\n     ", "debug": "storage_7 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_32 + 4: 0x2\ncallvalue: 0x2386f26fc10000\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 303, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4547, "code": "ate,\n                 ", "debug": "callvalue: 0x8c00000000018cb424400107647947753e0753c0837eec69933dd0a3908001e5\nstorage_7 + keccac_calldata_CryptoBetOn_4: 0xbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 + keccac_calldata_CryptoBetOn_4: 0x7e8000000000028500e000034f3d74f06ad379ff88600168c0b41ea800000575\ncalldata_CryptoBetOn_32 + 4: 0x2\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 307, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4587, "code": "er);\n    }\n\n    fu", "debug": "storage_6 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_32 + 4: 0x1\ncallvalue: 0x2386f26fc10000\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 310, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4712, "code": "        require(_amoun", "debug": "storage_4 + keccac_calldata_CryptoBetOn_4: 0x7e8000000000028500e000034f3d74f06ad379ff88600168c0b41ea800000575\ncallvalue: 0x8c00000000018cb424400107647947753e0753c0837eec69933dd0a3908001e5\nstorage_6 + keccac_calldata_CryptoBetOn_4: 0xbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_32 + 4: 0x1\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 315, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5094, "debug": "SOLVER OUTPUT:\ncalldata_CryptoBetOn_32 + 4: 0x1\nstorage_2: 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2\ncaller: 0x0\ncalldata_CryptoBetOn_0: 0xb2852bec00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\ncallvalue: 0x0\n", "description": "In the function `saveCash(address,uint256)` a non-zero amount of Ether is sent to an address taken from function arguments.\n\nThere is a check on storage index 2. This storage slot can be written to by calling the function `acceptBet(uint256,uint8)`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `acceptBet(uint256,uint8)`.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "saveCash(address,uint256)", "lineno": 329, "title": "Ether send", "type": "Warning"}, {"address": 5857, "code": "ortMatch(uint _matchId) onlyowner hasmatch(_mat", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 5857\n", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "abortMatch(uint256)", "lineno": 176, "title": "Multiple Calls", "type": "Information"}, {"address": 7637, "code": "ct CryptoBetOn {\n\n    struct Gamer {\n        address wallet;\n        uint amount;\n    }\n\n    struct Match {\n        bool bets;\n        uint number;\n        uint winPotA;\n        uint winPotB;\n        uint winPotD;\n        Gamer[] gamersA;\n        Gamer[] gamersD;\n        Gamer[] gamersB;\n    }\n\n    uint16 constant MATCH_COUNT_LIMIT = 512;\n    uint8 constant HOUSE_EDGE_TOP_BAR = 12;\n    uint8 constant HOUSE_EDGE_BOTTOM_BAR = 1;\n\n    uint8 constant TX_N01 = 1; // \"TX_N01. Not found match by id\";\n    uint8 constant TX_N02 = 2; // \"TX_N02. Thanks, brother!\";\n    uint8 constant TX_N03 = 3; // \"TX_N03. The number of matches should not exceed the limit\";\n    uint8 constant TX_N04 = 4; // \"TX_N04. The percentage of the fee should not exceed the limits\";\n    uint8 constant TX_N16 = 16; // \"TX_N16. Non-standard situation: We did not receive fees\"\n    uint8 constant TX_N17 = 17; // \"TX_N17. Abnormal situation: Failed to return some bets back\"\n    uint8 constant TX_N18 = 18; // \"TX_N18. Abnormal situation: Failed to return some bets back\"\n    uint8 constant TX_N19 = 19; // \"TX_N19. Match with id already exists\";\n\n    // Fee is 4 percent of win amount\n    uint8 private houseEdge = 3;\n    uint constant JACKPOT_FEE = 1;\n    uint jackpotAmount = 0;\n    address private owner;\n    uint16 matchCount = 0;\n    mapping (uint => Match) matchesMap;\n\n    modifier onlyowner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier hasmatch(uint _matchId) {\n        var m = matchesMap[_matchId];\n        if (m.number != 0) {\n            _;\n        } else {\n            TxMessage(_matchId, TX_N01, 0);\n        }\n     }\n\n    function CryptoBetOn() payable {\n        owner = msg.sender;\n    }\n\n    event TxMessage(uint _matchId,\n                    uint8 _code,\n                    uint _value);\n\n    event MatchAdded(uint _matchId,\n                     uint8 _houseEdge,\n                     uint16 _matchCount);\n\n    event MatchGetted(uint _matchId,\n                      bool _bets,\n                      uint _number,\n                      uint _winPotA,\n                      uint _winPotB);\n\n    event MatchPayoff(uint _matchId,\n                       uint _winPot,\n                       uint _collectedFees,\n                       uint _jackpotAmount);\n\n    event MatchAborted(uint _matchId);\n\n    event BetAccepted(uint _matchId,\n                      uint8 _betState,\n                      address _wallet,\n                      uint _amount,\n                      uint _blockNumber);\n\n\n    event CashSaved(uint _amount);\n\n    event JackpotPayoff(uint _matchId, uint _amount, address _wallet);\n\n    function() payable {\n        if (msg.value > 0) {\n            TxMessage(0, TX_N02, msg.value);\n        }\n    }\n\n    function setHouseEdge(uint8 _houseEdge) onlyowner {\n        if (houseEdge < HOUSE_EDGE_BOTTOM_BAR || _houseEdge > HOUSE_EDGE_TOP_BAR) {\n            TxMessage(0, TX_N04, _houseEdge);\n            return;\n        }\n        houseEdge = _houseEdge;\n    }\n\n    function getHouseEdge() constant returns(uint8) {\n        return houseEdge;\n    }\n\n    function getOwner() constant returns(address) {\n        return owner;\n    }\n\n    function getBalance() constant returns (uint) {\n        return this.balance;\n    }\n\n    function getJackpotAmount() constant returns(uint) {\n        return jackpotAmount;\n    }\n\n    function getMatchCount() constant returns(uint16) {\n        return matchCount;\n    }\n\n    function addNewMatch(uint _matchId) private returns(bool) {\n        var m = matchesMap[_matchId];\n        if (m.number != 0) {\n            return true;\n        }\n        if (_matchId == 0) {\n            TxMessage(_matchId, TX_N19, m.number);\n            return false;\n        }\n        if (matchCount >= MATCH_COUNT_LIMIT) {\n            TxMessage(_matchId, TX_N03, matchCount);\n            return false;\n        }\n        matchesMap[_matchId].bets = true;\n        matchesMap[_matchId].number = block.number;\n        matchCount += 1;\n        MatchAdded(_matchId,\n                   houseEdge,\n                   matchCount);\n        return true;\n    }\n\n    function getMatch(uint _matchId) hasmatch(_matchId) {\n        var m = matchesMap[_matchId];\n        MatchGetted(_matchId,\n                    m.bets,\n                    m.number,\n                    m.winPotA,\n                    m.winPotB);\n    }\n\n    function betsOff(uint _matchId) onlyowner hasmatch(_matchId) returns (bool) {\n        matchesMap[_matchId].bets = false;\n        return true;\n    }\n\n    function cashBack(Gamer[] gamers) private returns(uint) {\n        uint amount = 0;\n        for (uint index = 0; index < gamers.length; index++) {\n            if (!gamers[index].wallet.send(gamers[index].amount)) {\n                amount += gamers[index].amount;\n            }\n        }\n        return amount;\n    }\n\n    function abortMatch(uint _matchId) onlyowner hasmatch(_matchId) {\n        var m = matchesMap[_matchId]; // TODO whether the data is copied or it is the reference to storage\n        cashBack(m.gamersA);\n        cashBack(m.gamersB);\n        cashBack(m.gamersD);\n        clearMatch(_matchId);\n        MatchAborted(_matchId);\n    }\n\n    function eraseMatch(uint _matchId) onlyowner hasmatch(_matchId) {\n        clearMatch(_matchId);\n        MatchAborted(_matchId);\n    }\n\n    function payoutJackpot(uint _matchId, Gamer[] gamers) onlyowner private {\n        uint tmpAmount = 0;\n        address jackpotWinner = 0;\n        uint tmpJackpotAmount = jackpotAmount;\n        jackpotAmount = 0;\n        for (uint pos = 0; pos < gamers.length; pos += 1) {\n            if (gamers[pos].amount > tmpAmount) {\n                tmpAmount = gamers[pos].amount;\n                jackpotWinner = gamers[pos].wallet;\n            }\n        }\n        if (jackpotWinner != 0 && jackpotWinner.send(tmpJackpotAmount)) {\n            JackpotPayoff(_matchId, tmpJackpotAmount, jackpotWinner);\n        }\n    }\n\n    function checkMatchToBeAborted(uint _matchId, uint8 _winner) private returns(bool) {\n        var m = matchesMap[_matchId];\n        if (m.number == 0 || m.bets) {\n            return true;\n        }\n        if ((m.winPotA == 0 && _winner == 0) || (m.winPotD == 0 && _winner == 1) || (m.winPotB == 0 && _winner == 2)) {\n            return true;\n        }\n        if ((m.winPotA == 0 && m.winPotB == 0) || (m.winPotA == 0 && m.winPotD == 0) || (m.winPotB == 0 && m.winPotD == 0)) {\n            return true;\n        }\n        return false;\n    }\n\n    function payoutMatch(uint _matchId, uint8 _winner, bool _jackpot) onlyowner {\n        // cash back if need abort\n        if (checkMatchToBeAborted(_matchId, _winner)) {\n            abortMatch(_matchId);\n            return;\n        }\n        var m = matchesMap[_matchId];\n        var gamers = m.gamersA;\n        uint winPot = m.winPotA;\n        uint losePot_ = m.winPotB + m.winPotD;\n        if (_winner == 2) {\n            gamers = m.gamersB;\n            winPot = m.winPotB;\n            losePot_ = m.winPotA + m.winPotD;\n        } else if (_winner == 1) {\n            gamers = m.gamersD;\n            winPot = m.winPotD;\n            losePot_ = m.winPotA + m.winPotB;\n        }\n        uint fallbackAmount = 0;\n        uint collectedFees = (losePot_ * houseEdge) / uint(100);\n        uint jackpotFees = (losePot_ * JACKPOT_FEE) / uint(100);\n        uint losePot = losePot_ - collectedFees - jackpotFees;\n        for (uint index = 0; index < gamers.length; index += 1) {\n            uint winAmount = gamers[index].amount + ((gamers[index].amount * losePot) / winPot);\n            if (!gamers[index].wallet.send(winAmount)) {\n                fallbackAmount += winAmount;\n            }\n        }\n        jackpotAmount += jackpotFees;\n        if (_jackpot) {\n            payoutJackpot(_matchId, gamers);\n        }\n        // pay housecut & reset for next bet\n        if (collectedFees > 0) {\n            if (!owner.send(collectedFees)) {\n                TxMessage(_matchId, TX_N16, collectedFees);\n                   // There is a manual way of withdrawing money!\n            }\n        }\n        if (fallbackAmount > 0) {\n            if (owner.send(fallbackAmount)) {\n                TxMessage(_matchId, TX_N17, fallbackAmount);\n            } else {\n                TxMessage(_matchId, TX_N18, fallbackAmount);\n            }\n        }\n        clearMatch(_matchId);\n        MatchPayoff(_matchId,\n                    losePot,\n                    collectedFees, \n                    jackpotAmount);\n    }\n\n    function clearMatch(uint _matchId) private hasmatch(_matchId) {\n        delete matchesMap[_matchId].gamersA;\n        delete matchesMap[_matchId].gamersB;\n        delete matchesMap[_matchId].gamersD;\n        delete matchesMap[_matchId];\n        matchCount--;\n    }\n\n    function acceptBet(uint _matchId, uint8 _betState) payable {\n        var m = matchesMap[_matchId];\n        if (m.number == 0 ) {\n            require(addNewMatch(_matchId));\n            m = matchesMap[_matchId];\n        }\n        require(m.bets);\n        require(msg.value >= 10 finney); //  && msg.value <= 100 ether\n        if (_betState == 0) {\n            var gamerA = m.gamersA[m.gamersA.length++];\n            gamerA.wallet = msg.sender;\n            gamerA.amount = msg.value;\n            m.winPotA += msg.value;\n        } else if (_betState == 2) {\n            var gamerB = m.gamersB[m.gamersB.length++];\n            gamerB.wallet = msg.sender;\n            gamerB.amount = msg.value;\n            m.winPotB += msg.value;\n        } else if (_betState == 1) {\n            var gamerD = m.gamersD[m.gamersD.length++];\n            gamerD.wallet = msg.sender;\n            gamerD.amount = msg.value;\n            m.winPotD += msg.value;\n        }\n        BetAccepted(_matchId,\n                    _betState,\n                    msg.sender,\n                    msg.value,\n                    block.number);\n    }\n\n    function saveCash(address _receiver, uint _amount) onlyowner {\n         require(matchCount == 0);\n         require(_amount > 0);\n         require(this.balance > _amount);\n         // send cash\n         if (_receiver.send(_amount)) {\n             // confirm\n             CashSaved(_amount);\n         }\n     }\n\n    function killContract () onlyowner {\n        require(matchCount == 0);\n        // transfer amount to wallet address\n        selfdestruct(owner);\n    }\n}", "debug": "storage_5 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_5_+_keccac_calldata_CryptoBetOn_4: 0x545491e000000000000000000000000000000000000000000000000000000000\ncalldata_CryptoBetOn_32 + 4: 0x0\ncallvalue: 0x2386f26fc10000\nstorage_0 + keccac_calldata_CryptoBetOn_4: 0xff00\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoBetOn_0: 0x9adcb5eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\n", "description": "A possible integer overflow exists in the function `acceptBet(uint256,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "acceptBet(uint256,uint8)", "lineno": 7, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7665, "code": "ct CryptoBetOn {\n\n    struct Gamer {\n        address wallet;\n        uint amount;\n    }\n\n    struct Match {\n        bool bets;\n        uint number;\n        uint winPotA;\n        uint winPotB;\n        uint winPotD;\n        Gamer[] gamersA;\n        Gamer[] gamersD;\n        Gamer[] gamersB;\n    }\n\n    uint16 constant MATCH_COUNT_LIMIT = 512;\n    uint8 constant HOUSE_EDGE_TOP_BAR = 12;\n    uint8 constant HOUSE_EDGE_BOTTOM_BAR = 1;\n\n    uint8 constant TX_N01 = 1; // \"TX_N01. Not found match by id\";\n    uint8 constant TX_N02 = 2; // \"TX_N02. Thanks, brother!\";\n    uint8 constant TX_N03 = 3; // \"TX_N03. The number of matches should not exceed the limit\";\n    uint8 constant TX_N04 = 4; // \"TX_N04. The percentage of the fee should not exceed the limits\";\n    uint8 constant TX_N16 = 16; // \"TX_N16. Non-standard situation: We did not receive fees\"\n    uint8 constant TX_N17 = 17; // \"TX_N17. Abnormal situation: Failed to return some bets back\"\n    uint8 constant TX_N18 = 18; // \"TX_N18. Abnormal situation: Failed to return some bets back\"\n    uint8 constant TX_N19 = 19; // \"TX_N19. Match with id already exists\";\n\n    // Fee is 4 percent of win amount\n    uint8 private houseEdge = 3;\n    uint constant JACKPOT_FEE = 1;\n    uint jackpotAmount = 0;\n    address private owner;\n    uint16 matchCount = 0;\n    mapping (uint => Match) matchesMap;\n\n    modifier onlyowner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier hasmatch(uint _matchId) {\n        var m = matchesMap[_matchId];\n        if (m.number != 0) {\n            _;\n        } else {\n            TxMessage(_matchId, TX_N01, 0);\n        }\n     }\n\n    function CryptoBetOn() payable {\n        owner = msg.sender;\n    }\n\n    event TxMessage(uint _matchId,\n                    uint8 _code,\n                    uint _value);\n\n    event MatchAdded(uint _matchId,\n                     uint8 _houseEdge,\n                     uint16 _matchCount);\n\n    event MatchGetted(uint _matchId,\n                      bool _bets,\n                      uint _number,\n                      uint _winPotA,\n                      uint _winPotB);\n\n    event MatchPayoff(uint _matchId,\n                       uint _winPot,\n                       uint _collectedFees,\n                       uint _jackpotAmount);\n\n    event MatchAborted(uint _matchId);\n\n    event BetAccepted(uint _matchId,\n                      uint8 _betState,\n                      address _wallet,\n                      uint _amount,\n                      uint _blockNumber);\n\n\n    event CashSaved(uint _amount);\n\n    event JackpotPayoff(uint _matchId, uint _amount, address _wallet);\n\n    function() payable {\n        if (msg.value > 0) {\n            TxMessage(0, TX_N02, msg.value);\n        }\n    }\n\n    function setHouseEdge(uint8 _houseEdge) onlyowner {\n        if (houseEdge < HOUSE_EDGE_BOTTOM_BAR || _houseEdge > HOUSE_EDGE_TOP_BAR) {\n            TxMessage(0, TX_N04, _houseEdge);\n            return;\n        }\n        houseEdge = _houseEdge;\n    }\n\n    function getHouseEdge() constant returns(uint8) {\n        return houseEdge;\n    }\n\n    function getOwner() constant returns(address) {\n        return owner;\n    }\n\n    function getBalance() constant returns (uint) {\n        return this.balance;\n    }\n\n    function getJackpotAmount() constant returns(uint) {\n        return jackpotAmount;\n    }\n\n    function getMatchCount() constant returns(uint16) {\n        return matchCount;\n    }\n\n    function addNewMatch(uint _matchId) private returns(bool) {\n        var m = matchesMap[_matchId];\n        if (m.number != 0) {\n            return true;\n        }\n        if (_matchId == 0) {\n            TxMessage(_matchId, TX_N19, m.number);\n            return false;\n        }\n        if (matchCount >= MATCH_COUNT_LIMIT) {\n            TxMessage(_matchId, TX_N03, matchCount);\n            return false;\n        }\n        matchesMap[_matchId].bets = true;\n        matchesMap[_matchId].number = block.number;\n        matchCount += 1;\n        MatchAdded(_matchId,\n                   houseEdge,\n                   matchCount);\n        return true;\n    }\n\n    function getMatch(uint _matchId) hasmatch(_matchId) {\n        var m = matchesMap[_matchId];\n        MatchGetted(_matchId,\n                    m.bets,\n                    m.number,\n                    m.winPotA,\n                    m.winPotB);\n    }\n\n    function betsOff(uint _matchId) onlyowner hasmatch(_matchId) returns (bool) {\n        matchesMap[_matchId].bets = false;\n        return true;\n    }\n\n    function cashBack(Gamer[] gamers) private returns(uint) {\n        uint amount = 0;\n        for (uint index = 0; index < gamers.length; index++) {\n            if (!gamers[index].wallet.send(gamers[index].amount)) {\n                amount += gamers[index].amount;\n            }\n        }\n        return amount;\n    }\n\n    function abortMatch(uint _matchId) onlyowner hasmatch(_matchId) {\n        var m = matchesMap[_matchId]; // TODO whether the data is copied or it is the reference to storage\n        cashBack(m.gamersA);\n        cashBack(m.gamersB);\n        cashBack(m.gamersD);\n        clearMatch(_matchId);\n        MatchAborted(_matchId);\n    }\n\n    function eraseMatch(uint _matchId) onlyowner hasmatch(_matchId) {\n        clearMatch(_matchId);\n        MatchAborted(_matchId);\n    }\n\n    function payoutJackpot(uint _matchId, Gamer[] gamers) onlyowner private {\n        uint tmpAmount = 0;\n        address jackpotWinner = 0;\n        uint tmpJackpotAmount = jackpotAmount;\n        jackpotAmount = 0;\n        for (uint pos = 0; pos < gamers.length; pos += 1) {\n            if (gamers[pos].amount > tmpAmount) {\n                tmpAmount = gamers[pos].amount;\n                jackpotWinner = gamers[pos].wallet;\n            }\n        }\n        if (jackpotWinner != 0 && jackpotWinner.send(tmpJackpotAmount)) {\n            JackpotPayoff(_matchId, tmpJackpotAmount, jackpotWinner);\n        }\n    }\n\n    function checkMatchToBeAborted(uint _matchId, uint8 _winner) private returns(bool) {\n        var m = matchesMap[_matchId];\n        if (m.number == 0 || m.bets) {\n            return true;\n        }\n        if ((m.winPotA == 0 && _winner == 0) || (m.winPotD == 0 && _winner == 1) || (m.winPotB == 0 && _winner == 2)) {\n            return true;\n        }\n        if ((m.winPotA == 0 && m.winPotB == 0) || (m.winPotA == 0 && m.winPotD == 0) || (m.winPotB == 0 && m.winPotD == 0)) {\n            return true;\n        }\n        return false;\n    }\n\n    function payoutMatch(uint _matchId, uint8 _winner, bool _jackpot) onlyowner {\n        // cash back if need abort\n        if (checkMatchToBeAborted(_matchId, _winner)) {\n            abortMatch(_matchId);\n            return;\n        }\n        var m = matchesMap[_matchId];\n        var gamers = m.gamersA;\n        uint winPot = m.winPotA;\n        uint losePot_ = m.winPotB + m.winPotD;\n        if (_winner == 2) {\n            gamers = m.gamersB;\n            winPot = m.winPotB;\n            losePot_ = m.winPotA + m.winPotD;\n        } else if (_winner == 1) {\n            gamers = m.gamersD;\n            winPot = m.winPotD;\n            losePot_ = m.winPotA + m.winPotB;\n        }\n        uint fallbackAmount = 0;\n        uint collectedFees = (losePot_ * houseEdge) / uint(100);\n        uint jackpotFees = (losePot_ * JACKPOT_FEE) / uint(100);\n        uint losePot = losePot_ - collectedFees - jackpotFees;\n        for (uint index = 0; index < gamers.length; index += 1) {\n            uint winAmount = gamers[index].amount + ((gamers[index].amount * losePot) / winPot);\n            if (!gamers[index].wallet.send(winAmount)) {\n                fallbackAmount += winAmount;\n            }\n        }\n        jackpotAmount += jackpotFees;\n        if (_jackpot) {\n            payoutJackpot(_matchId, gamers);\n        }\n        // pay housecut & reset for next bet\n        if (collectedFees > 0) {\n            if (!owner.send(collectedFees)) {\n                TxMessage(_matchId, TX_N16, collectedFees);\n                   // There is a manual way of withdrawing money!\n            }\n        }\n        if (fallbackAmount > 0) {\n            if (owner.send(fallbackAmount)) {\n                TxMessage(_matchId, TX_N17, fallbackAmount);\n            } else {\n                TxMessage(_matchId, TX_N18, fallbackAmount);\n            }\n        }\n        clearMatch(_matchId);\n        MatchPayoff(_matchId,\n                    losePot,\n                    collectedFees, \n                    jackpotAmount);\n    }\n\n    function clearMatch(uint _matchId) private hasmatch(_matchId) {\n        delete matchesMap[_matchId].gamersA;\n        delete matchesMap[_matchId].gamersB;\n        delete matchesMap[_matchId].gamersD;\n        delete matchesMap[_matchId];\n        matchCount--;\n    }\n\n    function acceptBet(uint _matchId, uint8 _betState) payable {\n        var m = matchesMap[_matchId];\n        if (m.number == 0 ) {\n            require(addNewMatch(_matchId));\n            m = matchesMap[_matchId];\n        }\n        require(m.bets);\n        require(msg.value >= 10 finney); //  && msg.value <= 100 ether\n        if (_betState == 0) {\n            var gamerA = m.gamersA[m.gamersA.length++];\n            gamerA.wallet = msg.sender;\n            gamerA.amount = msg.value;\n            m.winPotA += msg.value;\n        } else if (_betState == 2) {\n            var gamerB = m.gamersB[m.gamersB.length++];\n            gamerB.wallet = msg.sender;\n            gamerB.amount = msg.value;\n            m.winPotB += msg.value;\n        } else if (_betState == 1) {\n            var gamerD = m.gamersD[m.gamersD.length++];\n            gamerD.wallet = msg.sender;\n            gamerD.amount = msg.value;\n            m.winPotD += msg.value;\n        }\n        BetAccepted(_matchId,\n                    _betState,\n                    msg.sender,\n                    msg.value,\n                    block.number);\n    }\n\n    function saveCash(address _receiver, uint _amount) onlyowner {\n         require(matchCount == 0);\n         require(_amount > 0);\n         require(this.balance > _amount);\n         // send cash\n         if (_receiver.send(_amount)) {\n             // confirm\n             CashSaved(_amount);\n         }\n     }\n\n    function killContract () onlyowner {\n        require(matchCount == 0);\n        // transfer amount to wallet address\n        selfdestruct(owner);\n    }\n}", "debug": "storage_5 + keccac_calldata_CryptoBetOn_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x0\ncaller: 0x0\ncalldata_CryptoBetOn_0: 0xbc81f2f500000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `eraseMatch(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "eraseMatch(uint256)", "lineno": 7, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7677, "code": "ct CryptoBetOn {\n\n    struct Gamer {\n        address wallet;\n        uint amount;\n    }\n\n    struct Match {\n        bool bets;\n        uint number;\n        uint winPotA;\n        uint winPotB;\n        uint winPotD;\n        Gamer[] gamersA;\n        Gamer[] gamersD;\n        Gamer[] gamersB;\n    }\n\n    uint16 constant MATCH_COUNT_LIMIT = 512;\n    uint8 constant HOUSE_EDGE_TOP_BAR = 12;\n    uint8 constant HOUSE_EDGE_BOTTOM_BAR = 1;\n\n    uint8 constant TX_N01 = 1; // \"TX_N01. Not found match by id\";\n    uint8 constant TX_N02 = 2; // \"TX_N02. Thanks, brother!\";\n    uint8 constant TX_N03 = 3; // \"TX_N03. The number of matches should not exceed the limit\";\n    uint8 constant TX_N04 = 4; // \"TX_N04. The percentage of the fee should not exceed the limits\";\n    uint8 constant TX_N16 = 16; // \"TX_N16. Non-standard situation: We did not receive fees\"\n    uint8 constant TX_N17 = 17; // \"TX_N17. Abnormal situation: Failed to return some bets back\"\n    uint8 constant TX_N18 = 18; // \"TX_N18. Abnormal situation: Failed to return some bets back\"\n    uint8 constant TX_N19 = 19; // \"TX_N19. Match with id already exists\";\n\n    // Fee is 4 percent of win amount\n    uint8 private houseEdge = 3;\n    uint constant JACKPOT_FEE = 1;\n    uint jackpotAmount = 0;\n    address private owner;\n    uint16 matchCount = 0;\n    mapping (uint => Match) matchesMap;\n\n    modifier onlyowner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    modifier hasmatch(uint _matchId) {\n        var m = matchesMap[_matchId];\n        if (m.number != 0) {\n            _;\n        } else {\n            TxMessage(_matchId, TX_N01, 0);\n        }\n     }\n\n    function CryptoBetOn() payable {\n        owner = msg.sender;\n    }\n\n    event TxMessage(uint _matchId,\n                    uint8 _code,\n                    uint _value);\n\n    event MatchAdded(uint _matchId,\n                     uint8 _houseEdge,\n                     uint16 _matchCount);\n\n    event MatchGetted(uint _matchId,\n                      bool _bets,\n                      uint _number,\n                      uint _winPotA,\n                      uint _winPotB);\n\n    event MatchPayoff(uint _matchId,\n                       uint _winPot,\n                       uint _collectedFees,\n                       uint _jackpotAmount);\n\n    event MatchAborted(uint _matchId);\n\n    event BetAccepted(uint _matchId,\n                      uint8 _betState,\n                      address _wallet,\n                      uint _amount,\n                      uint _blockNumber);\n\n\n    event CashSaved(uint _amount);\n\n    event JackpotPayoff(uint _matchId, uint _amount, address _wallet);\n\n    function() payable {\n        if (msg.value > 0) {\n            TxMessage(0, TX_N02, msg.value);\n        }\n    }\n\n    function setHouseEdge(uint8 _houseEdge) onlyowner {\n        if (houseEdge < HOUSE_EDGE_BOTTOM_BAR || _houseEdge > HOUSE_EDGE_TOP_BAR) {\n            TxMessage(0, TX_N04, _houseEdge);\n            return;\n        }\n        houseEdge = _houseEdge;\n    }\n\n    function getHouseEdge() constant returns(uint8) {\n        return houseEdge;\n    }\n\n    function getOwner() constant returns(address) {\n        return owner;\n    }\n\n    function getBalance() constant returns (uint) {\n        return this.balance;\n    }\n\n    function getJackpotAmount() constant returns(uint) {\n        return jackpotAmount;\n    }\n\n    function getMatchCount() constant returns(uint16) {\n        return matchCount;\n    }\n\n    function addNewMatch(uint _matchId) private returns(bool) {\n        var m = matchesMap[_matchId];\n        if (m.number != 0) {\n            return true;\n        }\n        if (_matchId == 0) {\n            TxMessage(_matchId, TX_N19, m.number);\n            return false;\n        }\n        if (matchCount >= MATCH_COUNT_LIMIT) {\n            TxMessage(_matchId, TX_N03, matchCount);\n            return false;\n        }\n        matchesMap[_matchId].bets = true;\n        matchesMap[_matchId].number = block.number;\n        matchCount += 1;\n        MatchAdded(_matchId,\n                   houseEdge,\n                   matchCount);\n        return true;\n    }\n\n    function getMatch(uint _matchId) hasmatch(_matchId) {\n        var m = matchesMap[_matchId];\n        MatchGetted(_matchId,\n                    m.bets,\n                    m.number,\n                    m.winPotA,\n                    m.winPotB);\n    }\n\n    function betsOff(uint _matchId) onlyowner hasmatch(_matchId) returns (bool) {\n        matchesMap[_matchId].bets = false;\n        return true;\n    }\n\n    function cashBack(Gamer[] gamers) private returns(uint) {\n        uint amount = 0;\n        for (uint index = 0; index < gamers.length; index++) {\n            if (!gamers[index].wallet.send(gamers[index].amount)) {\n                amount += gamers[index].amount;\n            }\n        }\n        return amount;\n    }\n\n    function abortMatch(uint _matchId) onlyowner hasmatch(_matchId) {\n        var m = matchesMap[_matchId]; // TODO whether the data is copied or it is the reference to storage\n        cashBack(m.gamersA);\n        cashBack(m.gamersB);\n        cashBack(m.gamersD);\n        clearMatch(_matchId);\n        MatchAborted(_matchId);\n    }\n\n    function eraseMatch(uint _matchId) onlyowner hasmatch(_matchId) {\n        clearMatch(_matchId);\n        MatchAborted(_matchId);\n    }\n\n    function payoutJackpot(uint _matchId, Gamer[] gamers) onlyowner private {\n        uint tmpAmount = 0;\n        address jackpotWinner = 0;\n        uint tmpJackpotAmount = jackpotAmount;\n        jackpotAmount = 0;\n        for (uint pos = 0; pos < gamers.length; pos += 1) {\n            if (gamers[pos].amount > tmpAmount) {\n                tmpAmount = gamers[pos].amount;\n                jackpotWinner = gamers[pos].wallet;\n            }\n        }\n        if (jackpotWinner != 0 && jackpotWinner.send(tmpJackpotAmount)) {\n            JackpotPayoff(_matchId, tmpJackpotAmount, jackpotWinner);\n        }\n    }\n\n    function checkMatchToBeAborted(uint _matchId, uint8 _winner) private returns(bool) {\n        var m = matchesMap[_matchId];\n        if (m.number == 0 || m.bets) {\n            return true;\n        }\n        if ((m.winPotA == 0 && _winner == 0) || (m.winPotD == 0 && _winner == 1) || (m.winPotB == 0 && _winner == 2)) {\n            return true;\n        }\n        if ((m.winPotA == 0 && m.winPotB == 0) || (m.winPotA == 0 && m.winPotD == 0) || (m.winPotB == 0 && m.winPotD == 0)) {\n            return true;\n        }\n        return false;\n    }\n\n    function payoutMatch(uint _matchId, uint8 _winner, bool _jackpot) onlyowner {\n        // cash back if need abort\n        if (checkMatchToBeAborted(_matchId, _winner)) {\n            abortMatch(_matchId);\n            return;\n        }\n        var m = matchesMap[_matchId];\n        var gamers = m.gamersA;\n        uint winPot = m.winPotA;\n        uint losePot_ = m.winPotB + m.winPotD;\n        if (_winner == 2) {\n            gamers = m.gamersB;\n            winPot = m.winPotB;\n            losePot_ = m.winPotA + m.winPotD;\n        } else if (_winner == 1) {\n            gamers = m.gamersD;\n            winPot = m.winPotD;\n            losePot_ = m.winPotA + m.winPotB;\n        }\n        uint fallbackAmount = 0;\n        uint collectedFees = (losePot_ * houseEdge) / uint(100);\n        uint jackpotFees = (losePot_ * JACKPOT_FEE) / uint(100);\n        uint losePot = losePot_ - collectedFees - jackpotFees;\n        for (uint index = 0; index < gamers.length; index += 1) {\n            uint winAmount = gamers[index].amount + ((gamers[index].amount * losePot) / winPot);\n            if (!gamers[index].wallet.send(winAmount)) {\n                fallbackAmount += winAmount;\n            }\n        }\n        jackpotAmount += jackpotFees;\n        if (_jackpot) {\n            payoutJackpot(_matchId, gamers);\n        }\n        // pay housecut & reset for next bet\n        if (collectedFees > 0) {\n            if (!owner.send(collectedFees)) {\n                TxMessage(_matchId, TX_N16, collectedFees);\n                   // There is a manual way of withdrawing money!\n            }\n        }\n        if (fallbackAmount > 0) {\n            if (owner.send(fallbackAmount)) {\n                TxMessage(_matchId, TX_N17, fallbackAmount);\n            } else {\n                TxMessage(_matchId, TX_N18, fallbackAmount);\n            }\n        }\n        clearMatch(_matchId);\n        MatchPayoff(_matchId,\n                    losePot,\n                    collectedFees, \n                    jackpotAmount);\n    }\n\n    function clearMatch(uint _matchId) private hasmatch(_matchId) {\n        delete matchesMap[_matchId].gamersA;\n        delete matchesMap[_matchId].gamersB;\n        delete matchesMap[_matchId].gamersD;\n        delete matchesMap[_matchId];\n        matchCount--;\n    }\n\n    function acceptBet(uint _matchId, uint8 _betState) payable {\n        var m = matchesMap[_matchId];\n        if (m.number == 0 ) {\n            require(addNewMatch(_matchId));\n            m = matchesMap[_matchId];\n        }\n        require(m.bets);\n        require(msg.value >= 10 finney); //  && msg.value <= 100 ether\n        if (_betState == 0) {\n            var gamerA = m.gamersA[m.gamersA.length++];\n            gamerA.wallet = msg.sender;\n            gamerA.amount = msg.value;\n            m.winPotA += msg.value;\n        } else if (_betState == 2) {\n            var gamerB = m.gamersB[m.gamersB.length++];\n            gamerB.wallet = msg.sender;\n            gamerB.amount = msg.value;\n            m.winPotB += msg.value;\n        } else if (_betState == 1) {\n            var gamerD = m.gamersD[m.gamersD.length++];\n            gamerD.wallet = msg.sender;\n            gamerD.amount = msg.value;\n            m.winPotD += msg.value;\n        }\n        BetAccepted(_matchId,\n                    _betState,\n                    msg.sender,\n                    msg.value,\n                    block.number);\n    }\n\n    function saveCash(address _receiver, uint _amount) onlyowner {\n         require(matchCount == 0);\n         require(_amount > 0);\n         require(this.balance > _amount);\n         // send cash\n         if (_receiver.send(_amount)) {\n             // confirm\n             CashSaved(_amount);\n         }\n     }\n\n    function killContract () onlyowner {\n        require(matchCount == 0);\n        // transfer amount to wallet address\n        selfdestruct(owner);\n    }\n}", "debug": "storage_5 + keccac_calldata_CryptoBetOn_4: 0x4522846f8a480087ded1df3dd4eba28607966bc300b077b978d5d6ec3644e4af\nkeccac_5_+_keccac_calldata_CryptoBetOn_4: 0xab35dd14103840033983a97295e767efe80e1872fe7e8ffcfdee28e74a899e9e\nstorage_1 + keccac_calldata_CryptoBetOn_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x0\ncaller: 0x0\ncalldata_CryptoBetOn_0: 0xbc81f2f500000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoBetOn: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `eraseMatch(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x0dc568fc30eb731b6551848382e53bdf2c47a230.sol", "function": "eraseMatch(uint256)", "lineno": 7, "title": "Integer Overflow ", "type": "Warning"}], "success": true}