{
  "contract": "0x4368c145cb149686e0e11b8e84ea464679e46907",
  "tool": "mythril",
  "start": 1563249333.0247085,
  "end": 1563250144.9177575,
  "duration": 811.8930490016937,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 6587,
        "code": "        return totalDaiCents;\n    }\n\n    /**\n    ",
        "debug": "calldatasize_Weth: 0x2000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0x8421084210842108421084210842108421084210842108421084210842108420\ntimestamp: 0x0\ncalldata_Weth_32 + 4: 0x1\ncalldata_Weth_0: 0x7329ba4c00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `outstandingBalanceUntil(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "outstandingBalanceUntil(address,uint256)",
        "lineno": 377,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6589,
        "code": "        return totalDaiCents;\n    }\n\n    /**\n    ",
        "debug": "calldatasize_Weth: 0x80000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ntimestamp: 0x0\ncalldata_Weth_32 + 4: 0x1\ncalldata_Weth_0: 0x7329ba4c00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `outstandingBalanceUntil(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "outstandingBalanceUntil(address,uint256)",
        "lineno": 377,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7378,
        "code": "e > 1, \"Invalid price for DAI.\");\n",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 7680\n",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "allowedBalance(address)",
        "lineno": 479,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 8748,
        "code": "led by the subscriber's account.\n     * First pa",
        "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_Weth: 0x4000000000000000000000000000000000000000000000000000000000000040\ncalldata_Weth_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0x0\ncalldata_Weth_0: 0xaeee4eb200000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "_function_0xaeee4eb2",
        "lineno": 200,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8878,
        "code": "    * Actual payment is made in Wrapped Ether (wET",
        "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_Weth: 0x4000000000000000000000000000000000000000000000000000000000000040\ncalldata_Weth_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0x0\ncalldata_Weth_0: 0xc358b3b000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "_function_0xc358b3b0",
        "lineno": 202,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 15246,
        "code": "ublic wethContract;\n\n    /**\n     * Constructor\n     * @param daiMedianizerContract address\n     * @param wethContractAddress address\n     */\n    constructor(address daiMedianizerContract, address wethContractAddress) public {\n        daiPriceContract = Medianizer(daiMedianizerContract);\n        wethContract = Weth(wethContractAddress);\n    }\n\n    event NewSubscription(\n        address indexed subscriber,\n        address indexed receiver,\n        uint daiCents,\n        uint32 interval\n    );\n\n    event Unsubscribe(\n        address indexed subscriber, \n        address indexed receiver\n    );\n\n    event ReceiverPaymentsCollected(\n        address indexed receiver,\n        uint weiAmount,\n        uint startIndex,\n        uint endIndex\n    );\n\n    event PaymentCollected(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents,\n        uint48 effectiveTimestamp\n    );\n\n    event UnfundedPayment(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents\n    );\n\n    event StaleSubscription(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionDeactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionReactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    // Conservative amount of gas used per loop in collectPayments()\n    uint constant MIN_GAS_PER_COLLECT_PAYMENT = 45000;\n    // Force subscribers to use multiple accounts when this limit is reached.\n    uint constant MAX_SUBSCRIPTION_PER_SUBSCRIBER = 10000;\n    // Minimum payment of 1 DAI\n    uint constant MIN_SUBSCRIPTION_DAI_CENTS = 100;\n    // If this many intervals pass without being collected, mark as inactive\n    uint constant STALE_INTERVAL_THRESHOLD = 3;\n\n    struct Subscription {\n        bool    isActive;        //  1 byte\n        uint48  nextPaymentTime; //  6 bytes\n        uint32  interval;        //  4 bytes\n        address subscriber;      // 20 bytes\n        address receiver;        // 20 bytes\n        uint    daiCents;        // 32 bytes\n    }\n\n    // global counter for suscriptions\n    uint64 nextIndex = 1;\n\n    // source of truth for subscriptions\n    mapping(uint64 => Subscription) public subscriptions;\n\n    // subscriber => receiver => subsciptionIndex\n    mapping(address => mapping(address => uint64)) public subscriberReceiver;\n\n    // receiver => subs array\n    mapping(address => uint64[]) public receiverSubs;\n\n    // subscriber => subs array\n    mapping(address => uint64[]) public subscriberSubs;\n\n    /**\n     * Create a new subscription. Must be called by the subscriber's account.\n     * First payment of `daiCents` is paid on creation.\n     * Actual payment is made in Wrapped Ether (wETH) using currenct DAI-ETH conversion rate.\n     * @param receiver address\n     * @param daiCents subscription amount in hundredths of DAI\n     * @param interval seconds between payments\n     */\n    function subscribe(address receiver, uint daiCents, uint32 interval) external {\n        uint weiAmount = daiCentsToEthWei(daiCents, ethPriceInDaiWad());\n        uint64 existingIndex = subscriberReceiver[msg.sender][receiver];\n        require(subscriptions[existingIndex].daiCents == 0, \"Subscription exists\");\n        require(daiCents >= MIN_SUBSCRIPTION_DAI_CENTS, \"Subsciption amount too low\");\n        require(interval >= 86400, \"Interval must be at least 1 day\");\n        require(interval <= 31557600, \"Interval must be at most 1 year\");\n        require(subscriberSubs[msg.sender].length < MAX_SUBSCRIPTION_PER_SUBSCRIBER,\"Subscription count limit reached\");\n\n        // first payment\n        require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"wETH transferFrom() failed\");\n\n        // add to subscription mappings\n        subscriptions[nextIndex] = Subscription(\n            true,\n            uint48(now.add(interval)),\n            interval,\n            msg.sender,\n            receiver,\n            daiCents\n        );\n        subscriberReceiver[msg.sender][receiver] = nextIndex;\n        receiverSubs[receiver].push(nextIndex);\n        subscriberSubs[msg.sender].push(nextIndex);\n\n        emit NewSubscription(msg.sender, receiver, daiCents, interval);\n        emit PaymentCollected(msg.sender, receiver, weiAmount, daiCents, uint48(now));\n\n        nextIndex++;\n    }\n    \n    /**\n     * Deactivate a subscription. Must be called by the subscriber's account.\n     * Payments cannot be collected from deactivated subscriptons.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function deactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(sub.isActive, \"Subscription is already disabled\");\n        require(sub.daiCents > 0, \"Subscription does not exist\");\n\n        sub.isActive = false;\n        emit SubscriptionDeactivated(msg.sender, receiver);\n\n        return true;\n    }\n\n    /**\n     * Reactivate a subscription. Must be called by the subscriber's account.\n     * If less than one interval has passed since the last payment, no payment is collected now.\n     * Otherwise it is treated as a new subscription starting now, and the first payment is collected.\n     * No back-payments are collected.\n     * @param receiver addres used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function reactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(!sub.isActive, \"Subscription is already active\");\n\n        sub.isActive = true;\n        emit SubscriptionReactivated(msg.sender, receiver);\n\n        if (calculateUnpaidIntervalsUntil(sub, now) > 0) {\n            // only make a payment if at least one interval has lapsed since the last payment\n            uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceInDaiWad());\n            require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"Insufficient funds to reactivate subscription\");\n            emit PaymentCollected(msg.sender, receiver, weiAmount, sub.daiCents, uint48(now));\n        }\n\n        sub.nextPaymentTime = uint48(now.add(sub.interval));\n\n        return true;\n    }\n\n    /**\n     * Delete a subscription. Must be called by the subscriber's account.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribe(address receiver) external {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[msg.sender][receiver];\n        deleteElement(subscriberSubs[msg.sender], index);\n        emit Unsubscribe(msg.sender, receiver);\n    }\n\n    /**\n     * Delete a subscription. Must be called by the receiver's account.\n     * @param subscriber address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribeByReceiver(address subscriber) external {\n        uint64 index = subscriberReceiver[subscriber][msg.sender];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[subscriber][msg.sender];\n        deleteElement(subscriberSubs[subscriber], index);\n        emit Unsubscribe(subscriber, msg.sender);\n    }\n\n    /**\n     * Collect all available *funded* payments for a receiver's account.\n     * Helper function that calls collectPaymentsRange() with the full range.\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     */\n    function collectPayments(address receiver) external {\n        collectPaymentsRange(receiver, 0, receiverSubs[receiver].length);\n    }\n\n    /**\n     * A read-only version of collectPayments()\n     * Calculates uncollected *funded* payments for a receiver.\n     * @param receiver address\n     * @return total unclaimed value in wei\n     */\n    function getTotalUnclaimedPayments(address receiver) external view returns (uint) {\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        for (uint i = 0; i < receiverSubs[receiver].length; i++) {\n            Subscription storage sub = subscriptions[receiverSubs[receiver][i]];\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                if (wholeUnpaidIntervals > 0 && wholeUnpaidIntervals < STALE_INTERVAL_THRESHOLD) {\n                    uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                    uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                    do {\n                        if (authorizedBalance >= weiAmount) {\n                            totalPayment = totalPayment.add(weiAmount);\n                            authorizedBalance = authorizedBalance.sub(weiAmount);\n                        }\n                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                    } while (wholeUnpaidIntervals > 0);\n                }\n            }\n        }\n\n        return totalPayment;\n    }\n\n    /**\n     * Calculates a subscriber's total outstanding payments in daiCents\n     * @param subscriber address\n     * @param time in seconds. If `time` < `now`, then we simply use `now`\n     * @return total amount owed at `time` in daiCents\n     */\n    function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) {\n        uint until = time <= now ? now : time;\n\n        uint64[] memory subs = subscriberSubs[subscriber];\n\n        uint totalDaiCents = 0;\n        for (uint64 i = 0; i < subs.length; i++) {\n            Subscription memory sub = subscriptions[subs[i]];\n            if (sub.isActive) {\n                totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until)));\n            }\n        }\n\n        return totalDaiCents;\n    }\n\n    /**\n     * Collect available *funded* payments for a receiver's account within a certain range of receiverSubs[receiver].\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     * @param start starting index of receiverSubs[receiver]\n     * @param end ending index of receiverSubs[receiver]\n     * @return last processed index\n     */\n    function collectPaymentsRange(address receiver, uint start, uint end) public returns (uint) {\n        uint64[] storage subs = receiverSubs[receiver];\n        require(subs.length > 0, \"receiver has no subscriptions\");\n        require(start < end && end <= subs.length, \"wrong arguments for range\");\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        uint last = end;\n        uint i = start;\n        while (i < last) {\n            if (gasleft() < MIN_GAS_PER_COLLECT_PAYMENT) {\n                break;\n            }\n            Subscription storage sub = subscriptions[subs[i]];\n\n            // delete empty subs\n            while (sub.daiCents == 0 && subs.length > 0) {\n                uint lastIndex = subs.length.sub(1);\n                subs[i] = subs[lastIndex];\n                delete(subs[lastIndex]);\n                subs.length = lastIndex;\n                if (last > lastIndex) {\n                    last = lastIndex;\n                }\n                if (lastIndex > 0) {\n                    sub = subscriptions[subs[i]];\n                }\n            }\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                \n                if (wholeUnpaidIntervals > 0) {\n                    // this could be placed in the following else{} block, but the stack becomes too deep\n                    uint subscriberPayment = 0;\n\n                    if (wholeUnpaidIntervals >= STALE_INTERVAL_THRESHOLD) {\n                        sub.isActive = false;\n                        emit SubscriptionDeactivated(sub.subscriber, receiver);\n                        emit StaleSubscription(sub.subscriber, receiver);\n                    } else {\n                        uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                        uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                        do {\n                            if (authorizedBalance >= weiAmount) {\n                                totalPayment = totalPayment.add(weiAmount);\n                                subscriberPayment = subscriberPayment.add(weiAmount);\n                                authorizedBalance = authorizedBalance.sub(weiAmount);\n                                emit PaymentCollected(sub.subscriber, receiver, weiAmount, sub.daiCents, sub.nextPaymentTime);\n                                sub.nextPaymentTime = calculateNextPaymentTime(sub);\n                            } else {\n                                emit UnfundedPayment(sub.subscriber, receiver, weiAmount, sub.daiCents);\n                            }\n                            wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                        } while (wholeUnpaidIntervals > 0);\n                    }\n\n                    if (subscriberPayment > 0) {\n                        assert(wethContract.transferFrom(sub.subscriber, receiver, subscriberPayment));\n                    }\n                }\n            }\n\n            i++;\n        }\n\n        emit ReceiverPaymentsCollected(receiver, totalPayment, start, i);\n        return i;\n    }\n\n    /**\n     * Calculates how much wETH balance Subscrypto is authorized to use on bealf of `subscriber`.\n     * Returns the minimum(subscriber's wETH balance, amount authorized to Subscrypto).\n     * @param subscriber address\n     * @return wad amount of wETH available for Subscrypto payments\n     */\n    function allowedBalance(address subscriber) public view returns (uint) {\n        uint balance = wethContract.balanceOf(subscriber);\n        uint allowance = wethContract.allowance(subscriber, address(this));\n\n        return balance > allowance ? allowance : balance;\n    }\n\n    /**\n     * Calls the DAI medianizer contract to get the current exchange rate for ETH-DAI\n     * @return current ETH price in DAI (wad format)\n     */\n    function ethPriceInDaiWad() public view returns (uint) {\n        uint price = uint(daiPriceContract.read());\n        require(price > 1, \"Invalid price for DAI.\");\n        return price;\n    }\n\n    /**\n     * Helper function to search for and delete an array element without leaving a gap.\n     * Array size is also decremented.\n     * DO NOT USE if ordering is important.\n     * @param array array to be modified\n     * @param element value to be removed\n     */\n    function deleteElement(uint64[] storage array, uint64 element) internal {\n        uint lastIndex = array.length.sub(1);\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                array[i] = array[lastIndex];\n                delete(array[lastIndex]);\n                array.length = lastIndex;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Calculates how many whole unpaid intervals (will) have elapsed since the last payment at a specific `time`.\n     * DOES NOT check if subscriber account is funded.\n     * @param sub Subscription object\n     * @param time timestamp in seconds\n     * @return number of unpaid intervals\n     */\n    function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) {\n        require(time >= now, \"don't use a time before now\");\n\n        if (time > sub.nextPaymentTime) {\n            return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Safely calculate the next payment timestamp for a Subscription\n     * @param sub Subscription object\n     * @return uint48 timestamp in seconds of the next payment\n     */\n    function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) {\n        uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval;\n        assert(nextPaymentTime > sub.nextPaymentTime);\n        return nextPaymentTime;\n    }\n\n    /**\n     * Converts DAI (cents) to ETH (wei) without losing precision\n     * @param daiCents one hundreth of a DAI\n     * @param ethPriceWad price from calling ethPriceInDaiWad()\n     * @return ETH value denominated in wei\n     */\n    function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) {\n        return centsToWad(daiCents).mul(10**18).div(ethPriceWad);\n    }\n\n    /**\n     * Converts amount in cents (hundredths of DAI) to amount in wad\n     * @param cents daiCents (hundredths of DAI)\n     * @return amount of dai in wad\n     */\n    function centsToWad(uint cents) internal pure returns (uint) {\n        return cents.mul(10**16);\n    }\n}",
        "debug": "calldatasize_Weth: 0x8000000000000000000000000000000000000000000000000000000000000020\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd\nstorage_0 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0xffffffffffffffff00\ncalldata_Weth_0: 0x7262561c00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `unsubscribe(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "unsubscribe(address)",
        "lineno": 105,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15254,
        "code": "ublic wethContract;\n\n    /**\n     * Constructor\n     * @param daiMedianizerContract address\n     * @param wethContractAddress address\n     */\n    constructor(address daiMedianizerContract, address wethContractAddress) public {\n        daiPriceContract = Medianizer(daiMedianizerContract);\n        wethContract = Weth(wethContractAddress);\n    }\n\n    event NewSubscription(\n        address indexed subscriber,\n        address indexed receiver,\n        uint daiCents,\n        uint32 interval\n    );\n\n    event Unsubscribe(\n        address indexed subscriber, \n        address indexed receiver\n    );\n\n    event ReceiverPaymentsCollected(\n        address indexed receiver,\n        uint weiAmount,\n        uint startIndex,\n        uint endIndex\n    );\n\n    event PaymentCollected(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents,\n        uint48 effectiveTimestamp\n    );\n\n    event UnfundedPayment(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents\n    );\n\n    event StaleSubscription(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionDeactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionReactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    // Conservative amount of gas used per loop in collectPayments()\n    uint constant MIN_GAS_PER_COLLECT_PAYMENT = 45000;\n    // Force subscribers to use multiple accounts when this limit is reached.\n    uint constant MAX_SUBSCRIPTION_PER_SUBSCRIBER = 10000;\n    // Minimum payment of 1 DAI\n    uint constant MIN_SUBSCRIPTION_DAI_CENTS = 100;\n    // If this many intervals pass without being collected, mark as inactive\n    uint constant STALE_INTERVAL_THRESHOLD = 3;\n\n    struct Subscription {\n        bool    isActive;        //  1 byte\n        uint48  nextPaymentTime; //  6 bytes\n        uint32  interval;        //  4 bytes\n        address subscriber;      // 20 bytes\n        address receiver;        // 20 bytes\n        uint    daiCents;        // 32 bytes\n    }\n\n    // global counter for suscriptions\n    uint64 nextIndex = 1;\n\n    // source of truth for subscriptions\n    mapping(uint64 => Subscription) public subscriptions;\n\n    // subscriber => receiver => subsciptionIndex\n    mapping(address => mapping(address => uint64)) public subscriberReceiver;\n\n    // receiver => subs array\n    mapping(address => uint64[]) public receiverSubs;\n\n    // subscriber => subs array\n    mapping(address => uint64[]) public subscriberSubs;\n\n    /**\n     * Create a new subscription. Must be called by the subscriber's account.\n     * First payment of `daiCents` is paid on creation.\n     * Actual payment is made in Wrapped Ether (wETH) using currenct DAI-ETH conversion rate.\n     * @param receiver address\n     * @param daiCents subscription amount in hundredths of DAI\n     * @param interval seconds between payments\n     */\n    function subscribe(address receiver, uint daiCents, uint32 interval) external {\n        uint weiAmount = daiCentsToEthWei(daiCents, ethPriceInDaiWad());\n        uint64 existingIndex = subscriberReceiver[msg.sender][receiver];\n        require(subscriptions[existingIndex].daiCents == 0, \"Subscription exists\");\n        require(daiCents >= MIN_SUBSCRIPTION_DAI_CENTS, \"Subsciption amount too low\");\n        require(interval >= 86400, \"Interval must be at least 1 day\");\n        require(interval <= 31557600, \"Interval must be at most 1 year\");\n        require(subscriberSubs[msg.sender].length < MAX_SUBSCRIPTION_PER_SUBSCRIBER,\"Subscription count limit reached\");\n\n        // first payment\n        require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"wETH transferFrom() failed\");\n\n        // add to subscription mappings\n        subscriptions[nextIndex] = Subscription(\n            true,\n            uint48(now.add(interval)),\n            interval,\n            msg.sender,\n            receiver,\n            daiCents\n        );\n        subscriberReceiver[msg.sender][receiver] = nextIndex;\n        receiverSubs[receiver].push(nextIndex);\n        subscriberSubs[msg.sender].push(nextIndex);\n\n        emit NewSubscription(msg.sender, receiver, daiCents, interval);\n        emit PaymentCollected(msg.sender, receiver, weiAmount, daiCents, uint48(now));\n\n        nextIndex++;\n    }\n    \n    /**\n     * Deactivate a subscription. Must be called by the subscriber's account.\n     * Payments cannot be collected from deactivated subscriptons.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function deactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(sub.isActive, \"Subscription is already disabled\");\n        require(sub.daiCents > 0, \"Subscription does not exist\");\n\n        sub.isActive = false;\n        emit SubscriptionDeactivated(msg.sender, receiver);\n\n        return true;\n    }\n\n    /**\n     * Reactivate a subscription. Must be called by the subscriber's account.\n     * If less than one interval has passed since the last payment, no payment is collected now.\n     * Otherwise it is treated as a new subscription starting now, and the first payment is collected.\n     * No back-payments are collected.\n     * @param receiver addres used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function reactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(!sub.isActive, \"Subscription is already active\");\n\n        sub.isActive = true;\n        emit SubscriptionReactivated(msg.sender, receiver);\n\n        if (calculateUnpaidIntervalsUntil(sub, now) > 0) {\n            // only make a payment if at least one interval has lapsed since the last payment\n            uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceInDaiWad());\n            require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"Insufficient funds to reactivate subscription\");\n            emit PaymentCollected(msg.sender, receiver, weiAmount, sub.daiCents, uint48(now));\n        }\n\n        sub.nextPaymentTime = uint48(now.add(sub.interval));\n\n        return true;\n    }\n\n    /**\n     * Delete a subscription. Must be called by the subscriber's account.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribe(address receiver) external {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[msg.sender][receiver];\n        deleteElement(subscriberSubs[msg.sender], index);\n        emit Unsubscribe(msg.sender, receiver);\n    }\n\n    /**\n     * Delete a subscription. Must be called by the receiver's account.\n     * @param subscriber address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribeByReceiver(address subscriber) external {\n        uint64 index = subscriberReceiver[subscriber][msg.sender];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[subscriber][msg.sender];\n        deleteElement(subscriberSubs[subscriber], index);\n        emit Unsubscribe(subscriber, msg.sender);\n    }\n\n    /**\n     * Collect all available *funded* payments for a receiver's account.\n     * Helper function that calls collectPaymentsRange() with the full range.\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     */\n    function collectPayments(address receiver) external {\n        collectPaymentsRange(receiver, 0, receiverSubs[receiver].length);\n    }\n\n    /**\n     * A read-only version of collectPayments()\n     * Calculates uncollected *funded* payments for a receiver.\n     * @param receiver address\n     * @return total unclaimed value in wei\n     */\n    function getTotalUnclaimedPayments(address receiver) external view returns (uint) {\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        for (uint i = 0; i < receiverSubs[receiver].length; i++) {\n            Subscription storage sub = subscriptions[receiverSubs[receiver][i]];\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                if (wholeUnpaidIntervals > 0 && wholeUnpaidIntervals < STALE_INTERVAL_THRESHOLD) {\n                    uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                    uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                    do {\n                        if (authorizedBalance >= weiAmount) {\n                            totalPayment = totalPayment.add(weiAmount);\n                            authorizedBalance = authorizedBalance.sub(weiAmount);\n                        }\n                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                    } while (wholeUnpaidIntervals > 0);\n                }\n            }\n        }\n\n        return totalPayment;\n    }\n\n    /**\n     * Calculates a subscriber's total outstanding payments in daiCents\n     * @param subscriber address\n     * @param time in seconds. If `time` < `now`, then we simply use `now`\n     * @return total amount owed at `time` in daiCents\n     */\n    function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) {\n        uint until = time <= now ? now : time;\n\n        uint64[] memory subs = subscriberSubs[subscriber];\n\n        uint totalDaiCents = 0;\n        for (uint64 i = 0; i < subs.length; i++) {\n            Subscription memory sub = subscriptions[subs[i]];\n            if (sub.isActive) {\n                totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until)));\n            }\n        }\n\n        return totalDaiCents;\n    }\n\n    /**\n     * Collect available *funded* payments for a receiver's account within a certain range of receiverSubs[receiver].\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     * @param start starting index of receiverSubs[receiver]\n     * @param end ending index of receiverSubs[receiver]\n     * @return last processed index\n     */\n    function collectPaymentsRange(address receiver, uint start, uint end) public returns (uint) {\n        uint64[] storage subs = receiverSubs[receiver];\n        require(subs.length > 0, \"receiver has no subscriptions\");\n        require(start < end && end <= subs.length, \"wrong arguments for range\");\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        uint last = end;\n        uint i = start;\n        while (i < last) {\n            if (gasleft() < MIN_GAS_PER_COLLECT_PAYMENT) {\n                break;\n            }\n            Subscription storage sub = subscriptions[subs[i]];\n\n            // delete empty subs\n            while (sub.daiCents == 0 && subs.length > 0) {\n                uint lastIndex = subs.length.sub(1);\n                subs[i] = subs[lastIndex];\n                delete(subs[lastIndex]);\n                subs.length = lastIndex;\n                if (last > lastIndex) {\n                    last = lastIndex;\n                }\n                if (lastIndex > 0) {\n                    sub = subscriptions[subs[i]];\n                }\n            }\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                \n                if (wholeUnpaidIntervals > 0) {\n                    // this could be placed in the following else{} block, but the stack becomes too deep\n                    uint subscriberPayment = 0;\n\n                    if (wholeUnpaidIntervals >= STALE_INTERVAL_THRESHOLD) {\n                        sub.isActive = false;\n                        emit SubscriptionDeactivated(sub.subscriber, receiver);\n                        emit StaleSubscription(sub.subscriber, receiver);\n                    } else {\n                        uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                        uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                        do {\n                            if (authorizedBalance >= weiAmount) {\n                                totalPayment = totalPayment.add(weiAmount);\n                                subscriberPayment = subscriberPayment.add(weiAmount);\n                                authorizedBalance = authorizedBalance.sub(weiAmount);\n                                emit PaymentCollected(sub.subscriber, receiver, weiAmount, sub.daiCents, sub.nextPaymentTime);\n                                sub.nextPaymentTime = calculateNextPaymentTime(sub);\n                            } else {\n                                emit UnfundedPayment(sub.subscriber, receiver, weiAmount, sub.daiCents);\n                            }\n                            wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                        } while (wholeUnpaidIntervals > 0);\n                    }\n\n                    if (subscriberPayment > 0) {\n                        assert(wethContract.transferFrom(sub.subscriber, receiver, subscriberPayment));\n                    }\n                }\n            }\n\n            i++;\n        }\n\n        emit ReceiverPaymentsCollected(receiver, totalPayment, start, i);\n        return i;\n    }\n\n    /**\n     * Calculates how much wETH balance Subscrypto is authorized to use on bealf of `subscriber`.\n     * Returns the minimum(subscriber's wETH balance, amount authorized to Subscrypto).\n     * @param subscriber address\n     * @return wad amount of wETH available for Subscrypto payments\n     */\n    function allowedBalance(address subscriber) public view returns (uint) {\n        uint balance = wethContract.balanceOf(subscriber);\n        uint allowance = wethContract.allowance(subscriber, address(this));\n\n        return balance > allowance ? allowance : balance;\n    }\n\n    /**\n     * Calls the DAI medianizer contract to get the current exchange rate for ETH-DAI\n     * @return current ETH price in DAI (wad format)\n     */\n    function ethPriceInDaiWad() public view returns (uint) {\n        uint price = uint(daiPriceContract.read());\n        require(price > 1, \"Invalid price for DAI.\");\n        return price;\n    }\n\n    /**\n     * Helper function to search for and delete an array element without leaving a gap.\n     * Array size is also decremented.\n     * DO NOT USE if ordering is important.\n     * @param array array to be modified\n     * @param element value to be removed\n     */\n    function deleteElement(uint64[] storage array, uint64 element) internal {\n        uint lastIndex = array.length.sub(1);\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                array[i] = array[lastIndex];\n                delete(array[lastIndex]);\n                array.length = lastIndex;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Calculates how many whole unpaid intervals (will) have elapsed since the last payment at a specific `time`.\n     * DOES NOT check if subscriber account is funded.\n     * @param sub Subscription object\n     * @param time timestamp in seconds\n     * @return number of unpaid intervals\n     */\n    function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) {\n        require(time >= now, \"don't use a time before now\");\n\n        if (time > sub.nextPaymentTime) {\n            return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Safely calculate the next payment timestamp for a Subscription\n     * @param sub Subscription object\n     * @return uint48 timestamp in seconds of the next payment\n     */\n    function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) {\n        uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval;\n        assert(nextPaymentTime > sub.nextPaymentTime);\n        return nextPaymentTime;\n    }\n\n    /**\n     * Converts DAI (cents) to ETH (wei) without losing precision\n     * @param daiCents one hundreth of a DAI\n     * @param ethPriceWad price from calling ethPriceInDaiWad()\n     * @return ETH value denominated in wei\n     */\n    function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) {\n        return centsToWad(daiCents).mul(10**18).div(ethPriceWad);\n    }\n\n    /**\n     * Converts amount in cents (hundredths of DAI) to amount in wad\n     * @param cents daiCents (hundredths of DAI)\n     * @return amount of dai in wad\n     */\n    function centsToWad(uint cents) internal pure returns (uint) {\n        return cents.mul(10**16);\n    }\n}",
        "debug": "calldatasize_Weth: 0x30000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_0 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0xffffffffffffffff00\ncalldata_Weth_0: 0x7262561c00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `unsubscribe(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "unsubscribe(address)",
        "lineno": 105,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15270,
        "code": "ublic wethContract;\n\n    /**\n     * Constructor\n     * @param daiMedianizerContract address\n     * @param wethContractAddress address\n     */\n    constructor(address daiMedianizerContract, address wethContractAddress) public {\n        daiPriceContract = Medianizer(daiMedianizerContract);\n        wethContract = Weth(wethContractAddress);\n    }\n\n    event NewSubscription(\n        address indexed subscriber,\n        address indexed receiver,\n        uint daiCents,\n        uint32 interval\n    );\n\n    event Unsubscribe(\n        address indexed subscriber, \n        address indexed receiver\n    );\n\n    event ReceiverPaymentsCollected(\n        address indexed receiver,\n        uint weiAmount,\n        uint startIndex,\n        uint endIndex\n    );\n\n    event PaymentCollected(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents,\n        uint48 effectiveTimestamp\n    );\n\n    event UnfundedPayment(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents\n    );\n\n    event StaleSubscription(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionDeactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionReactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    // Conservative amount of gas used per loop in collectPayments()\n    uint constant MIN_GAS_PER_COLLECT_PAYMENT = 45000;\n    // Force subscribers to use multiple accounts when this limit is reached.\n    uint constant MAX_SUBSCRIPTION_PER_SUBSCRIBER = 10000;\n    // Minimum payment of 1 DAI\n    uint constant MIN_SUBSCRIPTION_DAI_CENTS = 100;\n    // If this many intervals pass without being collected, mark as inactive\n    uint constant STALE_INTERVAL_THRESHOLD = 3;\n\n    struct Subscription {\n        bool    isActive;        //  1 byte\n        uint48  nextPaymentTime; //  6 bytes\n        uint32  interval;        //  4 bytes\n        address subscriber;      // 20 bytes\n        address receiver;        // 20 bytes\n        uint    daiCents;        // 32 bytes\n    }\n\n    // global counter for suscriptions\n    uint64 nextIndex = 1;\n\n    // source of truth for subscriptions\n    mapping(uint64 => Subscription) public subscriptions;\n\n    // subscriber => receiver => subsciptionIndex\n    mapping(address => mapping(address => uint64)) public subscriberReceiver;\n\n    // receiver => subs array\n    mapping(address => uint64[]) public receiverSubs;\n\n    // subscriber => subs array\n    mapping(address => uint64[]) public subscriberSubs;\n\n    /**\n     * Create a new subscription. Must be called by the subscriber's account.\n     * First payment of `daiCents` is paid on creation.\n     * Actual payment is made in Wrapped Ether (wETH) using currenct DAI-ETH conversion rate.\n     * @param receiver address\n     * @param daiCents subscription amount in hundredths of DAI\n     * @param interval seconds between payments\n     */\n    function subscribe(address receiver, uint daiCents, uint32 interval) external {\n        uint weiAmount = daiCentsToEthWei(daiCents, ethPriceInDaiWad());\n        uint64 existingIndex = subscriberReceiver[msg.sender][receiver];\n        require(subscriptions[existingIndex].daiCents == 0, \"Subscription exists\");\n        require(daiCents >= MIN_SUBSCRIPTION_DAI_CENTS, \"Subsciption amount too low\");\n        require(interval >= 86400, \"Interval must be at least 1 day\");\n        require(interval <= 31557600, \"Interval must be at most 1 year\");\n        require(subscriberSubs[msg.sender].length < MAX_SUBSCRIPTION_PER_SUBSCRIBER,\"Subscription count limit reached\");\n\n        // first payment\n        require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"wETH transferFrom() failed\");\n\n        // add to subscription mappings\n        subscriptions[nextIndex] = Subscription(\n            true,\n            uint48(now.add(interval)),\n            interval,\n            msg.sender,\n            receiver,\n            daiCents\n        );\n        subscriberReceiver[msg.sender][receiver] = nextIndex;\n        receiverSubs[receiver].push(nextIndex);\n        subscriberSubs[msg.sender].push(nextIndex);\n\n        emit NewSubscription(msg.sender, receiver, daiCents, interval);\n        emit PaymentCollected(msg.sender, receiver, weiAmount, daiCents, uint48(now));\n\n        nextIndex++;\n    }\n    \n    /**\n     * Deactivate a subscription. Must be called by the subscriber's account.\n     * Payments cannot be collected from deactivated subscriptons.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function deactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(sub.isActive, \"Subscription is already disabled\");\n        require(sub.daiCents > 0, \"Subscription does not exist\");\n\n        sub.isActive = false;\n        emit SubscriptionDeactivated(msg.sender, receiver);\n\n        return true;\n    }\n\n    /**\n     * Reactivate a subscription. Must be called by the subscriber's account.\n     * If less than one interval has passed since the last payment, no payment is collected now.\n     * Otherwise it is treated as a new subscription starting now, and the first payment is collected.\n     * No back-payments are collected.\n     * @param receiver addres used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function reactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(!sub.isActive, \"Subscription is already active\");\n\n        sub.isActive = true;\n        emit SubscriptionReactivated(msg.sender, receiver);\n\n        if (calculateUnpaidIntervalsUntil(sub, now) > 0) {\n            // only make a payment if at least one interval has lapsed since the last payment\n            uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceInDaiWad());\n            require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"Insufficient funds to reactivate subscription\");\n            emit PaymentCollected(msg.sender, receiver, weiAmount, sub.daiCents, uint48(now));\n        }\n\n        sub.nextPaymentTime = uint48(now.add(sub.interval));\n\n        return true;\n    }\n\n    /**\n     * Delete a subscription. Must be called by the subscriber's account.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribe(address receiver) external {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[msg.sender][receiver];\n        deleteElement(subscriberSubs[msg.sender], index);\n        emit Unsubscribe(msg.sender, receiver);\n    }\n\n    /**\n     * Delete a subscription. Must be called by the receiver's account.\n     * @param subscriber address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribeByReceiver(address subscriber) external {\n        uint64 index = subscriberReceiver[subscriber][msg.sender];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[subscriber][msg.sender];\n        deleteElement(subscriberSubs[subscriber], index);\n        emit Unsubscribe(subscriber, msg.sender);\n    }\n\n    /**\n     * Collect all available *funded* payments for a receiver's account.\n     * Helper function that calls collectPaymentsRange() with the full range.\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     */\n    function collectPayments(address receiver) external {\n        collectPaymentsRange(receiver, 0, receiverSubs[receiver].length);\n    }\n\n    /**\n     * A read-only version of collectPayments()\n     * Calculates uncollected *funded* payments for a receiver.\n     * @param receiver address\n     * @return total unclaimed value in wei\n     */\n    function getTotalUnclaimedPayments(address receiver) external view returns (uint) {\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        for (uint i = 0; i < receiverSubs[receiver].length; i++) {\n            Subscription storage sub = subscriptions[receiverSubs[receiver][i]];\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                if (wholeUnpaidIntervals > 0 && wholeUnpaidIntervals < STALE_INTERVAL_THRESHOLD) {\n                    uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                    uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                    do {\n                        if (authorizedBalance >= weiAmount) {\n                            totalPayment = totalPayment.add(weiAmount);\n                            authorizedBalance = authorizedBalance.sub(weiAmount);\n                        }\n                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                    } while (wholeUnpaidIntervals > 0);\n                }\n            }\n        }\n\n        return totalPayment;\n    }\n\n    /**\n     * Calculates a subscriber's total outstanding payments in daiCents\n     * @param subscriber address\n     * @param time in seconds. If `time` < `now`, then we simply use `now`\n     * @return total amount owed at `time` in daiCents\n     */\n    function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) {\n        uint until = time <= now ? now : time;\n\n        uint64[] memory subs = subscriberSubs[subscriber];\n\n        uint totalDaiCents = 0;\n        for (uint64 i = 0; i < subs.length; i++) {\n            Subscription memory sub = subscriptions[subs[i]];\n            if (sub.isActive) {\n                totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until)));\n            }\n        }\n\n        return totalDaiCents;\n    }\n\n    /**\n     * Collect available *funded* payments for a receiver's account within a certain range of receiverSubs[receiver].\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     * @param start starting index of receiverSubs[receiver]\n     * @param end ending index of receiverSubs[receiver]\n     * @return last processed index\n     */\n    function collectPaymentsRange(address receiver, uint start, uint end) public returns (uint) {\n        uint64[] storage subs = receiverSubs[receiver];\n        require(subs.length > 0, \"receiver has no subscriptions\");\n        require(start < end && end <= subs.length, \"wrong arguments for range\");\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        uint last = end;\n        uint i = start;\n        while (i < last) {\n            if (gasleft() < MIN_GAS_PER_COLLECT_PAYMENT) {\n                break;\n            }\n            Subscription storage sub = subscriptions[subs[i]];\n\n            // delete empty subs\n            while (sub.daiCents == 0 && subs.length > 0) {\n                uint lastIndex = subs.length.sub(1);\n                subs[i] = subs[lastIndex];\n                delete(subs[lastIndex]);\n                subs.length = lastIndex;\n                if (last > lastIndex) {\n                    last = lastIndex;\n                }\n                if (lastIndex > 0) {\n                    sub = subscriptions[subs[i]];\n                }\n            }\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                \n                if (wholeUnpaidIntervals > 0) {\n                    // this could be placed in the following else{} block, but the stack becomes too deep\n                    uint subscriberPayment = 0;\n\n                    if (wholeUnpaidIntervals >= STALE_INTERVAL_THRESHOLD) {\n                        sub.isActive = false;\n                        emit SubscriptionDeactivated(sub.subscriber, receiver);\n                        emit StaleSubscription(sub.subscriber, receiver);\n                    } else {\n                        uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                        uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                        do {\n                            if (authorizedBalance >= weiAmount) {\n                                totalPayment = totalPayment.add(weiAmount);\n                                subscriberPayment = subscriberPayment.add(weiAmount);\n                                authorizedBalance = authorizedBalance.sub(weiAmount);\n                                emit PaymentCollected(sub.subscriber, receiver, weiAmount, sub.daiCents, sub.nextPaymentTime);\n                                sub.nextPaymentTime = calculateNextPaymentTime(sub);\n                            } else {\n                                emit UnfundedPayment(sub.subscriber, receiver, weiAmount, sub.daiCents);\n                            }\n                            wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                        } while (wholeUnpaidIntervals > 0);\n                    }\n\n                    if (subscriberPayment > 0) {\n                        assert(wethContract.transferFrom(sub.subscriber, receiver, subscriberPayment));\n                    }\n                }\n            }\n\n            i++;\n        }\n\n        emit ReceiverPaymentsCollected(receiver, totalPayment, start, i);\n        return i;\n    }\n\n    /**\n     * Calculates how much wETH balance Subscrypto is authorized to use on bealf of `subscriber`.\n     * Returns the minimum(subscriber's wETH balance, amount authorized to Subscrypto).\n     * @param subscriber address\n     * @return wad amount of wETH available for Subscrypto payments\n     */\n    function allowedBalance(address subscriber) public view returns (uint) {\n        uint balance = wethContract.balanceOf(subscriber);\n        uint allowance = wethContract.allowance(subscriber, address(this));\n\n        return balance > allowance ? allowance : balance;\n    }\n\n    /**\n     * Calls the DAI medianizer contract to get the current exchange rate for ETH-DAI\n     * @return current ETH price in DAI (wad format)\n     */\n    function ethPriceInDaiWad() public view returns (uint) {\n        uint price = uint(daiPriceContract.read());\n        require(price > 1, \"Invalid price for DAI.\");\n        return price;\n    }\n\n    /**\n     * Helper function to search for and delete an array element without leaving a gap.\n     * Array size is also decremented.\n     * DO NOT USE if ordering is important.\n     * @param array array to be modified\n     * @param element value to be removed\n     */\n    function deleteElement(uint64[] storage array, uint64 element) internal {\n        uint lastIndex = array.length.sub(1);\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                array[i] = array[lastIndex];\n                delete(array[lastIndex]);\n                array.length = lastIndex;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Calculates how many whole unpaid intervals (will) have elapsed since the last payment at a specific `time`.\n     * DOES NOT check if subscriber account is funded.\n     * @param sub Subscription object\n     * @param time timestamp in seconds\n     * @return number of unpaid intervals\n     */\n    function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) {\n        require(time >= now, \"don't use a time before now\");\n\n        if (time > sub.nextPaymentTime) {\n            return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Safely calculate the next payment timestamp for a Subscription\n     * @param sub Subscription object\n     * @return uint48 timestamp in seconds of the next payment\n     */\n    function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) {\n        uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval;\n        assert(nextPaymentTime > sub.nextPaymentTime);\n        return nextPaymentTime;\n    }\n\n    /**\n     * Converts DAI (cents) to ETH (wei) without losing precision\n     * @param daiCents one hundreth of a DAI\n     * @param ethPriceWad price from calling ethPriceInDaiWad()\n     * @return ETH value denominated in wei\n     */\n    function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) {\n        return centsToWad(daiCents).mul(10**18).div(ethPriceWad);\n    }\n\n    /**\n     * Converts amount in cents (hundredths of DAI) to amount in wad\n     * @param cents daiCents (hundredths of DAI)\n     * @return amount of dai in wad\n     */\n    function centsToWad(uint cents) internal pure returns (uint) {\n        return cents.mul(10**16);\n    }\n}",
        "debug": "calldatasize_Weth: 0x800018d8571f47c59e8b4e21150908929a00740a20c707500000000000000200\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xcf07ff7e97149ebabb81dae3de35b8bbd96147e4cb769ffffffffffffffffffe\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xf708b8dd9879974c389f548a060d408008a5e30007f9ae94563e8d20eda11216\nstorage_0 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0xffffffffffffffff00\ncalldata_Weth_0: 0x7262561c00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `unsubscribe(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "unsubscribe(address)",
        "lineno": 105,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15272,
        "code": "ublic wethContract;\n\n    /**\n     * Constructor\n     * @param daiMedianizerContract address\n     * @param wethContractAddress address\n     */\n    constructor(address daiMedianizerContract, address wethContractAddress) public {\n        daiPriceContract = Medianizer(daiMedianizerContract);\n        wethContract = Weth(wethContractAddress);\n    }\n\n    event NewSubscription(\n        address indexed subscriber,\n        address indexed receiver,\n        uint daiCents,\n        uint32 interval\n    );\n\n    event Unsubscribe(\n        address indexed subscriber, \n        address indexed receiver\n    );\n\n    event ReceiverPaymentsCollected(\n        address indexed receiver,\n        uint weiAmount,\n        uint startIndex,\n        uint endIndex\n    );\n\n    event PaymentCollected(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents,\n        uint48 effectiveTimestamp\n    );\n\n    event UnfundedPayment(\n        address indexed subscriber,\n        address indexed receiver,\n        uint weiAmount,\n        uint daiCents\n    );\n\n    event StaleSubscription(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionDeactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    event SubscriptionReactivated(\n        address indexed subscriber,\n        address indexed receiver\n    );\n\n    // Conservative amount of gas used per loop in collectPayments()\n    uint constant MIN_GAS_PER_COLLECT_PAYMENT = 45000;\n    // Force subscribers to use multiple accounts when this limit is reached.\n    uint constant MAX_SUBSCRIPTION_PER_SUBSCRIBER = 10000;\n    // Minimum payment of 1 DAI\n    uint constant MIN_SUBSCRIPTION_DAI_CENTS = 100;\n    // If this many intervals pass without being collected, mark as inactive\n    uint constant STALE_INTERVAL_THRESHOLD = 3;\n\n    struct Subscription {\n        bool    isActive;        //  1 byte\n        uint48  nextPaymentTime; //  6 bytes\n        uint32  interval;        //  4 bytes\n        address subscriber;      // 20 bytes\n        address receiver;        // 20 bytes\n        uint    daiCents;        // 32 bytes\n    }\n\n    // global counter for suscriptions\n    uint64 nextIndex = 1;\n\n    // source of truth for subscriptions\n    mapping(uint64 => Subscription) public subscriptions;\n\n    // subscriber => receiver => subsciptionIndex\n    mapping(address => mapping(address => uint64)) public subscriberReceiver;\n\n    // receiver => subs array\n    mapping(address => uint64[]) public receiverSubs;\n\n    // subscriber => subs array\n    mapping(address => uint64[]) public subscriberSubs;\n\n    /**\n     * Create a new subscription. Must be called by the subscriber's account.\n     * First payment of `daiCents` is paid on creation.\n     * Actual payment is made in Wrapped Ether (wETH) using currenct DAI-ETH conversion rate.\n     * @param receiver address\n     * @param daiCents subscription amount in hundredths of DAI\n     * @param interval seconds between payments\n     */\n    function subscribe(address receiver, uint daiCents, uint32 interval) external {\n        uint weiAmount = daiCentsToEthWei(daiCents, ethPriceInDaiWad());\n        uint64 existingIndex = subscriberReceiver[msg.sender][receiver];\n        require(subscriptions[existingIndex].daiCents == 0, \"Subscription exists\");\n        require(daiCents >= MIN_SUBSCRIPTION_DAI_CENTS, \"Subsciption amount too low\");\n        require(interval >= 86400, \"Interval must be at least 1 day\");\n        require(interval <= 31557600, \"Interval must be at most 1 year\");\n        require(subscriberSubs[msg.sender].length < MAX_SUBSCRIPTION_PER_SUBSCRIBER,\"Subscription count limit reached\");\n\n        // first payment\n        require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"wETH transferFrom() failed\");\n\n        // add to subscription mappings\n        subscriptions[nextIndex] = Subscription(\n            true,\n            uint48(now.add(interval)),\n            interval,\n            msg.sender,\n            receiver,\n            daiCents\n        );\n        subscriberReceiver[msg.sender][receiver] = nextIndex;\n        receiverSubs[receiver].push(nextIndex);\n        subscriberSubs[msg.sender].push(nextIndex);\n\n        emit NewSubscription(msg.sender, receiver, daiCents, interval);\n        emit PaymentCollected(msg.sender, receiver, weiAmount, daiCents, uint48(now));\n\n        nextIndex++;\n    }\n    \n    /**\n     * Deactivate a subscription. Must be called by the subscriber's account.\n     * Payments cannot be collected from deactivated subscriptons.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function deactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(sub.isActive, \"Subscription is already disabled\");\n        require(sub.daiCents > 0, \"Subscription does not exist\");\n\n        sub.isActive = false;\n        emit SubscriptionDeactivated(msg.sender, receiver);\n\n        return true;\n    }\n\n    /**\n     * Reactivate a subscription. Must be called by the subscriber's account.\n     * If less than one interval has passed since the last payment, no payment is collected now.\n     * Otherwise it is treated as a new subscription starting now, and the first payment is collected.\n     * No back-payments are collected.\n     * @param receiver addres used to identify the unique subscriber-receiver pair.\n     * @return success\n     */\n    function reactivateSubscription(address receiver) external returns (bool) {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n\n        Subscription storage sub = subscriptions[index];\n        require(!sub.isActive, \"Subscription is already active\");\n\n        sub.isActive = true;\n        emit SubscriptionReactivated(msg.sender, receiver);\n\n        if (calculateUnpaidIntervalsUntil(sub, now) > 0) {\n            // only make a payment if at least one interval has lapsed since the last payment\n            uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceInDaiWad());\n            require(wethContract.transferFrom(msg.sender, receiver, weiAmount), \"Insufficient funds to reactivate subscription\");\n            emit PaymentCollected(msg.sender, receiver, weiAmount, sub.daiCents, uint48(now));\n        }\n\n        sub.nextPaymentTime = uint48(now.add(sub.interval));\n\n        return true;\n    }\n\n    /**\n     * Delete a subscription. Must be called by the subscriber's account.\n     * @param receiver address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribe(address receiver) external {\n        uint64 index = subscriberReceiver[msg.sender][receiver];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[msg.sender][receiver];\n        deleteElement(subscriberSubs[msg.sender], index);\n        emit Unsubscribe(msg.sender, receiver);\n    }\n\n    /**\n     * Delete a subscription. Must be called by the receiver's account.\n     * @param subscriber address used to identify the unique subscriber-receiver pair.\n     */\n    function unsubscribeByReceiver(address subscriber) external {\n        uint64 index = subscriberReceiver[subscriber][msg.sender];\n        require(index != 0, \"Subscription does not exist\");\n        delete subscriptions[index];\n        delete subscriberReceiver[subscriber][msg.sender];\n        deleteElement(subscriberSubs[subscriber], index);\n        emit Unsubscribe(subscriber, msg.sender);\n    }\n\n    /**\n     * Collect all available *funded* payments for a receiver's account.\n     * Helper function that calls collectPaymentsRange() with the full range.\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     */\n    function collectPayments(address receiver) external {\n        collectPaymentsRange(receiver, 0, receiverSubs[receiver].length);\n    }\n\n    /**\n     * A read-only version of collectPayments()\n     * Calculates uncollected *funded* payments for a receiver.\n     * @param receiver address\n     * @return total unclaimed value in wei\n     */\n    function getTotalUnclaimedPayments(address receiver) external view returns (uint) {\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        for (uint i = 0; i < receiverSubs[receiver].length; i++) {\n            Subscription storage sub = subscriptions[receiverSubs[receiver][i]];\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                if (wholeUnpaidIntervals > 0 && wholeUnpaidIntervals < STALE_INTERVAL_THRESHOLD) {\n                    uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                    uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                    do {\n                        if (authorizedBalance >= weiAmount) {\n                            totalPayment = totalPayment.add(weiAmount);\n                            authorizedBalance = authorizedBalance.sub(weiAmount);\n                        }\n                        wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                    } while (wholeUnpaidIntervals > 0);\n                }\n            }\n        }\n\n        return totalPayment;\n    }\n\n    /**\n     * Calculates a subscriber's total outstanding payments in daiCents\n     * @param subscriber address\n     * @param time in seconds. If `time` < `now`, then we simply use `now`\n     * @return total amount owed at `time` in daiCents\n     */\n    function outstandingBalanceUntil(address subscriber, uint time) external view returns (uint) {\n        uint until = time <= now ? now : time;\n\n        uint64[] memory subs = subscriberSubs[subscriber];\n\n        uint totalDaiCents = 0;\n        for (uint64 i = 0; i < subs.length; i++) {\n            Subscription memory sub = subscriptions[subs[i]];\n            if (sub.isActive) {\n                totalDaiCents = totalDaiCents.add(sub.daiCents.mul(calculateUnpaidIntervalsUntil(sub, until)));\n            }\n        }\n\n        return totalDaiCents;\n    }\n\n    /**\n     * Collect available *funded* payments for a receiver's account within a certain range of receiverSubs[receiver].\n     * Will process as many payments as possible with the gas provided and exit gracefully.\n     * \n     * @param receiver address\n     * @param start starting index of receiverSubs[receiver]\n     * @param end ending index of receiverSubs[receiver]\n     * @return last processed index\n     */\n    function collectPaymentsRange(address receiver, uint start, uint end) public returns (uint) {\n        uint64[] storage subs = receiverSubs[receiver];\n        require(subs.length > 0, \"receiver has no subscriptions\");\n        require(start < end && end <= subs.length, \"wrong arguments for range\");\n        uint totalPayment = 0;\n        uint ethPriceWad = ethPriceInDaiWad();\n\n        uint last = end;\n        uint i = start;\n        while (i < last) {\n            if (gasleft() < MIN_GAS_PER_COLLECT_PAYMENT) {\n                break;\n            }\n            Subscription storage sub = subscriptions[subs[i]];\n\n            // delete empty subs\n            while (sub.daiCents == 0 && subs.length > 0) {\n                uint lastIndex = subs.length.sub(1);\n                subs[i] = subs[lastIndex];\n                delete(subs[lastIndex]);\n                subs.length = lastIndex;\n                if (last > lastIndex) {\n                    last = lastIndex;\n                }\n                if (lastIndex > 0) {\n                    sub = subscriptions[subs[i]];\n                }\n            }\n\n            if (sub.isActive && sub.daiCents != 0) {\n                uint wholeUnpaidIntervals = calculateUnpaidIntervalsUntil(sub, now);\n                \n                if (wholeUnpaidIntervals > 0) {\n                    // this could be placed in the following else{} block, but the stack becomes too deep\n                    uint subscriberPayment = 0;\n\n                    if (wholeUnpaidIntervals >= STALE_INTERVAL_THRESHOLD) {\n                        sub.isActive = false;\n                        emit SubscriptionDeactivated(sub.subscriber, receiver);\n                        emit StaleSubscription(sub.subscriber, receiver);\n                    } else {\n                        uint weiAmount = daiCentsToEthWei(sub.daiCents, ethPriceWad);\n                        uint authorizedBalance = allowedBalance(sub.subscriber);\n\n                        do {\n                            if (authorizedBalance >= weiAmount) {\n                                totalPayment = totalPayment.add(weiAmount);\n                                subscriberPayment = subscriberPayment.add(weiAmount);\n                                authorizedBalance = authorizedBalance.sub(weiAmount);\n                                emit PaymentCollected(sub.subscriber, receiver, weiAmount, sub.daiCents, sub.nextPaymentTime);\n                                sub.nextPaymentTime = calculateNextPaymentTime(sub);\n                            } else {\n                                emit UnfundedPayment(sub.subscriber, receiver, weiAmount, sub.daiCents);\n                            }\n                            wholeUnpaidIntervals = wholeUnpaidIntervals.sub(1);\n                        } while (wholeUnpaidIntervals > 0);\n                    }\n\n                    if (subscriberPayment > 0) {\n                        assert(wethContract.transferFrom(sub.subscriber, receiver, subscriberPayment));\n                    }\n                }\n            }\n\n            i++;\n        }\n\n        emit ReceiverPaymentsCollected(receiver, totalPayment, start, i);\n        return i;\n    }\n\n    /**\n     * Calculates how much wETH balance Subscrypto is authorized to use on bealf of `subscriber`.\n     * Returns the minimum(subscriber's wETH balance, amount authorized to Subscrypto).\n     * @param subscriber address\n     * @return wad amount of wETH available for Subscrypto payments\n     */\n    function allowedBalance(address subscriber) public view returns (uint) {\n        uint balance = wethContract.balanceOf(subscriber);\n        uint allowance = wethContract.allowance(subscriber, address(this));\n\n        return balance > allowance ? allowance : balance;\n    }\n\n    /**\n     * Calls the DAI medianizer contract to get the current exchange rate for ETH-DAI\n     * @return current ETH price in DAI (wad format)\n     */\n    function ethPriceInDaiWad() public view returns (uint) {\n        uint price = uint(daiPriceContract.read());\n        require(price > 1, \"Invalid price for DAI.\");\n        return price;\n    }\n\n    /**\n     * Helper function to search for and delete an array element without leaving a gap.\n     * Array size is also decremented.\n     * DO NOT USE if ordering is important.\n     * @param array array to be modified\n     * @param element value to be removed\n     */\n    function deleteElement(uint64[] storage array, uint64 element) internal {\n        uint lastIndex = array.length.sub(1);\n        for (uint i = 0; i < array.length; i++) {\n            if (array[i] == element) {\n                array[i] = array[lastIndex];\n                delete(array[lastIndex]);\n                array.length = lastIndex;\n                break;\n            }\n        }\n    }\n\n    /**\n     * Calculates how many whole unpaid intervals (will) have elapsed since the last payment at a specific `time`.\n     * DOES NOT check if subscriber account is funded.\n     * @param sub Subscription object\n     * @param time timestamp in seconds\n     * @return number of unpaid intervals\n     */\n    function calculateUnpaidIntervalsUntil(Subscription memory sub, uint time) internal view returns (uint) {\n        require(time >= now, \"don't use a time before now\");\n\n        if (time > sub.nextPaymentTime) {\n            return ((time.sub(sub.nextPaymentTime)).div(sub.interval)).add(1);\n        }\n\n        return 0;\n    }\n\n    /**\n     * Safely calculate the next payment timestamp for a Subscription\n     * @param sub Subscription object\n     * @return uint48 timestamp in seconds of the next payment\n     */\n    function calculateNextPaymentTime(Subscription memory sub) internal pure returns (uint48) {\n        uint48 nextPaymentTime = sub.nextPaymentTime + sub.interval;\n        assert(nextPaymentTime > sub.nextPaymentTime);\n        return nextPaymentTime;\n    }\n\n    /**\n     * Converts DAI (cents) to ETH (wei) without losing precision\n     * @param daiCents one hundreth of a DAI\n     * @param ethPriceWad price from calling ethPriceInDaiWad()\n     * @return ETH value denominated in wei\n     */\n    function daiCentsToEthWei(uint daiCents, uint ethPriceWad) internal pure returns (uint) {\n        return centsToWad(daiCents).mul(10**18).div(ethPriceWad);\n    }\n\n    /**\n     * Converts amount in cents (hundredths of DAI) to amount in wad\n     * @param cents daiCents (hundredths of DAI)\n     * @return amount of dai in wad\n     */\n    function centsToWad(uint cents) internal pure returns (uint) {\n        return cents.mul(10**16);\n    }\n}",
        "debug": "calldatasize_Weth: 0x9000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xdcd0acd76f9071938b669eff001a0500090000f773effa283020000008ea0000\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xf7bb8cb8a3a12c91cf112921fff9e21383244720102bd6122c03e80ea3b8e420\nstorage_0 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Weth_4: 0xffffffffffffffff00\ncalldata_Weth_0: 0x7262561c00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `unsubscribe(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4368c145cb149686e0e11b8e84ea464679e46907.sol",
        "function": "unsubscribe(address)",
        "lineno": 105,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}