{
  "contract": "0xc5903fe72a9530e4382187f729ccc050d7e89fae",
  "tool": "mythril",
  "start": 1563410552.6115894,
  "end": 1563411435.5407481,
  "duration": 882.9291586875916,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 640,
        "code": ";\n                ",
        "debug": "storage_6: 0xf77124b52a24e057d8a070024000e4e0e29fe1280e6ec1bac4ce6c09cd081036\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nretval_522: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "fallback",
        "lineno": 126,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 651,
        "code": "ount;\n                Transfer(this, m",
        "debug": "storage_6: 0xd6272c21e28ee2a9aa37d12c12aa92d6ef8a62d929fb586fbd8dc825613\nstorage_5: 0xf6d14ebf7e33fcecfe2fefad81f75d89c06c6b40002039460fff8eb5eff80000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nretval_522: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "fallback",
        "lineno": 127,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 728,
        "code": ";\n                Claimed[msg.s",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbd10b7c7400062cfbeb7d5fbcbfabfe87fdd87bfa8f79fa9e60ab0c3bf940000\nstorage_6: 0x2bcf132164ead8b4032659fd905c1d5161b04c23dfde04577db0a18a3b5b\nretval_522: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "fallback",
        "lineno": 128,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 744,
        "code": "        }\n\n            ",
        "debug": "storage_2: 0x8cfcf72bfffccb8c3d575aa5a921c137fc900387f1e53ffe1fa7e65d9d9c0000\nstorage_6: 0x30c0a13b47a897a2e806bb57dd6cfbc147e285f48aa90122eec66ddf542f\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nretval_522: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "fallback",
        "lineno": 130,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2190,
        "code": "remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwne",
        "debug": "calldata_Tablow_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 161,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2202,
        "code": "remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwne",
        "debug": "calldata_Tablow_4 + calldata_Tablow_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 161,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2211,
        "code": "remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwne",
        "debug": "calldata_Tablow_4 + calldata_Tablow_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 161,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2217,
        "code": "remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwne",
        "debug": "calldata_Tablow_4 + calldata_Tablow_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 161,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4729,
        "code": "ply += _remainingAmount;\n                    Transfer",
        "debug": "storage_3: 0x8000000000000000000000000\nstorage_15: 0xff00\nstorage_5: 0x8000000000000000000000001\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Tablow_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `StopDistrib()`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "StopDistrib()",
        "lineno": 215,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4844,
        "code": "       }\n            }\n            DistribStarted = false;\n  ",
        "debug": "storage_3: 0x940e7efffffee1ffc453c844ecaf3d009306789a479485f37b0944eae86247c4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_14,_256): 0xca0b416000014175629c58be85d948d81ba0869287028324cd21131dbdaec8b4\nstorage_5: 0x10268100000120017ede3713feedee02fffeffffe3bff40dd8d3adbff621419f\nstorage_15: 0xff00\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Tablow_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `StopDistrib()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "StopDistrib()",
        "lineno": 217,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4860,
        "code": "ing = false;\n        } else {\n  ",
        "debug": "storage_3: 0x940e7efffffee1ffc453c844ecaf3d009306789a479485f37b0944eae86247c4\nstorage_2: 0xca0b416000014175629c58be85d948d81ba0869287028324cd21131dbdaec8b4\nstorage_5: 0x10268100000120017ede3713feedee02fffeffffe3bff40dd8d3adbff621419f\nstorage_15: 0xff00\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Tablow_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `StopDistrib()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "StopDistrib()",
        "lineno": 220,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5648,
        "code": " sender */\n    functio",
        "debug": "calldata_Tablow_32 + 36: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Tablow_32_+_4: 0x800000000000000000008eb2e34648ee0801030820000000000000000000a000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Tablow_4: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\ncalldata_Tablow_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 368,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6083,
        "code": "   }\n        ",
        "debug": "calldata_Tablow_4: 0xf77124b52a24e057d8a070024000e4e0e29fe1280e6ec1bac4ce6c09cd081036\ncalldata_Tablow_0: 0x2cd3fd7000000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `BurnTokens(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "BurnTokens(uint256)",
        "lineno": 282,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6243,
        "code": "turn _totalSupply;\n    ",
        "debug": "calldata_Tablow_4: 0xf2c71b6ec72a2bc2cbdb1100a6c0a6800901d865bacf0a0402981f33eb\nstorage_2: 0x8311d86797e4b35c6094b1d0993b66af86537eac20e1bf6e2b9a265f94cbffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8311d86797e4b35c6094b1d0993b66af86537eac20e1bf6e2b9a265f94cc0000\ncalldata_Tablow_0: 0x2cd3fd7000000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `BurnTokens(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "BurnTokens(uint256)",
        "lineno": 287,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 6650,
        "code": "      _MaxDistribPub",
        "debug": "storage_15: 0x0\ncalldata_Tablow_4 + calldata_Tablow_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff21\ncaller: 0x0\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 167,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11705,
        "code": "public symbol = \"TC\";\n    string public name = \"Tablow Club\";\n    uint8 public constant decimals = 18;\n    uint256 _totalSupply = 0;\n    uint256 _MaxDistribPublicSupply = 0;\n    uint256 _OwnerDistribSupply = 0;\n    uint256 _CurrentDistribPublicSupply = 0;\n    uint256 _FreeTokens = 0;\n    uint256 _Multiplier1 = 2;\n    uint256 _Multiplier2 = 3;\n    uint256 _LimitMultiplier1 = 4e15;\n    uint256 _LimitMultiplier2 = 8e15;\n    uint256 _HighDonateLimit = 5e16;\n    uint256 _BonusTokensPerETHdonated = 0;\n    address _DistribFundsReceiverAddress = 0;\n    address _remainingTokensReceiverAddress = 0;\n    address owner = 0;\n    bool setupDone = false;\n    bool IsDistribRunning = false;\n    bool DistribStarted = false;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _owner, uint256 _value);\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n    mapping(address => bool) public Claimed;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Tablow() public {\n        owner = msg.sender;\n    }\n\n    function() public payable {\n        if (IsDistribRunning) {\n            uint256 _amount;\n            if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert();\n            if (!_DistribFundsReceiverAddress.send(msg.value)) revert();\n            if (Claimed[msg.sender] == false) {\n                _amount = _FreeTokens * 1e18;\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n                Claimed[msg.sender] = true;\n            }\n\n            require(msg.value <= _HighDonateLimit);\n\n            if (msg.value >= 1e15) {\n                if (msg.value >= _LimitMultiplier2) {\n                    _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier2;\n                } else {\n                    if (msg.value >= _LimitMultiplier1) {\n                        _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier1;\n                    } else {\n\n                        _amount = msg.value * _BonusTokensPerETHdonated;\n\n                    }\n\n                }\n\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n            }\n\n\n\n        } else {\n            revert();\n        }\n    }\n\n    function SetupToken(string tokenName, string tokenSymbol, uint256 BonusTokensPerETHdonated, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwner public {\n        _Multiplier1 = Multiplier1inX;\n        _Multiplier2 = Multiplier2inX;\n        _LimitMultiplier1 = LimitMultiplier1inWei;\n        _LimitMultiplier2 = LimitMultiplier2inWei;\n        _HighDonateLimit = HighDonateLimitInWei;\n    }\n\n    function SetBonus(uint256 BonusTokensPerETHdonated) onlyOwner public {\n        _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n    }\n\n    function SetFreeTokens(uint256 FreeTokens) onlyOwner public {\n        _FreeTokens = FreeTokens;\n    }\n\n    function StartDistrib() public returns(bool success) {\n        if (msg.sender == owner && !DistribStarted && setupDone) {\n            DistribStarted = true;\n            IsDistribRunning = true;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function StopDistrib() public returns(bool success) {\n        if (msg.sender == owner && IsDistribRunning) {\n            if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) {\n                uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n                if (_remainingAmount > 0) {\n                    balances[_remainingTokensReceiverAddress] += _remainingAmount;\n                    _totalSupply += _remainingAmount;\n                    Transfer(this, _remainingTokensReceiverAddress, _remainingAmount);\n                }\n            }\n            DistribStarted = false;\n            IsDistribRunning = false;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function distribution(address[] addresses, uint256 _amount) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        require(addresses.length <= 255);\n        require(_amount <= _remainingAmount);\n        _amount = _amount * 1e18;\n\n        for (uint i = 0; i < addresses.length; i++) {\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[addresses[i]] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n        }\n\n        if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n            DistribStarted = false;\n            IsDistribRunning = false;\n        }\n    }\n\n    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        uint256 _amount;\n\n        require(addresses.length <= 255);\n        require(addresses.length == amounts.length);\n\n        for (uint8 i = 0; i < addresses.length; i++) {\n            _amount = amounts[i] * 1e18;\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[addresses[i]] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n\n            if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n                DistribStarted = false;\n                IsDistribRunning = false;\n            }\n        }\n    }\n\n    function BurnTokens(uint256 amount) public returns(bool success) {\n        uint256 _amount = amount * 1e18;\n        if (balances[msg.sender] >= _amount) {\n            balances[msg.sender] -= _amount;\n            _totalSupply -= _amount;\n            Burn(msg.sender, _amount);\n            Transfer(msg.sender, 0, _amount);\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function totalSupply() public constant returns(uint256 totalSupplyValue) {\n        return _totalSupply;\n    }\n\n    function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) {\n        return _MaxDistribPublicSupply;\n    }\n\n    function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) {\n        return _OwnerDistribSupply;\n    }\n\n    function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) {\n        return _CurrentDistribPublicSupply;\n    }\n\n    function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) {\n        return _remainingTokensReceiverAddress;\n    }\n\n    function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) {\n        return _DistribFundsReceiverAddress;\n    }\n\n    function Owner() public constant returns(address ownerAddress) {\n        return owner;\n    }\n\n    function SetupDone() public constant returns(bool setupDoneFlag) {\n        return setupDone;\n    }\n\n    function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) {\n        return IsDistribRunning;\n    }\n\n    function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) {\n        return DistribStarted;\n    }\n    \n     \n    /**\n     * @dev Transfer the specified amount of tokens to the specified address.\n     *      This function works the same with the previous one\n     *      but doesn't contain `_data` param.\n     *      Added due to backwards compatibility reasons.\n     *\n     * @param _to    Receiver address.\n     * @param _value Amount of tokens that will be transferred.\n     */\n    \n    function transfer(address _to, uint _value) returns (bool success) {\n        if (balances[msg.sender] >= _value\n            && _value > 0\n            && balances[_to] + _value > balances[_to]) {\n            bytes memory empty;\n            if(isContract(_to)) {\n                return transferToContract(_to, _value, empty);\n            } else {\n                return transferToAddress(_to, _value, empty);\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /* Withdraws to address _to form the address _from up to the amount _value */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balances[_from] >= _value\n            && allowed[_from][msg.sender] >= _value\n            && _value > 0\n            && balances[_to] + _value > balances[_to]) {\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Allows _spender to withdraw the _allowance amount form sender */\n    function approve(address _spender, uint256 _allowance) returns (bool success) {\n        if (_allowance <= _totalSupply) {\n            allowed[msg.sender][_spender] = _allowance;\n            Approval(msg.sender, _spender, _allowance);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Checks how much _spender can withdraw from _owner */\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n     \n     \n     function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n        if (balances[msg.sender] >= _value\n            && _value > 0\n            && balances[_to] + _value > balances[_to]) {\n            if(isContract(_to)) {\n                return transferToContract(_to, _value, _data);\n            } else {\n                return transferToAddress(_to, _value, _data);\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /* Transfer function when _to represents a regular address */\n    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /* Transfer function when _to represents a contract address, with the caveat\n    that the contract needs to implement the tokenFallback function in order to receive tokens */\n    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n        Transfer(msg.sender, _to, _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /* Infers if whether _address is a contract based on the presence of bytecode */\n    function isContract(address _address) internal returns (bool is_contract) {\n        uint length;\n        if (_address == 0) return false;\n        assembly {\n            length := extcodesize(_address)\n        }\n        if(length > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    \n    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n\n    \n    function balanceOf(address _owner) public constant returns(uint256 balance) {\n        return balances[_owner];\n    }\n    \n    \n}",
        "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Tablow_4 + calldata_Tablow_4)): 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_15: 0x0\ncaller: 0x0\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 80,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11719,
        "code": "public symbol = \"TC\";\n    string public name = \"Tablow Club\";\n    uint8 public constant decimals = 18;\n    uint256 _totalSupply = 0;\n    uint256 _MaxDistribPublicSupply = 0;\n    uint256 _OwnerDistribSupply = 0;\n    uint256 _CurrentDistribPublicSupply = 0;\n    uint256 _FreeTokens = 0;\n    uint256 _Multiplier1 = 2;\n    uint256 _Multiplier2 = 3;\n    uint256 _LimitMultiplier1 = 4e15;\n    uint256 _LimitMultiplier2 = 8e15;\n    uint256 _HighDonateLimit = 5e16;\n    uint256 _BonusTokensPerETHdonated = 0;\n    address _DistribFundsReceiverAddress = 0;\n    address _remainingTokensReceiverAddress = 0;\n    address owner = 0;\n    bool setupDone = false;\n    bool IsDistribRunning = false;\n    bool DistribStarted = false;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _owner, uint256 _value);\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n    mapping(address => bool) public Claimed;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Tablow() public {\n        owner = msg.sender;\n    }\n\n    function() public payable {\n        if (IsDistribRunning) {\n            uint256 _amount;\n            if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert();\n            if (!_DistribFundsReceiverAddress.send(msg.value)) revert();\n            if (Claimed[msg.sender] == false) {\n                _amount = _FreeTokens * 1e18;\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n                Claimed[msg.sender] = true;\n            }\n\n            require(msg.value <= _HighDonateLimit);\n\n            if (msg.value >= 1e15) {\n                if (msg.value >= _LimitMultiplier2) {\n                    _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier2;\n                } else {\n                    if (msg.value >= _LimitMultiplier1) {\n                        _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier1;\n                    } else {\n\n                        _amount = msg.value * _BonusTokensPerETHdonated;\n\n                    }\n\n                }\n\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n            }\n\n\n\n        } else {\n            revert();\n        }\n    }\n\n    function SetupToken(string tokenName, string tokenSymbol, uint256 BonusTokensPerETHdonated, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwner public {\n        _Multiplier1 = Multiplier1inX;\n        _Multiplier2 = Multiplier2inX;\n        _LimitMultiplier1 = LimitMultiplier1inWei;\n        _LimitMultiplier2 = LimitMultiplier2inWei;\n        _HighDonateLimit = HighDonateLimitInWei;\n    }\n\n    function SetBonus(uint256 BonusTokensPerETHdonated) onlyOwner public {\n        _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n    }\n\n    function SetFreeTokens(uint256 FreeTokens) onlyOwner public {\n        _FreeTokens = FreeTokens;\n    }\n\n    function StartDistrib() public returns(bool success) {\n        if (msg.sender == owner && !DistribStarted && setupDone) {\n            DistribStarted = true;\n            IsDistribRunning = true;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function StopDistrib() public returns(bool success) {\n        if (msg.sender == owner && IsDistribRunning) {\n            if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) {\n                uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n                if (_remainingAmount > 0) {\n                    balances[_remainingTokensReceiverAddress] += _remainingAmount;\n                    _totalSupply += _remainingAmount;\n                    Transfer(this, _remainingTokensReceiverAddress, _remainingAmount);\n                }\n            }\n            DistribStarted = false;\n            IsDistribRunning = false;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function distribution(address[] addresses, uint256 _amount) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        require(addresses.length <= 255);\n        require(_amount <= _remainingAmount);\n        _amount = _amount * 1e18;\n\n        for (uint i = 0; i < addresses.length; i++) {\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[addresses[i]] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n        }\n\n        if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n            DistribStarted = false;\n            IsDistribRunning = false;\n        }\n    }\n\n    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        uint256 _amount;\n\n        require(addresses.length <= 255);\n        require(addresses.length == amounts.length);\n\n        for (uint8 i = 0; i < addresses.length; i++) {\n            _amount = amounts[i] * 1e18;\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[addresses[i]] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n\n            if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n                DistribStarted = false;\n                IsDistribRunning = false;\n            }\n        }\n    }\n\n    function BurnTokens(uint256 amount) public returns(bool success) {\n        uint256 _amount = amount * 1e18;\n        if (balances[msg.sender] >= _amount) {\n            balances[msg.sender] -= _amount;\n            _totalSupply -= _amount;\n            Burn(msg.sender, _amount);\n            Transfer(msg.sender, 0, _amount);\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function totalSupply() public constant returns(uint256 totalSupplyValue) {\n        return _totalSupply;\n    }\n\n    function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) {\n        return _MaxDistribPublicSupply;\n    }\n\n    function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) {\n        return _OwnerDistribSupply;\n    }\n\n    function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) {\n        return _CurrentDistribPublicSupply;\n    }\n\n    function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) {\n        return _remainingTokensReceiverAddress;\n    }\n\n    function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) {\n        return _DistribFundsReceiverAddress;\n    }\n\n    function Owner() public constant returns(address ownerAddress) {\n        return owner;\n    }\n\n    function SetupDone() public constant returns(bool setupDoneFlag) {\n        return setupDone;\n    }\n\n    function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) {\n        return IsDistribRunning;\n    }\n\n    function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) {\n        return DistribStarted;\n    }\n    \n     \n    /**\n     * @dev Transfer the specified amount of tokens to the specified address.\n     *      This function works the same with the previous one\n     *      but doesn't contain `_data` param.\n     *      Added due to backwards compatibility reasons.\n     *\n     * @param _to    Receiver address.\n     * @param _value Amount of tokens that will be transferred.\n     */\n    \n    function transfer(address _to, uint _value) returns (bool success) {\n        if (balances[msg.sender] >= _value\n            && _value > 0\n            && balances[_to] + _value > balances[_to]) {\n            bytes memory empty;\n            if(isContract(_to)) {\n                return transferToContract(_to, _value, empty);\n            } else {\n                return transferToAddress(_to, _value, empty);\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /* Withdraws to address _to form the address _from up to the amount _value */\n    function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {\n        if (balances[_from] >= _value\n            && allowed[_from][msg.sender] >= _value\n            && _value > 0\n            && balances[_to] + _value > balances[_to]) {\n            balances[_from] -= _value;\n            allowed[_from][msg.sender] -= _value;\n            balances[_to] += _value;\n            Transfer(_from, _to, _value);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Allows _spender to withdraw the _allowance amount form sender */\n    function approve(address _spender, uint256 _allowance) returns (bool success) {\n        if (_allowance <= _totalSupply) {\n            allowed[msg.sender][_spender] = _allowance;\n            Approval(msg.sender, _spender, _allowance);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /* Checks how much _spender can withdraw from _owner */\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n     \n     \n     function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n        if (balances[msg.sender] >= _value\n            && _value > 0\n            && balances[_to] + _value > balances[_to]) {\n            if(isContract(_to)) {\n                return transferToContract(_to, _value, _data);\n            } else {\n                return transferToAddress(_to, _value, _data);\n            }\n        } else {\n            return false;\n        }\n    }\n\n    /* Transfer function when _to represents a regular address */\n    function transferToAddress(address _to, uint _value, bytes _data) internal returns (bool success) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        Transfer(msg.sender, _to, _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /* Transfer function when _to represents a contract address, with the caveat\n    that the contract needs to implement the tokenFallback function in order to receive tokens */\n    function transferToContract(address _to, uint _value, bytes _data) internal returns (bool success) {\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n        receiver.tokenFallback(msg.sender, _value, _data);\n        Transfer(msg.sender, _to, _value);\n        Transfer(msg.sender, _to, _value, _data);\n        return true;\n    }\n\n    /* Infers if whether _address is a contract based on the presence of bytecode */\n    function isContract(address _address) internal returns (bool is_contract) {\n        uint length;\n        if (_address == 0) return false;\n        assembly {\n            length := extcodesize(_address)\n        }\n        if(length > 0) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n\n    \n    function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n\n    \n    function balanceOf(address _owner) public constant returns(uint256 balance) {\n        return balances[_owner];\n    }\n    \n    \n}",
        "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Tablow_4 + calldata_Tablow_4)): 0xa7d18fd5703fddff6f5377fa44900dfb4a10ffffe39800000000000000000060\nstorage_15: 0x0\ncalldata_Tablow_4 + calldata_Tablow_4: 0x7fffffffffffffffffffffffffffffffffffffff3fffffffffffffffffffff41\ncaller: 0x0\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc5903fe72a9530e4382187f729ccc050d7e89fae.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 80,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}