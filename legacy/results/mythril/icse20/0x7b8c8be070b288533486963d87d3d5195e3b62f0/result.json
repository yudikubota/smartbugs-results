{
  "contract": "0x7b8c8be070b288533486963d87d3d5195e3b62f0",
  "tool": "mythril",
  "start": 1563587423.0345025,
  "end": 1563587575.1280305,
  "duration": 152.09352803230286,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 521,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 533,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4 + calldata_TokenSwap_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 536,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4 + calldata_TokenSwap_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 542,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4 + calldata_TokenSwap_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 625,
        "code": " internal isTokenAllocated;\n    mapping(",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\ncalldata_TokenSwap_0: 0x200d2ed200000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x200d2ed2",
        "lineno": 482,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 998,
        "code": "           \"There is no swap offer with this token\"\n        );\n\n        for (uint256 i = 0; i < _secondsSinceLockupStart.length; i++) {\n            LockupStage memory stage = LockupStage(\n                _secondsSinceLockupStart[i], _unlockedTokensPercentages[i]\n            );\n            lockupStagesByToken[_token].push(stage);\n\n            emit AddLockupStage(\n                _token, stage.secondsSinceLockupStart, stage.unlockedTokensPercentage\n            );\n        }\n\n        _validateLockupStages(_token);\n    }\n\n    /**\n     * @dev Add token allocation.\n     * @param _token A token previously added via addParty.\n     * @param _receivers Who receives tokens.\n     * @param _amounts How much tokens will each receiver get.\n     */\n    function addTokenAllocation(\n        ERC20 _token,\n        address[] _receivers,\n        uint256[] _amounts\n    )\n        external\n        onlyOwner\n        canAddTokenAllocation\n    {\n        require(_token != address(0), \"Invalid token\");\n        require(_receivers.length == _amounts.length, \"Invalid arguments' lengths\");\n        require(offerByToken[_token].token != address(0), \"There is no swap offer with this token\");\n        requi",
        "debug": "calldata_TokenSwap_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenSwap_0: 0x2fe65b5100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x2fe65b51`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x2fe65b51",
        "lineno": 651,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2359,
        "code": "public owners;\n    byte",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenSwap_4: 0x0\nstorage_3: 0x0\ncalldata_TokenSwap_0: 0x25e7c2700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x025e7c27",
        "lineno": 11,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2591,
        "code": "ies,\n            \"Unable to",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x2577911f00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x2577911f",
        "lineno": 547,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3656,
        "code": ";\n\n// File: Multio",
        "debug": "storage_11: 0x0\nstorage_12: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenSwap_4: 0x0\ncalldata_TokenSwap_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenSwap_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenSwap_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x2577911f00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x2577911f`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x2577911f",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4513,
        "code": "        require(_doesEveryT",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x2fe65b5100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x2fe65b51",
        "lineno": 551,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6165,
        "code": "g to swap.\n     * @param _toke",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TokenSwap_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "withdraw()",
        "lineno": 591,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 7515,
        "code": "ublic allOperations;\n    addre",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenSwap_4: 0x0\nstorage_4: 0x0\ncalldata_TokenSwap_0: 0x431ab23300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x431ab233",
        "lineno": 12,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8665,
        "code": "  }\n\n    modifier canConfir",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x6b5c8fba00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "confirmParties()",
        "lineno": 562,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9808,
        "code": ");\n        _;\n    }\n\n    mo",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x6cab976100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x6cab9761",
        "lineno": 552,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 13886,
        "code": "ner\n        canAddParty\n    {\n",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TokenSwap_0: 0x80e9071b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "reclaim()",
        "lineno": 600,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 23364,
        "code": "operation = keccak256(msg.dat",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x5e1a795700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `_function_0x5e1a7957`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x5e1a7957",
        "lineno": 145,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 23546,
        "code": "lready voted for the operation\");\n   ",
        "debug": "calldatasize_TokenSwap: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x5e1a795700000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x5e1a7957`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x5e1a7957",
        "lineno": 147,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23555,
        "code": "lready voted for the operation\");\n   ",
        "debug": "calldatasize_TokenSwap: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x5e1a795700000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x5e1a7957`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x5e1a7957",
        "lineno": 147,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23835,
        "code": "      allOperationsIndicies[operatio",
        "debug": "2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x4000000000000000000000000000001000000000000000000000000000000000\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128): 0xbfffffffffffffffffffffffffffffefffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x5e1a795700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x5e1a7957`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x5e1a7957",
        "lineno": 152,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23925,
        "code": ";\n\n// File: Multio",
        "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128): 0x0\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x5e1a795700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x5e1a7957`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "_function_0x5e1a7957",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 25229,
        "code": " index;\n        }\n      ",
        "debug": "storage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferOwnership(address[])`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 176,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 25258,
        "code": "yOperation[operation];\n        delete v",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_4: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x2edcbb76edd9b366d9b325e517366cd99f1e7fffffef2fff7fefdbff77ed73d6\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1123448912264c99264cda1ae8c9932660e180000010d0008010240088128c28\nstorage_2: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 180,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 25372,
        "code": "\n    // PUBLIC METHODS",
        "debug": "storage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferOwnership(address[])`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 184,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 27591,
        "code": " uint8 unlockedTokensPercentage;\n    }\n\n    // VARIABLES\n    Status public status = Status.AddParties;\n\n    address[] internal participants;\n    mapping(address => bool) internal isParticipant;\n    mapping(address => address) internal tokenByParticipant;\n    mapping(address => SwapOffer) internal offerByToken;\n\n    uint256 internal startLockupAt;\n    mapping(address => LockupStage[]) internal lockupStagesByToken;\n\n    address[] internal receivers;\n    mapping(address => bool) internal isReceiver;\n    mapping(address => bool) internal isTokenAllocated;\n    mapping(address => mapping(address => uint256)) internal allocatedTokens;\n    mapping(address => mapping(address => uint256)) internal withdrawnTokens;\n\n    // EVENTS\n    event StatusUpdate(Status oldStatus, Status newStatus);\n    event AddParty(address participant, ERC20 token, uint256 tokensTotal);\n    event AddTokenAllocation(ERC20 token, address receiver, uint256 amount);\n    event AddLockupStage(\n        ERC20 token,\n        uint256 secondsSinceLockupStart,\n        uint8 unlockedTokensPercentage\n    );\n    event ConfirmParties();\n    event CancelSwap();\n    event ConfirmSwap();\n    event StartLockup(uint256 startLockupAt);\n    event Withdraw(address participant, ERC20 token, uint256 amount);\n    event WithdrawFee(ERC20 token, uint256 amount);\n    event Reclaim(address participant, ERC20 token, uint256 amount);\n    event SoftEmergency(ERC20 token, address receiver, uint256 amount);\n    event HardEmergency(ERC20 token, address receiver, uint256 amount);\n\n    // MODIFIERS\n    modifier onlyParticipant {\n        require(\n            isParticipant[msg.sender] == true,\n            \"Only swap participants allowed to call the method\"\n        );\n        _;\n    }\n\n    modifier onlyReceiver {\n        require(\n            isReceiver[msg.sender] == true,\n            \"Only token receivers allowed to call the method\"\n        );\n       _;\n    }\n\n    modifier canTransferOwnership {\n        require(status == Status.AddParties, \"Unable to transfer ownership in the current status\");\n        _;\n    }\n\n    modifier canAddParty {\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\n        _;\n    }\n\n    modifier canAddLockupPeriod {\n        require(status == Status.AddParties, \"Unable to add lockup period in the current status\");\n        _;\n    }\n\n    modifier canAddTokenAllocation {\n        require(\n            status == Status.AddParties,\n            \"Unable to add token allocation in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmParties {\n        require(\n            status == Status.AddParties,\n            \"Unable to confirm parties in the current status\"\n        );\n        require(participants.length > 1, \"Need at least two participants\");\n        require(_doesEveryTokenHaveLockupPeriod(), \"Each token must have lockup period\");\n        require(_isEveryTokenFullyAllocated(), \"Each token must be fully allocated\");\n        _;\n    }\n\n    modifier canCancelSwap {\n        require(\n            status == Status.WaitingDeposits,\n            \"Unable to cancel swap in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmSwap {\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\n        require(\n            _haveEveryoneDeposited(),\n            \"Unable to confirm swap before all parties have deposited tokens\"\n        );\n        _;\n    }\n\n    modifier canWithdraw {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canReclaim {\n        require(\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n            \"Unable to reclaim in the current status\"\n        );\n        _;\n    }\n\n    // EXTERNAL METHODS\n    /**\n     * @dev Add new party to the swap.\n     * @param _participant Address of the participant.\n     * @param _token An ERC20-compliant token which participant is offering to swap.\n     * @param _tokensTotal How much tokens the participant is offering.\n     */\n    function addParty(\n        address _participant,\n        ERC20 _token,\n        uint256 _tokensTotal\n    )\n        external\n        onlyOwner\n        canAddParty\n    {\n        require(_participant != address(0), \"_participant is invalid address\");\n        require(_token != address(0), \"_token is invalid address\");\n        require(_tokensTotal > 0, \"Positive amount of tokens is required\");\n        require(\n            isParticipant[_participant] == false,\n            \"Unable to add the same party multiple times\"\n        );\n\n        isParticipant[_participant] = true;\n        SwapOffer memory offer = SwapOffer({\n            participant: _participant,\n            token: _token,\n            tokensTotal: _tokensTotal,\n            withdrawnTokensTotal: 0\n        });\n        participants.push(offer.participant);\n        offerByToken[offer.token] = offer;\n        tokenByParticipant[offer.participant] = offer.token;\n\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n    }\n\n    /**\n     * @dev Add lockup period stages for one of the tokens.\n     * @param _token A token previously added via addParty.\n     * @param _secondsSinceLockupStart Array of starts of the stages of the lockup period.\n     * @param _unlockedTokensPercentages Array of percentages of the unlocked tokens.\n     */\n    function addLockupPeriod(\n        ERC20 _token,\n        uint256[] _secondsSinceLockupStart,\n        uint8[] _unlockedTokensPercentages\n    )\n        external\n        onlyOwner\n        canAddLockupPeriod\n    {\n        require(_token != address(0), \"Invalid token\");\n        require(\n            _secondsSinceLockupStart.length == _unlockedTokensPercentages.length,\n            \"Invalid lockup period\"\n        );\n        require(\n            lockupStagesByToken[_token].length == 0,\n            \"Lockup period for this token has been added already\"\n        );\n        require(\n            offerByToken[_token].token != address(0),\n            \"There is no swap offer with this token\"\n        );\n\n        for (uint256 i = 0; i < _secondsSinceLockupStart.length; i++) {\n            LockupStage memory stage = LockupStage(\n                _secondsSinceLockupStart[i], _unlockedTokensPercentages[i]\n            );\n            lockupStagesByToken[_token].push(stage);\n\n            emit AddLockupStage(\n                _token, stage.secondsSinceLockupStart, stage.unlockedTokensPercentage\n            );\n        }\n\n        _validateLockupStages(_token);\n    }\n\n    /**\n     * @dev Add token allocation.\n     * @param _token A token previously added via addParty.\n     * @param _receivers Who receives tokens.\n     * @param _amounts How much tokens will each receiver get.\n     */\n    function addTokenAllocation(\n        ERC20 _token,\n        address[] _receivers,\n        uint256[] _amounts\n    )\n        external\n        onlyOwner\n        canAddTokenAllocation\n    {\n        require(_token != address(0), \"Invalid token\");\n        require(_receivers.length == _amounts.length, \"Invalid arguments' lengths\");\n        require(offerByToken[_token].token != address(0), \"There is no swap offer with this token\");\n        require(!isTokenAllocated[_token], \"Token has been allocated already\");\n\n        uint256 totalAllocation = 0;\n        uint256 i;\n\n        for (i = 0; i < _receivers.length; i++) {\n            require(_receivers[i] != address(0), \"Invalid receiver\");\n            require(_amounts[i] > 0, \"Positive amount is required\");\n            require(\n                allocatedTokens[_token][_receivers[i]] == 0,\n                \"Tokens for this receiver have been allocated already\"\n            );\n\n            if (!isReceiver[_receivers[i]]) {\n                receivers.push(_receivers[i]);\n                isReceiver[_receivers[i]] = true;\n            }\n\n            allocatedTokens[_token][_receivers[i]] = _amounts[i];\n            totalAllocation = totalAllocation.add(_amounts[i]);\n\n            emit AddTokenAllocation(_token, _receivers[i], _amounts[i]);\n        }\n\n        require(totalAllocation == offerByToken[_token].tokensTotal, \"Invalid allocation\");\n        require(isReceiver[owner], \"Swap fee hasn't been allocated\");\n\n        for (i = 0; i < participants.length; i++) {\n            if (tokenByParticipant[participants[i]] == address(_token)) {\n                continue;\n            }\n            require(isReceiver[participants[i]], \"Tokens for a participant haven't been allocated\");\n        }\n\n        isTokenAllocated[_token] = true;\n    }\n\n    /**\n     * @dev Confirm swap parties\n     */\n    function confirmParties() external onlyOwner canConfirmParties {\n        address[] memory newOwners = new address[](participants.length + 1);\n\n        for (uint256 i = 0; i < participants.length; i++) {\n            newOwners[i] = participants[i];\n        }\n\n        newOwners[newOwners.length - 1] = owner;\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n        _changeStatus(Status.WaitingDeposits);\n        emit ConfirmParties();\n    }\n\n    /**\n     * @dev Confirm swap.\n     */\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\n        emit ConfirmSwap();\n        _changeStatus(Status.SwapConfirmed);\n        _startLockup();\n    }\n\n    /**\n     * @dev Cancel swap.\n     */\n    function cancelSwap() external canCancelSwap onlyManyOwners {\n        emit CancelSwap();\n        _changeStatus(Status.SwapCanceled);\n    }\n\n    /**\n     * @dev Withdraw tokens\n     */\n    function withdraw() external onlyReceiver canWithdraw {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            if (offer.participant == msg.sender) {\n                continue;\n            }\n\n            uint256 tokensAmount = _withdrawableAmount(offer.token, msg.sender);\n\n            if (tokensAmount > 0) {\n                withdrawnTokens[offer.token][msg.sender] =\n                    withdrawnTokens[offer.token][msg.sender].add(tokensAmount);\n                offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n                offer.token.safeTransfer(msg.sender, tokensAmount);\n                emit Withdraw(msg.sender, offer.token, tokensAmount);\n            }\n        }\n    }\n\n    /**\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n     */\n    function reclaim() external onlyParticipant canReclaim {\n        address token = tokenByParticipant[msg.sender];\n\n        SwapOffer storage offer = offerByToken[token];\n        uint256 currentBalance = offer.token.balanceOf(address(this));\n        uint256 availableForReclaim = currentBalance;\n\n        if (status != Status.SwapCanceled) {\n            uint256 lockedTokens = offer.tokensTotal.sub(offer.withdrawnTokensTotal);\n            availableForReclaim = currentBalance.sub(lockedTokens);\n        }\n\n        if (availableForReclaim > 0) {\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\n        }\n\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n    }\n\n    /**\n     * @dev Transfer tokens back to owners.\n     */\n    function softEmergency() external onlyOwner {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n            uint256 tokensAmount = offer.token.balanceOf(address(this));\n\n            require(offer.withdrawnTokensTotal == 0, \"Unavailable after the first withdrawal.\");\n\n            if (tokensAmount > 0) {\n                offer.token.safeTransfer(offer.participant, tokensAmount);\n                emit SoftEmergency(offer.token, offer.participant, tokensAmount);\n            }\n        }\n    }\n\n    /**\n     * @dev A way out if nothing else is working.\n     */\n    function hardEmergency(\n        ERC20[] _tokens,\n        address[] _receivers,\n        uint256[] _values\n    )\n        external\n        onlyAllOwners\n    {\n        require(_tokens.length == _receivers.length, \"Invalid lengths.\");\n        require(_receivers.length == _values.length, \"Invalid lengths.\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].safeTransfer(_receivers[i], _values[i]);\n            emit HardEmergency(_tokens[i], _receivers[i], _values[i]);\n        }\n    }\n\n    // PUBLIC METHODS\n    /**\n     * @dev Standard ERC223 function that will handle incoming token transfers.\n     *\n     * @param _from  Token sender address.\n     * @param _value Amount of tokens.\n     * @param _data  Transaction metadata.\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n\n    }\n\n    /**\n     * @dev Transfer ownership.\n     * @param _newOwner Address of the new owner.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner canTransferOwnership {\n        require(_newOwner != address(0), \"_newOwner is invalid address\");\n        require(owners.length == 1, \"Unable to transfer ownership in presence of multiowners\");\n        require(owners[0] == owner, \"Unexpected multiowners state\");\n\n        address[] memory newOwners = new address[](1);\n        newOwners[0] = _newOwner;\n\n        Ownable.transferOwnership(_newOwner);\n        Multiownable.transferOwnership(newOwners);\n    }\n\n    // INTERNAL METHODS\n    /**\n     * @dev Validate lock-up period configuration.\n     */\n    function _validateLockupStages(ERC20 _token) internal view {\n        LockupStage[] storage lockupStages = lockupStagesByToken[_token];\n\n        for (uint i = 0; i < lockupStages.length; i++) {\n            LockupStage memory stage = lockupStages[i];\n\n            require(\n                stage.unlockedTokensPercentage >= 0,\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\n            );\n            require(\n                stage.unlockedTokensPercentage <= 100,\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\n            );\n\n            if (i == 0) {\n                continue;\n            }\n\n            LockupStage memory previousStage = lockupStages[i - 1];\n            require(\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\n            );\n            require(\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\n            );\n        }\n\n        require(\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n            \"The last lockup stage must unlock 100% of tokens\"\n        );\n    }\n\n    /**\n     * @dev Change swap status.\n     */\n    function _changeStatus(Status _newStatus) internal {\n        emit StatusUpdate(status, _newStatus);\n        status = _newStatus;\n    }\n\n    /**\n     * @dev Check if every token has lockup period.\n     */\n    function _doesEveryTokenHaveLockupPeriod() internal view returns(bool) {\n        for (uint256 i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n\n            if (lockupStagesByToken[token].length == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Check if every token has been fully allocated.\n     */\n    function _isEveryTokenFullyAllocated() internal view returns(bool) {\n        for (uint256 i = 0; i < participants.length; i++) {\n            if (!isTokenAllocated[tokenByParticipant[participants[i]]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n     */\n    function _haveEveryoneDeposited() internal view returns(bool) {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer memory offer = offerByToken[token];\n\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Start lockup period\n     */\n    function _startLockup() internal {\n        startLockupAt = now;\n        emit StartLockup(startLockupAt);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn.\n     */\n    function _withdrawableAmount(\n        ERC20 _token,\n        address _receiver\n    )\n        internal\n        view\n        returns(uint256)\n    {\n        uint256 allocated = allocatedTokens[_token][_receiver];\n        uint256 withdrawn = withdrawnTokens[_token][_receiver];\n        uint256 unlockedPercentage = _getUnlockedTokensPercentage(_token);\n        uint256 unlockedAmount = allocated.mul(unlockedPercentage).div(100);\n\n        return unlockedAmount.sub(withdrawn);\n    }\n\n    /**\n     * @dev Get percent of unlocked tokens\n     */\n    function _getUnlockedTokensPercentage(ERC20 _token) internal view returns(uint256) {\n        for (uint256 i = lockupStagesByToken[_token].length; i > 0; i--) {\n            LockupStage storage stage = lockupStagesByToken[_token][i - 1];\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n\n            if (now < stageBecomesActiveAt) {\n                continue;\n            }\n\n            return stage.unlockedTokensPercentage;\n        }\n    }\n}",
        "debug": "storage_4: 0x75ca53043ea007e5c65182cbb1ffffffffffffffffffffffffffffffffffffff\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_2: 0x75ca53043ea007e5c65182cbb1ffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 466,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 27593,
        "code": " uint8 unlockedTokensPercentage;\n    }\n\n    // VARIABLES\n    Status public status = Status.AddParties;\n\n    address[] internal participants;\n    mapping(address => bool) internal isParticipant;\n    mapping(address => address) internal tokenByParticipant;\n    mapping(address => SwapOffer) internal offerByToken;\n\n    uint256 internal startLockupAt;\n    mapping(address => LockupStage[]) internal lockupStagesByToken;\n\n    address[] internal receivers;\n    mapping(address => bool) internal isReceiver;\n    mapping(address => bool) internal isTokenAllocated;\n    mapping(address => mapping(address => uint256)) internal allocatedTokens;\n    mapping(address => mapping(address => uint256)) internal withdrawnTokens;\n\n    // EVENTS\n    event StatusUpdate(Status oldStatus, Status newStatus);\n    event AddParty(address participant, ERC20 token, uint256 tokensTotal);\n    event AddTokenAllocation(ERC20 token, address receiver, uint256 amount);\n    event AddLockupStage(\n        ERC20 token,\n        uint256 secondsSinceLockupStart,\n        uint8 unlockedTokensPercentage\n    );\n    event ConfirmParties();\n    event CancelSwap();\n    event ConfirmSwap();\n    event StartLockup(uint256 startLockupAt);\n    event Withdraw(address participant, ERC20 token, uint256 amount);\n    event WithdrawFee(ERC20 token, uint256 amount);\n    event Reclaim(address participant, ERC20 token, uint256 amount);\n    event SoftEmergency(ERC20 token, address receiver, uint256 amount);\n    event HardEmergency(ERC20 token, address receiver, uint256 amount);\n\n    // MODIFIERS\n    modifier onlyParticipant {\n        require(\n            isParticipant[msg.sender] == true,\n            \"Only swap participants allowed to call the method\"\n        );\n        _;\n    }\n\n    modifier onlyReceiver {\n        require(\n            isReceiver[msg.sender] == true,\n            \"Only token receivers allowed to call the method\"\n        );\n       _;\n    }\n\n    modifier canTransferOwnership {\n        require(status == Status.AddParties, \"Unable to transfer ownership in the current status\");\n        _;\n    }\n\n    modifier canAddParty {\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\n        _;\n    }\n\n    modifier canAddLockupPeriod {\n        require(status == Status.AddParties, \"Unable to add lockup period in the current status\");\n        _;\n    }\n\n    modifier canAddTokenAllocation {\n        require(\n            status == Status.AddParties,\n            \"Unable to add token allocation in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmParties {\n        require(\n            status == Status.AddParties,\n            \"Unable to confirm parties in the current status\"\n        );\n        require(participants.length > 1, \"Need at least two participants\");\n        require(_doesEveryTokenHaveLockupPeriod(), \"Each token must have lockup period\");\n        require(_isEveryTokenFullyAllocated(), \"Each token must be fully allocated\");\n        _;\n    }\n\n    modifier canCancelSwap {\n        require(\n            status == Status.WaitingDeposits,\n            \"Unable to cancel swap in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmSwap {\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\n        require(\n            _haveEveryoneDeposited(),\n            \"Unable to confirm swap before all parties have deposited tokens\"\n        );\n        _;\n    }\n\n    modifier canWithdraw {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canReclaim {\n        require(\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n            \"Unable to reclaim in the current status\"\n        );\n        _;\n    }\n\n    // EXTERNAL METHODS\n    /**\n     * @dev Add new party to the swap.\n     * @param _participant Address of the participant.\n     * @param _token An ERC20-compliant token which participant is offering to swap.\n     * @param _tokensTotal How much tokens the participant is offering.\n     */\n    function addParty(\n        address _participant,\n        ERC20 _token,\n        uint256 _tokensTotal\n    )\n        external\n        onlyOwner\n        canAddParty\n    {\n        require(_participant != address(0), \"_participant is invalid address\");\n        require(_token != address(0), \"_token is invalid address\");\n        require(_tokensTotal > 0, \"Positive amount of tokens is required\");\n        require(\n            isParticipant[_participant] == false,\n            \"Unable to add the same party multiple times\"\n        );\n\n        isParticipant[_participant] = true;\n        SwapOffer memory offer = SwapOffer({\n            participant: _participant,\n            token: _token,\n            tokensTotal: _tokensTotal,\n            withdrawnTokensTotal: 0\n        });\n        participants.push(offer.participant);\n        offerByToken[offer.token] = offer;\n        tokenByParticipant[offer.participant] = offer.token;\n\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n    }\n\n    /**\n     * @dev Add lockup period stages for one of the tokens.\n     * @param _token A token previously added via addParty.\n     * @param _secondsSinceLockupStart Array of starts of the stages of the lockup period.\n     * @param _unlockedTokensPercentages Array of percentages of the unlocked tokens.\n     */\n    function addLockupPeriod(\n        ERC20 _token,\n        uint256[] _secondsSinceLockupStart,\n        uint8[] _unlockedTokensPercentages\n    )\n        external\n        onlyOwner\n        canAddLockupPeriod\n    {\n        require(_token != address(0), \"Invalid token\");\n        require(\n            _secondsSinceLockupStart.length == _unlockedTokensPercentages.length,\n            \"Invalid lockup period\"\n        );\n        require(\n            lockupStagesByToken[_token].length == 0,\n            \"Lockup period for this token has been added already\"\n        );\n        require(\n            offerByToken[_token].token != address(0),\n            \"There is no swap offer with this token\"\n        );\n\n        for (uint256 i = 0; i < _secondsSinceLockupStart.length; i++) {\n            LockupStage memory stage = LockupStage(\n                _secondsSinceLockupStart[i], _unlockedTokensPercentages[i]\n            );\n            lockupStagesByToken[_token].push(stage);\n\n            emit AddLockupStage(\n                _token, stage.secondsSinceLockupStart, stage.unlockedTokensPercentage\n            );\n        }\n\n        _validateLockupStages(_token);\n    }\n\n    /**\n     * @dev Add token allocation.\n     * @param _token A token previously added via addParty.\n     * @param _receivers Who receives tokens.\n     * @param _amounts How much tokens will each receiver get.\n     */\n    function addTokenAllocation(\n        ERC20 _token,\n        address[] _receivers,\n        uint256[] _amounts\n    )\n        external\n        onlyOwner\n        canAddTokenAllocation\n    {\n        require(_token != address(0), \"Invalid token\");\n        require(_receivers.length == _amounts.length, \"Invalid arguments' lengths\");\n        require(offerByToken[_token].token != address(0), \"There is no swap offer with this token\");\n        require(!isTokenAllocated[_token], \"Token has been allocated already\");\n\n        uint256 totalAllocation = 0;\n        uint256 i;\n\n        for (i = 0; i < _receivers.length; i++) {\n            require(_receivers[i] != address(0), \"Invalid receiver\");\n            require(_amounts[i] > 0, \"Positive amount is required\");\n            require(\n                allocatedTokens[_token][_receivers[i]] == 0,\n                \"Tokens for this receiver have been allocated already\"\n            );\n\n            if (!isReceiver[_receivers[i]]) {\n                receivers.push(_receivers[i]);\n                isReceiver[_receivers[i]] = true;\n            }\n\n            allocatedTokens[_token][_receivers[i]] = _amounts[i];\n            totalAllocation = totalAllocation.add(_amounts[i]);\n\n            emit AddTokenAllocation(_token, _receivers[i], _amounts[i]);\n        }\n\n        require(totalAllocation == offerByToken[_token].tokensTotal, \"Invalid allocation\");\n        require(isReceiver[owner], \"Swap fee hasn't been allocated\");\n\n        for (i = 0; i < participants.length; i++) {\n            if (tokenByParticipant[participants[i]] == address(_token)) {\n                continue;\n            }\n            require(isReceiver[participants[i]], \"Tokens for a participant haven't been allocated\");\n        }\n\n        isTokenAllocated[_token] = true;\n    }\n\n    /**\n     * @dev Confirm swap parties\n     */\n    function confirmParties() external onlyOwner canConfirmParties {\n        address[] memory newOwners = new address[](participants.length + 1);\n\n        for (uint256 i = 0; i < participants.length; i++) {\n            newOwners[i] = participants[i];\n        }\n\n        newOwners[newOwners.length - 1] = owner;\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n        _changeStatus(Status.WaitingDeposits);\n        emit ConfirmParties();\n    }\n\n    /**\n     * @dev Confirm swap.\n     */\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\n        emit ConfirmSwap();\n        _changeStatus(Status.SwapConfirmed);\n        _startLockup();\n    }\n\n    /**\n     * @dev Cancel swap.\n     */\n    function cancelSwap() external canCancelSwap onlyManyOwners {\n        emit CancelSwap();\n        _changeStatus(Status.SwapCanceled);\n    }\n\n    /**\n     * @dev Withdraw tokens\n     */\n    function withdraw() external onlyReceiver canWithdraw {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            if (offer.participant == msg.sender) {\n                continue;\n            }\n\n            uint256 tokensAmount = _withdrawableAmount(offer.token, msg.sender);\n\n            if (tokensAmount > 0) {\n                withdrawnTokens[offer.token][msg.sender] =\n                    withdrawnTokens[offer.token][msg.sender].add(tokensAmount);\n                offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n                offer.token.safeTransfer(msg.sender, tokensAmount);\n                emit Withdraw(msg.sender, offer.token, tokensAmount);\n            }\n        }\n    }\n\n    /**\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n     */\n    function reclaim() external onlyParticipant canReclaim {\n        address token = tokenByParticipant[msg.sender];\n\n        SwapOffer storage offer = offerByToken[token];\n        uint256 currentBalance = offer.token.balanceOf(address(this));\n        uint256 availableForReclaim = currentBalance;\n\n        if (status != Status.SwapCanceled) {\n            uint256 lockedTokens = offer.tokensTotal.sub(offer.withdrawnTokensTotal);\n            availableForReclaim = currentBalance.sub(lockedTokens);\n        }\n\n        if (availableForReclaim > 0) {\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\n        }\n\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n    }\n\n    /**\n     * @dev Transfer tokens back to owners.\n     */\n    function softEmergency() external onlyOwner {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n            uint256 tokensAmount = offer.token.balanceOf(address(this));\n\n            require(offer.withdrawnTokensTotal == 0, \"Unavailable after the first withdrawal.\");\n\n            if (tokensAmount > 0) {\n                offer.token.safeTransfer(offer.participant, tokensAmount);\n                emit SoftEmergency(offer.token, offer.participant, tokensAmount);\n            }\n        }\n    }\n\n    /**\n     * @dev A way out if nothing else is working.\n     */\n    function hardEmergency(\n        ERC20[] _tokens,\n        address[] _receivers,\n        uint256[] _values\n    )\n        external\n        onlyAllOwners\n    {\n        require(_tokens.length == _receivers.length, \"Invalid lengths.\");\n        require(_receivers.length == _values.length, \"Invalid lengths.\");\n\n        for (uint256 i = 0; i < _tokens.length; i++) {\n            _tokens[i].safeTransfer(_receivers[i], _values[i]);\n            emit HardEmergency(_tokens[i], _receivers[i], _values[i]);\n        }\n    }\n\n    // PUBLIC METHODS\n    /**\n     * @dev Standard ERC223 function that will handle incoming token transfers.\n     *\n     * @param _from  Token sender address.\n     * @param _value Amount of tokens.\n     * @param _data  Transaction metadata.\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n\n    }\n\n    /**\n     * @dev Transfer ownership.\n     * @param _newOwner Address of the new owner.\n     */\n    function transferOwnership(address _newOwner) public onlyOwner canTransferOwnership {\n        require(_newOwner != address(0), \"_newOwner is invalid address\");\n        require(owners.length == 1, \"Unable to transfer ownership in presence of multiowners\");\n        require(owners[0] == owner, \"Unexpected multiowners state\");\n\n        address[] memory newOwners = new address[](1);\n        newOwners[0] = _newOwner;\n\n        Ownable.transferOwnership(_newOwner);\n        Multiownable.transferOwnership(newOwners);\n    }\n\n    // INTERNAL METHODS\n    /**\n     * @dev Validate lock-up period configuration.\n     */\n    function _validateLockupStages(ERC20 _token) internal view {\n        LockupStage[] storage lockupStages = lockupStagesByToken[_token];\n\n        for (uint i = 0; i < lockupStages.length; i++) {\n            LockupStage memory stage = lockupStages[i];\n\n            require(\n                stage.unlockedTokensPercentage >= 0,\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\n            );\n            require(\n                stage.unlockedTokensPercentage <= 100,\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\n            );\n\n            if (i == 0) {\n                continue;\n            }\n\n            LockupStage memory previousStage = lockupStages[i - 1];\n            require(\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\n            );\n            require(\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\n            );\n        }\n\n        require(\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n            \"The last lockup stage must unlock 100% of tokens\"\n        );\n    }\n\n    /**\n     * @dev Change swap status.\n     */\n    function _changeStatus(Status _newStatus) internal {\n        emit StatusUpdate(status, _newStatus);\n        status = _newStatus;\n    }\n\n    /**\n     * @dev Check if every token has lockup period.\n     */\n    function _doesEveryTokenHaveLockupPeriod() internal view returns(bool) {\n        for (uint256 i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n\n            if (lockupStagesByToken[token].length == 0) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Check if every token has been fully allocated.\n     */\n    function _isEveryTokenFullyAllocated() internal view returns(bool) {\n        for (uint256 i = 0; i < participants.length; i++) {\n            if (!isTokenAllocated[tokenByParticipant[participants[i]]]) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /**\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n     */\n    function _haveEveryoneDeposited() internal view returns(bool) {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer memory offer = offerByToken[token];\n\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Start lockup period\n     */\n    function _startLockup() internal {\n        startLockupAt = now;\n        emit StartLockup(startLockupAt);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn.\n     */\n    function _withdrawableAmount(\n        ERC20 _token,\n        address _receiver\n    )\n        internal\n        view\n        returns(uint256)\n    {\n        uint256 allocated = allocatedTokens[_token][_receiver];\n        uint256 withdrawn = withdrawnTokens[_token][_receiver];\n        uint256 unlockedPercentage = _getUnlockedTokensPercentage(_token);\n        uint256 unlockedAmount = allocated.mul(unlockedPercentage).div(100);\n\n        return unlockedAmount.sub(withdrawn);\n    }\n\n    /**\n     * @dev Get percent of unlocked tokens\n     */\n    function _getUnlockedTokensPercentage(ERC20 _token) internal view returns(uint256) {\n        for (uint256 i = lockupStagesByToken[_token].length; i > 0; i--) {\n            LockupStage storage stage = lockupStagesByToken[_token][i - 1];\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n\n            if (now < stageBecomesActiveAt) {\n                continue;\n            }\n\n            return stage.unlockedTokensPercentage;\n        }\n    }\n}",
        "debug": "storage_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_2: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0x7b8c8be070b288533486963d87d3d5195e3b62f0.sol",
        "function": "transferOwnership(address[])",
        "lineno": 466,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}