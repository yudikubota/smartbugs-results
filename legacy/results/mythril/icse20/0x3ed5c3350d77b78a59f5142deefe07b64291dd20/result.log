{"error": null, "issues": [{"address": 709, "code": "256 tokens, address token, bytes data) public{\n      require(msg.sender==vrfAddress);\n      vrfcontract.transferFrom(from,this,tokens);\n      _placeBet(tokens,from,data);\n  }\n  function placeBetEth(bytes victoryMessage) p", "debug": "calldata_VerifyToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_VerifyToken_0: 0x8f4ffcb100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `receiveApproval(address,uint256,address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 44, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1377, "code": " }\n  /*\n    require", "debug": "block_number: 0x1fffffffffffffffffffe\nstorage_0 + keccac_storage_3_+_1: 0xffffffffffffffffffffffffffffffffffffe0020001ffffffffffffffffff02\nstorage_4: 0x0\nstorage_3: 0x1\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VerifyToken_0: 0x7b6d79f100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `cancelBet()`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 110, "title": "Integer Underflow", "type": "Warning"}, {"address": 1510, "code": "one\n  */", "debug": "block_number: 0x3fffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 + keccac_storage_3_+_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\nstorage_1 + keccac_storage_3: 0x0\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VerifyToken_0: 0x7b6d79f100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cancelBet()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 112, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2051, "code": "     _placeBet(tokens,from,data);\n  }\n  fu", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 47, "title": "Message call to external contract", "type": "Informational"}, {"address": 2051, "code": "     _placeBet(tokens,from,data);\n  }\n  fu", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6681\n", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 47, "title": "Multiple Calls", "type": "Information"}, {"address": 2415, "code": "buyTokens.value(msg.value)(", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "placeBetEth(bytes)", "lineno": 52, "title": "Message call to external contract", "type": "Informational"}, {"address": 2415, "code": "buyTokens.value(msg.value)(", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2831\nCall at address: 2610\n", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "placeBetEth(bytes)", "lineno": 52, "title": "Multiple Calls", "type": "Information"}, {"address": 2610, "code": "_placeBet(vrfcontract.balanceOf(this).sub(tok", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "placeBetEth(bytes)", "lineno": 53, "title": "Message call to external contract", "type": "Informational"}, {"address": 2610, "code": "_placeBet(vrfcontract.balanceOf(this).sub(tok", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2831\n", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "placeBetEth(bytes)", "lineno": 53, "title": "Multiple Calls", "type": "Information"}, {"address": 2831, "code": "nder,victoryMessage);\n  }\n ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "placeBetEth(bytes)", "lineno": 53, "title": "Message call to external contract", "type": "Informational"}, {"address": 2936, "code": "returns(bool){\n    ", "debug": "storage_4: 0x1\nstorage_3: 0x2\ncalldata_VerifyToken_0: 0xb90f65a200000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `canCancelBet()`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "canCancelBet()", "lineno": 117, "title": "Integer Underflow", "type": "Warning"}, {"address": 3175, "code": "d\n          if(block.number>betQu", "debug": "storage_0 + keccac_storage_3_+_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VerifyToken_0: 0xcb7129a300000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `resolvePriorBets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "resolvePriorBets()", "lineno": 68, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3270, "code": "ndval= random(totalbet,betQueue[index+1].blockPlaced,", "debug": "block_number: 0x8000000000000000000000000000000000000000000000000000000018\nstorage_2 + keccac_storage_3: 0x9e856d74a352cff2db7717f5eef58bbebcf6e5240e1cc27ef7db7fdb970e5ad2\nstorage_2 + keccac_storage_3_+_1: 0xd08535988e520f00de405c0590c1c94022f689d16d95a674c6d3fd1007c494d1\nstorage_0 + keccac_storage_3_+_1: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffff64\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VerifyToken_0: 0x7b6d79f100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cancelBet()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 76, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5610, "code": "[index+1", "debug": "storage_3: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_0 + keccac_storage_3_+_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff06\nreturndatasize: 0x20\nretval_6681: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0x0\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VerifyToken_0: 0x7b6d79f100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cancelBet()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 97, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5616, "code": "[index+1", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 97, "title": "State change after external call", "type": "Warning"}, {"address": 6229, "code": ":from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMes", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 61, "title": "State change after external call", "type": "Warning"}, {"address": 6299, "code": ":from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMes", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 61, "title": "State change after external call", "type": "Warning"}, {"address": 6310, "code": ":from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMes", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 61, "title": "State change after external call", "type": "Warning"}, {"address": 6323, "code": " }\n  function re", "debug": "block_number: 0x3fffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 + keccac_storage_3_+_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_2051: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncaller: 0x0\ncalldata_VerifyToken_0: 0x8f4ffcb100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `receiveApproval(address,uint256,address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 64, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6329, "code": " }\n  function re", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 64, "title": "State change after external call", "type": "Warning"}, {"address": 6469, "code": "ublic view returns(uint){\n    for(", "debug": "The exception is triggered under the following conditions:\n\nblock_number: 0x1fffffffffffffffffffffffffff\nstorage_0 + keccac_storage_3_+_1: 0x1fffffffffffffffffffffffff80\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VerifyToken_0: 0x7b6d79f100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\nstorage_2 + keccac_storage_3_+_1: 0x0\nstorage_2 + keccac_storage_3: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 139, "title": "Exception state", "type": "Informational"}, {"address": 6681, "code": "numTokens);\n  }\n  function _placeB", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "resolvePriorBets()", "lineno": 57, "title": "Message call to external contract", "type": "Informational"}, {"address": 6681, "code": "numTokens);\n  }\n  function _placeB", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6681\n", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "cancelBet()", "lineno": 57, "title": "Multiple Calls", "type": "Information"}, {"address": 7079, "code": "oveAndCallFallBack{\n  using SafeMath for uint;\n  struct Bet{\n    uint blockPlaced;\n    address bettor;\n    uint betAmount;\n  }\n  mapping(address => bytes) public victoryMessages;\n  mapping(uint => Bet) public betQueue;\n  uint public MAX_SIMULTANEOUS_BETS=20;\n  uint public index=0;//index for processing bets\n  uint public indexBetPlace=0;//index for placing bets\n  address vrfAddress= 0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;//0xe0832c4f024D2427bBC6BD0C4931096d2ab5CCaF; //0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;\n  VerifyToken vrfcontract=VerifyToken(vrfAddress);\n  AutomatedExchange exchangecontract=AutomatedExchange(0x48bF5e13A1ee8Bd4385C182904B3ABf73E042675);\n\n  event Payout(address indexed to, uint tokens);\n  event BetFinalized(address indexed bettor,uint tokensWagered,uint tokensAgainst,uint tokensWon,bytes victoryMessage);\n\n  //Send tokens with ApproveAndCallFallBack, place a bet\n  function receiveApproval(address from, uint256 tokens, address token, bytes data) public{\n      require(msg.sender==vrfAddress);\n      vrfcontract.transferFrom(from,this,tokens);\n      _placeBet(tokens,from,data);\n  }\n  function placeBetEth(bytes victoryMessage) public payable{\n    require(indexBetPlace-index<MAX_SIMULTANEOUS_BETS);//ensures you don't get a situation where there are too many existing bets to process, locking VRF in the contract\n    uint tokensBefore=vrfcontract.balanceOf(this);\n    exchangecontract.buyTokens.value(msg.value)();\n    _placeBet(vrfcontract.balanceOf(this).sub(tokensBefore),msg.sender,victoryMessage);\n  }\n  function payout(address to,uint numTokens) private{\n    vrfcontract.transfer(to,numTokens);\n    emit Payout(to,numTokens);\n  }\n  function _placeBet(uint numTokens,address from,bytes victoryMessage) private{\n    resolvePriorBets();\n    betQueue[indexBetPlace]=Bet({blockPlaced:block.number,bettor:from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMessage;\n  }\n  function resolvePriorBets() public{\n    while(betQueue[index].blockPlaced!=0){\n      if(betQueue[index+1].blockPlaced!=0){\n        if(betQueue[index+1].blockPlaced+250>block.number){//bet is not expired\n          if(block.number>betQueue[index+1].blockPlaced){//bet was in the past, future blockhash can be safely used to compute random\n\n          /*\n            Bet is between two players.\n            Outcome is computed as whether rand(bet1+bet2)<bet1. This makes the probability of winning proportional to the size of your bet, ensuring all bets are EV neutral.\n          */\n            uint totalbet=betQueue[index].betAmount+betQueue[index+1].betAmount;\n            uint randval= random(totalbet,betQueue[index+1].blockPlaced,betQueue[index+1].bettor);\n            if(randval < betQueue[index].betAmount){\n              payout(betQueue[index].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,0,victoryMessages[betQueue[index].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,totalbet,victoryMessages[betQueue[index].bettor]);\n            }\n            else{\n              payout(betQueue[index+1].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,totalbet,victoryMessages[betQueue[index+1].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,0,victoryMessages[betQueue[index+1].bettor]);\n            }\n            index+=2;\n          }\n          else{ //bet is in the current block, cannot be resolved, no point in continuing the loop\n            return;\n          }\n        }\n        else{//bet has expired, return tokens to users\n          payout(betQueue[index+1].bettor,betQueue[index+1].betAmount);\n          payout(betQueue[index].bettor,betQueue[index].betAmount);\n          index+=2;\n          emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,betQueue[index].betAmount,\"\");\n          emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,betQueue[index+1].betAmount,\"\");\n        }\n      }\n      else{ //single bet with no other to pair it to, must wait for another bet\n        return;\n      }\n    }\n  }\n  function cancelBet() public{\n    resolvePriorBets();\n    require(indexBetPlace-index==1 && betQueue[index].bettor==msg.sender);\n    index+=1;//skip the last remaining bet\n  }\n  /*\n    requires an odd number of bets and your bet is the last one\n  */\n  function canCancelBet() public view returns(bool){\n    return indexBetPlace>0 && !isEven(indexBetPlace-index) && betQueue[indexBetPlace-1].bettor==msg.sender;\n  }\n  function isEven(uint num) public view returns(bool){\n    return 2*(num/2)==num;\n  }\n  function maxRandom(uint blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return uint256(keccak256(\n          abi.encodePacked(\n            blockhash(blockn),\n            entropy)\n      ));\n  }\n  function random(uint256 upper, uint256 blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return maxRandom(blockn, entropy) % upper + 1;\n  }\n  /*\n    only for frontend viewing purposes\n  */\n  function getBetState(address bettor) public view returns(uint){\n    for(uint i=index;i<indexBetPlace;i++){\n      if(betQueue[i].bettor==bettor){\n        if(!isEven(indexBetPlace-index)){//i<indexBetPlace-1){\n          return 1;\n        }\n        else{\n          return 2;\n        }\n      }\n    }\n    return 0;\n  }\n}\n// ----------------------------------------------------------------------------\n// Safe maths\n// -----------------------------------------------------", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VerifyToken_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VerifyToken_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nreturndatasize: 0x20\nretval_2051: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncaller: 0x0\ncalldata_VerifyToken_0: 0x8f4ffcb100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\nstorage_0 + keccac_storage_3: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `receiveApproval(address,uint256,address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 24, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7108, "code": "oveAndCallFallBack{\n  using SafeMath for uint;\n  struct Bet{\n    uint blockPlaced;\n    address bettor;\n    uint betAmount;\n  }\n  mapping(address => bytes) public victoryMessages;\n  mapping(uint => Bet) public betQueue;\n  uint public MAX_SIMULTANEOUS_BETS=20;\n  uint public index=0;//index for processing bets\n  uint public indexBetPlace=0;//index for placing bets\n  address vrfAddress= 0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;//0xe0832c4f024D2427bBC6BD0C4931096d2ab5CCaF; //0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;\n  VerifyToken vrfcontract=VerifyToken(vrfAddress);\n  AutomatedExchange exchangecontract=AutomatedExchange(0x48bF5e13A1ee8Bd4385C182904B3ABf73E042675);\n\n  event Payout(address indexed to, uint tokens);\n  event BetFinalized(address indexed bettor,uint tokensWagered,uint tokensAgainst,uint tokensWon,bytes victoryMessage);\n\n  //Send tokens with ApproveAndCallFallBack, place a bet\n  function receiveApproval(address from, uint256 tokens, address token, bytes data) public{\n      require(msg.sender==vrfAddress);\n      vrfcontract.transferFrom(from,this,tokens);\n      _placeBet(tokens,from,data);\n  }\n  function placeBetEth(bytes victoryMessage) public payable{\n    require(indexBetPlace-index<MAX_SIMULTANEOUS_BETS);//ensures you don't get a situation where there are too many existing bets to process, locking VRF in the contract\n    uint tokensBefore=vrfcontract.balanceOf(this);\n    exchangecontract.buyTokens.value(msg.value)();\n    _placeBet(vrfcontract.balanceOf(this).sub(tokensBefore),msg.sender,victoryMessage);\n  }\n  function payout(address to,uint numTokens) private{\n    vrfcontract.transfer(to,numTokens);\n    emit Payout(to,numTokens);\n  }\n  function _placeBet(uint numTokens,address from,bytes victoryMessage) private{\n    resolvePriorBets();\n    betQueue[indexBetPlace]=Bet({blockPlaced:block.number,bettor:from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMessage;\n  }\n  function resolvePriorBets() public{\n    while(betQueue[index].blockPlaced!=0){\n      if(betQueue[index+1].blockPlaced!=0){\n        if(betQueue[index+1].blockPlaced+250>block.number){//bet is not expired\n          if(block.number>betQueue[index+1].blockPlaced){//bet was in the past, future blockhash can be safely used to compute random\n\n          /*\n            Bet is between two players.\n            Outcome is computed as whether rand(bet1+bet2)<bet1. This makes the probability of winning proportional to the size of your bet, ensuring all bets are EV neutral.\n          */\n            uint totalbet=betQueue[index].betAmount+betQueue[index+1].betAmount;\n            uint randval= random(totalbet,betQueue[index+1].blockPlaced,betQueue[index+1].bettor);\n            if(randval < betQueue[index].betAmount){\n              payout(betQueue[index].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,0,victoryMessages[betQueue[index].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,totalbet,victoryMessages[betQueue[index].bettor]);\n            }\n            else{\n              payout(betQueue[index+1].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,totalbet,victoryMessages[betQueue[index+1].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,0,victoryMessages[betQueue[index+1].bettor]);\n            }\n            index+=2;\n          }\n          else{ //bet is in the current block, cannot be resolved, no point in continuing the loop\n            return;\n          }\n        }\n        else{//bet has expired, return tokens to users\n          payout(betQueue[index+1].bettor,betQueue[index+1].betAmount);\n          payout(betQueue[index].bettor,betQueue[index].betAmount);\n          index+=2;\n          emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,betQueue[index].betAmount,\"\");\n          emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,betQueue[index+1].betAmount,\"\");\n        }\n      }\n      else{ //single bet with no other to pair it to, must wait for another bet\n        return;\n      }\n    }\n  }\n  function cancelBet() public{\n    resolvePriorBets();\n    require(indexBetPlace-index==1 && betQueue[index].bettor==msg.sender);\n    index+=1;//skip the last remaining bet\n  }\n  /*\n    requires an odd number of bets and your bet is the last one\n  */\n  function canCancelBet() public view returns(bool){\n    return indexBetPlace>0 && !isEven(indexBetPlace-index) && betQueue[indexBetPlace-1].bettor==msg.sender;\n  }\n  function isEven(uint num) public view returns(bool){\n    return 2*(num/2)==num;\n  }\n  function maxRandom(uint blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return uint256(keccak256(\n          abi.encodePacked(\n            blockhash(blockn),\n            entropy)\n      ));\n  }\n  function random(uint256 upper, uint256 blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return maxRandom(blockn, entropy) % upper + 1;\n  }\n  /*\n    only for frontend viewing purposes\n  */\n  function getBetState(address bettor) public view returns(uint){\n    for(uint i=index;i<indexBetPlace;i++){\n      if(betQueue[i].bettor==bettor){\n        if(!isEven(indexBetPlace-index)){//i<indexBetPlace-1){\n          return 1;\n        }\n        else{\n          return 2;\n        }\n      }\n    }\n    return 0;\n  }\n}\n// ----------------------------------------------------------------------------\n// Safe maths\n// -----------------------------------------------------", "debug": "calldata_VerifyToken_4 + calldata_VerifyToken_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0 + keccac_storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_2051: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncaller: 0x0\ncalldata_VerifyToken_0: 0x8f4ffcb100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\nstorage_0 + keccac_storage_3_+_1: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `receiveApproval(address,uint256,address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 24, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7113, "code": "oveAndCallFallBack{\n  using SafeMath for uint;\n  struct Bet{\n    uint blockPlaced;\n    address bettor;\n    uint betAmount;\n  }\n  mapping(address => bytes) public victoryMessages;\n  mapping(uint => Bet) public betQueue;\n  uint public MAX_SIMULTANEOUS_BETS=20;\n  uint public index=0;//index for processing bets\n  uint public indexBetPlace=0;//index for placing bets\n  address vrfAddress= 0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;//0xe0832c4f024D2427bBC6BD0C4931096d2ab5CCaF; //0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;\n  VerifyToken vrfcontract=VerifyToken(vrfAddress);\n  AutomatedExchange exchangecontract=AutomatedExchange(0x48bF5e13A1ee8Bd4385C182904B3ABf73E042675);\n\n  event Payout(address indexed to, uint tokens);\n  event BetFinalized(address indexed bettor,uint tokensWagered,uint tokensAgainst,uint tokensWon,bytes victoryMessage);\n\n  //Send tokens with ApproveAndCallFallBack, place a bet\n  function receiveApproval(address from, uint256 tokens, address token, bytes data) public{\n      require(msg.sender==vrfAddress);\n      vrfcontract.transferFrom(from,this,tokens);\n      _placeBet(tokens,from,data);\n  }\n  function placeBetEth(bytes victoryMessage) public payable{\n    require(indexBetPlace-index<MAX_SIMULTANEOUS_BETS);//ensures you don't get a situation where there are too many existing bets to process, locking VRF in the contract\n    uint tokensBefore=vrfcontract.balanceOf(this);\n    exchangecontract.buyTokens.value(msg.value)();\n    _placeBet(vrfcontract.balanceOf(this).sub(tokensBefore),msg.sender,victoryMessage);\n  }\n  function payout(address to,uint numTokens) private{\n    vrfcontract.transfer(to,numTokens);\n    emit Payout(to,numTokens);\n  }\n  function _placeBet(uint numTokens,address from,bytes victoryMessage) private{\n    resolvePriorBets();\n    betQueue[indexBetPlace]=Bet({blockPlaced:block.number,bettor:from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMessage;\n  }\n  function resolvePriorBets() public{\n    while(betQueue[index].blockPlaced!=0){\n      if(betQueue[index+1].blockPlaced!=0){\n        if(betQueue[index+1].blockPlaced+250>block.number){//bet is not expired\n          if(block.number>betQueue[index+1].blockPlaced){//bet was in the past, future blockhash can be safely used to compute random\n\n          /*\n            Bet is between two players.\n            Outcome is computed as whether rand(bet1+bet2)<bet1. This makes the probability of winning proportional to the size of your bet, ensuring all bets are EV neutral.\n          */\n            uint totalbet=betQueue[index].betAmount+betQueue[index+1].betAmount;\n            uint randval= random(totalbet,betQueue[index+1].blockPlaced,betQueue[index+1].bettor);\n            if(randval < betQueue[index].betAmount){\n              payout(betQueue[index].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,0,victoryMessages[betQueue[index].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,totalbet,victoryMessages[betQueue[index].bettor]);\n            }\n            else{\n              payout(betQueue[index+1].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,totalbet,victoryMessages[betQueue[index+1].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,0,victoryMessages[betQueue[index+1].bettor]);\n            }\n            index+=2;\n          }\n          else{ //bet is in the current block, cannot be resolved, no point in continuing the loop\n            return;\n          }\n        }\n        else{//bet has expired, return tokens to users\n          payout(betQueue[index+1].bettor,betQueue[index+1].betAmount);\n          payout(betQueue[index].bettor,betQueue[index].betAmount);\n          index+=2;\n          emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,betQueue[index].betAmount,\"\");\n          emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,betQueue[index+1].betAmount,\"\");\n        }\n      }\n      else{ //single bet with no other to pair it to, must wait for another bet\n        return;\n      }\n    }\n  }\n  function cancelBet() public{\n    resolvePriorBets();\n    require(indexBetPlace-index==1 && betQueue[index].bettor==msg.sender);\n    index+=1;//skip the last remaining bet\n  }\n  /*\n    requires an odd number of bets and your bet is the last one\n  */\n  function canCancelBet() public view returns(bool){\n    return indexBetPlace>0 && !isEven(indexBetPlace-index) && betQueue[indexBetPlace-1].bettor==msg.sender;\n  }\n  function isEven(uint num) public view returns(bool){\n    return 2*(num/2)==num;\n  }\n  function maxRandom(uint blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return uint256(keccak256(\n          abi.encodePacked(\n            blockhash(blockn),\n            entropy)\n      ));\n  }\n  function random(uint256 upper, uint256 blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return maxRandom(blockn, entropy) % upper + 1;\n  }\n  /*\n    only for frontend viewing purposes\n  */\n  function getBetState(address bettor) public view returns(uint){\n    for(uint i=index;i<indexBetPlace;i++){\n      if(betQueue[i].bettor==bettor){\n        if(!isEven(indexBetPlace-index)){//i<indexBetPlace-1){\n          return 1;\n        }\n        else{\n          return 2;\n        }\n      }\n    }\n    return 0;\n  }\n}\n// ----------------------------------------------------------------------------\n// Safe maths\n// -----------------------------------------------------", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 24, "title": "State change after external call", "type": "Warning"}, {"address": 7122, "code": "oveAndCallFallBack{\n  using SafeMath for uint;\n  struct Bet{\n    uint blockPlaced;\n    address bettor;\n    uint betAmount;\n  }\n  mapping(address => bytes) public victoryMessages;\n  mapping(uint => Bet) public betQueue;\n  uint public MAX_SIMULTANEOUS_BETS=20;\n  uint public index=0;//index for processing bets\n  uint public indexBetPlace=0;//index for placing bets\n  address vrfAddress= 0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;//0xe0832c4f024D2427bBC6BD0C4931096d2ab5CCaF; //0x5BD574410F3A2dA202bABBa1609330Db02aD64C2;\n  VerifyToken vrfcontract=VerifyToken(vrfAddress);\n  AutomatedExchange exchangecontract=AutomatedExchange(0x48bF5e13A1ee8Bd4385C182904B3ABf73E042675);\n\n  event Payout(address indexed to, uint tokens);\n  event BetFinalized(address indexed bettor,uint tokensWagered,uint tokensAgainst,uint tokensWon,bytes victoryMessage);\n\n  //Send tokens with ApproveAndCallFallBack, place a bet\n  function receiveApproval(address from, uint256 tokens, address token, bytes data) public{\n      require(msg.sender==vrfAddress);\n      vrfcontract.transferFrom(from,this,tokens);\n      _placeBet(tokens,from,data);\n  }\n  function placeBetEth(bytes victoryMessage) public payable{\n    require(indexBetPlace-index<MAX_SIMULTANEOUS_BETS);//ensures you don't get a situation where there are too many existing bets to process, locking VRF in the contract\n    uint tokensBefore=vrfcontract.balanceOf(this);\n    exchangecontract.buyTokens.value(msg.value)();\n    _placeBet(vrfcontract.balanceOf(this).sub(tokensBefore),msg.sender,victoryMessage);\n  }\n  function payout(address to,uint numTokens) private{\n    vrfcontract.transfer(to,numTokens);\n    emit Payout(to,numTokens);\n  }\n  function _placeBet(uint numTokens,address from,bytes victoryMessage) private{\n    resolvePriorBets();\n    betQueue[indexBetPlace]=Bet({blockPlaced:block.number,bettor:from,betAmount:numTokens});\n    indexBetPlace+=1;\n    victoryMessages[from]=victoryMessage;\n  }\n  function resolvePriorBets() public{\n    while(betQueue[index].blockPlaced!=0){\n      if(betQueue[index+1].blockPlaced!=0){\n        if(betQueue[index+1].blockPlaced+250>block.number){//bet is not expired\n          if(block.number>betQueue[index+1].blockPlaced){//bet was in the past, future blockhash can be safely used to compute random\n\n          /*\n            Bet is between two players.\n            Outcome is computed as whether rand(bet1+bet2)<bet1. This makes the probability of winning proportional to the size of your bet, ensuring all bets are EV neutral.\n          */\n            uint totalbet=betQueue[index].betAmount+betQueue[index+1].betAmount;\n            uint randval= random(totalbet,betQueue[index+1].blockPlaced,betQueue[index+1].bettor);\n            if(randval < betQueue[index].betAmount){\n              payout(betQueue[index].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,0,victoryMessages[betQueue[index].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,totalbet,victoryMessages[betQueue[index].bettor]);\n            }\n            else{\n              payout(betQueue[index+1].bettor,totalbet);\n              emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,totalbet,victoryMessages[betQueue[index+1].bettor]);\n              emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,0,victoryMessages[betQueue[index+1].bettor]);\n            }\n            index+=2;\n          }\n          else{ //bet is in the current block, cannot be resolved, no point in continuing the loop\n            return;\n          }\n        }\n        else{//bet has expired, return tokens to users\n          payout(betQueue[index+1].bettor,betQueue[index+1].betAmount);\n          payout(betQueue[index].bettor,betQueue[index].betAmount);\n          index+=2;\n          emit BetFinalized(betQueue[index].bettor,betQueue[index].betAmount,betQueue[index+1].betAmount,betQueue[index].betAmount,\"\");\n          emit BetFinalized(betQueue[index+1].bettor,betQueue[index+1].betAmount,betQueue[index].betAmount,betQueue[index+1].betAmount,\"\");\n        }\n      }\n      else{ //single bet with no other to pair it to, must wait for another bet\n        return;\n      }\n    }\n  }\n  function cancelBet() public{\n    resolvePriorBets();\n    require(indexBetPlace-index==1 && betQueue[index].bettor==msg.sender);\n    index+=1;//skip the last remaining bet\n  }\n  /*\n    requires an odd number of bets and your bet is the last one\n  */\n  function canCancelBet() public view returns(bool){\n    return indexBetPlace>0 && !isEven(indexBetPlace-index) && betQueue[indexBetPlace-1].bettor==msg.sender;\n  }\n  function isEven(uint num) public view returns(bool){\n    return 2*(num/2)==num;\n  }\n  function maxRandom(uint blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return uint256(keccak256(\n          abi.encodePacked(\n            blockhash(blockn),\n            entropy)\n      ));\n  }\n  function random(uint256 upper, uint256 blockn, address entropy)\n    internal\n    returns (uint256 randomNumber)\n  {\n      return maxRandom(blockn, entropy) % upper + 1;\n  }\n  /*\n    only for frontend viewing purposes\n  */\n  function getBetState(address bettor) public view returns(uint){\n    for(uint i=index;i<indexBetPlace;i++){\n      if(betQueue[i].bettor==bettor){\n        if(!isEven(indexBetPlace-index)){//i<indexBetPlace-1){\n          return 1;\n        }\n        else{\n          return 2;\n        }\n      }\n    }\n    return 0;\n  }\n}\n// ----------------------------------------------------------------------------\n// Safe maths\n// -----------------------------------------------------", "debug": "calldata_VerifyToken_4 + calldata_VerifyToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nreturndatasize: 0x20\nretval_2051: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncaller: 0x0\ncalldata_VerifyToken_0: 0x8f4ffcb100000000000000000000000000000000000000000000000000000000\ncalldatasize_VerifyToken: 0x4\nstorage_0 + keccac_storage_3: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `receiveApproval(address,uint256,address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0x3ed5c3350d77b78a59f5142deefe07b64291dd20.sol", "function": "receiveApproval(address,uint256,address,bytes)", "lineno": 24, "title": "Integer Overflow ", "type": "Warning"}], "success": true}