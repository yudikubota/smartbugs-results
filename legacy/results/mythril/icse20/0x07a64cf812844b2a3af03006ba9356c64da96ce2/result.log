{"error": null, "issues": [{"address": 3952, "code": "\n/**\n * @title Saf", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_32_+_4: 0xfe1ca6d89f8e3a03002f24a31bbeb3ba0ce2ffffffffffffffffffffffffffff\ncalldatasize_eGoldchain: 0x68\ncalldata_eGoldchain_32 + 36: 0x1e359276071c5fcffd0db5ce4414c45f31d0000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1e359276071c5fcffd0db5ce4414c45f31d0000000000000000000000000000\ncalldata_eGoldchain_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_eGoldchain_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_4: 0x1e359276071c5fcffd0db5ce4414c45f31d0000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/39/0x07a64cf812844b2a3af03006ba9356c64da96ce2.sol", "function": "transferFrom(address,address,uint256)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7564, "code": "    return a -", "debug": "The exception is triggered under the following conditions:\n\nblock_number: 0x0\nstorage_9: 0x1\ncalldata_eGoldchain_0: 0x42cbb15c00000000000000000000000000000000000000000000000000000000\ncalldatasize_eGoldchain: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/39/0x07a64cf812844b2a3af03006ba9356c64da96ce2.sol", "function": "getBlockNumber()", "lineno": 22, "title": "Exception state", "type": "Informational"}, {"address": 7582, "code": "= a);", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_32_+_4: 0xa7bca7eb20733138dd8e253a403ad95ba5fd3ed930537821235d8892dbe20edf\ncalldatasize_eGoldchain: 0x80000000000000070\ncalldata_eGoldchain_32 + 36: 0x760282803f43b13b1e09a8030ec4945910dd3ad6a112406594a1ceb6931a88df\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_4: 0x760282803f43b13b1e09a8030ec4945910dd3ad6a112406594a1ceb6931a88df\ncalldata_eGoldchain_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_eGoldchain_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/39/0x07a64cf812844b2a3af03006ba9356c64da96ce2.sol", "function": "transferFrom(address,address,uint256)", "lineno": 27, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7595, "code": "turn c;\n    }\n", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_32_+_4: 0xd000000000000c0000004020000000001b06000097fffed0c905fe3fdfffb57c\ncalldatasize_eGoldchain: 0x10000000000000000000000000000000000000000064\ncalldata_eGoldchain_32 + 36: 0x800000000000bffffffebfbffffffeffe07dffa5508000a0e3f0000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_4: 0x800000000000bffffffebfbffffffeffe07dffa5508000a0e3f0000000000000\ncalldata_eGoldchain_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_eGoldchain_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/39/0x07a64cf812844b2a3af03006ba9356c64da96ce2.sol", "function": "transferFrom(address,address,uint256)", "lineno": 28, "title": "Exception state", "type": "Informational"}, {"address": 8697, "code": "- Changed name of contract\n    string public name = \"eGoldchain\";\n    string public symbol = \"EGC\";\n    uint public decimals = 18;\n\n    uint public chainStartTime; //chain start time\n    uint public chainStartBlockNumber; //chain start block number\n    uint public stakeStartTime; //stake start time\n    uint public stakeMinAge = 3 days; // minimum age for coin age: 3D\n    uint public stakeMaxAge = 90 days; // stake age of full weight: 90D\n    uint public maxMintProofOfStake = 10**17; // default 10% annual interest\n\n    uint public totalSupply;\n    uint public maxTotalSupply;\n    uint public totalInitialSupply;\n\n    struct transferInStruct{\n    uint128 amount;\n    uint64 time;\n    }\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping (address => uint256)) allowed;\n    mapping(address => transferInStruct[]) transferIns;\n\n//eGoldchain - Removed burn system\n    //event Burn(address indexed burner, uint256 value);\n\n    /**\n     * @dev Fix for the ERC20 short address attack.\n     */\n    modifier onlyPayloadSize(uint size) {\n        require(msg.data.length >= size + 4);\n        _;\n    }\n\n    modifier canPoSMint() {\n        require(totalSupply < maxTotalSupply);\n        _;\n    }\n\n    function eGoldchainStart() onlyOwner {\n        address recipient;\n        uint value;\n        uint64 _now = uint64(now);\n        //kill start if this has already been ran\n        require((maxTotalSupply <= 0));\n\n        maxTotalSupply = 30000000000000000000000000; // 30 Mil.\n        \n        //eGoldchain - Modified initial supply to 15mil\n        totalInitialSupply = 15*(10**23); // 15mil\n\n        chainStartTime = now;\n        chainStartBlockNumber = block.number;\n\n        totalSupply = totalInitialSupply;\n    }\n\n    function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) {\n        //eGoldchain - Modified to mine\n        if(msg.sender == _to) return mine();\n        balances[msg.sender] = balances[msg.sender].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        Transfer(msg.sender, _to, _value);\n        if(transferIns[msg.sender].length > 0) delete transferIns[msg.sender];\n        uint64 _now = uint64(now);\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),_now));\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\n        return true;\n    }\n\n    function balanceOf(address _owner) constant returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) returns (bool) {\n        require(_to != address(0));\n\n        var _allowance = allowed[_from][msg.sender];\n\n        // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met\n        // require (_value <= _allowance);\n\n        balances[_from] = balances[_from].sub(_value);\n        balances[_to] = balances[_to].add(_value);\n        allowed[_from][msg.sender] = _allowance.sub(_value);\n        Transfer(_from, _to, _value);\n        if(transferIns[_from].length > 0) delete transferIns[_from];\n        uint64 _now = uint64(now);\n        transferIns[_from].push(transferInStruct(uint128(balances[_from]),_now));\n        transferIns[_to].push(transferInStruct(uint128(_value),_now));\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool) {\n        require((_value == 0) || (allowed[msg.sender][_spender] == 0));\n\n        allowed[msg.sender][_spender] = _value;\n        Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n//eGoldchain - Modified the correct technical term \"mint\" to a well know term \"mine\" for marketing purposes.\n    function mine() canPoSMint returns (bool) {\n        if(balances[msg.sender] <= 0) return false;\n        if(transferIns[msg.sender].length <= 0) return false;\n\n        uint reward = getProofOfStakeReward(msg.sender);\n        if(reward <= 0) return false;\n\n        totalSupply = totalSupply.add(reward);\n        balances[msg.sender] = balances[msg.sender].add(reward);\n        delete transferIns[msg.sender];\n        transferIns[msg.sender].push(transferInStruct(uint128(balances[msg.sender]),uint64(now)));\n//eGoldchain - Change event to Mine\n        Mine(msg.sender, reward);\n        return true;\n    }\n\n    function getBlockNumber() returns (uint blockNumber) {\n        blockNumber = block.number.sub(chainStartBlockNumber);\n    }\n\n    function coinAge(address who) constant returns (uint myCoinAge) {\n        myCoinAge = getCoinAge(who,now);\n    }\n\n    function annualInterest() constant returns(uint interest) {\n        uint _now = now;\n        interest = maxMintProofOfStake;\n        //eGoldchain - Modified initial interest rate to 300%\n        if((_now.sub(stakeStartTime)).div(1 years) == 0) {\n            interest = (1650 * maxMintProofOfStake).div(100);\n        } else if((_now.sub(stakeStartTime)).div(1 years) == 1) {\n            interest = (770 * maxMintProofOfStake).div(100);\n        } else if((_now.sub(stakeStartTime)).div(1 years) == 2){\n            interest = (435 * maxMintProofOfStake).div(100);\n        }\n    }\n\n    function getProofOfStakeReward(address _address) internal returns (uint) {\n        require( (now >= stakeStartTime) && (stakeStartTime > 0) );\n\n        uint _now = now;\n        uint _coinAge = getCoinAge(_address, _now);\n        if(_coinAge <= 0) return 0;\n\n        uint interest = maxMintProofOfStake;\n        // Due to the high interest rate for the first two years, compounding should be taken into account.\n        // Effective annual interest rate = (1 + (nominal rate / number of compounding periods)) ^ (number of compounding periods) - 1\n        //eGoldchain - Modified initial interest rate to 300%\n        if((_now.sub(stakeStartTime)).div(1 years) == 0) {\n            // 1st year effective annual interest rate is 300% when we select the stakeMaxAge (90 days) as the compounding period.\n            interest = (1650 * maxMintProofOfStake).div(100);\n        } else if((_now.sub(stakeStartTime)).div(1 years) == 1) {\n            // 2nd year effective annual interest rate is 100% when we select the stakeMaxAge (90 days) as the compounding period.\n            interest = (770 * maxMintProofOfStake).div(100);\n        } else if((_now.sub(stakeStartTime)).div(1 years) == 2){\n            // 3nd year effective annual interest rate is 50%\n            interest = (435 * maxMintProofOfStake).div(100);\n        }\n\n        return (_coinAge * interest).div(365 * (10**decimals));\n    }\n\n    function getCoinAge(address _address, uint _now) internal returns (uint _coinAge) {\n        if(transferIns[_address].length <= 0) return 0;\n\n        for (uint i = 0; i < transferIns[_address].length; i++){\n            if( _now < uint(transferIns[_address][i].time).add(stakeMinAge) ) continue;\n\n            uint nCoinSeconds = _now.sub(uint(transferIns[_address][i].time));\n            if( nCoinSeconds > stakeMaxAge ) nCoinSeconds = stakeMaxAge;\n\n            _coinAge = _coinAge.add(uint(transferIns[_address][i].amount) * nCoinSeconds.div(1 days));\n        }\n    }\n\n    function ownerSetStakeStartTime(uint timestamp) onlyOwner {\n        require((stakeStartTime <= 0) && (timestamp >= chainStartTime));\n        stakeStartTime = timestamp;\n    }\n\n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_32_+_4: 0xb3716337e807c000c8002511dc40858ab64ed89071cbf64fb490d64b3aea9783\ncalldatasize_eGoldchain: 0x64\ncalldata_eGoldchain_32 + 36: 0x329b0cbc270e7723100000000040000000000000000000000000000000000000\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_4: 0x62f93cd43082295c23f9db743f73f8e3e4080b04effb8b7d90362045dabc7578\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_eGoldchain_4: 0xd0f5f74215fb8c53abfe048bc033c0f2074172278c051fd93768b761c037296f\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x329b0cbc270e7723100000000040000000000000000000000000000000000000\ncalldata_eGoldchain_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_eGoldchain_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/39/0x07a64cf812844b2a3af03006ba9356c64da96ce2.sol", "function": "transferFrom(address,address,uint256)", "lineno": 104, "title": "Integer Overflow ", "type": "Warning"}], "success": true}