{"error": null, "issues": [{"address": 970, "code": ";\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n        return vestingAddresses.length;\n    }\n\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n        require(vestingExists(_vestingAddress));\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n        add", "debug": "calldata_VestingMasterInterface_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_VestingMasterInterface_0: 0x428657f700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `storeNewVesting(address,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "storeNewVesting(address,string,uint256)", "lineno": 253, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1188, "code": "e(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        internalBalance = internalBalance.add(_amount);\n    }\n    \n    function addLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amoun", "debug": "calldata_VestingMasterInterface_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_VestingMasterInterface_0: 0x5e00a17700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `revokeVesting(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "revokeVesting(address,string)", "lineno": 319, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2520, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x23c8be200000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "setWithdrawalAddress(address,address)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 2703, "code": "tingMasterAddress = _vestingMasterAddress;\n    }\n    \n    function totalSu", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "setWithdrawalAddress(address,address)", "lineno": 374, "title": "Message call to external contract", "type": "Warning"}, {"address": 2744, "code": "amount);\n    event LockedAmountIn", "debug": "The exception is triggered under the following conditions:\n\ncalldata_VestingMasterInterface_4: 0x0\nstorage_4: 0x0\ncalldata_VestingMasterInterface_0: 0xd427b7200000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "_function_0x0d427b72", "lineno": 241, "title": "Exception state", "type": "Informational"}, {"address": 2880, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x1076426800000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "salvageOtherTokensFromContract(address,address,address,uint256)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 3181, "code": "  ERC20TokenInterface(tokenAddress).transfer(owner, getTo", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "salvageOtherTokensFromContract(address,address,address,uint256)", "lineno": 358, "title": "Message call to external contract", "type": "Warning"}, {"address": 3181, "code": "  ERC20TokenInterface(tokenAddress).transfer(owner, getTo", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3477\n", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "salvageOtherTokensFromContract(address,address,address,uint256)", "lineno": 358, "title": "Multiple Calls", "type": "Information"}, {"address": 3477, "code": "walAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n        require(vestin", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "salvageOtherTokensFromContract(address,address,address,uint256)", "lineno": 361, "title": "Message call to external contract", "type": "Warning"}, {"address": 3599, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x136cf5c100000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "deleteVestingFromStorage(address)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 4054, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x1c02708d00000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "killContract()", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 4305, "code": " EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "killContract()", "lineno": 368, "title": "Message call to external contract", "type": "Informational"}, {"address": 4518, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x428657f700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "storeNewVesting(address,string,uint256)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 5092, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x5e00a17700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "revokeVesting(address,string)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 5315, "code": ") external {\n        require(vesti", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "revokeVesting(address,string)", "lineno": 324, "title": "Message call to external contract", "type": "Warning"}, {"address": 5442, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x64f1543000000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "fundVesting(address,uint256)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 6241, "code": "  require(!vestingExists(_vestingAddress));\n        addressToVes", "debug": "The exception is triggered under the following conditions:\n\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x8910cd5800000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "substractLockedAmount(uint256)", "lineno": 252, "title": "Exception state", "type": "Informational"}, {"address": 6407, "code": "ender == owner);\n        _;", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_0: 0x788c26b400000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "createNewVesting(address,uint256,uint256,uint256,string,uint256,bool)", "lineno": 13, "title": "Exception state", "type": "Informational"}, {"address": 7308, "code": "estingFromStorage(_vestingContract);\n    }\n    \n    functi", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "getTokenBalance()", "lineno": 316, "title": "Message call to external contract", "type": "Informational"}, {"address": 7308, "code": "estingFromStorage(_vestingContract);\n    }\n    \n    functi", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4305\n", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "killContract()", "lineno": 316, "title": "Multiple Calls", "type": "Information"}, {"address": 8311, "code": "Inter", "debug": "storage_3: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_VestingMasterInterface_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_VestingMasterInterface_0: 0x59d90c1900000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addLockedAmount(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "addLockedAmount(uint256)", "lineno": 75, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8325, "code": "    function t", "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0x1\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VestingMasterInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_VestingMasterInterface_0: 0x59d90c1900000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "addLockedAmount(uint256)", "lineno": 76, "title": "Exception state", "type": "Informational"}, {"address": 8388, "code": "56 public amountLockedInVestings = 0;\n    \n    struct VestingStruct{\n        uint256 arrayPointer;\n        string vestingType;\n        uint256 version;\n        \n    }\n    address[] public vestingAddresses;\n    mapping (address => VestingStruct) public addressToVesting;\n    \n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n    event LockedAmountDecreased(uint256 amount);\n    event LockedAmountIncreased(uint256 amount);\n    event TokensReceivedSinceLastCheck(uint256 amount);\n\n    \n    function vestingExists(address _vestingAddress) public view returns(bool exists){\n        if(vestingAddresses.length == 0) {return false;}\n        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\n    }\n    \n    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\n        require(!vestingExists(_vestingAddress));\n        addressToVesting[_vestingAddress].version = _version;\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n        return vestingAddresses.length;\n    }\n\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n        require(vestingExists(_vestingAddress));\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n        vestingAddresses[indexToDelete] = keyToMove;\n        addressToVesting[keyToMove].arrayPointer = indexToDelete;\n        vestingAddresses.length--;\n        return vestingAddresses.length;\n    }\n    \n    function createNewVesting(\n        \n        address _beneficiary,\n        uint256 _startTime, \n        uint256 _tickDuration, \n        uint256 _amountPerTick,\n        string _vestingType,\n        uint256 _version,\n        bool _revocable\n        ) \n        \n        public onlyOwner returns(address){\n            TokenVestingContract newVesting = new TokenVestingContract(   \n                _beneficiary,\n                tokenAddress,\n                _startTime, \n                _tickDuration, \n                _amountPerTick,\n                _version,\n                _revocable\n                );\n           \n        storeNewVesting(newVesting, _vestingType, _version);\n        return newVesting;\n    }\n    \n    \n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n        \n        checkForReceivedTokens();\n        \n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n        \n        require(vestingExists(_vestingContract)); \n        internalBalance = internalBalance.sub(_amount);\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n    }\n    \n    function getTokenBalance() public constant returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n    }\n    \n    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n        subVestingContract.revoke(_reason);\n        deleteVestingFromStorage(_vestingContract);\n    }\n    \n    function addInternalBalance(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        internalBalance = internalBalance.add(_amount);\n    }\n    \n    function addLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\n        emit LockedAmountIncreased(_amount);\n    }\n    \n    function substractLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n        emit LockedAmountDecreased(_amount);\n    }\n    \n    function checkForReceivedTokens() public{\n        if (getTokenBalance() != internalBalance){\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n            internalBalance = getTokenBalance();\n            emit TokensReceivedSinceLastCheck(receivedFunds);\n        }else{\n        emit TokensReceivedSinceLastCheck(0);\n        }\n    }\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n        require(_tokenAddress != tokenAddress);\n        if (_contractAddress == address(this)){\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n        }\n        if (vestingExists(_contractAddress)){\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n        }\n    }\n    \n    function killContract() public onlyOwner{\n        require(vestingAddresses.length == 0);\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n        selfdestruct(owner);\n    }\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n        require(vestingExists(_vestingContract));\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n    }\n}\n\n\ncontract EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n    address public vestingMasterAddress;\n    \n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n        tokenAddress = _tokenAddress;\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n    \n    function totalSupply() view", "debug": "storage_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffff9001c942e61\ncalldata_VestingMasterInterface_4: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VestingMasterInterface_4: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VestingMasterInterface_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffff9001c942e60\nstorage_0: 0x0\ncaller: 0x0\ncalldata_VestingMasterInterface_0: 0x136cf5c100000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `deleteVestingFromStorage(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "deleteVestingFromStorage(address)", "lineno": 229, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8390, "code": "56 public amountLockedInVestings = 0;\n    \n    struct VestingStruct{\n        uint256 arrayPointer;\n        string vestingType;\n        uint256 version;\n        \n    }\n    address[] public vestingAddresses;\n    mapping (address => VestingStruct) public addressToVesting;\n    \n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n    event LockedAmountDecreased(uint256 amount);\n    event LockedAmountIncreased(uint256 amount);\n    event TokensReceivedSinceLastCheck(uint256 amount);\n\n    \n    function vestingExists(address _vestingAddress) public view returns(bool exists){\n        if(vestingAddresses.length == 0) {return false;}\n        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\n    }\n    \n    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\n        require(!vestingExists(_vestingAddress));\n        addressToVesting[_vestingAddress].version = _version;\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n        return vestingAddresses.length;\n    }\n\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n        require(vestingExists(_vestingAddress));\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n        vestingAddresses[indexToDelete] = keyToMove;\n        addressToVesting[keyToMove].arrayPointer = indexToDelete;\n        vestingAddresses.length--;\n        return vestingAddresses.length;\n    }\n    \n    function createNewVesting(\n        \n        address _beneficiary,\n        uint256 _startTime, \n        uint256 _tickDuration, \n        uint256 _amountPerTick,\n        string _vestingType,\n        uint256 _version,\n        bool _revocable\n        ) \n        \n        public onlyOwner returns(address){\n            TokenVestingContract newVesting = new TokenVestingContract(   \n                _beneficiary,\n                tokenAddress,\n                _startTime, \n                _tickDuration, \n                _amountPerTick,\n                _version,\n                _revocable\n                );\n           \n        storeNewVesting(newVesting, _vestingType, _version);\n        return newVesting;\n    }\n    \n    \n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n        \n        checkForReceivedTokens();\n        \n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n        \n        require(vestingExists(_vestingContract)); \n        internalBalance = internalBalance.sub(_amount);\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n    }\n    \n    function getTokenBalance() public constant returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n    }\n    \n    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n        subVestingContract.revoke(_reason);\n        deleteVestingFromStorage(_vestingContract);\n    }\n    \n    function addInternalBalance(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        internalBalance = internalBalance.add(_amount);\n    }\n    \n    function addLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\n        emit LockedAmountIncreased(_amount);\n    }\n    \n    function substractLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n        emit LockedAmountDecreased(_amount);\n    }\n    \n    function checkForReceivedTokens() public{\n        if (getTokenBalance() != internalBalance){\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n            internalBalance = getTokenBalance();\n            emit TokensReceivedSinceLastCheck(receivedFunds);\n        }else{\n        emit TokensReceivedSinceLastCheck(0);\n        }\n    }\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n        require(_tokenAddress != tokenAddress);\n        if (_contractAddress == address(this)){\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n        }\n        if (vestingExists(_contractAddress)){\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n        }\n    }\n    \n    function killContract() public onlyOwner{\n        require(vestingAddresses.length == 0);\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n        selfdestruct(owner);\n    }\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n        require(vestingExists(_vestingContract));\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n    }\n}\n\n\ncontract EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n    address public vestingMasterAddress;\n    \n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n        tokenAddress = _tokenAddress;\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n    \n    function totalSupply() view", "debug": "storage_4: 0x7ffffffffffff7dffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_VestingMasterInterface_4: 0x0\nstorage_62514009886607029107290561805838585334079798074568712924583230797734656856475 +\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VestingMasterInterface_4: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VestingMasterInterface_4: 0x7ffffffffffff7dffffffffffffffffffffffffffffffffffffffffffffffffd\nstorage_0: 0x0\ncaller: 0x0\ncalldata_VestingMasterInterface_0: 0x136cf5c100000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `deleteVestingFromStorage(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "deleteVestingFromStorage(address)", "lineno": 229, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8447, "code": "56 public amountLockedInVestings = 0;\n    \n    struct VestingStruct{\n        uint256 arrayPointer;\n        string vestingType;\n        uint256 version;\n        \n    }\n    address[] public vestingAddresses;\n    mapping (address => VestingStruct) public addressToVesting;\n    \n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n    event LockedAmountDecreased(uint256 amount);\n    event LockedAmountIncreased(uint256 amount);\n    event TokensReceivedSinceLastCheck(uint256 amount);\n\n    \n    function vestingExists(address _vestingAddress) public view returns(bool exists){\n        if(vestingAddresses.length == 0) {return false;}\n        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\n    }\n    \n    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\n        require(!vestingExists(_vestingAddress));\n        addressToVesting[_vestingAddress].version = _version;\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n        return vestingAddresses.length;\n    }\n\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n        require(vestingExists(_vestingAddress));\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n        vestingAddresses[indexToDelete] = keyToMove;\n        addressToVesting[keyToMove].arrayPointer = indexToDelete;\n        vestingAddresses.length--;\n        return vestingAddresses.length;\n    }\n    \n    function createNewVesting(\n        \n        address _beneficiary,\n        uint256 _startTime, \n        uint256 _tickDuration, \n        uint256 _amountPerTick,\n        string _vestingType,\n        uint256 _version,\n        bool _revocable\n        ) \n        \n        public onlyOwner returns(address){\n            TokenVestingContract newVesting = new TokenVestingContract(   \n                _beneficiary,\n                tokenAddress,\n                _startTime, \n                _tickDuration, \n                _amountPerTick,\n                _version,\n                _revocable\n                );\n           \n        storeNewVesting(newVesting, _vestingType, _version);\n        return newVesting;\n    }\n    \n    \n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n        \n        checkForReceivedTokens();\n        \n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n        \n        require(vestingExists(_vestingContract)); \n        internalBalance = internalBalance.sub(_amount);\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n    }\n    \n    function getTokenBalance() public constant returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n    }\n    \n    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n        subVestingContract.revoke(_reason);\n        deleteVestingFromStorage(_vestingContract);\n    }\n    \n    function addInternalBalance(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        internalBalance = internalBalance.add(_amount);\n    }\n    \n    function addLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\n        emit LockedAmountIncreased(_amount);\n    }\n    \n    function substractLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n        emit LockedAmountDecreased(_amount);\n    }\n    \n    function checkForReceivedTokens() public{\n        if (getTokenBalance() != internalBalance){\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n            internalBalance = getTokenBalance();\n            emit TokensReceivedSinceLastCheck(receivedFunds);\n        }else{\n        emit TokensReceivedSinceLastCheck(0);\n        }\n    }\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n        require(_tokenAddress != tokenAddress);\n        if (_contractAddress == address(this)){\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n        }\n        if (vestingExists(_contractAddress)){\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n        }\n    }\n    \n    function killContract() public onlyOwner{\n        require(vestingAddresses.length == 0);\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n        selfdestruct(owner);\n    }\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n        require(vestingExists(_vestingContract));\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n    }\n}\n\n\ncontract EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n    address public vestingMasterAddress;\n    \n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n        tokenAddress = _tokenAddress;\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n    \n    function totalSupply() view", "debug": "keccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VestingMasterInterface_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VestingMasterInterface_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_0: 0x0\ncaller: 0x0\ncalldata_VestingMasterInterface_0: 0x428657f700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `storeNewVesting(address,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "storeNewVesting(address,string,uint256)", "lineno": 229, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8478, "code": "56 public amountLockedInVestings = 0;\n    \n    struct VestingStruct{\n        uint256 arrayPointer;\n        string vestingType;\n        uint256 version;\n        \n    }\n    address[] public vestingAddresses;\n    mapping (address => VestingStruct) public addressToVesting;\n    \n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n    event LockedAmountDecreased(uint256 amount);\n    event LockedAmountIncreased(uint256 amount);\n    event TokensReceivedSinceLastCheck(uint256 amount);\n\n    \n    function vestingExists(address _vestingAddress) public view returns(bool exists){\n        if(vestingAddresses.length == 0) {return false;}\n        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\n    }\n    \n    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\n        require(!vestingExists(_vestingAddress));\n        addressToVesting[_vestingAddress].version = _version;\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n        return vestingAddresses.length;\n    }\n\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n        require(vestingExists(_vestingAddress));\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n        vestingAddresses[indexToDelete] = keyToMove;\n        addressToVesting[keyToMove].arrayPointer = indexToDelete;\n        vestingAddresses.length--;\n        return vestingAddresses.length;\n    }\n    \n    function createNewVesting(\n        \n        address _beneficiary,\n        uint256 _startTime, \n        uint256 _tickDuration, \n        uint256 _amountPerTick,\n        string _vestingType,\n        uint256 _version,\n        bool _revocable\n        ) \n        \n        public onlyOwner returns(address){\n            TokenVestingContract newVesting = new TokenVestingContract(   \n                _beneficiary,\n                tokenAddress,\n                _startTime, \n                _tickDuration, \n                _amountPerTick,\n                _version,\n                _revocable\n                );\n           \n        storeNewVesting(newVesting, _vestingType, _version);\n        return newVesting;\n    }\n    \n    \n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n        \n        checkForReceivedTokens();\n        \n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n        \n        require(vestingExists(_vestingContract)); \n        internalBalance = internalBalance.sub(_amount);\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n    }\n    \n    function getTokenBalance() public constant returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n    }\n    \n    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n        subVestingContract.revoke(_reason);\n        deleteVestingFromStorage(_vestingContract);\n    }\n    \n    function addInternalBalance(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        internalBalance = internalBalance.add(_amount);\n    }\n    \n    function addLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\n        emit LockedAmountIncreased(_amount);\n    }\n    \n    function substractLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n        emit LockedAmountDecreased(_amount);\n    }\n    \n    function checkForReceivedTokens() public{\n        if (getTokenBalance() != internalBalance){\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n            internalBalance = getTokenBalance();\n            emit TokensReceivedSinceLastCheck(receivedFunds);\n        }else{\n        emit TokensReceivedSinceLastCheck(0);\n        }\n    }\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n        require(_tokenAddress != tokenAddress);\n        if (_contractAddress == address(this)){\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n        }\n        if (vestingExists(_contractAddress)){\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n        }\n    }\n    \n    function killContract() public onlyOwner{\n        require(vestingAddresses.length == 0);\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n        selfdestruct(owner);\n    }\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n        require(vestingExists(_vestingContract));\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n    }\n}\n\n\ncontract EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n    address public vestingMasterAddress;\n    \n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n        tokenAddress = _tokenAddress;\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n    \n    function totalSupply() view", "debug": "calldata_VestingMasterInterface_4 + calldata_VestingMasterInterface_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\ncaller: 0x0\ncalldata_VestingMasterInterface_0: 0x428657f700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `storeNewVesting(address,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "storeNewVesting(address,string,uint256)", "lineno": 229, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8493, "code": "56 public amountLockedInVestings = 0;\n    \n    struct VestingStruct{\n        uint256 arrayPointer;\n        string vestingType;\n        uint256 version;\n        \n    }\n    address[] public vestingAddresses;\n    mapping (address => VestingStruct) public addressToVesting;\n    \n    event VestingContractFunded(address beneficiary, address tokenAddress, uint256 amount);\n    event LockedAmountDecreased(uint256 amount);\n    event LockedAmountIncreased(uint256 amount);\n    event TokensReceivedSinceLastCheck(uint256 amount);\n\n    \n    function vestingExists(address _vestingAddress) public view returns(bool exists){\n        if(vestingAddresses.length == 0) {return false;}\n        return (vestingAddresses[addressToVesting[_vestingAddress].arrayPointer] == _vestingAddress);\n    }\n    \n    function storeNewVesting(address _vestingAddress, string _vestingType, uint256 _version) public onlyOwner returns(uint256 vestingsLength) {\n        require(!vestingExists(_vestingAddress));\n        addressToVesting[_vestingAddress].version = _version;\n        addressToVesting[_vestingAddress].vestingType = _vestingType ;\n        addressToVesting[_vestingAddress].arrayPointer = vestingAddresses.push(_vestingAddress) - 1;\n        return vestingAddresses.length;\n    }\n\n    function deleteVestingFromStorage(address _vestingAddress) public onlyOwner returns(uint256 vestingsLength) {\n        require(vestingExists(_vestingAddress));\n        uint256 indexToDelete = addressToVesting[_vestingAddress].arrayPointer;\n        address keyToMove = vestingAddresses[vestingAddresses.length - 1];\n        vestingAddresses[indexToDelete] = keyToMove;\n        addressToVesting[keyToMove].arrayPointer = indexToDelete;\n        vestingAddresses.length--;\n        return vestingAddresses.length;\n    }\n    \n    function createNewVesting(\n        \n        address _beneficiary,\n        uint256 _startTime, \n        uint256 _tickDuration, \n        uint256 _amountPerTick,\n        string _vestingType,\n        uint256 _version,\n        bool _revocable\n        ) \n        \n        public onlyOwner returns(address){\n            TokenVestingContract newVesting = new TokenVestingContract(   \n                _beneficiary,\n                tokenAddress,\n                _startTime, \n                _tickDuration, \n                _amountPerTick,\n                _version,\n                _revocable\n                );\n           \n        storeNewVesting(newVesting, _vestingType, _version);\n        return newVesting;\n    }\n    \n    \n    function fundVesting(address _vestingContract, uint256 _amount) public onlyOwner {\n        \n        checkForReceivedTokens();\n        \n        require((internalBalance >= _amount) && (getTokenBalance() >= _amount));\n        \n        require(vestingExists(_vestingContract)); \n        internalBalance = internalBalance.sub(_amount);\n        ERC20TokenInterface(tokenAddress).transfer(_vestingContract, _amount);\n        TokenVestingInterface(_vestingContract).updateBalanceOnFunding(_amount);\n        emit VestingContractFunded(_vestingContract, tokenAddress, _amount);\n    }\n    \n    function getTokenBalance() public constant returns(uint256) {\n        return ERC20TokenInterface(tokenAddress).balanceOf(address(this));\n    }\n    \n    function revokeVesting(address _vestingContract, string _reason) public onlyOwner{\n        TokenVestingInterface subVestingContract = TokenVestingInterface(_vestingContract);\n        subVestingContract.revoke(_reason);\n        deleteVestingFromStorage(_vestingContract);\n    }\n    \n    function addInternalBalance(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        internalBalance = internalBalance.add(_amount);\n    }\n    \n    function addLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.add(_amount);\n        emit LockedAmountIncreased(_amount);\n    }\n    \n    function substractLockedAmount(uint256 _amount) external {\n        require(vestingExists(msg.sender));\n        amountLockedInVestings = amountLockedInVestings.sub(_amount);\n        emit LockedAmountDecreased(_amount);\n    }\n    \n    function checkForReceivedTokens() public{\n        if (getTokenBalance() != internalBalance){\n            uint256 receivedFunds = getTokenBalance().sub(internalBalance);\n            amountLockedInVestings = amountLockedInVestings.add(receivedFunds);\n            internalBalance = getTokenBalance();\n            emit TokensReceivedSinceLastCheck(receivedFunds);\n        }else{\n        emit TokensReceivedSinceLastCheck(0);\n        }\n    }\n    function salvageOtherTokensFromContract(address _tokenAddress, address _contractAddress, address _to, uint _amount) public onlyOwner {\n        require(_tokenAddress != tokenAddress);\n        if (_contractAddress == address(this)){\n            ERC20TokenInterface(_tokenAddress).transfer(_to, _amount);\n        }\n        if (vestingExists(_contractAddress)){\n            TokenVestingInterface(_contractAddress).salvageOtherTokensFromContract(_tokenAddress, _to, _amount);\n        }\n    }\n    \n    function killContract() public onlyOwner{\n        require(vestingAddresses.length == 0);\n        ERC20TokenInterface(tokenAddress).transfer(owner, getTokenBalance());\n        selfdestruct(owner);\n    }\n    function setWithdrawalAddress(address _vestingContract, address _beneficiary) public onlyOwner{\n        require(vestingExists(_vestingContract));\n        TokenVestingInterface(_vestingContract).setWithdrawalAddress(_beneficiary);\n    }\n}\n\n\ncontract EligmaSupplyContract  is Owned {\n    address public tokenAddress;\n    address public vestingMasterAddress;\n    \n    function EligmaSupplyContract(address _tokenAddress, address _vestingMasterAddress) public onlyOwner{\n        tokenAddress = _tokenAddress;\n        vestingMasterAddress = _vestingMasterAddress;\n    }\n    \n    function totalSupply() view", "debug": "calldata_VestingMasterInterface_4 + calldata_VestingMasterInterface_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_VestingMasterInterface_0: 0x428657f700000000000000000000000000000000000000000000000000000000\ncalldatasize_VestingMasterInterface: 0x4\nstorage_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `storeNewVesting(address,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/10/0x4ed85ace60083f2fe413554a015af15e59b618d2.sol", "function": "storeNewVesting(address,string,uint256)", "lineno": 229, "title": "Integer Overflow ", "type": "Warning"}], "success": true}