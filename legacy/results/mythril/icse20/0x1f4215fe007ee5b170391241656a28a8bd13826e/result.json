{
  "contract": "0x1f4215fe007ee5b170391241656a28a8bd13826e",
  "tool": "mythril",
  "start": 1563473308.8937225,
  "end": 1563473721.1796818,
  "duration": 412.2859592437744,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 4363,
        "code": "= previousBalances);\t\n\t}\n\t\n\tfunction bur",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xa870d5e7fffffffffffffffffffffffffffffffffffffffffffffffffffffefe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x57f2c1f800000000000000000000000000000000000000000000000000000100\ncalldata_VVToken_0: 0x95e596f00000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AccountVoid(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "AccountVoid(address)",
        "lineno": 269,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4512,
        "code": "equire(balanceOf[this] >= BurnValue);\n\t\t",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0x95e493df09774eb49bd48003c0850b30f8d10a2a1341043d4c008560e08500c4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa923bc2c35ea58231bc6409900885b40fedbadcbd5004fbf0bfef9fcf6f50329\ncalldata_VVToken_0: 0x95e596f00000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AccountVoid(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "AccountVoid(address)",
        "lineno": 274,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5686,
        "code": "           count ",
        "debug": "storage_3: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `kill()`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "kill()",
        "lineno": 75,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 5711,
        "code": "uired)\n  ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\nstorage_3: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "kill()",
        "lineno": 76,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5991,
        "debug": "calldata_VVToken_4: 0xff3717ddf147ba7fd6976a72ee859c9c251431c6dd4346e384e0fd941c87b69c\n10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xde9aa0007ffff9dbbb05d00001000207fffdffbfffbfbfbfffbfbfefbfbff7f6\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x24749b5900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `bonus(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "bonus(uint256)",
        "lineno": 287,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6221,
        "debug": "storage_8980041631919178290161226234105977776452779202751091583642356499240698725347: 0x27df6fcfa638253effdebbfa1d0bc2c1437f5edbc0f2112102fbbfefdfefe235\nstorage_7: 0xb5431bc79bd0647c7f6bafd75d8f3a76a3ef379e5c64804f813fef3144013fdb\ncalldata_VVToken_4: 0x1\n10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xa2411387aa3f431a80514c1861e4406023acb1484d2684d9f5a4cc306fd8a211\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x24749b5900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `bonus(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "bonus(uint256)",
        "lineno": 287,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6668,
        "code": "[this] + BonusValue > balanceOf[",
        "debug": "calldata_VVToken_4: 0xff3717ddf147ba7fd6976a72ee859c9c251431c6dd4346e384e0fd941c87b69c\n10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xde9aa0007ffff9dbbb05d00001000207fffdffbfffbfbfbfffbfbfefbfbff7f6\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `burn(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "burn(uint256)",
        "lineno": 282,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6834,
        "code": "nusValue);\n\t}\n}",
        "debug": "storage_7: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_8980041631919178290161226234105977776452779202751091583642356499240698725347: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VVToken_4: 0x1\n10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `burn(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "burn(uint256)",
        "lineno": 285,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 7828,
        "code": "     return tru",
        "debug": "storage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffcc\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x6f2293ab00000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncalldata_VVToken_32 + 68: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256,bool)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "transferFrom(address,address,uint256,bool)",
        "lineno": 184,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7837,
        "code": "arge);\n        return true",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x6f2293ab00000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\nstorage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c\ncalldata_VVToken_32 + 68: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "transferFrom(address,address,uint256,bool)",
        "lineno": 183,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8177,
        "code": ";\n\ncontract MultiO",
        "debug": "storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x7065cb4800000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "addOwner(address)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 12090,
        "code": "nt Confirmation(address sender, bytes32 transactionHash);\n\tevent Execution(bytes32 transactionHash);\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent FeePaid(address indexed from, address indexed to, uint256 value);\n\tevent VoidAccount(address indexed from, address indexed to, uint256 value);\n\tevent Bonus(uint256 value);\n\tevent Burn(uint256 value);\n\t\n\tstring public name = \"VV Coin\";\n\tstring public symbol = \"VVI\";\n\tuint8 public decimals = 8;\n\tuint256 public totalSupply = 3000000000 * 10 ** uint256(decimals);\n\tuint256 public EthPerToken = 300000;\n\tuint256 public ChargeFee = 2;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction VVToken(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tbalanceOf[msg.sender] = totalSupply;                    \n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _collect_fee(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n\t\tFeePaid(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\t\n\tfunction transferFrom(address _from, address _to, uint256 _value, bool _fee) onlyOwner public returns (bool success) {\n\t\tuint256 charge = 0 ;\n\t\tuint256 t_value = _value;\n\t\tif(_fee){\n\t\t\tcharge = _value * ChargeFee / 100;\n\t\t}else{\n\t\t\tcharge = _value - (_value / (ChargeFee + 100) * 100);\n\t\t}\n\t\tt_value = _value - charge;\n\t\trequire(t_value + charge == _value);\n        _transfer(_from, _to, t_value);\n\t\t_collect_fee(_from, this, charge);\n        return true;\n    }\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n    \n\tfunction setFee(uint256 newValue) onlyOwner public {\n        ChargeFee = newValue;\n    }\n\t\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable {\n\t\trequire(msg.value > 0);\n\t\tuint amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1 ether;\n        _transfer(this, msg.sender, amount);\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = sha3(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction AccountVoid(address _from) onlyOwner public{\n\t\trequire (balanceOf[_from] > 0); \n\t\tuint256 CurrentBalances = balanceOf[_from];\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\n        balanceOf[_from] -= CurrentBalances;                         \n        balanceOf[msg.sender] += CurrentBalances;\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\n\t}\n\t\n\tfunction burn(uint amount) onlyOwner{\n\t\tuint BurnValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] >= BurnValue);\n\t\tbalanceOf[this] -= BurnValue;\n\t\ttotalSupply -= BurnValue;\n\t\tBurn(BurnValue);\n\t}\n\t\n\tfunction bonus(uint amount) onlyOwner{\n\t\tuint BonusValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] + BonusValue > balanceOf[this]);\n\t\tbalanceOf[this] += BonusValue;\n\t\ttotalSupply += BonusValue;\n\t\tBonus(BonusValue);\n\t}\n}",
        "debug": "storage_3: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VVToken_4: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037083: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "removeOwner(address)",
        "lineno": 90,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 12092,
        "code": "nt Confirmation(address sender, bytes32 transactionHash);\n\tevent Execution(bytes32 transactionHash);\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent FeePaid(address indexed from, address indexed to, uint256 value);\n\tevent VoidAccount(address indexed from, address indexed to, uint256 value);\n\tevent Bonus(uint256 value);\n\tevent Burn(uint256 value);\n\t\n\tstring public name = \"VV Coin\";\n\tstring public symbol = \"VVI\";\n\tuint8 public decimals = 8;\n\tuint256 public totalSupply = 3000000000 * 10 ** uint256(decimals);\n\tuint256 public EthPerToken = 300000;\n\tuint256 public ChargeFee = 2;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction VVToken(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tbalanceOf[msg.sender] = totalSupply;                    \n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _collect_fee(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n\t\tFeePaid(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\t\n\tfunction transferFrom(address _from, address _to, uint256 _value, bool _fee) onlyOwner public returns (bool success) {\n\t\tuint256 charge = 0 ;\n\t\tuint256 t_value = _value;\n\t\tif(_fee){\n\t\t\tcharge = _value * ChargeFee / 100;\n\t\t}else{\n\t\t\tcharge = _value - (_value / (ChargeFee + 100) * 100);\n\t\t}\n\t\tt_value = _value - charge;\n\t\trequire(t_value + charge == _value);\n        _transfer(_from, _to, t_value);\n\t\t_collect_fee(_from, this, charge);\n        return true;\n    }\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n    \n\tfunction setFee(uint256 newValue) onlyOwner public {\n        ChargeFee = newValue;\n    }\n\t\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable {\n\t\trequire(msg.value > 0);\n\t\tuint amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1 ether;\n        _transfer(this, msg.sender, amount);\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = sha3(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction AccountVoid(address _from) onlyOwner public{\n\t\trequire (balanceOf[_from] > 0); \n\t\tuint256 CurrentBalances = balanceOf[_from];\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\n        balanceOf[_from] -= CurrentBalances;                         \n        balanceOf[msg.sender] += CurrentBalances;\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\n\t}\n\t\n\tfunction burn(uint amount) onlyOwner{\n\t\tuint BurnValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] >= BurnValue);\n\t\tbalanceOf[this] -= BurnValue;\n\t\ttotalSupply -= BurnValue;\n\t\tBurn(BurnValue);\n\t}\n\t\n\tfunction bonus(uint amount) onlyOwner{\n\t\tuint BonusValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] + BonusValue > balanceOf[this]);\n\t\tbalanceOf[this] += BonusValue;\n\t\ttotalSupply += BonusValue;\n\t\tBonus(BonusValue);\n\t}\n}",
        "debug": "storage_3: 0x7fffffffffffffffffffffefffffffffffffffffffffffffffffc00000000000\ncalldata_VVToken_4: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037083: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1f4215fe007ee5b170391241656a28a8bd13826e.sol",
        "function": "removeOwner(address)",
        "lineno": 90,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}