{"error": null, "issues": [{"address": 1198, "code": "[msg.sender].sub(_value);\n        if(accounts[msg.sender] == 0){\n            holders.remove(msg.sender);\n        }\n        accounts[_to] = accou", "debug": "calldata_UmkaToken_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_UmkaToken_0: 0x3042b17d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUmkaAddress(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "setUmkaAddress(string)", "lineno": 430, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1204, "code": "[msg.sender].sub(_value);\n        if(accounts[msg.sender] == 0){\n            holders.remove(msg.sender);\n        }\n        accounts[_to] = accou", "debug": "calldata_UmkaToken_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_UmkaToken_0: 0x3042b17d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUmkaAddress(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "setUmkaAddress(string)", "lineno": 430, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5111, "code": "\n    }\n\n    modifier whenNotPaused(", "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_UmkaToken: 0x4\ncalldata_UmkaToken_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "transferFrom(address,address,uint256)", "lineno": 268, "title": "Exception state", "type": "Informational"}, {"address": 8492, "code": "\n    }\n\n    modifier whenNotPaused(", "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_UmkaToken: 0x4\ncalldata_UmkaToken_0: 0x426a849300000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "approve(address,uint256,uint256)", "lineno": 268, "title": "Exception state", "type": "Informational"}, {"address": 16232, "code": "      return a", "debug": "The exception is triggered under the following conditions:\n\ncalldata_UmkaToken_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_UmkaToken_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UmkaToken_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x7800\nstorage_11: 0x100\ncalldata_UmkaToken_0: 0x48cf8ed00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "serviceDecreaseBalance(address,uint256)", "lineno": 20, "title": "Exception state", "type": "Informational"}, {"address": 16834, "code": " >= a", "debug": "calldata_UmkaToken_32 + 4: 0xbf7ffe4f2a5667b039c0059d3cc2cf4320f6d4369ac06bedb5bf3eb62df45525\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_UmkaToken_4: 0x887ffefff226834979c7e45d3e04880080c503665e676fe0372c391c9209f955\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_0,_256): 0xbf7ffe4f2a5667b039c0059d3cc2cf4320f6d4369ac06bedb5bf3eb62df45525\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xec00\nstorage_11: 0x3200\ncalldata_UmkaToken_0: 0x420aa07d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `serviceTrasferToDist(bytes32,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "serviceTrasferToDist(bytes32,uint256)", "lineno": 25, "title": "Integer Overflow ", "type": "Warning"}, {"address": 16847, "code": "return c;\n    ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_UmkaToken_32 + 4: 0xa07b559b2eac1750bb0848f4ccd79818b3ea77dafcd6d5648d12ab390e04bd52\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_UmkaToken_4: 0x9f5c7c9b46b98c7289d87d3c550419848fc263808090df59a486aba3008ba379\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_0,_256): 0xa07b559b2eac1750bb0848f4ccd79818b3ea77dafcd6d5648d12ab390e04bd52\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xb600\nstorage_11: 0x2d00\ncalldata_UmkaToken_0: 0x420aa07d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "serviceTrasferToDist(bytes32,uint256)", "lineno": 26, "title": "Exception state", "type": "Informational"}, {"address": 18560, "code": " public              contractEnable = true;\n\n    uint256 private             summarySupply;\n\n    string  public              name = \"\";\n    string  public              symbol = \"\";\n    uint8   public              decimals = 0;\n\n    mapping(address => uint256)                      private   accounts;\n    mapping(address => string)                       private   umkaAddresses;\n    mapping(address => mapping (address => uint256)) private   allowed;\n    mapping(address => uint8)                        private   group;\n    mapping(bytes32 => uint256)                      private   distribution;\n\n    RingList.LinkedList                              private   holders;\n\n    struct groupPolicy {\n        uint8 _default;\n        uint8 _backend;\n        uint8 _admin;\n        uint8 _migration;\n        uint8 _subowner;\n        uint8 _owner;\n    }\n\n    groupPolicy public currentState = groupPolicy(0, 3, 4, 9, 2, 9);\n\n    event EvGroupChanged(address _address, uint8 _oldgroup, uint8 _newgroup);\n    event EvMigration(address _address, uint256 _balance, uint256 _secret);\n    event Pause();\n    event Unpause();\n\n    constructor (string _name, string _symbol, uint8 _decimals, uint256 _startTokens) public {\n        owner = msg.sender;\n\n        group[owner] = currentState._owner;\n\n        accounts[msg.sender]  = _startTokens;\n\n        holders.push(msg.sender, true);\n        summarySupply    = _startTokens;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        emit Transfer(address(0x0), msg.sender, _startTokens);\n    }\n\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n\n    modifier minGroup(int _require) {\n        require(group[msg.sender] >= _require);\n        _;\n    }\n\n    modifier onlyGroup(int _require) {\n        require(group[msg.sender] == _require);\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused || group[msg.sender] >= currentState._backend);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    function servicePause() minGroup(currentState._admin) whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    function serviceUnpause() minGroup(currentState._admin) whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n    function serviceGroupChange(address _address, uint8 _group) minGroup(currentState._admin) external returns(uint8) {\n        require(_address != address(0));\n\n        uint8 old = group[_address];\n        if(old <= currentState._admin) {\n            group[_address] = _group;\n            emit EvGroupChanged(_address, old, _group);\n        }\n        return group[_address];\n    }\n\n    function serviceTransferOwnership(address newOwner) minGroup(currentState._owner) external {\n        require(newOwner != address(0));\n\n        group[newOwner] = currentState._subowner;\n        group[msg.sender] = currentState._subowner;\n        emit EvGroupChanged(newOwner, currentState._owner, currentState._subowner);\n    }\n\n    function serviceClaimOwnership() onlyGroup(currentState._subowner) external {\n        address temp = owner;\n        uint256 value = accounts[owner];\n\n        accounts[owner] = accounts[owner].sub(value);\n        holders.remove(owner);\n        accounts[msg.sender] = accounts[msg.sender].add(value);\n        holders.push(msg.sender, true);\n\n        owner = msg.sender;\n\n        delete group[temp];\n        group[msg.sender] = currentState._owner;\n\n        emit EvGroupChanged(msg.sender, currentState._subowner, currentState._owner);\n        emit Transfer(temp, owner, value);\n    }\n\n    function serviceIncreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\n        require(_who != address(0));\n        require(_value > 0);\n\n        accounts[_who] = accounts[_who].add(_value);\n        summarySupply = summarySupply.add(_value);\n        holders.push(_who, true);\n        emit Transfer(address(0), _who, _value);\n        return true;\n    }\n\n    function serviceDecreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\n        require(_who != address(0));\n        require(_value > 0);\n        require(accounts[_who] >= _value);\n\n        accounts[_who] = accounts[_who].sub(_value);\n        summarySupply = summarySupply.sub(_value);\n        if(accounts[_who] == 0){\n            holders.remove(_who);\n        }\n        emit Transfer(_who, address(0), _value);\n        return true;\n    }\n\n    function serviceRedirect(address _from, address _to, uint256 _value) minGroup(currentState._admin) external returns(bool){\n        require(_from != address(0));\n        require(_to != address(0));\n        require(_value > 0);\n        require(accounts[_from] >= _value);\n        require(_from != _to);\n\n        accounts[_from] = accounts[_from].sub(_value);\n        if(accounts[_from] == 0){\n            holders.remove(_from);\n        }\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function serviceTokensBurn(address _address) external minGroup(currentState._admin) returns(uint256 balance) {\n        require(_address != address(0));\n        require(accounts[_address] > 0);\n\n        uint256 sum = accounts[_address];\n        accounts[_address] = 0;\n        summarySupply = summarySupply.sub(sum);\n        holders.remove(_address);\n        emit Transfer(_address, address(0), sum);\n        return accounts[_address];\n    }\n\n    function serviceTrasferToDist(bytes32 _to, uint256 _value) external minGroup(currentState._admin) {\n        require(_value > 0);\n        require(accounts[owner] >= _value);\n\n        distribution[_to] = distribution[_to].add(_value);\n        accounts[owner] = accounts[owner].sub(_value);\n        emit Transfer(owner, address(0), _value);\n    }\n\n    function serviceTrasferFromDist(bytes32 _from, address _to, uint256 _value) external minGroup(currentState._backend) {\n        require(_to != address(0));\n        require(_value > 0);\n        require(distribution[_from] >= _value);\n\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        distribution[_from] = distribution[_from].sub(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    function getGroup(address _check) external constant returns(uint8 _group) {\n        return group[_check];\n    }\n\n    function getBalanceOfDist(bytes32 _of) external constant returns(uint256){\n        return distribution[_of];\n    }\n\n    function getHoldersLength() external constant returns(uint256){\n        return holders.sizeOf();\n    }\n\n    function getHolderLink(address _holder) external constant returns(bool, address, address){\n        return holders.getNode(_holder);\n    }\n\n    function getUmkaAddress(address _who) external constant returns(string umkaAddress){\n        return umkaAddresses[_who];\n    }\n\n    function setUmkaAddress(string _umka) minGroup(currentState._default) whenNotPaused external{\n        umkaAddresses[msg.sender] = _umka;\n    }\n\n    function transfer(address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require(_to != address(0));\n        require (accounts[msg.sender] >= _value);\n\n        accounts[msg.sender] = accounts[msg.sender].sub(_value);\n        if(accounts[msg.sender] == 0){\n            holders.remove(msg.sender);\n        }\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require(_to != address(0));\n        require(_from != address(0));\n        require(_value <= accounts[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        accounts[_from] = accounts[_from].sub(_value);\n        if(accounts[_from] == 0){\n            holders.remove(_from);\n        }\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _old, uint256 _new) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require (_old == allowed[msg.sender][_spender]);\n        require(_spender != address(0));\n\n        allowed[msg.sender][_spender] = _new;\n        emit Approval(msg.sender, _spender, _new);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\n        if (_owner == address(0))\n            return accounts[msg.sender];\n        return accounts[_owner];\n    }\n\n    function totalSupply() external constant returns (uint256 _totalSupply) {\n        _totalSupply = summarySupply;\n    }\n\n    function destroy() minGroup(currentState._owner) external {\n        selfdestruct(msg.sender);\n    }\n\n    function settingsSwitchState() external minGroup(currentState._owner) returns (bool state) {\n\n        if(contractEnable) {\n            currentState._default = 9;\n            currentState._migration = 0;\n            contractEnable = false;\n        } else {\n            currentState._default = 0;\n            currentState._migration = 9;\n            contractEnable = true;\n        }\n\n        return contractEnable;\n    }\n\n    function userMigration(uint256 _secrect) external minGroup(currentState._migration) returns (bool successful) {\n        uint256 balance = accounts[msg.sender];\n\n        require (balance > 0);\n\n        accounts[msg.sender] = accounts[msg.sender].sub(balance);\n        holders.remove(msg.sender);\n        accounts[owner] = accounts[owner].add(balance);\n        holders.push(owner, true);\n        emit EvMigration(msg.sender, balance, _secrect);\n        emit Transfer(msg.sender, owner, balance);\n        return true;\n    }\n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe692762ddbbfffb779ef5f437af9f2b5ea1840272a7e44c0eaeaff7f7ffeffc1\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff0d16d3372e7fef891c155d675f8454ef139e7e6337f8ecf7f827fcf8ffc0ff\nstorage_0: 0xff00\nstorage_11: 0x100\ncalldata_UmkaToken_0: 0x3042b17d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUmkaAddress(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "setUmkaAddress(string)", "lineno": 209, "title": "Integer Overflow ", "type": "Warning"}, {"address": 18589, "code": " public              contractEnable = true;\n\n    uint256 private             summarySupply;\n\n    string  public              name = \"\";\n    string  public              symbol = \"\";\n    uint8   public              decimals = 0;\n\n    mapping(address => uint256)                      private   accounts;\n    mapping(address => string)                       private   umkaAddresses;\n    mapping(address => mapping (address => uint256)) private   allowed;\n    mapping(address => uint8)                        private   group;\n    mapping(bytes32 => uint256)                      private   distribution;\n\n    RingList.LinkedList                              private   holders;\n\n    struct groupPolicy {\n        uint8 _default;\n        uint8 _backend;\n        uint8 _admin;\n        uint8 _migration;\n        uint8 _subowner;\n        uint8 _owner;\n    }\n\n    groupPolicy public currentState = groupPolicy(0, 3, 4, 9, 2, 9);\n\n    event EvGroupChanged(address _address, uint8 _oldgroup, uint8 _newgroup);\n    event EvMigration(address _address, uint256 _balance, uint256 _secret);\n    event Pause();\n    event Unpause();\n\n    constructor (string _name, string _symbol, uint8 _decimals, uint256 _startTokens) public {\n        owner = msg.sender;\n\n        group[owner] = currentState._owner;\n\n        accounts[msg.sender]  = _startTokens;\n\n        holders.push(msg.sender, true);\n        summarySupply    = _startTokens;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        emit Transfer(address(0x0), msg.sender, _startTokens);\n    }\n\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n\n    modifier minGroup(int _require) {\n        require(group[msg.sender] >= _require);\n        _;\n    }\n\n    modifier onlyGroup(int _require) {\n        require(group[msg.sender] == _require);\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused || group[msg.sender] >= currentState._backend);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    function servicePause() minGroup(currentState._admin) whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    function serviceUnpause() minGroup(currentState._admin) whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n    function serviceGroupChange(address _address, uint8 _group) minGroup(currentState._admin) external returns(uint8) {\n        require(_address != address(0));\n\n        uint8 old = group[_address];\n        if(old <= currentState._admin) {\n            group[_address] = _group;\n            emit EvGroupChanged(_address, old, _group);\n        }\n        return group[_address];\n    }\n\n    function serviceTransferOwnership(address newOwner) minGroup(currentState._owner) external {\n        require(newOwner != address(0));\n\n        group[newOwner] = currentState._subowner;\n        group[msg.sender] = currentState._subowner;\n        emit EvGroupChanged(newOwner, currentState._owner, currentState._subowner);\n    }\n\n    function serviceClaimOwnership() onlyGroup(currentState._subowner) external {\n        address temp = owner;\n        uint256 value = accounts[owner];\n\n        accounts[owner] = accounts[owner].sub(value);\n        holders.remove(owner);\n        accounts[msg.sender] = accounts[msg.sender].add(value);\n        holders.push(msg.sender, true);\n\n        owner = msg.sender;\n\n        delete group[temp];\n        group[msg.sender] = currentState._owner;\n\n        emit EvGroupChanged(msg.sender, currentState._subowner, currentState._owner);\n        emit Transfer(temp, owner, value);\n    }\n\n    function serviceIncreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\n        require(_who != address(0));\n        require(_value > 0);\n\n        accounts[_who] = accounts[_who].add(_value);\n        summarySupply = summarySupply.add(_value);\n        holders.push(_who, true);\n        emit Transfer(address(0), _who, _value);\n        return true;\n    }\n\n    function serviceDecreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\n        require(_who != address(0));\n        require(_value > 0);\n        require(accounts[_who] >= _value);\n\n        accounts[_who] = accounts[_who].sub(_value);\n        summarySupply = summarySupply.sub(_value);\n        if(accounts[_who] == 0){\n            holders.remove(_who);\n        }\n        emit Transfer(_who, address(0), _value);\n        return true;\n    }\n\n    function serviceRedirect(address _from, address _to, uint256 _value) minGroup(currentState._admin) external returns(bool){\n        require(_from != address(0));\n        require(_to != address(0));\n        require(_value > 0);\n        require(accounts[_from] >= _value);\n        require(_from != _to);\n\n        accounts[_from] = accounts[_from].sub(_value);\n        if(accounts[_from] == 0){\n            holders.remove(_from);\n        }\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function serviceTokensBurn(address _address) external minGroup(currentState._admin) returns(uint256 balance) {\n        require(_address != address(0));\n        require(accounts[_address] > 0);\n\n        uint256 sum = accounts[_address];\n        accounts[_address] = 0;\n        summarySupply = summarySupply.sub(sum);\n        holders.remove(_address);\n        emit Transfer(_address, address(0), sum);\n        return accounts[_address];\n    }\n\n    function serviceTrasferToDist(bytes32 _to, uint256 _value) external minGroup(currentState._admin) {\n        require(_value > 0);\n        require(accounts[owner] >= _value);\n\n        distribution[_to] = distribution[_to].add(_value);\n        accounts[owner] = accounts[owner].sub(_value);\n        emit Transfer(owner, address(0), _value);\n    }\n\n    function serviceTrasferFromDist(bytes32 _from, address _to, uint256 _value) external minGroup(currentState._backend) {\n        require(_to != address(0));\n        require(_value > 0);\n        require(distribution[_from] >= _value);\n\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        distribution[_from] = distribution[_from].sub(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    function getGroup(address _check) external constant returns(uint8 _group) {\n        return group[_check];\n    }\n\n    function getBalanceOfDist(bytes32 _of) external constant returns(uint256){\n        return distribution[_of];\n    }\n\n    function getHoldersLength() external constant returns(uint256){\n        return holders.sizeOf();\n    }\n\n    function getHolderLink(address _holder) external constant returns(bool, address, address){\n        return holders.getNode(_holder);\n    }\n\n    function getUmkaAddress(address _who) external constant returns(string umkaAddress){\n        return umkaAddresses[_who];\n    }\n\n    function setUmkaAddress(string _umka) minGroup(currentState._default) whenNotPaused external{\n        umkaAddresses[msg.sender] = _umka;\n    }\n\n    function transfer(address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require(_to != address(0));\n        require (accounts[msg.sender] >= _value);\n\n        accounts[msg.sender] = accounts[msg.sender].sub(_value);\n        if(accounts[msg.sender] == 0){\n            holders.remove(msg.sender);\n        }\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require(_to != address(0));\n        require(_from != address(0));\n        require(_value <= accounts[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        accounts[_from] = accounts[_from].sub(_value);\n        if(accounts[_from] == 0){\n            holders.remove(_from);\n        }\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _old, uint256 _new) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require (_old == allowed[msg.sender][_spender]);\n        require(_spender != address(0));\n\n        allowed[msg.sender][_spender] = _new;\n        emit Approval(msg.sender, _spender, _new);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\n        if (_owner == address(0))\n            return accounts[msg.sender];\n        return accounts[_owner];\n    }\n\n    function totalSupply() external constant returns (uint256 _totalSupply) {\n        _totalSupply = summarySupply;\n    }\n\n    function destroy() minGroup(currentState._owner) external {\n        selfdestruct(msg.sender);\n    }\n\n    function settingsSwitchState() external minGroup(currentState._owner) returns (bool state) {\n\n        if(contractEnable) {\n            currentState._default = 9;\n            currentState._migration = 0;\n            contractEnable = false;\n        } else {\n            currentState._default = 0;\n            currentState._migration = 9;\n            contractEnable = true;\n        }\n\n        return contractEnable;\n    }\n\n    function userMigration(uint256 _secrect) external minGroup(currentState._migration) returns (bool successful) {\n        uint256 balance = accounts[msg.sender];\n\n        require (balance > 0);\n\n        accounts[msg.sender] = accounts[msg.sender].sub(balance);\n        holders.remove(msg.sender);\n        accounts[owner] = accounts[owner].add(balance);\n        holders.push(owner, true);\n        emit EvMigration(msg.sender, balance, _secrect);\n        emit Transfer(msg.sender, owner, balance);\n        return true;\n    }\n}", "debug": "calldata_UmkaToken_4 + calldata_UmkaToken_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfe00\nstorage_11: 0x0\ncalldata_UmkaToken_0: 0x3042b17d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUmkaAddress(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "setUmkaAddress(string)", "lineno": 209, "title": "Integer Overflow ", "type": "Warning"}, {"address": 18603, "code": " public              contractEnable = true;\n\n    uint256 private             summarySupply;\n\n    string  public              name = \"\";\n    string  public              symbol = \"\";\n    uint8   public              decimals = 0;\n\n    mapping(address => uint256)                      private   accounts;\n    mapping(address => string)                       private   umkaAddresses;\n    mapping(address => mapping (address => uint256)) private   allowed;\n    mapping(address => uint8)                        private   group;\n    mapping(bytes32 => uint256)                      private   distribution;\n\n    RingList.LinkedList                              private   holders;\n\n    struct groupPolicy {\n        uint8 _default;\n        uint8 _backend;\n        uint8 _admin;\n        uint8 _migration;\n        uint8 _subowner;\n        uint8 _owner;\n    }\n\n    groupPolicy public currentState = groupPolicy(0, 3, 4, 9, 2, 9);\n\n    event EvGroupChanged(address _address, uint8 _oldgroup, uint8 _newgroup);\n    event EvMigration(address _address, uint256 _balance, uint256 _secret);\n    event Pause();\n    event Unpause();\n\n    constructor (string _name, string _symbol, uint8 _decimals, uint256 _startTokens) public {\n        owner = msg.sender;\n\n        group[owner] = currentState._owner;\n\n        accounts[msg.sender]  = _startTokens;\n\n        holders.push(msg.sender, true);\n        summarySupply    = _startTokens;\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        emit Transfer(address(0x0), msg.sender, _startTokens);\n    }\n\n    modifier onlyPayloadSize(uint size) {\n        assert(msg.data.length >= size + 4);\n        _;\n    }\n\n    modifier minGroup(int _require) {\n        require(group[msg.sender] >= _require);\n        _;\n    }\n\n    modifier onlyGroup(int _require) {\n        require(group[msg.sender] == _require);\n        _;\n    }\n\n    modifier whenNotPaused() {\n        require(!paused || group[msg.sender] >= currentState._backend);\n        _;\n    }\n\n    modifier whenPaused() {\n        require(paused);\n        _;\n    }\n\n    function servicePause() minGroup(currentState._admin) whenNotPaused public {\n        paused = true;\n        emit Pause();\n    }\n\n    function serviceUnpause() minGroup(currentState._admin) whenPaused public {\n        paused = false;\n        emit Unpause();\n    }\n\n    function serviceGroupChange(address _address, uint8 _group) minGroup(currentState._admin) external returns(uint8) {\n        require(_address != address(0));\n\n        uint8 old = group[_address];\n        if(old <= currentState._admin) {\n            group[_address] = _group;\n            emit EvGroupChanged(_address, old, _group);\n        }\n        return group[_address];\n    }\n\n    function serviceTransferOwnership(address newOwner) minGroup(currentState._owner) external {\n        require(newOwner != address(0));\n\n        group[newOwner] = currentState._subowner;\n        group[msg.sender] = currentState._subowner;\n        emit EvGroupChanged(newOwner, currentState._owner, currentState._subowner);\n    }\n\n    function serviceClaimOwnership() onlyGroup(currentState._subowner) external {\n        address temp = owner;\n        uint256 value = accounts[owner];\n\n        accounts[owner] = accounts[owner].sub(value);\n        holders.remove(owner);\n        accounts[msg.sender] = accounts[msg.sender].add(value);\n        holders.push(msg.sender, true);\n\n        owner = msg.sender;\n\n        delete group[temp];\n        group[msg.sender] = currentState._owner;\n\n        emit EvGroupChanged(msg.sender, currentState._subowner, currentState._owner);\n        emit Transfer(temp, owner, value);\n    }\n\n    function serviceIncreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\n        require(_who != address(0));\n        require(_value > 0);\n\n        accounts[_who] = accounts[_who].add(_value);\n        summarySupply = summarySupply.add(_value);\n        holders.push(_who, true);\n        emit Transfer(address(0), _who, _value);\n        return true;\n    }\n\n    function serviceDecreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) {\n        require(_who != address(0));\n        require(_value > 0);\n        require(accounts[_who] >= _value);\n\n        accounts[_who] = accounts[_who].sub(_value);\n        summarySupply = summarySupply.sub(_value);\n        if(accounts[_who] == 0){\n            holders.remove(_who);\n        }\n        emit Transfer(_who, address(0), _value);\n        return true;\n    }\n\n    function serviceRedirect(address _from, address _to, uint256 _value) minGroup(currentState._admin) external returns(bool){\n        require(_from != address(0));\n        require(_to != address(0));\n        require(_value > 0);\n        require(accounts[_from] >= _value);\n        require(_from != _to);\n\n        accounts[_from] = accounts[_from].sub(_value);\n        if(accounts[_from] == 0){\n            holders.remove(_from);\n        }\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function serviceTokensBurn(address _address) external minGroup(currentState._admin) returns(uint256 balance) {\n        require(_address != address(0));\n        require(accounts[_address] > 0);\n\n        uint256 sum = accounts[_address];\n        accounts[_address] = 0;\n        summarySupply = summarySupply.sub(sum);\n        holders.remove(_address);\n        emit Transfer(_address, address(0), sum);\n        return accounts[_address];\n    }\n\n    function serviceTrasferToDist(bytes32 _to, uint256 _value) external minGroup(currentState._admin) {\n        require(_value > 0);\n        require(accounts[owner] >= _value);\n\n        distribution[_to] = distribution[_to].add(_value);\n        accounts[owner] = accounts[owner].sub(_value);\n        emit Transfer(owner, address(0), _value);\n    }\n\n    function serviceTrasferFromDist(bytes32 _from, address _to, uint256 _value) external minGroup(currentState._backend) {\n        require(_to != address(0));\n        require(_value > 0);\n        require(distribution[_from] >= _value);\n\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        distribution[_from] = distribution[_from].sub(_value);\n        emit Transfer(address(0), _to, _value);\n    }\n\n    function getGroup(address _check) external constant returns(uint8 _group) {\n        return group[_check];\n    }\n\n    function getBalanceOfDist(bytes32 _of) external constant returns(uint256){\n        return distribution[_of];\n    }\n\n    function getHoldersLength() external constant returns(uint256){\n        return holders.sizeOf();\n    }\n\n    function getHolderLink(address _holder) external constant returns(bool, address, address){\n        return holders.getNode(_holder);\n    }\n\n    function getUmkaAddress(address _who) external constant returns(string umkaAddress){\n        return umkaAddresses[_who];\n    }\n\n    function setUmkaAddress(string _umka) minGroup(currentState._default) whenNotPaused external{\n        umkaAddresses[msg.sender] = _umka;\n    }\n\n    function transfer(address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require(_to != address(0));\n        require (accounts[msg.sender] >= _value);\n\n        accounts[msg.sender] = accounts[msg.sender].sub(_value);\n        if(accounts[msg.sender] == 0){\n            holders.remove(msg.sender);\n        }\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require(_to != address(0));\n        require(_from != address(0));\n        require(_value <= accounts[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        accounts[_from] = accounts[_from].sub(_value);\n        if(accounts[_from] == 0){\n            holders.remove(_from);\n        }\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n        accounts[_to] = accounts[_to].add(_value);\n        holders.push(_to, true);\n        emit Transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _old, uint256 _new) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) {\n        require (_old == allowed[msg.sender][_spender]);\n        require(_spender != address(0));\n\n        allowed[msg.sender][_spender] = _new;\n        emit Approval(msg.sender, _spender, _new);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external constant returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) external constant returns (uint256 balance) {\n        if (_owner == address(0))\n            return accounts[msg.sender];\n        return accounts[_owner];\n    }\n\n    function totalSupply() external constant returns (uint256 _totalSupply) {\n        _totalSupply = summarySupply;\n    }\n\n    function destroy() minGroup(currentState._owner) external {\n        selfdestruct(msg.sender);\n    }\n\n    function settingsSwitchState() external minGroup(currentState._owner) returns (bool state) {\n\n        if(contractEnable) {\n            currentState._default = 9;\n            currentState._migration = 0;\n            contractEnable = false;\n        } else {\n            currentState._default = 0;\n            currentState._migration = 9;\n            contractEnable = true;\n        }\n\n        return contractEnable;\n    }\n\n    function userMigration(uint256 _secrect) external minGroup(currentState._migration) returns (bool successful) {\n        uint256 balance = accounts[msg.sender];\n\n        require (balance > 0);\n\n        accounts[msg.sender] = accounts[msg.sender].sub(balance);\n        holders.remove(msg.sender);\n        accounts[owner] = accounts[owner].add(balance);\n        holders.push(owner, true);\n        emit EvMigration(msg.sender, balance, _secrect);\n        emit Transfer(msg.sender, owner, balance);\n        return true;\n    }\n}", "debug": "calldata_UmkaToken_4: 0x8100083bdfbbb029a4397a9700dbb7fb89fffffffffffffffffffffffffffff1\ncalldata_UmkaToken_4 + calldata_UmkaToken_4: 0x7f11f8b810040ffb60e3fa357f9a4ffa3dffeefe27e7fffbfffffffffffffffd\nstorage_0: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfc00\nstorage_11: 0x100\ncalldata_UmkaToken_0: 0x3042b17d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UmkaToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setUmkaAddress(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/20/0x8e5afc69f6227a3ad75ed346c8723bc62ce97123.sol", "function": "setUmkaAddress(string)", "lineno": 209, "title": "Integer Overflow ", "type": "Warning"}], "success": true}