{"error": null, "issues": [{"address": 331, "code": "game is ready ", "debug": "The exception is triggered under the following conditions:\n\ncallvalue: 0xfbe9fa905fbf660dd4859ad783ff7b8fbfffffffffffefffffffffffff029bef\nstorage_13: 0x6983da8ea00098410c4552b38210761fbfffffffffffeffffffffffff61954d6\nstorage_14: 0x0\nstorage_16: 0x0\nretval_293: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0x1\ncalldatasize_RussianRoulette: 0x3\nstorage_63806209331542711802848847270949280092855778197726125910674179583545433573378 +\nstorage_16 +\n0: 0x0\nblock_number: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "fallback", "lineno": 283, "title": "Exception state", "type": "Informational"}, {"address": 3063, "code": "kpot){\n      ", "debug": "The exception is triggered under the following conditions:\n\nstorage_63806209331542711802848847270949280092855778197726125910674179583545433573378 +\nstorage_16 +\n0: 0x7800\nstorage_14: 0x1\nstorage_16: 0x0\ncallvalue: 0x0\nblock_number: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff87\nstorage_15: 0x1\nstorage_13: 0x0\ncalldatasize_RussianRoulette: 0x3\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "fallback", "lineno": 346, "title": "Exception state", "type": "Informational"}, {"address": 3320, "code": ";\n\n\n/** \nRussian R", "debug": "callvalue: 0xc000000600021c08e001ffffffff000000000310c1ededecea00000003d01e00\nstorage_13: 0x3ffffffc0004e3f61ffe000000004000000000099000000001fffffbfffff6fe\nstorage_14: 0x40000000000000002\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896639: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_16: 0x0\nretval_293: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0x1\ncalldatasize_RussianRoulette: 0x3\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896638: 0x0\nstorage_63806209331542711802848847270949280092855778197726125910674179583545433573378 +\nstorage_16 +\n0: 0x0\nblock_number: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "fallback", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3578, "code": "th = gtf", "debug": "The exception is triggered under the following conditions:\n\ncalldata_RussianRoulette_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\nstorage_14: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "withdraw()", "lineno": 327, "title": "Exception state", "type": "Informational"}, {"address": 4349, "code": " 10);\n        }\n ", "debug": "The exception is triggered under the following conditions:\n\nstorage_15: 0x0\ncalldata_RussianRoulette_4: 0x0\nstorage_16: 0x0\ncalldata_RussianRoulette_0: 0x3c7af09600000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "getUnfinished(uint256)", "lineno": 475, "title": "Exception state", "type": "Informational"}, {"address": 4564, "code": "  3    ether,\n        5    ether,\n        7    ether,\n        10   ether\n    ];\n\n    struct GameToFinish{\n        uint8 game;\n        uint64 blockNumber;\n        uint64 height;\n    }\n\n    Cylinder.Data[] private games;\n    GameToFinish[] private gtf; //Games that are waiting to be finished\n    uint private gtfStart = 0; //", "debug": "The exception is triggered under the following conditions:\n\ncalldata_RussianRoulette_4: 0xe\ncalldata_RussianRoulette_0: 0x92d5a1ae00000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "_function_0x92d5a1ae", "lineno": 243, "title": "Exception state", "type": "Informational"}, {"address": 4626, "code": "        ind", "debug": "The exception is triggered under the following conditions:\n\ncalldata_RussianRoulette_4: 0x0\nstorage_14: 0x0\ncalldata_RussianRoulette_0: 0xd34dfc6800000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "getCylinders(uint256,uint256,uint256)", "lineno": 433, "title": "Exception state", "type": "Informational"}, {"address": 5220, "code": "{\n         ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_RussianRoulette_4: 0x0\nstorage_14: 0x0\ncalldata_RussianRoulette_0: 0xe6dad82400000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "withdrawFrom(uint256)", "lineno": 315, "title": "Exception state", "type": "Informational"}, {"address": 5409, "code": "\n        //", "debug": "The exception is triggered under the following conditions:\n\ncalldata_RussianRoulette_4: 0x0\nstorage_14: 0x0\ncalldata_RussianRoulette_0: 0xec284e0a00000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "_function_0xec284e0a", "lineno": 380, "title": "Exception state", "type": "Informational"}, {"address": 5773, "code": "er-1);\n    ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_RussianRoulette_4: 0x0\nstorage_14: 0x0\ncalldata_RussianRoulette_0: 0xffde0c7400000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "getGameState(uint256)", "lineno": 354, "title": "Exception state", "type": "Informational"}, {"address": 7153, "code": "th){\n                    c.slots[i] = c.slo", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 7246\n", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "withdrawFrom(uint256)", "lineno": 184, "title": "Multiple Calls", "type": "Information"}, {"address": 10227, "code": ",\n        0.5  ether,\n        0.7  ether,\n        1    ether,\n        1.5  ether,\n        2    ether,\n        3    ether,\n        5    ether,\n        7    ether,\n        10   ether\n    ];\n\n    struct GameToFinish{\n        uint8 game;\n        uint64 blockNumber;\n        uint64 height;\n    }\n\n    Cylinder.Data[] private games;\n    GameToFinish[] private gtf; //Games that are waiting to be finished\n    uint private gtfStart = 0; //Starting index of games to finish queue\n\n    constructor() public {\n        Cylinder.checkPercentConsistency();\n        //Initialize games for different bets\n        games.length = BETS.length;\n    }\n\n    function() public payable {\n        //first choose the game on the basis of the bets table\n        for(int i=int(BETS.length)-1; i>=0; i--){\n            uint bet = BETS[uint(i)];\n            if(msg.value >= bet){\n                //Finish the games if there are any waiting\n                finishGames();\n\n                if(msg.value > bet) //return change\n                    msg.sender.transfer(msg.value - bet);\n\n                Cylinder.Data storage game = games[uint(i)];\n                if(game.dep == 0){ //Initialize game data on first deposit\n                    game.dep = bet;\n                }\n\n                uint height = game.currentCylinderHeight;\n                if(game.addDep(msg.sender)){\n                    //The game is ready to be finished\n                    //Put it to finish queue\n                    gtf.push(GameToFinish(uint8(i), uint64(block.number), uint64(height)));\n                }\n                return;\n            }\n        }\n\n        if(msg.value == 0.00000112 ether){\n            withdraw();\n            return;\n        }\n\n        if(msg.value == 0){\n            finishGames();\n            return;\n        }\n\n        revert(\"Deposit is too small\");\n    }\n\n    function withdrawFrom(uint game) public {\n        require(game < BETS.length);\n        require(games[game].withdraw(msg.sender), \"You are not betting in this game\");\n\n        //Finish the games if there are any waiting\n        finishGames();\n    }\n\n    function withdraw() public {\n        uint length = BETS.length;\n        for(uint i=0; i<length; ++i){\n            if(games[i].withdraw(msg.sender)){\n                //Finish the games if there are any waiting\n                finishGames();\n                return;\n            }\n        }\n\n        revert(\"You are not betting in any game\");\n    }\n\n    function finishGames() private {\n        Random.Data memory r;\n        uint length = gtf.length;\n        for(uint i=gtfStart; i<length; ++i){\n            GameToFinish memory g = gtf[i];\n            uint bn = g.blockNumber;\n            if(bn == block.number)\n                break; //We can not finish the game in the same block\n\n            r.init(bn);\n\n            Cylinder.Data storage c = games[g.game];\n            c.finish(g.height, r);\n\n            delete gtf[i];\n        }\n\n        if(i > gtfStart)\n            gtfStart = i;\n    }\n\n    function getGameState(uint game) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 slotsCount, uint64 resultsCount, uint64 currentCylinderIndex, uint96 jackpot){\n        Cylinder.Data storage c = games[game];\n        dep = uint96(c.dep);\n        slotsCount = uint64(c.slots.length);\n        resultsCount = uint64(c.results.length);\n        currentCylinderIndex = uint64(c.currentCylinderHeight/Cylinder.getCapacity());\n        jackpot = uint96(c.jackpot);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n    }\n\n    function getGameStates() public view returns (uint64 blockNumber, bytes32 blockHash, uint96[] dep, uint64[] slotsCount, uint64[] resultsCount, uint64[] currentCylinderIndex, uint96[] jackpot){\n        dep = new uint96[](BETS.length);\n        slotsCount = new uint64[](BETS.length);\n        resultsCount = new uint64[](BETS.length);\n        currentCylinderIndex = new uint64[](BETS.length);\n        jackpot = new uint96[](BETS.length);\n\n        for(uint i=0; i<BETS.length; ++i){\n            (blockNumber, blockHash, dep[i], slotsCount[i], resultsCount[i], currentCylinderIndex[i], jackpot[i]) = getGameState(i);\n        }\n    }\n\n    function getCylinder(uint game, int _idx) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 index, address[] deps, uint8 unlucky, int96 jackpot, uint64 lastDepTime, uint8 status){\n        Cylinder.Data storage c = games[game];\n        index = uint64(_idx < 0 ? c.slots.length/Cylinder.getCapacity() : uint(_idx));\n\n        (dep, index, deps, unlucky, jackpot, lastDepTime) = c.getCylinder(index);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n        //status = 0; //The game is running\n\n        uint8 _unlucky;\n        int96 _jackpot;\n\n        //We will try to get preliminary results of the ready to be finished game\n        (_unlucky, _jackpot, status) = _getGameResults(game, index);\n        if(status == 2){\n            unlucky = _unlucky;\n            jackpot = _jackpot;\n        }\n    }\n\n    function _getGameResults(uint game, uint index) private view returns (uint8 unlucky, int96 jackpot, uint8 status){\n        Cylinder.Data storage c = games[game];\n        if(index < c.results.length){\n            status = 3; //Finished and has finalized results\n        }else if(c.slots.length >= (index+1)*Cylinder.getCapacity()){\n            status = 1; //Closed, but no results yet\n            //This game needs finishing, so try to find out who wins\n            Random.Data memory r;\n            uint length = gtf.length;\n            for(uint i=gtfStart; i<length; ++i){\n                GameToFinish memory g = gtf[i];\n                uint bn = g.blockNumber;\n                if(blockhash(bn) == 0)\n                    break; //We either on the same block or too far from this block\n\n                r.init(bn);\n\n                Cylinder.GameResult memory gr = games[g.game].computeGameResult(g.height, r);\n\n                if(uint(g.height) == index*Cylinder.getCapacity() && uint(g.game) == game){\n                    //We have found our game so just fill the results\n                    unlucky = gr.unlucky;\n                    jackpot = gr.full ? -int96(gr.jackpot) : int96(gr.jackpot); //The jackpot amount may be inaccurate\n                    status = 2; //Closed and has preliminary results\n                    break;\n                }\n            }\n        }\n    }\n\n    function getCylinders(uint game, uint idxFrom, uint idxTo) public view returns (uint blockNumber, bytes32 blockHash, uint96 dep, uint64[] index, address[] deps, uint8[] unlucky, int96[] jackpot, uint64[] lastDepTime, uint8[] status){\n        Cylinder.Data storage c = games[game];\n        uint lastCylinderIndex = c.slots.length/Cylinder.getCapacity();\n        blockNumber = block.number-1;\n        blockHash = blockhash(block.number-1);\n        dep = uint96(c.dep);\n\n        require(idxFrom <= lastCylinderIndex && idxFrom <= idxTo, \"Wrong cylinder index range\");\n\n        if(idxTo > lastCylinderIndex)\n            idxTo = lastCylinderIndex;\n\n        uint count = idxTo - idxFrom + 1;\n\n        index = new uint64[](count);\n        deps = new address[](count*Cylinder.getCapacity());\n        unlucky = new uint8[](count);\n        jackpot = new int96[](count);\n        lastDepTime = new uint64[](count);\n        status = new uint8[](count);\n\n        _putCylindersToArrays(game, idxFrom, count, index, deps, unlucky, jackpot, lastDepTime, status);\n    }\n\n    function _putCylindersToArrays(uint game, uint idxFrom, uint count, uint64[] index, address[] deps, uint8[] unlucky, int96[] jackpot, uint64[] lastDepTime, uint8[] status) private view {\n        for(uint i=0; i<count; ++i){\n            address[] memory _deps;\n            (, , , index[i], _deps, unlucky[i], jackpot[i], lastDepTime[i], status[i]) = getCylinder(game, int(idxFrom + i));\n            _copyDeps(i*Cylinder.getCapacity(), deps, _deps);\n        }\n    }\n\n    function _copyDeps(uint start, address[] deps, address[] memory _deps) private pure {\n        for(uint j=0; j<_deps.length; ++j){\n            deps[start + j] = _deps[j];\n        }\n    }\n\n    function getUnfinishedCount() public view returns (uint) {\n        return gtf.length - gtfStart;\n    }\n\n    function getUnfinished(uint i) public view returns (uint game, uint blockNumber, uint cylinder) {\n        game = gtf[gtfStart + i].game;\n        blockNumber = gtf[gtfStart + i].blockNumber;\n        cylinder = gtf[gtfStart + i].height/Cylinder.getCapacity();\n    }\n\n    function getTotalCylindersCount() public view returns (uint) {\n        return gtf.length;\n    }\n\n    function testRandom() public view returns (uint[] numbers) {\n        numbers = new uint[](32);\n        Random.Data memory r;\n        for(uint i=0; i<256; i+=8){\n            numbers[i/8] = Random.random(r, 10);\n        }\n    }\n}", "debug": "storage_84800337471693920904250232874319843718400766719524250287777680170677855896574: 0xf800000000000000000000000000000000000000000000000000000000000000\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896576: 0x2002eeb7ffc07fffffffffffffa0000000000003fffffffffffffffffffffff\nretval_7246: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_7153: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_0 +\n18940601526244221442472567336879010336403038740184106260379442626829811865710 +\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896576: 0x0\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_RussianRoulette_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `withdraw()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "withdraw()", "lineno": 237, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10229, "code": ",\n        0.5  ether,\n        0.7  ether,\n        1    ether,\n        1.5  ether,\n        2    ether,\n        3    ether,\n        5    ether,\n        7    ether,\n        10   ether\n    ];\n\n    struct GameToFinish{\n        uint8 game;\n        uint64 blockNumber;\n        uint64 height;\n    }\n\n    Cylinder.Data[] private games;\n    GameToFinish[] private gtf; //Games that are waiting to be finished\n    uint private gtfStart = 0; //Starting index of games to finish queue\n\n    constructor() public {\n        Cylinder.checkPercentConsistency();\n        //Initialize games for different bets\n        games.length = BETS.length;\n    }\n\n    function() public payable {\n        //first choose the game on the basis of the bets table\n        for(int i=int(BETS.length)-1; i>=0; i--){\n            uint bet = BETS[uint(i)];\n            if(msg.value >= bet){\n                //Finish the games if there are any waiting\n                finishGames();\n\n                if(msg.value > bet) //return change\n                    msg.sender.transfer(msg.value - bet);\n\n                Cylinder.Data storage game = games[uint(i)];\n                if(game.dep == 0){ //Initialize game data on first deposit\n                    game.dep = bet;\n                }\n\n                uint height = game.currentCylinderHeight;\n                if(game.addDep(msg.sender)){\n                    //The game is ready to be finished\n                    //Put it to finish queue\n                    gtf.push(GameToFinish(uint8(i), uint64(block.number), uint64(height)));\n                }\n                return;\n            }\n        }\n\n        if(msg.value == 0.00000112 ether){\n            withdraw();\n            return;\n        }\n\n        if(msg.value == 0){\n            finishGames();\n            return;\n        }\n\n        revert(\"Deposit is too small\");\n    }\n\n    function withdrawFrom(uint game) public {\n        require(game < BETS.length);\n        require(games[game].withdraw(msg.sender), \"You are not betting in this game\");\n\n        //Finish the games if there are any waiting\n        finishGames();\n    }\n\n    function withdraw() public {\n        uint length = BETS.length;\n        for(uint i=0; i<length; ++i){\n            if(games[i].withdraw(msg.sender)){\n                //Finish the games if there are any waiting\n                finishGames();\n                return;\n            }\n        }\n\n        revert(\"You are not betting in any game\");\n    }\n\n    function finishGames() private {\n        Random.Data memory r;\n        uint length = gtf.length;\n        for(uint i=gtfStart; i<length; ++i){\n            GameToFinish memory g = gtf[i];\n            uint bn = g.blockNumber;\n            if(bn == block.number)\n                break; //We can not finish the game in the same block\n\n            r.init(bn);\n\n            Cylinder.Data storage c = games[g.game];\n            c.finish(g.height, r);\n\n            delete gtf[i];\n        }\n\n        if(i > gtfStart)\n            gtfStart = i;\n    }\n\n    function getGameState(uint game) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 slotsCount, uint64 resultsCount, uint64 currentCylinderIndex, uint96 jackpot){\n        Cylinder.Data storage c = games[game];\n        dep = uint96(c.dep);\n        slotsCount = uint64(c.slots.length);\n        resultsCount = uint64(c.results.length);\n        currentCylinderIndex = uint64(c.currentCylinderHeight/Cylinder.getCapacity());\n        jackpot = uint96(c.jackpot);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n    }\n\n    function getGameStates() public view returns (uint64 blockNumber, bytes32 blockHash, uint96[] dep, uint64[] slotsCount, uint64[] resultsCount, uint64[] currentCylinderIndex, uint96[] jackpot){\n        dep = new uint96[](BETS.length);\n        slotsCount = new uint64[](BETS.length);\n        resultsCount = new uint64[](BETS.length);\n        currentCylinderIndex = new uint64[](BETS.length);\n        jackpot = new uint96[](BETS.length);\n\n        for(uint i=0; i<BETS.length; ++i){\n            (blockNumber, blockHash, dep[i], slotsCount[i], resultsCount[i], currentCylinderIndex[i], jackpot[i]) = getGameState(i);\n        }\n    }\n\n    function getCylinder(uint game, int _idx) public view returns (uint64 blockNumber, bytes32 blockHash, uint96 dep, uint64 index, address[] deps, uint8 unlucky, int96 jackpot, uint64 lastDepTime, uint8 status){\n        Cylinder.Data storage c = games[game];\n        index = uint64(_idx < 0 ? c.slots.length/Cylinder.getCapacity() : uint(_idx));\n\n        (dep, index, deps, unlucky, jackpot, lastDepTime) = c.getCylinder(index);\n        blockNumber = uint64(block.number-1);\n        blockHash = blockhash(block.number-1);\n        //status = 0; //The game is running\n\n        uint8 _unlucky;\n        int96 _jackpot;\n\n        //We will try to get preliminary results of the ready to be finished game\n        (_unlucky, _jackpot, status) = _getGameResults(game, index);\n        if(status == 2){\n            unlucky = _unlucky;\n            jackpot = _jackpot;\n        }\n    }\n\n    function _getGameResults(uint game, uint index) private view returns (uint8 unlucky, int96 jackpot, uint8 status){\n        Cylinder.Data storage c = games[game];\n        if(index < c.results.length){\n            status = 3; //Finished and has finalized results\n        }else if(c.slots.length >= (index+1)*Cylinder.getCapacity()){\n            status = 1; //Closed, but no results yet\n            //This game needs finishing, so try to find out who wins\n            Random.Data memory r;\n            uint length = gtf.length;\n            for(uint i=gtfStart; i<length; ++i){\n                GameToFinish memory g = gtf[i];\n                uint bn = g.blockNumber;\n                if(blockhash(bn) == 0)\n                    break; //We either on the same block or too far from this block\n\n                r.init(bn);\n\n                Cylinder.GameResult memory gr = games[g.game].computeGameResult(g.height, r);\n\n                if(uint(g.height) == index*Cylinder.getCapacity() && uint(g.game) == game){\n                    //We have found our game so just fill the results\n                    unlucky = gr.unlucky;\n                    jackpot = gr.full ? -int96(gr.jackpot) : int96(gr.jackpot); //The jackpot amount may be inaccurate\n                    status = 2; //Closed and has preliminary results\n                    break;\n                }\n            }\n        }\n    }\n\n    function getCylinders(uint game, uint idxFrom, uint idxTo) public view returns (uint blockNumber, bytes32 blockHash, uint96 dep, uint64[] index, address[] deps, uint8[] unlucky, int96[] jackpot, uint64[] lastDepTime, uint8[] status){\n        Cylinder.Data storage c = games[game];\n        uint lastCylinderIndex = c.slots.length/Cylinder.getCapacity();\n        blockNumber = block.number-1;\n        blockHash = blockhash(block.number-1);\n        dep = uint96(c.dep);\n\n        require(idxFrom <= lastCylinderIndex && idxFrom <= idxTo, \"Wrong cylinder index range\");\n\n        if(idxTo > lastCylinderIndex)\n            idxTo = lastCylinderIndex;\n\n        uint count = idxTo - idxFrom + 1;\n\n        index = new uint64[](count);\n        deps = new address[](count*Cylinder.getCapacity());\n        unlucky = new uint8[](count);\n        jackpot = new int96[](count);\n        lastDepTime = new uint64[](count);\n        status = new uint8[](count);\n\n        _putCylindersToArrays(game, idxFrom, count, index, deps, unlucky, jackpot, lastDepTime, status);\n    }\n\n    function _putCylindersToArrays(uint game, uint idxFrom, uint count, uint64[] index, address[] deps, uint8[] unlucky, int96[] jackpot, uint64[] lastDepTime, uint8[] status) private view {\n        for(uint i=0; i<count; ++i){\n            address[] memory _deps;\n            (, , , index[i], _deps, unlucky[i], jackpot[i], lastDepTime[i], status[i]) = getCylinder(game, int(idxFrom + i));\n            _copyDeps(i*Cylinder.getCapacity(), deps, _deps);\n        }\n    }\n\n    function _copyDeps(uint start, address[] deps, address[] memory _deps) private pure {\n        for(uint j=0; j<_deps.length; ++j){\n            deps[start + j] = _deps[j];\n        }\n    }\n\n    function getUnfinishedCount() public view returns (uint) {\n        return gtf.length - gtfStart;\n    }\n\n    function getUnfinished(uint i) public view returns (uint game, uint blockNumber, uint cylinder) {\n        game = gtf[gtfStart + i].game;\n        blockNumber = gtf[gtfStart + i].blockNumber;\n        cylinder = gtf[gtfStart + i].height/Cylinder.getCapacity();\n    }\n\n    function getTotalCylindersCount() public view returns (uint) {\n        return gtf.length;\n    }\n\n    function testRandom() public view returns (uint[] numbers) {\n        numbers = new uint[](32);\n        Random.Data memory r;\n        for(uint i=0; i<256; i+=8){\n            numbers[i/8] = Random.random(r, 10);\n        }\n    }\n}", "debug": "storage_84800337471693920904250232874319843718400766719524250287777680170677855896574: 0xeb00000000000000000000000000000000000000000000000000000000000000\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896576: 0xffffffffffffffffffffffffffffffffffffffffffffff\nretval_7246: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_7153: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_0 +\n18940601526244221442472567336879010336403038740184106260379442626829811865710 +\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896576: 0x0\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_RussianRoulette_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_RussianRoulette: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `withdraw()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x0ab2c9e20aa31fd3a3728a86f2526cca06a2b76d.sol", "function": "withdraw()", "lineno": 237, "title": "Integer Overflow ", "type": "Warning"}], "success": true}