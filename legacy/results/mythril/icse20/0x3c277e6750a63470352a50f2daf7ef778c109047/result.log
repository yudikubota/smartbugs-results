{"error": null, "issues": [{"address": 3617, "code": " onlyAdmin {\n\t    if (msg.s", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_EthermiumTokenList_0: 0xb78f9c000000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "setFees(uint256,uint256)", "lineno": 52, "title": "Exception state", "type": "Informational"}, {"address": 3790, "code": " onlyAdmin {\n\t    if (msg.s", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_EthermiumTokenList_0: 0x13af403500000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "setOwner(address)", "lineno": 52, "title": "Exception state", "type": "Informational"}, {"address": 3983, "code": " onlyAdmin {\n\t    if (msg.s", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_EthermiumTokenList_0: 0x4b023cf800000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "setFeeAccount(address)", "lineno": 52, "title": "Exception state", "type": "Informational"}, {"address": 4139, "code": " onlyAdmin {\n\t    if (msg.s", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_EthermiumTokenList_0: 0x4b0bddd200000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "setAdmin(address,bool)", "lineno": 52, "title": "Exception state", "type": "Informational"}, {"address": 6276, "code": "g(address => Token) public", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthermiumTokenList_4: 0x0\nstorage_3: 0x0\ncalldata_EthermiumTokenList_0: 0x9ead722200000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "_function_0x9ead7222", "lineno": 37, "title": "Exception state", "type": "Informational"}, {"address": 8001, "code": "= a);\n\t    ret", "debug": "The exception is triggered under the following conditions:\n\ncalldata_EthermiumTokenList_4: 0x0\ncalldata_EthermiumTokenList_32 + 4: 0x1\ncalldata_EthermiumTokenList_0: 0xa293d1e800000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "safeSub(uint256,uint256)", "lineno": 11, "title": "Exception state", "type": "Informational"}, {"address": 11658, "code": "ntract EthermiumTokenList {\n\tfunction safeMul(uint a, uint b) returns (uint) {\n\t    uint c = a * b;\n\t    assert(a == 0 || c / a == b);\n\t    return c;\n\t}\n\n\tfunction safeSub(uint a, uint b) returns (uint) {\n\t    assert(b <= a);\n\t    return a - b;\n\t}\n\n\tfunction safeAdd(uint a, uint b) returns (uint) {\n\t    uint c = a + b;\n\t    assert(c>=a && c>=b);\n\t    return c;\n\t}\n\t\n\tstruct Token {\n\t\taddress tokenAddress; // token ethereum address\n\t\tuint256 decimals; // number of token decimals\n\t\tstring url; // token website url\n\t\tstring symbol; // token symbol\n\t\tstring name; // token name\n\t\tstring logoUrl; // link to logo\n\t\tbool verified; // true if the url was verified\n\t\taddress owner; // address from which the token was added\n\t\tbool enabled; // owner of the token can disable it\n\t}\n\n\taddress public owner;\n\tmapping (address => bool) public admins;\n\taddress public feeAccount;\n\taddress[] public tokenList;\n\tmapping(address => Token) public tokens; \n\tuint256 public listTokenFee; // in wei per block\n\tuint256 public modifyTokenFee; // in wei\n\n\tevent TokenAdded(address tokenAddress, uint256 decimals, string url, string symbol, string name, address owner, string logoUrl);\n\tevent TokenModified(address tokenAddress, uint256 decimals, string url, string symbol, string name, bool enabled, string logoUrl);\n\tevent FeeChange(uint256 listTokenFee, uint256 modifyTokenFee);\n\tevent TokenVerify(address tokenAddress, bool verified);\n\tevent TokenOwnerChanged(address tokenAddress, address newOwner);\n\n\tmodifier onlyOwner {\n\t\tassert(msg.sender == owner);\n\t\t_;\n\t}\n\n\tmodifier onlyAdmin {\n\t    if (msg.sender != owner && !admins[msg.sender]) throw;\n\t    _;\n\t}\n\n\tfunction setAdmin(address admin, bool isAdmin) public onlyOwner {\n    \tadmins[admin] = isAdmin;\n  \t}\n\n  \tfunction setOwner(address newOwner) public onlyOwner {\n\t    owner = newOwner;\n\t}\n\n\tfunction setFeeAccount(address feeAccount_) public onlyOwner {\n\t    feeAccount = feeAccount_;\n\t}\n\n\tfunction setFees(uint256 listTokenFee_, uint256 modifyTokenFee_) public onlyOwner\n\t{\n\t\tlistTokenFee = listTokenFee_;\n\t\tmodifyTokenFee = modifyTokenFee_;\n\t\tFeeChange(listTokenFee, modifyTokenFee);\n\t}\n\n\t\n\n\tfunction EthermiumTokenList (address owner_, address feeAccount_, uint256 listTokenFee_, uint256 modifyTokenFee_)\n\t{\n\t\towner = owner_;\n\t\tfeeAccount = feeAccount_;\n\t\tlistTokenFee = listTokenFee_;\n\t\tmodifyTokenFee = modifyTokenFee_;\n\t}\n\n\n\tfunction addToken(address tokenAddress, uint256 decimals, string url, string symbol, string name, string logoUrl) public payable\n\t{\n\t\trequire(tokens[tokenAddress].tokenAddress == address(0x0));\n\t\tif (msg.sender != owner && !admins[msg.sender])\n\t\t{\n\t\t\trequire(msg.value >= listTokenFee);\n\t\t}\n\n\t\ttokens[tokenAddress] = Token({\n\t\t\ttokenAddress: tokenAddress, \n\t\t\tdecimals: decimals,\n\t\t\turl: url,\n\t\t\tsymbol: symbol,\n\t\t\tname: name,\n\t\t\tverified: false,\n\t\t\towner: msg.sender,\n\t\t\tenabled: true,\n\t\t\tlogoUrl: logoUrl\n\t\t});\n\t\t\n\t\tif (!feeAccount.send(msg.value)) throw;\n\t\ttokenList.push(tokenAddress);\n\t\tTokenAdded(tokenAddress, decimals, url, symbol, name, msg.sender, logoUrl);\n\t}\n\n\tfunction modifyToken(address tokenAddress, uint256 decimals, string url, string symbol, string name,  string logoUrl, bool enabled) public payable\n\t{\n\t\trequire(tokens[tokenAddress].tokenAddress != address(0x0));\n\t\trequire(msg.sender == tokens[tokenAddress].owner);\n\n\t\tif (keccak256(url) != keccak256(tokens[tokenAddress].url))\n\t\t\ttokens[tokenAddress].verified = false;\n\n\t\ttokens[tokenAddress].decimals = decimals;\n\t\ttokens[tokenAddress].url = url;\n\t\ttokens[tokenAddress].symbol = symbol;\n\t\ttokens[tokenAddress].name = name;\n\t\ttokens[tokenAddress].enabled = enabled;\n\t\ttokens[tokenAddress].logoUrl = logoUrl;\n\n\t\tTokenModified(tokenAddress, decimals, url, symbol, name, enabled, logoUrl);\n\t}\n\n\tfunction changeOwner(address tokenAddress, address newOwner) public\n\t{\n\t\trequire(tokens[tokenAddress].tokenAddress != address(0x0));\n\t\trequire(msg.sender == tokens[tokenAddress].owner || msg.sender == owner);\n\n\t\ttokens[tokenAddress].owner = newOwner;\n\n\t\tTokenOwnerChanged(tokenAddress, newOwner);\n\t}\n\n\tfunction setVerified(address tokenAddress, bool verified_) onlyAdmin public\n\t{\n\t\trequire(tokens[tokenAddress].tokenAddress != address(0x0));\n\n\t\ttokens[tokenAddress].verified = verified_;\n\n\t\tTokenVerify(tokenAddress, verified_);\n\t}\n\n\tfunction isTokenInList(address tokenAddress) public constant returns (bool)\n\t{\n\t\tif (tokens[tokenAddress].tokenAddress != address(0x0))\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction getToken(address tokenAddress) public constant returns ( uint256, string, string, string, bool, string)\n\t{\n\t\trequire(tokens[tokenAddress].tokenAddress != address(0x0));\n\t\t\n\t\treturn ( \n\t\t\ttokens[tokenAddress].decimals, \n\t\t\ttokens[tokenAddress].url,\n\t\t\ttokens[tokenAddress].symbol,\n\t\t\ttokens[tokenAddress].name,\n\t\t\ttokens[tokenAddress].enabled,\n\t\t\ttokens[tokenAddress].logoUrl\n\t\t);\n\t}\n\n\tfunction getTokenCount() public constant returns(uint count)\n\t{\n\t\treturn tokenList.length;\n\t}\n\n\tfunction isTokenVerified(address tokenAddress) public constant returns (bool)\n\t{\n\t\tif (tokens[tokenAddress].tokenAddress != address(0x0) && tokens[tokenAddress].verified)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t}\n\n}", "debug": "mem_mem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_EthermiumTokenList_4 + calldata_EthermiumTokenList_32 + 36)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_EthermiumTokenList_4 + calldata_EthermiumTokenList_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_EthermiumTokenList_4 + calldata_EthermiumTokenList_32 + 100)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_EthermiumTokenList_4 + calldata_EthermiumTokenList_32 + 132)) +\n64: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EthermiumTokenList_4: 0x0\ncalldata_EthermiumTokenList_0: 0xa105785200000000000000000000000000000000000000000000000000000000\ncalldatasize_EthermiumTokenList: 0x4\n", "description": "A possible integer overflow exists in the function `addToken(address,uint256,string,string,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x3c277e6750a63470352a50f2daf7ef778c109047.sol", "function": "addToken(address,uint256,string,string,string,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}