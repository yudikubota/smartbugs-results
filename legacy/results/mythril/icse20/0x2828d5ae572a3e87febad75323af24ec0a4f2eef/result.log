{"error": null, "issues": [{"address": 1215, "code": ";\n\n/*\nGame Name: C", "debug": "storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x5eb19eda00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `InitiatePlanets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "InitiatePlanets()", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1267, "code": "InitiatePlanets() public onlyCeo {\n        require(planetsAreI", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x2289115b00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createPlanet(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "createPlanet(string,uint256)", "lineno": 152, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1430, "code": "      curResources", "debug": "The exception is triggered under the following conditions:\n\ncalldata_CryptoPlanets_4: 0x0\nstorage_1: 0x0\ncalldata_CryptoPlanets_0: 0x34efcb8e00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "getPlanet(uint256)", "lineno": 140, "title": "Exception state", "type": "Informational"}, {"address": 2067, "code": "nction purchaseDefense() payable", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_1970: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoPlanets_0: 0x3be9421900000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\nstorage_5: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `purchaseAttack()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "purchaseAttack()", "lineno": 85, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2192, "code": "s\n        require(", "debug": "The exception is triggered under the following conditions:\n\ncalldata_CryptoPlanets_4: 0x0\nstorage_1: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoPlanets_0: 0x4a7510fc00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "StealResources(uint256)", "lineno": 102, "title": "Exception state", "type": "Informational"}, {"address": 2653, "code": "r\n         ", "debug": "storage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoPlanets_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_1_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n4*calldata_CryptoPlanets_4,\n_____256): 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_3 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n4*calldata_CryptoPlanets_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_1 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n4*calldata_CryptoPlanets_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_1: 0x1\ncalldata_CryptoPlanets_0: 0x4a7510fc00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `StealResources(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "StealResources(uint256)", "lineno": 111, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3639, "code": "culate the 5% valu", "debug": "The exception is triggered under the following conditions:\n\ncalldata_CryptoPlanets_4: 0x0\nstorage_1: 0x0\ncalldata_CryptoPlanets_0: 0xb7a40f2100000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "purchasePlanet(uint256)", "lineno": 48, "title": "Exception state", "type": "Informational"}, {"address": 3818, "code": "wner);\n\n        // Reduce number of planets for previous ", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4255\n", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "purchasePlanet(uint256)", "lineno": 53, "title": "Multiple Calls", "type": "Information"}, {"address": 3818, "code": "wner);\n\n        // Reduce number of planets for previous ", "debug": "", "description": "A possible transaction order independence vulnerability exists in function purchasePlanet(uint256). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "purchasePlanet(uint256)", "lineno": 53, "title": "Transaction order dependence", "type": "Warning"}, {"address": 3972, "code": "1;\n\n        // Keep 5% in the resources of the planet\n  ", "debug": "calldata_CryptoPlanets_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_1_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n4*calldata_CryptoPlanets_4,\n_____256): 0x0\nretval_3818: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x1\ncalldata_CryptoPlanets_0: 0xb7a40f2100000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\nstorage_2 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n4*calldata_CryptoPlanets_4: 0x0\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `purchasePlanet(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "purchasePlanet(uint256)", "lineno": 56, "title": "Integer Underflow", "type": "Warning"}, {"address": 4821, "code": "     // Verify that the address a", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_4724: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoPlanets_0: 0xcb1c8b6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\nstorage_6: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `purchaseDefense()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "purchaseDefense()", "lineno": 96, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5125, "code": "ryptoPlanets {\n\n    address ceoAddress = 0x8e6DBF31540d2299a674b8240596ae85ebD21314;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Planet {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curResources;\n    }\n    Planet[] planets;\n\n\n    // How many shares an addres own\n    mapping (address => uint) public addressPlanetsCount;\n    mapping (address => uint) public addressAttackCount;\n    mapping (address => uint) public addressDefenseCount;\n    \n\n    uint256 attackCost = 10000000000000000;\n    uint256 defenseCost = 10000000000000000;\n    \n    uint randNonce = 0;\n    bool planetsAreInitiated;\n\n    /*\n    This function allows players to purchase planets from other players. \n    The price of the planets is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchasePlanet(uint _planetId) public payable {\n        require(msg.value == planets[_planetId].curPrice);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - (commission5percent * 2); // => 95%\n        planets[_planetId].ownerAddress.transfer(commissionOwner);\n\n        // Reduce number of planets for previous owner\n        addressPlanetsCount[planets[_planetId].ownerAddress] = addressPlanetsCount[planets[_planetId].ownerAddress] - 1;\n\n        // Keep 5% in the resources of the planet\n        planets[_planetId].curResources =  planets[_planetId].curResources + commission5percent;\n\n        // Transfer the 5% commission to the developer\n        ceoAddress.transfer(commission5percent);                  \n\n        // Update the planet owner and set the new price\n        planets[_planetId].ownerAddress = msg.sender;\n        planets[_planetId].curPrice = planets[_planetId].curPrice + (planets[_planetId].curPrice / 2);\n\n        // Increment number of planets for new owner\n        addressPlanetsCount[msg.sender] = addressPlanetsCount[msg.sender] + 1;\n    }\n\n    //User is purchasing attack\n    function purchaseAttack() payable {\n\n        // Verify that user is paying the correct price\n        require(msg.value == attackCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n\n        addressAttackCount[msg.sender]++;\n    }\n\n    //User is purchasing defense\n    function purchaseDefense() payable {\n        // Verify that user is paying the correct price\n        require(msg.value == defenseCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n        \n        addressDefenseCount[msg.sender]++;\n    }\n\n    function StealResources(uint _planetId) {\n        // Verify that the address actually own a planet\n        require(addressPlanetsCount[msg.sender] > 0);\n\n        // We verify that this address doesn't own this planet\n        require(planets[_planetId].ownerAddress != msg.sender);\n\n        // We verify that this planet has resources\n        require(planets[_planetId].curResources > 0);\n\n        // Transfer a random amount of resources (between 1% and 90%) of the resources of the planet to the stealer if it's attack is better than the planet's owner defense\n        if(addressAttackCount[msg.sender] > addressDefenseCount[planets[_planetId].ownerAddress]) {\n            // Generate a random number between 1 and 49\n            uint random = uint(keccak256(now, msg.sender, randNonce)) % 49;\n            randNonce++;\n            \n            // Calculate and transfer the random amount of resources to the stealer\n            uint256 resourcesStealable = (planets[_planetId].curResources * (50 + random)) / 100;\n            msg.sender.transfer(resourcesStealable);\n            \n            // Save the new resources count\n            planets[_planetId].curResources = planets[_planetId].curResources - resourcesStealable;\n        }\n\n    }\n    \n    // This function will return the details for the connected user (planets count, attack count, defense count)\n    function getUserDetails(address _user) public view returns(uint, uint, uint) {\n        return(addressPlanetsCount[_user], addressAttackCount[_user], addressDefenseCount[_user]);\n    }\n    \n    // This function will return the details of a planet\n    function getPlanet(uint _planetId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curResources,\n        uint ownerAttack,\n        uint ownerDefense\n    ) {\n        Planet storage _planet = planets[_planetId];\n\n        name = _planet.name;\n        ownerAddress = _planet.ownerAddress;\n        curPrice = _planet.curPrice;\n        curResources = _planet.curResources;\n        ownerAttack = addressAttackCount[_planet.ownerAddress];\n        ownerDefense = addressDefenseCount[_planet.ownerAddress];\n    }\n    \n    \n    // The dev can use this function to create new planets.\n    function createPlanet(string _planetName, uint256 _planetPrice) public onlyCeo {\n        uint planetId = planets.push(Planet(_planetName, ceoAddress, _planetPrice, 0)) - 1;\n    }\n    \n    // Initiate functions that will create the planets\n    function InitiatePlanets() public onlyCeo {\n        require(planetsAreInitiated == false);\n        createPlanet(\"Blue Lagoon\", 100000000000000000); \n        createPlanet(\"GreenPeace\", 100000000000000000); \n        createPlanet(\"Medusa\", 100000000000000000); \n        createPlanet(\"O'Ranger\", 100000000000000000); \n        createPlanet(\"Queen\", 90000000000000000); \n        createPlanet(\"Citrus\", 90000000000000000); \n        createPlanet(\"O'Ranger II\", 90000000000000000); \n        createPlanet(\"Craterion\", 50000000000000000);\n        createPlanet(\"Dark'Air\", 50000000000000000);\n\n    }\n}", "debug": "keccac_0_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n4*storage_1: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n4*storage_1: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_8: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x5eb19eda00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `InitiatePlanets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "InitiatePlanets()", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5154, "code": "ryptoPlanets {\n\n    address ceoAddress = 0x8e6DBF31540d2299a674b8240596ae85ebD21314;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Planet {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curResources;\n    }\n    Planet[] planets;\n\n\n    // How many shares an addres own\n    mapping (address => uint) public addressPlanetsCount;\n    mapping (address => uint) public addressAttackCount;\n    mapping (address => uint) public addressDefenseCount;\n    \n\n    uint256 attackCost = 10000000000000000;\n    uint256 defenseCost = 10000000000000000;\n    \n    uint randNonce = 0;\n    bool planetsAreInitiated;\n\n    /*\n    This function allows players to purchase planets from other players. \n    The price of the planets is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchasePlanet(uint _planetId) public payable {\n        require(msg.value == planets[_planetId].curPrice);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - (commission5percent * 2); // => 95%\n        planets[_planetId].ownerAddress.transfer(commissionOwner);\n\n        // Reduce number of planets for previous owner\n        addressPlanetsCount[planets[_planetId].ownerAddress] = addressPlanetsCount[planets[_planetId].ownerAddress] - 1;\n\n        // Keep 5% in the resources of the planet\n        planets[_planetId].curResources =  planets[_planetId].curResources + commission5percent;\n\n        // Transfer the 5% commission to the developer\n        ceoAddress.transfer(commission5percent);                  \n\n        // Update the planet owner and set the new price\n        planets[_planetId].ownerAddress = msg.sender;\n        planets[_planetId].curPrice = planets[_planetId].curPrice + (planets[_planetId].curPrice / 2);\n\n        // Increment number of planets for new owner\n        addressPlanetsCount[msg.sender] = addressPlanetsCount[msg.sender] + 1;\n    }\n\n    //User is purchasing attack\n    function purchaseAttack() payable {\n\n        // Verify that user is paying the correct price\n        require(msg.value == attackCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n\n        addressAttackCount[msg.sender]++;\n    }\n\n    //User is purchasing defense\n    function purchaseDefense() payable {\n        // Verify that user is paying the correct price\n        require(msg.value == defenseCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n        \n        addressDefenseCount[msg.sender]++;\n    }\n\n    function StealResources(uint _planetId) {\n        // Verify that the address actually own a planet\n        require(addressPlanetsCount[msg.sender] > 0);\n\n        // We verify that this address doesn't own this planet\n        require(planets[_planetId].ownerAddress != msg.sender);\n\n        // We verify that this planet has resources\n        require(planets[_planetId].curResources > 0);\n\n        // Transfer a random amount of resources (between 1% and 90%) of the resources of the planet to the stealer if it's attack is better than the planet's owner defense\n        if(addressAttackCount[msg.sender] > addressDefenseCount[planets[_planetId].ownerAddress]) {\n            // Generate a random number between 1 and 49\n            uint random = uint(keccak256(now, msg.sender, randNonce)) % 49;\n            randNonce++;\n            \n            // Calculate and transfer the random amount of resources to the stealer\n            uint256 resourcesStealable = (planets[_planetId].curResources * (50 + random)) / 100;\n            msg.sender.transfer(resourcesStealable);\n            \n            // Save the new resources count\n            planets[_planetId].curResources = planets[_planetId].curResources - resourcesStealable;\n        }\n\n    }\n    \n    // This function will return the details for the connected user (planets count, attack count, defense count)\n    function getUserDetails(address _user) public view returns(uint, uint, uint) {\n        return(addressPlanetsCount[_user], addressAttackCount[_user], addressDefenseCount[_user]);\n    }\n    \n    // This function will return the details of a planet\n    function getPlanet(uint _planetId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curResources,\n        uint ownerAttack,\n        uint ownerDefense\n    ) {\n        Planet storage _planet = planets[_planetId];\n\n        name = _planet.name;\n        ownerAddress = _planet.ownerAddress;\n        curPrice = _planet.curPrice;\n        curResources = _planet.curResources;\n        ownerAttack = addressAttackCount[_planet.ownerAddress];\n        ownerDefense = addressDefenseCount[_planet.ownerAddress];\n    }\n    \n    \n    // The dev can use this function to create new planets.\n    function createPlanet(string _planetName, uint256 _planetPrice) public onlyCeo {\n        uint planetId = planets.push(Planet(_planetName, ceoAddress, _planetPrice, 0)) - 1;\n    }\n    \n    // Initiate functions that will create the planets\n    function InitiatePlanets() public onlyCeo {\n        require(planetsAreInitiated == false);\n        createPlanet(\"Blue Lagoon\", 100000000000000000); \n        createPlanet(\"GreenPeace\", 100000000000000000); \n        createPlanet(\"Medusa\", 100000000000000000); \n        createPlanet(\"O'Ranger\", 100000000000000000); \n        createPlanet(\"Queen\", 90000000000000000); \n        createPlanet(\"Citrus\", 90000000000000000); \n        createPlanet(\"O'Ranger II\", 90000000000000000); \n        createPlanet(\"Craterion\", 50000000000000000);\n        createPlanet(\"Dark'Air\", 50000000000000000);\n\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x2289115b00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createPlanet(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "createPlanet(string,uint256)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5168, "code": "ryptoPlanets {\n\n    address ceoAddress = 0x8e6DBF31540d2299a674b8240596ae85ebD21314;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Planet {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curResources;\n    }\n    Planet[] planets;\n\n\n    // How many shares an addres own\n    mapping (address => uint) public addressPlanetsCount;\n    mapping (address => uint) public addressAttackCount;\n    mapping (address => uint) public addressDefenseCount;\n    \n\n    uint256 attackCost = 10000000000000000;\n    uint256 defenseCost = 10000000000000000;\n    \n    uint randNonce = 0;\n    bool planetsAreInitiated;\n\n    /*\n    This function allows players to purchase planets from other players. \n    The price of the planets is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchasePlanet(uint _planetId) public payable {\n        require(msg.value == planets[_planetId].curPrice);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - (commission5percent * 2); // => 95%\n        planets[_planetId].ownerAddress.transfer(commissionOwner);\n\n        // Reduce number of planets for previous owner\n        addressPlanetsCount[planets[_planetId].ownerAddress] = addressPlanetsCount[planets[_planetId].ownerAddress] - 1;\n\n        // Keep 5% in the resources of the planet\n        planets[_planetId].curResources =  planets[_planetId].curResources + commission5percent;\n\n        // Transfer the 5% commission to the developer\n        ceoAddress.transfer(commission5percent);                  \n\n        // Update the planet owner and set the new price\n        planets[_planetId].ownerAddress = msg.sender;\n        planets[_planetId].curPrice = planets[_planetId].curPrice + (planets[_planetId].curPrice / 2);\n\n        // Increment number of planets for new owner\n        addressPlanetsCount[msg.sender] = addressPlanetsCount[msg.sender] + 1;\n    }\n\n    //User is purchasing attack\n    function purchaseAttack() payable {\n\n        // Verify that user is paying the correct price\n        require(msg.value == attackCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n\n        addressAttackCount[msg.sender]++;\n    }\n\n    //User is purchasing defense\n    function purchaseDefense() payable {\n        // Verify that user is paying the correct price\n        require(msg.value == defenseCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n        \n        addressDefenseCount[msg.sender]++;\n    }\n\n    function StealResources(uint _planetId) {\n        // Verify that the address actually own a planet\n        require(addressPlanetsCount[msg.sender] > 0);\n\n        // We verify that this address doesn't own this planet\n        require(planets[_planetId].ownerAddress != msg.sender);\n\n        // We verify that this planet has resources\n        require(planets[_planetId].curResources > 0);\n\n        // Transfer a random amount of resources (between 1% and 90%) of the resources of the planet to the stealer if it's attack is better than the planet's owner defense\n        if(addressAttackCount[msg.sender] > addressDefenseCount[planets[_planetId].ownerAddress]) {\n            // Generate a random number between 1 and 49\n            uint random = uint(keccak256(now, msg.sender, randNonce)) % 49;\n            randNonce++;\n            \n            // Calculate and transfer the random amount of resources to the stealer\n            uint256 resourcesStealable = (planets[_planetId].curResources * (50 + random)) / 100;\n            msg.sender.transfer(resourcesStealable);\n            \n            // Save the new resources count\n            planets[_planetId].curResources = planets[_planetId].curResources - resourcesStealable;\n        }\n\n    }\n    \n    // This function will return the details for the connected user (planets count, attack count, defense count)\n    function getUserDetails(address _user) public view returns(uint, uint, uint) {\n        return(addressPlanetsCount[_user], addressAttackCount[_user], addressDefenseCount[_user]);\n    }\n    \n    // This function will return the details of a planet\n    function getPlanet(uint _planetId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curResources,\n        uint ownerAttack,\n        uint ownerDefense\n    ) {\n        Planet storage _planet = planets[_planetId];\n\n        name = _planet.name;\n        ownerAddress = _planet.ownerAddress;\n        curPrice = _planet.curPrice;\n        curResources = _planet.curResources;\n        ownerAttack = addressAttackCount[_planet.ownerAddress];\n        ownerDefense = addressDefenseCount[_planet.ownerAddress];\n    }\n    \n    \n    // The dev can use this function to create new planets.\n    function createPlanet(string _planetName, uint256 _planetPrice) public onlyCeo {\n        uint planetId = planets.push(Planet(_planetName, ceoAddress, _planetPrice, 0)) - 1;\n    }\n    \n    // Initiate functions that will create the planets\n    function InitiatePlanets() public onlyCeo {\n        require(planetsAreInitiated == false);\n        createPlanet(\"Blue Lagoon\", 100000000000000000); \n        createPlanet(\"GreenPeace\", 100000000000000000); \n        createPlanet(\"Medusa\", 100000000000000000); \n        createPlanet(\"O'Ranger\", 100000000000000000); \n        createPlanet(\"Queen\", 90000000000000000); \n        createPlanet(\"Citrus\", 90000000000000000); \n        createPlanet(\"O'Ranger II\", 90000000000000000); \n        createPlanet(\"Craterion\", 50000000000000000);\n        createPlanet(\"Dark'Air\", 50000000000000000);\n\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x2289115b00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createPlanet(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "createPlanet(string,uint256)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5185, "code": "ryptoPlanets {\n\n    address ceoAddress = 0x8e6DBF31540d2299a674b8240596ae85ebD21314;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Planet {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curResources;\n    }\n    Planet[] planets;\n\n\n    // How many shares an addres own\n    mapping (address => uint) public addressPlanetsCount;\n    mapping (address => uint) public addressAttackCount;\n    mapping (address => uint) public addressDefenseCount;\n    \n\n    uint256 attackCost = 10000000000000000;\n    uint256 defenseCost = 10000000000000000;\n    \n    uint randNonce = 0;\n    bool planetsAreInitiated;\n\n    /*\n    This function allows players to purchase planets from other players. \n    The price of the planets is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchasePlanet(uint _planetId) public payable {\n        require(msg.value == planets[_planetId].curPrice);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - (commission5percent * 2); // => 95%\n        planets[_planetId].ownerAddress.transfer(commissionOwner);\n\n        // Reduce number of planets for previous owner\n        addressPlanetsCount[planets[_planetId].ownerAddress] = addressPlanetsCount[planets[_planetId].ownerAddress] - 1;\n\n        // Keep 5% in the resources of the planet\n        planets[_planetId].curResources =  planets[_planetId].curResources + commission5percent;\n\n        // Transfer the 5% commission to the developer\n        ceoAddress.transfer(commission5percent);                  \n\n        // Update the planet owner and set the new price\n        planets[_planetId].ownerAddress = msg.sender;\n        planets[_planetId].curPrice = planets[_planetId].curPrice + (planets[_planetId].curPrice / 2);\n\n        // Increment number of planets for new owner\n        addressPlanetsCount[msg.sender] = addressPlanetsCount[msg.sender] + 1;\n    }\n\n    //User is purchasing attack\n    function purchaseAttack() payable {\n\n        // Verify that user is paying the correct price\n        require(msg.value == attackCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n\n        addressAttackCount[msg.sender]++;\n    }\n\n    //User is purchasing defense\n    function purchaseDefense() payable {\n        // Verify that user is paying the correct price\n        require(msg.value == defenseCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n        \n        addressDefenseCount[msg.sender]++;\n    }\n\n    function StealResources(uint _planetId) {\n        // Verify that the address actually own a planet\n        require(addressPlanetsCount[msg.sender] > 0);\n\n        // We verify that this address doesn't own this planet\n        require(planets[_planetId].ownerAddress != msg.sender);\n\n        // We verify that this planet has resources\n        require(planets[_planetId].curResources > 0);\n\n        // Transfer a random amount of resources (between 1% and 90%) of the resources of the planet to the stealer if it's attack is better than the planet's owner defense\n        if(addressAttackCount[msg.sender] > addressDefenseCount[planets[_planetId].ownerAddress]) {\n            // Generate a random number between 1 and 49\n            uint random = uint(keccak256(now, msg.sender, randNonce)) % 49;\n            randNonce++;\n            \n            // Calculate and transfer the random amount of resources to the stealer\n            uint256 resourcesStealable = (planets[_planetId].curResources * (50 + random)) / 100;\n            msg.sender.transfer(resourcesStealable);\n            \n            // Save the new resources count\n            planets[_planetId].curResources = planets[_planetId].curResources - resourcesStealable;\n        }\n\n    }\n    \n    // This function will return the details for the connected user (planets count, attack count, defense count)\n    function getUserDetails(address _user) public view returns(uint, uint, uint) {\n        return(addressPlanetsCount[_user], addressAttackCount[_user], addressDefenseCount[_user]);\n    }\n    \n    // This function will return the details of a planet\n    function getPlanet(uint _planetId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curResources,\n        uint ownerAttack,\n        uint ownerDefense\n    ) {\n        Planet storage _planet = planets[_planetId];\n\n        name = _planet.name;\n        ownerAddress = _planet.ownerAddress;\n        curPrice = _planet.curPrice;\n        curResources = _planet.curResources;\n        ownerAttack = addressAttackCount[_planet.ownerAddress];\n        ownerDefense = addressDefenseCount[_planet.ownerAddress];\n    }\n    \n    \n    // The dev can use this function to create new planets.\n    function createPlanet(string _planetName, uint256 _planetPrice) public onlyCeo {\n        uint planetId = planets.push(Planet(_planetName, ceoAddress, _planetPrice, 0)) - 1;\n    }\n    \n    // Initiate functions that will create the planets\n    function InitiatePlanets() public onlyCeo {\n        require(planetsAreInitiated == false);\n        createPlanet(\"Blue Lagoon\", 100000000000000000); \n        createPlanet(\"GreenPeace\", 100000000000000000); \n        createPlanet(\"Medusa\", 100000000000000000); \n        createPlanet(\"O'Ranger\", 100000000000000000); \n        createPlanet(\"Queen\", 90000000000000000); \n        createPlanet(\"Citrus\", 90000000000000000); \n        createPlanet(\"O'Ranger II\", 90000000000000000); \n        createPlanet(\"Craterion\", 50000000000000000);\n        createPlanet(\"Dark'Air\", 50000000000000000);\n\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0x25\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x2289115b00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createPlanet(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "createPlanet(string,uint256)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5190, "code": "ryptoPlanets {\n\n    address ceoAddress = 0x8e6DBF31540d2299a674b8240596ae85ebD21314;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Planet {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curResources;\n    }\n    Planet[] planets;\n\n\n    // How many shares an addres own\n    mapping (address => uint) public addressPlanetsCount;\n    mapping (address => uint) public addressAttackCount;\n    mapping (address => uint) public addressDefenseCount;\n    \n\n    uint256 attackCost = 10000000000000000;\n    uint256 defenseCost = 10000000000000000;\n    \n    uint randNonce = 0;\n    bool planetsAreInitiated;\n\n    /*\n    This function allows players to purchase planets from other players. \n    The price of the planets is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchasePlanet(uint _planetId) public payable {\n        require(msg.value == planets[_planetId].curPrice);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - (commission5percent * 2); // => 95%\n        planets[_planetId].ownerAddress.transfer(commissionOwner);\n\n        // Reduce number of planets for previous owner\n        addressPlanetsCount[planets[_planetId].ownerAddress] = addressPlanetsCount[planets[_planetId].ownerAddress] - 1;\n\n        // Keep 5% in the resources of the planet\n        planets[_planetId].curResources =  planets[_planetId].curResources + commission5percent;\n\n        // Transfer the 5% commission to the developer\n        ceoAddress.transfer(commission5percent);                  \n\n        // Update the planet owner and set the new price\n        planets[_planetId].ownerAddress = msg.sender;\n        planets[_planetId].curPrice = planets[_planetId].curPrice + (planets[_planetId].curPrice / 2);\n\n        // Increment number of planets for new owner\n        addressPlanetsCount[msg.sender] = addressPlanetsCount[msg.sender] + 1;\n    }\n\n    //User is purchasing attack\n    function purchaseAttack() payable {\n\n        // Verify that user is paying the correct price\n        require(msg.value == attackCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n\n        addressAttackCount[msg.sender]++;\n    }\n\n    //User is purchasing defense\n    function purchaseDefense() payable {\n        // Verify that user is paying the correct price\n        require(msg.value == defenseCost);\n        \n        // We transfer the amount paid to the owner\n        ceoAddress.transfer(msg.value);\n        \n        addressDefenseCount[msg.sender]++;\n    }\n\n    function StealResources(uint _planetId) {\n        // Verify that the address actually own a planet\n        require(addressPlanetsCount[msg.sender] > 0);\n\n        // We verify that this address doesn't own this planet\n        require(planets[_planetId].ownerAddress != msg.sender);\n\n        // We verify that this planet has resources\n        require(planets[_planetId].curResources > 0);\n\n        // Transfer a random amount of resources (between 1% and 90%) of the resources of the planet to the stealer if it's attack is better than the planet's owner defense\n        if(addressAttackCount[msg.sender] > addressDefenseCount[planets[_planetId].ownerAddress]) {\n            // Generate a random number between 1 and 49\n            uint random = uint(keccak256(now, msg.sender, randNonce)) % 49;\n            randNonce++;\n            \n            // Calculate and transfer the random amount of resources to the stealer\n            uint256 resourcesStealable = (planets[_planetId].curResources * (50 + random)) / 100;\n            msg.sender.transfer(resourcesStealable);\n            \n            // Save the new resources count\n            planets[_planetId].curResources = planets[_planetId].curResources - resourcesStealable;\n        }\n\n    }\n    \n    // This function will return the details for the connected user (planets count, attack count, defense count)\n    function getUserDetails(address _user) public view returns(uint, uint, uint) {\n        return(addressPlanetsCount[_user], addressAttackCount[_user], addressDefenseCount[_user]);\n    }\n    \n    // This function will return the details of a planet\n    function getPlanet(uint _planetId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curResources,\n        uint ownerAttack,\n        uint ownerDefense\n    ) {\n        Planet storage _planet = planets[_planetId];\n\n        name = _planet.name;\n        ownerAddress = _planet.ownerAddress;\n        curPrice = _planet.curPrice;\n        curResources = _planet.curResources;\n        ownerAttack = addressAttackCount[_planet.ownerAddress];\n        ownerDefense = addressDefenseCount[_planet.ownerAddress];\n    }\n    \n    \n    // The dev can use this function to create new planets.\n    function createPlanet(string _planetName, uint256 _planetPrice) public onlyCeo {\n        uint planetId = planets.push(Planet(_planetName, ceoAddress, _planetPrice, 0)) - 1;\n    }\n    \n    // Initiate functions that will create the planets\n    function InitiatePlanets() public onlyCeo {\n        require(planetsAreInitiated == false);\n        createPlanet(\"Blue Lagoon\", 100000000000000000); \n        createPlanet(\"GreenPeace\", 100000000000000000); \n        createPlanet(\"Medusa\", 100000000000000000); \n        createPlanet(\"O'Ranger\", 100000000000000000); \n        createPlanet(\"Queen\", 90000000000000000); \n        createPlanet(\"Citrus\", 90000000000000000); \n        createPlanet(\"O'Ranger II\", 90000000000000000); \n        createPlanet(\"Craterion\", 50000000000000000);\n        createPlanet(\"Dark'Air\", 50000000000000000);\n\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_CryptoPlanets_4 + calldata_CryptoPlanets_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nkeccac_0_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n4*storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_CryptoPlanets_0: 0x2289115b00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoPlanets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createPlanet(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x2828d5ae572a3e87febad75323af24ec0a4f2eef.sol", "function": "createPlanet(string,uint256)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}], "success": true}