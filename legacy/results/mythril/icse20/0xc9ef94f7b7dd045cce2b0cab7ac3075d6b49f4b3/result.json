{
  "contract": "0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3",
  "tool": "mythril",
  "start": 1563286126.1622517,
  "end": 1563287012.868778,
  "duration": 886.7065262794495,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 729,
        "code": "       user.id = addresses",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2017\nCall at address: 2017\nCall at address: 1693\nCall at address: 1501\nCall at address: 1501\nCall at address: 2017\nCall at address: 2017\nCall at address: 1693\nCall at address: 1501\nCall at address: 1501\n",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 76,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 762,
        "code": ";\n\ncontract SmartG",
        "debug": "callvalue: 0x10000000000000000000000000000000000000000000000006f26fc20000\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_729: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x0\ncaller: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_SmartGrowup_0: 0x900000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1163,
        "code": " msg.value, user.referrer",
        "debug": "callvalue: 0xcacb402a20200a09822135dfffffeff922203dffe9ef89df702387f26fc88c13\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xea439ff13bdff5fd84040010000000015ddfc2000c04018f81d8780d90138c40\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_729: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncalldatasize_SmartGrowup: 0x3\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 92,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1182,
        "code": " depAmount += msg.",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x8000000000000000000000000000000000000000000000000020000000000000\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_729: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncalldatasize_SmartGrowup: 0x3\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 94,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1393,
        "code": "// project fee for sup",
        "debug": "storage_2: 0xea439ff13bdff5fd84040010000000015ddfc2000c04018f81d8780d90138c40\ncallvalue: 0xcacb402a20200a09822135dfffffeff922203dffe9ef89df702387f26fc88c13\nstorage_38357942052654430511805280289652572966474101887281969759642760585367641502969: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_729: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncalldatasize_SmartGrowup: 0x3\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 97,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1501,
        "code": "alue / 100) * 3; // referrer co",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2017\nCall at address: 2017\nCall at address: 1693\n",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 98,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 1693,
        "code": "\", msg.sender);\n            }\n\n",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2017\nCall at address: 2017\n",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 102,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 1693,
        "code": "\", msg.sender);\n            }\n\n",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 102,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 2876,
        "code": "nt[] _deposit, uint[] _date, address[] _referrer) onlyOwner public {\n        // add initiated investors\n        for (uint i = 0; i < _addr.length; i++) {\n            uint id = addresses.length;\n            if (depositors[_addr[i]].deposit == 0) {\n                addresses.push(_addr[i]);\n                depAmount += _deposit[i];\n            }\n\n            depositors[_addr[i]] = Depositor(id, _deposit[i], 1, _date[i], _referrer[i]);\n            emit Deposit(_addr[i], _deposit  [i], _referrer[i]);\n        }\n        lastPayDate = now;\n    }\n\n    function() payable public {\n        if (owner == ",
        "debug": "calldata_SmartGrowup_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0xe52f53d3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 43,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3860,
        "code": "return addresses.length - 1",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2017\nCall at address: 2017\nCall at address: 1693\nCall at address: 1501\n",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 163,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4237,
        "code": " := mload(add(byt, 20))\n   ",
        "debug": "timestamp: 0x0\nstorage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldatasize_SmartGrowup: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `fallback`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "fallback",
        "lineno": 172,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4472,
        "code": "  if (depositors[addr].dat",
        "debug": "storage_5: 0x0\ncalldata_SmartGrowup_4: 0x1\nstorage_7: 0x0\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `payout(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 127,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4473,
        "code": "  if (depositors[addr].date + ",
        "debug": "storage_5: 0x0\ncalldata_SmartGrowup_4: 0x0\nstorage_7: 0x0\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `payout(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 127,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4512,
        "code": "  amount = get",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_5: 0x1\ncalldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x0\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 131,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4631,
        "code": "r);\n            depositors[addr]",
        "debug": "storage_3 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_1546678032441257452667456735582814959992782782816731922691272282333561699760_+\n115792089237316195423570985008687907853269984665640564039457584007913129639935_+\nstorage_5_+\n115792089237316195423570985008687907853269984665640564039457584007913129639935*\ncalldata_SmartGrowup_4,\n_____256): 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef6c0\nstorage_5: 0x200000000000000000000000000000000000000001\ncalldata_SmartGrowup_4: 0x0\nstorage_7: 0x0\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `payout(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 131,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5313,
        "code": ";\n\ncontract SmartG",
        "debug": "storage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SmartGrowup_cpy: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0xe52f53d3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5418,
        "code": "rs[_addr[i]",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nmem_128 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0x0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SmartGrowup_cpy: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 52,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5437,
        "code": "     depositors[_addr[i]",
        "debug": "storage_2: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nmem_0 + 192 + 32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SmartGrowup_cpy: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0xe52f53d3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 52,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5476,
        "code": "  emit Depo",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SmartGrowup_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nmem_128 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 53,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5512,
        "code": "addr[i],",
        "debug": "The exception is triggered under the following conditions:\n\nmem_128 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SmartGrowup_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nmem_160 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_32 + 4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 53,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5541,
        "code": "deposit  [i]",
        "debug": "The exception is triggered under the following conditions:\n\nmem_160 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SmartGrowup_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SmartGrowup_4 + calldata_SmartGrowup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SmartGrowup_0: 0xe52f53d300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nmem_192 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_4 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_32 + 4 +\n32 +\n32*calldata_SmartGrowup_4 + calldata_SmartGrowup_32 + 36: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xe52f53d3",
        "lineno": 53,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6048,
        "code": "blic addresses;\n    mappin",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SmartGrowup_4: 0x0\nstorage_5: 0x0\ncalldata_SmartGrowup_0: 0xedf26d9b00000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "_function_0xedf26d9b",
        "lineno": 13,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6349,
        "code": "\n                ret",
        "debug": "storage_5: 0x0\nstorage_7: 0xff00\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `payout(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 184,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 6375,
        "code": "  emit NextS",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_5: 0x0\nstorage_7: 0xff00\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 189,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6729,
        "debug": "storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0xff00\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\nstorage_5: 0x1\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `payout(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 197,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6783,
        "code": "ntract SmartGrowup {\n    address public owner;\n    address public support;\n    uint public depAmount;\n    uint public stage;\n    uint public lastPayDate;\n    \n    uint constant public MASS_LIMIT = 150;\n    uint constant public MIN_INVEST = 10000000000000000 wei;\n\n    address[] public addresses;\n    mapping(address => Depositor) public depositors;\n    bool public pause;\n\n    struct Depositor\n    {\n        uint id;\n        uint deposit;\n        uint deposits;\n        uint date;\n        address referrer;\n    }\n\n    event Deposit(address addr, uint amount, address referrer);\n    event Payout(address addr, uint amount, string eventType, address from);\n    event NextStageStarted(uint round, uint date, uint deposit);\n\n    modifier onlyOwner {if (msg.sender == owner) _;}\n\n    constructor() public {\n        owner = msg.sender;\n        support = msg.sender;\n        addresses.length = 1;\n        stage = 1;\n    }\n\n    function transferOwnership(address addr) onlyOwner public {\n        owner = addr;\n    }\n\n    function addDepositors(address[] _addr, uint[] _deposit, uint[] _date, address[] _referrer) onlyOwner public {\n        // add initiated investors\n        for (uint i = 0; i < _addr.length; i++) {\n            uint id = addresses.length;\n            if (depositors[_addr[i]].deposit == 0) {\n                addresses.push(_addr[i]);\n                depAmount += _deposit[i];\n            }\n\n            depositors[_addr[i]] = Depositor(id, _deposit[i], 1, _date[i], _referrer[i]);\n            emit Deposit(_addr[i], _deposit  [i], _referrer[i]);\n        }\n        lastPayDate = now;\n    }\n\n    function() payable public {\n        if (owner == msg.sender) {\n            return;\n        }\n\n        if (0 == msg.value) {\n            payoutSelf();\n            return;\n        }\n\n        require(false == pause, \"Restarting. Please wait.\");\n        require(msg.value >= MIN_INVEST, \"Small amount, minimum 0.01 ether\");\n        Depositor storage user = depositors[msg.sender];\n\n        if (user.id == 0) {\n            // ensure that payment not from hacker contract\n            msg.sender.transfer(0 wei);\n            addresses.push(msg.sender);\n            user.id = addresses.length;\n            user.date = now;\n\n            // referrer\n            address referrer = transferBytestoAddress(msg.data);\n            if (depositors[referrer].deposit > 0 && referrer != msg.sender) {\n                user.referrer = referrer;\n            }\n        } else {\n            payoutSelf();\n        }\n\n        // counter deposits and value deposits\n        user.deposit += msg.value;\n        user.deposits += 1;\n\n        emit Deposit(msg.sender, msg.value, user.referrer);\n\n        depAmount += msg.value;\n        lastPayDate = now;\n\n        support.transfer(msg.value / 5); // project fee for supporting\n        uint bonusAmount = (msg.value / 100) * 3; // referrer commission for all deposits\n\n        if (user.referrer > 0x0) {\n            if (user.referrer.send(bonusAmount)) {\n                emit Payout(user.referrer, bonusAmount, \"referral\", msg.sender);\n            }\n\n            if (user.deposits == 1) { // cashback only for the first deposit 3%\n                if (msg.sender.send(bonusAmount)) {\n                    emit Payout(msg.sender, bonusAmount, \"CashBack\", 0);\n                }\n            }\n        } \n\n\n    }\n\n    function payout(uint removal) public\n    {\n        if (pause == true) {\n            goRestart();\n            return;\n        }\n\n        uint txs;\n        uint amount;\n\n        for (uint idx = addresses.length - removal - 1; idx >= 1 && txs < MASS_LIMIT; idx--) {\n            address addr = addresses[idx];\n            if (depositors[addr].date + 20 hours > now) {\n                continue;\n            }\n\n            amount = getDividendsAmount(addr);\n            depositors[addr].date = now;\n\n            if (address(this).balance < amount) {\n                pause = true;\n                return;\n            }\n\n            if (addr.send(amount)) {\n                emit Payout(addr, amount, \"Payout\", 0);\n            }\n\n            txs++;\n        }\n    }\n\n    function payoutSelf() private {\n        require(depositors[msg.sender].id > 0, \"Investor not found.\");\n        uint amount = getDividendsAmount(msg.sender);\n\n        depositors[msg.sender].date = now;\n        if (address(this).balance < amount) {\n            pause = true;\n            return;\n        }\n\n        msg.sender.transfer(amount);\n        emit Payout(msg.sender, amount, \"Autopayout\", 0);\n    }\n\n\n    function getCount() public view returns (uint) {\n        return addresses.length - 1;\n    }\n\n    function getDividendsAmount(address addr) public view returns (uint) {\n        return depositors[addr].deposit / 100 * 4 * (now - depositors[addr].date) / 1 days;\n    }\n\n    function transferBytestoAddress(bytes byt) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(byt, 20))\n        }\n    }\n    \n    function goRestart() private {\n        uint txs;\n        address addr;\n\n        for (uint i = addresses.length - 1; i > 0; i--) {\n            addr = addresses[i];\n            addresses.length -= 1;\n            delete depositors[addr];\n            if (txs++ == MASS_LIMIT) {\n                return;\n            }\n        }\n\n        emit NextStageStarted(stage, now, depAmount);\n        pause = false;\n        stage += 1;\n        depAmount = 0;\n        lastPayDate = now;\n\n    }\n\n}",
        "debug": "storage_5: 0xfd1c2087ea80d07d2e2c706e2fb9fdc3af1f2106ac0b4ec06bfa3ea3963bd9c0\nstorage_7: 0xff00\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `payout(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6785,
        "code": "ntract SmartGrowup {\n    address public owner;\n    address public support;\n    uint public depAmount;\n    uint public stage;\n    uint public lastPayDate;\n    \n    uint constant public MASS_LIMIT = 150;\n    uint constant public MIN_INVEST = 10000000000000000 wei;\n\n    address[] public addresses;\n    mapping(address => Depositor) public depositors;\n    bool public pause;\n\n    struct Depositor\n    {\n        uint id;\n        uint deposit;\n        uint deposits;\n        uint date;\n        address referrer;\n    }\n\n    event Deposit(address addr, uint amount, address referrer);\n    event Payout(address addr, uint amount, string eventType, address from);\n    event NextStageStarted(uint round, uint date, uint deposit);\n\n    modifier onlyOwner {if (msg.sender == owner) _;}\n\n    constructor() public {\n        owner = msg.sender;\n        support = msg.sender;\n        addresses.length = 1;\n        stage = 1;\n    }\n\n    function transferOwnership(address addr) onlyOwner public {\n        owner = addr;\n    }\n\n    function addDepositors(address[] _addr, uint[] _deposit, uint[] _date, address[] _referrer) onlyOwner public {\n        // add initiated investors\n        for (uint i = 0; i < _addr.length; i++) {\n            uint id = addresses.length;\n            if (depositors[_addr[i]].deposit == 0) {\n                addresses.push(_addr[i]);\n                depAmount += _deposit[i];\n            }\n\n            depositors[_addr[i]] = Depositor(id, _deposit[i], 1, _date[i], _referrer[i]);\n            emit Deposit(_addr[i], _deposit  [i], _referrer[i]);\n        }\n        lastPayDate = now;\n    }\n\n    function() payable public {\n        if (owner == msg.sender) {\n            return;\n        }\n\n        if (0 == msg.value) {\n            payoutSelf();\n            return;\n        }\n\n        require(false == pause, \"Restarting. Please wait.\");\n        require(msg.value >= MIN_INVEST, \"Small amount, minimum 0.01 ether\");\n        Depositor storage user = depositors[msg.sender];\n\n        if (user.id == 0) {\n            // ensure that payment not from hacker contract\n            msg.sender.transfer(0 wei);\n            addresses.push(msg.sender);\n            user.id = addresses.length;\n            user.date = now;\n\n            // referrer\n            address referrer = transferBytestoAddress(msg.data);\n            if (depositors[referrer].deposit > 0 && referrer != msg.sender) {\n                user.referrer = referrer;\n            }\n        } else {\n            payoutSelf();\n        }\n\n        // counter deposits and value deposits\n        user.deposit += msg.value;\n        user.deposits += 1;\n\n        emit Deposit(msg.sender, msg.value, user.referrer);\n\n        depAmount += msg.value;\n        lastPayDate = now;\n\n        support.transfer(msg.value / 5); // project fee for supporting\n        uint bonusAmount = (msg.value / 100) * 3; // referrer commission for all deposits\n\n        if (user.referrer > 0x0) {\n            if (user.referrer.send(bonusAmount)) {\n                emit Payout(user.referrer, bonusAmount, \"referral\", msg.sender);\n            }\n\n            if (user.deposits == 1) { // cashback only for the first deposit 3%\n                if (msg.sender.send(bonusAmount)) {\n                    emit Payout(msg.sender, bonusAmount, \"CashBack\", 0);\n                }\n            }\n        } \n\n\n    }\n\n    function payout(uint removal) public\n    {\n        if (pause == true) {\n            goRestart();\n            return;\n        }\n\n        uint txs;\n        uint amount;\n\n        for (uint idx = addresses.length - removal - 1; idx >= 1 && txs < MASS_LIMIT; idx--) {\n            address addr = addresses[idx];\n            if (depositors[addr].date + 20 hours > now) {\n                continue;\n            }\n\n            amount = getDividendsAmount(addr);\n            depositors[addr].date = now;\n\n            if (address(this).balance < amount) {\n                pause = true;\n                return;\n            }\n\n            if (addr.send(amount)) {\n                emit Payout(addr, amount, \"Payout\", 0);\n            }\n\n            txs++;\n        }\n    }\n\n    function payoutSelf() private {\n        require(depositors[msg.sender].id > 0, \"Investor not found.\");\n        uint amount = getDividendsAmount(msg.sender);\n\n        depositors[msg.sender].date = now;\n        if (address(this).balance < amount) {\n            pause = true;\n            return;\n        }\n\n        msg.sender.transfer(amount);\n        emit Payout(msg.sender, amount, \"Autopayout\", 0);\n    }\n\n\n    function getCount() public view returns (uint) {\n        return addresses.length - 1;\n    }\n\n    function getDividendsAmount(address addr) public view returns (uint) {\n        return depositors[addr].deposit / 100 * 4 * (now - depositors[addr].date) / 1 days;\n    }\n\n    function transferBytestoAddress(bytes byt) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(byt, 20))\n        }\n    }\n    \n    function goRestart() private {\n        uint txs;\n        address addr;\n\n        for (uint i = addresses.length - 1; i > 0; i--) {\n            addr = addresses[i];\n            addresses.length -= 1;\n            delete depositors[addr];\n            if (txs++ == MASS_LIMIT) {\n                return;\n            }\n        }\n\n        emit NextStageStarted(stage, now, depAmount);\n        pause = false;\n        stage += 1;\n        depAmount = 0;\n        lastPayDate = now;\n\n    }\n\n}",
        "debug": "storage_5: 0xfe001c7bca580006000000000000000078f81e017b0000000201000000006010\nstorage_7: 0xff00\ncalldata_SmartGrowup_0: 0xe115234300000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartGrowup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `payout(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xc9ef94f7b7dd045cce2b0cab7ac3075d6b49f4b3.sol",
        "function": "payout(uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}