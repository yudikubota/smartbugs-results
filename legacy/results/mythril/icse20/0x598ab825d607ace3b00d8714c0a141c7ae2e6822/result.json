{
  "contract": "0x598ab825d607ace3b00d8714c0a141c7ae2e6822",
  "tool": "mythril",
  "start": 1563320962.7256765,
  "end": 1563321668.3645263,
  "duration": 705.63884973526,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 538,
        "code": "you arent on the `allowedSpenders` white list\n        if (!allowedSpenders[msg.sender] ) throw;\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\n        authorizedPayments.length++;\n\n        // The following lines fill out the payment struct\n        Payment p = authorizedPayments[idPayment];\n        p.spender = msg.sender;\n\n        // Overflow protection\n        if (_paymentDelay > 10**18) throw;\n\n        // Determines the earliest the recipient can receive payment (Unix time)\n        p.earliestPayTime = _paymentDelay >= timeLock ?\n                                now + _paymentDelay :\n                                now + timeLock;\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.name = _name;\n        p.reference = _reference;\n        PaymentAuthorized(idPayment, p.recipient, p.amount);\n        return idPayment;\n    }\n\n    /// @notice only `allowedSpenders[]` The recipient of a payment calls this\n    ///  function to send themselves the ether after the `earliestPayTime` has\n    ///  expired\n    /// @param _idPayment The payment ID to be ex",
        "debug": "calldata_Vault_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 205,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2698,
        "code": "     if (_paymentDelay > 10",
        "debug": "storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 215,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2723,
        "code": "nix time)\n        p.earliestP",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 217,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2843,
        "code": "nt;\n    }\n\n   ",
        "debug": "storage_3: 0x1ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x87ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Vault_32 + 100: 0x0\nstorage_6: 0x7fffffffffffffffffefffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 226,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2851,
        "code": "Payment, p.recipien",
        "debug": "storage_3: 0x40000000000000000000000000000000000000000000000000000000007fffff\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffff2e759770c07fd9\ncalldata_Vault_32 + 100: 0x80241477cee0911\nstorage_6: 0x80241477cee0911\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 225,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4085,
        "code": "yOwner` Cancel a payment all ",
        "debug": "calldata_Vault_32 + 4: 0xde0b6b3a763fffe\nstorage_6 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*calldata_Vault_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_Vault_4: 0x0\nstorage_3: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Vault_0: 0x846a5dde00000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `delayPayment(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "delayPayment(uint256,uint256)",
        "lineno": 283,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4157,
        "code": " onlyOwner {\n        if (_idPa",
        "debug": "calldata_Vault_32 + 4: 0x965da0625df9ffd\nstorage_6 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*calldata_Vault_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffff8e40008f46f9fa5\ncalldata_Vault_4: 0x0\nstorage_4 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*calldata_Vault_4: 0x0\nstorage_7: 0x249da0f1a4f3fa2\nstorage_3: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Vault_0: 0x846a5dde00000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `delayPayment(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "delayPayment(uint256,uint256)",
        "lineno": 285,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4175,
        "code": "thorizedPayments.length) th",
        "debug": "calldata_Vault_32 + 4: 0xde0b6b3a763fffe\nstorage_3 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*calldata_Vault_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_Vault_4: 0x0\nstorage_4 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*calldata_Vault_4: 0x0\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*calldata_Vault_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffff21f494c589c0001\nstorage_3: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_Vault_0: 0x846a5dde00000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `delayPayment(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "delayPayment(uint256,uint256)",
        "lineno": 286,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4877,
        "code": "meLock;\n    uint public timeLock;\n ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Vault_4: 0x0\nstorage_3: 0x0\ncalldata_Vault_0: 0xa0927a6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "_function_0xa0927a6a",
        "lineno": 105,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5915,
        "code": "cribes the details of\n    ///  each payment making it easy to track the movement of funds\n    ///  transparently\n    struct Payment {\n        string name;     // What is the purpose of this payment\n        bytes32 reference;  // Reference of the payment.\n        address spender;        // Who is sending the funds\n        uint earliestPayTime;   // The earliest a payment can be made (Unix Time)\n        bool canceled;         // If True then the payment has been canceled\n        bool paid;              // If True then the payment has been paid\n        address recipient;      // Who is receiving the funds\n        uint amount;            // The amount of wei sent in the payment\n        uint securityGuardDelay;// The seconds `securityGuard` can delay payment\n    }\n\n    Payment[] public authorizedPayments;\n\n    address public securityGuard;\n    uint public absoluteMinTimeLock;\n    uint public timeLock;\n    uint public maxSecurityGuardDelay;\n\n    /// @dev The white list of approved addresses allowed to set up && receive\n    ///  payments from this vault\n    mapping (address => bool) public allowedSpenders;\n\n    /// @dev The address assigned the role of `securityGuard` is the only\n    ///  addresses that can call a function with this modifier\n    modifier onlySecurityGuard { if (msg.sender != securityGuard) throw; _; }\n\n    // @dev Events to make the payment movements easy to find on the blockchain\n    event PaymentAuthorized(uint indexed idPayment, address indexed recipient, uint amount);\n    event PaymentExecuted(uint indexed idPayment, address indexed recipient, uint amount);\n    event PaymentCanceled(uint indexed idPayment);\n    event EtherReceived(address indexed from, uint amount);\n    event SpenderAuthorization(address indexed spender, bool authorized);\n\n/////////\n// Constructor\n/////////\n\n    /// @notice The Constructor creates the Vault on the blockchain\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\n    ///  call `escapeHatch()` to send the ether in this contract to the\n    ///  `escapeHatchDestination` it would be ideal if `escapeHatchCaller` cannot move\n    ///  funds out of `escapeHatchDestination`\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract in an emergency\n    /// @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\n    ///  be set to, if set to 0 the `owner` can remove the `timeLock` completely\n    /// @param _timeLock Initial number of seconds that payments are delayed\n    ///  after they are authorized (a security precaution)\n    /// @param _securityGuard Address that will be able to delay the payments\n    ///  beyond the initial timelock requirements; can be set to 0x0 to remove\n    ///  the `securityGuard` functionality\n    /// @param _maxSecurityGuardDelay The maximum number of seconds in total\n    ///   that `securityGuard` can delay a payment so that the owner can cancel\n    ///   the payment if needed\n    function Vault(\n        address _escapeHatchCaller,\n        address _escapeHatchDestination,\n        uint _absoluteMinTimeLock,\n        uint _timeLock,\n        address _securityGuard,\n        uint _maxSecurityGuardDelay) Escapable(_escapeHatchCaller, _escapeHatchDestination)\n    {\n        absoluteMinTimeLock = _absoluteMinTimeLock;\n        timeLock = _timeLock;\n        securityGuard = _securityGuard;\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n\n/////////\n// Helper functions\n/////////\n\n    /// @notice States the total number of authorized payments in this contract\n    /// @return The number of payments ever authorized even if they were canceled\n    function numberOfAuthorizedPayments() constant returns (uint) {\n        return authorizedPayments.length;\n    }\n\n//////\n// Receive Ether\n//////\n\n    /// @notice Called anytime ether is sent to the contract && creates an event\n    /// to more easily track the incoming transactions\n    function receiveEther() payable {\n        EtherReceived(msg.sender, msg.value);\n    }\n\n    /// @notice The fall back function is called whenever ether is sent to this\n    ///  contract\n    function () payable {\n        receiveEther();\n    }\n\n////////\n// Spender Interface\n////////\n\n    /// @notice only `allowedSpenders[]` Creates a new `Payment`\n    /// @param _name Brief description of the payment that is authorized\n    /// @param _reference External reference of the payment\n    /// @param _recipient Destination of the payment\n    /// @param _amount Amount to be paid in wei\n    /// @param _paymentDelay Number of seconds the payment is to be delayed, if\n    ///  this value is below `timeLock` then the `timeLock` determines the delay\n    /// @return The Payment ID number for the new authorized payment\n    function authorizePayment(\n        string _name,\n        bytes32 _reference,\n        address _recipient,\n        uint _amount,\n        uint _paymentDelay\n    ) returns(uint) {\n\n        // Fail if you arent on the `allowedSpenders` white list\n        if (!allowedSpenders[msg.sender] ) throw;\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\n        authorizedPayments.length++;\n\n        // The following lines fill out the payment struct\n        Payment p = authorizedPayments[idPayment];\n        p.spender = msg.sender;\n\n        // Overflow protection\n        if (_paymentDelay > 10**18) throw;\n\n        // Determines the earliest the recipient can receive payment (Unix time)\n        p.earliestPayTime = _paymentDelay >= timeLock ?\n                                now + _paymentDelay :\n                                now + timeLock;\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.name = _name;\n        p.reference = _reference;\n        PaymentAuthorized(idPayment, p.recipient, p.amount);\n        return idPayment;\n    }\n\n    /// @notice only `allowedSpenders[]` The recipient of a payment calls this\n    ///  function to send themselves the ether after the `earliestPayTime` has\n    ///  expired\n    /// @param _idPayment The payment ID to be executed\n    function collectAuthorizedPayment(uint _idPayment) {\n\n        // Check that the `_idPayment` has been added to the payments struct\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n        // Checking for reasons not to execute the payment\n        if (msg.sender != p.recipient) throw;\n        if (!allowedSpenders[p.spender]) throw;\n        if (now < p.earliestPayTime) throw;\n        if (p.canceled) throw;\n        if (p.paid) throw;\n        if (this.balance < p.amount) throw;\n\n        p.paid = true; // Set the payment to being paid\n        if (!p.recipient.send(p.amount)) {  // Make the payment\n            throw;\n        }\n        PaymentExecuted(_idPayment, p.recipient, p.amount);\n     }\n\n/////////\n// SecurityGuard Interface\n/////////\n\n    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds\n    /// @param _idPayment ID of the payment to be delayed\n    /// @param _delay The number of seconds to delay the payment\n    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        // Overflow test\n        if (_delay > 10**18) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n        if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) ||\n            (p.paid) ||\n            (p.canceled))\n            throw;\n\n        p.securityGuardDelay += _delay;\n        p.earliestPayTime += _delay;\n    }\n\n////////\n// Owner Interface\n///////\n\n    /// @notice `onlyOwner` Cancel a payment all together\n    /// @param _idPayment ID of the payment to be canceled.\n    function cancelPayment(uint _idPayment) onlyOwner {\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n\n        if (p.canceled) throw;\n        if (p.paid) throw;\n\n        p.canceled = true;\n        PaymentCanceled(_idPayment);\n    }\n\n    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list\n    /// @param _spender The address of the contract being authorized/unauthorized\n    /// @param _authorize `true` if authorizing and `false` if unauthorizing\n    function authorizeSpender(address _spender, bool _authorize) onlyOwner {\n        allowedSpenders[_spender] = _authorize;\n        SpenderAuthorization(_spender, _authorize);\n    }\n\n    /// @notice `onlyOwner` Sets the address of `securityGuard`\n    /// @param _newSecurityGuard Address of the new security guard\n    function setSecurityGuard(address _newSecurityGuard) onlyOwner {\n        securityGuard = _newSecurityGuard;\n    }\n\n    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be\n    ///  lower than `absoluteMinTimeLock`\n    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;\n    ///  pending payments maintain their `earliestPayTime`\n    function setTimelock(uint _newTimeLock) onlyOwner {\n        if (_newTimeLock < absoluteMinTimeLock) throw;\n        timeLock = _newTimeLock;\n    }\n\n    /// @notice `onlyOwner` Changes the maximum number of seconds\n    /// `securityGuard` can delay a payment\n    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that\n    ///  `securityGuard` can delay the payment's execution in total\n    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyOwner {\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n}",
        "debug": "storage_3: 0x80f3ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_0_+\n87903029871075914254377627908054574944891091886930582284385770809450030037083_+\n7*storage_3: 0xff3cd8f9fe03fdffdfdfffbfc434f484464cb3051635aa48120b57015cb0a1fc\ncalldata_Vault_32 + 100: 0xb3a7641000\nstorage_0 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n7*storage_3: 0xaeb4bf7c50ff16592d1951111500000201121565524d8ef6e0bfffffffffffc9\nstorage_6: 0xb3a7641001\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 87,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5944,
        "code": "cribes the details of\n    ///  each payment making it easy to track the movement of funds\n    ///  transparently\n    struct Payment {\n        string name;     // What is the purpose of this payment\n        bytes32 reference;  // Reference of the payment.\n        address spender;        // Who is sending the funds\n        uint earliestPayTime;   // The earliest a payment can be made (Unix Time)\n        bool canceled;         // If True then the payment has been canceled\n        bool paid;              // If True then the payment has been paid\n        address recipient;      // Who is receiving the funds\n        uint amount;            // The amount of wei sent in the payment\n        uint securityGuardDelay;// The seconds `securityGuard` can delay payment\n    }\n\n    Payment[] public authorizedPayments;\n\n    address public securityGuard;\n    uint public absoluteMinTimeLock;\n    uint public timeLock;\n    uint public maxSecurityGuardDelay;\n\n    /// @dev The white list of approved addresses allowed to set up && receive\n    ///  payments from this vault\n    mapping (address => bool) public allowedSpenders;\n\n    /// @dev The address assigned the role of `securityGuard` is the only\n    ///  addresses that can call a function with this modifier\n    modifier onlySecurityGuard { if (msg.sender != securityGuard) throw; _; }\n\n    // @dev Events to make the payment movements easy to find on the blockchain\n    event PaymentAuthorized(uint indexed idPayment, address indexed recipient, uint amount);\n    event PaymentExecuted(uint indexed idPayment, address indexed recipient, uint amount);\n    event PaymentCanceled(uint indexed idPayment);\n    event EtherReceived(address indexed from, uint amount);\n    event SpenderAuthorization(address indexed spender, bool authorized);\n\n/////////\n// Constructor\n/////////\n\n    /// @notice The Constructor creates the Vault on the blockchain\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\n    ///  call `escapeHatch()` to send the ether in this contract to the\n    ///  `escapeHatchDestination` it would be ideal if `escapeHatchCaller` cannot move\n    ///  funds out of `escapeHatchDestination`\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract in an emergency\n    /// @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\n    ///  be set to, if set to 0 the `owner` can remove the `timeLock` completely\n    /// @param _timeLock Initial number of seconds that payments are delayed\n    ///  after they are authorized (a security precaution)\n    /// @param _securityGuard Address that will be able to delay the payments\n    ///  beyond the initial timelock requirements; can be set to 0x0 to remove\n    ///  the `securityGuard` functionality\n    /// @param _maxSecurityGuardDelay The maximum number of seconds in total\n    ///   that `securityGuard` can delay a payment so that the owner can cancel\n    ///   the payment if needed\n    function Vault(\n        address _escapeHatchCaller,\n        address _escapeHatchDestination,\n        uint _absoluteMinTimeLock,\n        uint _timeLock,\n        address _securityGuard,\n        uint _maxSecurityGuardDelay) Escapable(_escapeHatchCaller, _escapeHatchDestination)\n    {\n        absoluteMinTimeLock = _absoluteMinTimeLock;\n        timeLock = _timeLock;\n        securityGuard = _securityGuard;\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n\n/////////\n// Helper functions\n/////////\n\n    /// @notice States the total number of authorized payments in this contract\n    /// @return The number of payments ever authorized even if they were canceled\n    function numberOfAuthorizedPayments() constant returns (uint) {\n        return authorizedPayments.length;\n    }\n\n//////\n// Receive Ether\n//////\n\n    /// @notice Called anytime ether is sent to the contract && creates an event\n    /// to more easily track the incoming transactions\n    function receiveEther() payable {\n        EtherReceived(msg.sender, msg.value);\n    }\n\n    /// @notice The fall back function is called whenever ether is sent to this\n    ///  contract\n    function () payable {\n        receiveEther();\n    }\n\n////////\n// Spender Interface\n////////\n\n    /// @notice only `allowedSpenders[]` Creates a new `Payment`\n    /// @param _name Brief description of the payment that is authorized\n    /// @param _reference External reference of the payment\n    /// @param _recipient Destination of the payment\n    /// @param _amount Amount to be paid in wei\n    /// @param _paymentDelay Number of seconds the payment is to be delayed, if\n    ///  this value is below `timeLock` then the `timeLock` determines the delay\n    /// @return The Payment ID number for the new authorized payment\n    function authorizePayment(\n        string _name,\n        bytes32 _reference,\n        address _recipient,\n        uint _amount,\n        uint _paymentDelay\n    ) returns(uint) {\n\n        // Fail if you arent on the `allowedSpenders` white list\n        if (!allowedSpenders[msg.sender] ) throw;\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\n        authorizedPayments.length++;\n\n        // The following lines fill out the payment struct\n        Payment p = authorizedPayments[idPayment];\n        p.spender = msg.sender;\n\n        // Overflow protection\n        if (_paymentDelay > 10**18) throw;\n\n        // Determines the earliest the recipient can receive payment (Unix time)\n        p.earliestPayTime = _paymentDelay >= timeLock ?\n                                now + _paymentDelay :\n                                now + timeLock;\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.name = _name;\n        p.reference = _reference;\n        PaymentAuthorized(idPayment, p.recipient, p.amount);\n        return idPayment;\n    }\n\n    /// @notice only `allowedSpenders[]` The recipient of a payment calls this\n    ///  function to send themselves the ether after the `earliestPayTime` has\n    ///  expired\n    /// @param _idPayment The payment ID to be executed\n    function collectAuthorizedPayment(uint _idPayment) {\n\n        // Check that the `_idPayment` has been added to the payments struct\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n        // Checking for reasons not to execute the payment\n        if (msg.sender != p.recipient) throw;\n        if (!allowedSpenders[p.spender]) throw;\n        if (now < p.earliestPayTime) throw;\n        if (p.canceled) throw;\n        if (p.paid) throw;\n        if (this.balance < p.amount) throw;\n\n        p.paid = true; // Set the payment to being paid\n        if (!p.recipient.send(p.amount)) {  // Make the payment\n            throw;\n        }\n        PaymentExecuted(_idPayment, p.recipient, p.amount);\n     }\n\n/////////\n// SecurityGuard Interface\n/////////\n\n    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds\n    /// @param _idPayment ID of the payment to be delayed\n    /// @param _delay The number of seconds to delay the payment\n    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        // Overflow test\n        if (_delay > 10**18) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n        if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) ||\n            (p.paid) ||\n            (p.canceled))\n            throw;\n\n        p.securityGuardDelay += _delay;\n        p.earliestPayTime += _delay;\n    }\n\n////////\n// Owner Interface\n///////\n\n    /// @notice `onlyOwner` Cancel a payment all together\n    /// @param _idPayment ID of the payment to be canceled.\n    function cancelPayment(uint _idPayment) onlyOwner {\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n\n        if (p.canceled) throw;\n        if (p.paid) throw;\n\n        p.canceled = true;\n        PaymentCanceled(_idPayment);\n    }\n\n    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list\n    /// @param _spender The address of the contract being authorized/unauthorized\n    /// @param _authorize `true` if authorizing and `false` if unauthorizing\n    function authorizeSpender(address _spender, bool _authorize) onlyOwner {\n        allowedSpenders[_spender] = _authorize;\n        SpenderAuthorization(_spender, _authorize);\n    }\n\n    /// @notice `onlyOwner` Sets the address of `securityGuard`\n    /// @param _newSecurityGuard Address of the new security guard\n    function setSecurityGuard(address _newSecurityGuard) onlyOwner {\n        securityGuard = _newSecurityGuard;\n    }\n\n    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be\n    ///  lower than `absoluteMinTimeLock`\n    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;\n    ///  pending payments maintain their `earliestPayTime`\n    function setTimelock(uint _newTimeLock) onlyOwner {\n        if (_newTimeLock < absoluteMinTimeLock) throw;\n        timeLock = _newTimeLock;\n    }\n\n    /// @notice `onlyOwner` Changes the maximum number of seconds\n    /// `securityGuard` can delay a payment\n    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that\n    ///  `securityGuard` can delay the payment's execution in total\n    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyOwner {\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n}",
        "debug": "storage_3: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Vault_4 + calldata_Vault_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_Vault_32 + 100: 0x0\nstorage_6: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 87,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5958,
        "code": "cribes the details of\n    ///  each payment making it easy to track the movement of funds\n    ///  transparently\n    struct Payment {\n        string name;     // What is the purpose of this payment\n        bytes32 reference;  // Reference of the payment.\n        address spender;        // Who is sending the funds\n        uint earliestPayTime;   // The earliest a payment can be made (Unix Time)\n        bool canceled;         // If True then the payment has been canceled\n        bool paid;              // If True then the payment has been paid\n        address recipient;      // Who is receiving the funds\n        uint amount;            // The amount of wei sent in the payment\n        uint securityGuardDelay;// The seconds `securityGuard` can delay payment\n    }\n\n    Payment[] public authorizedPayments;\n\n    address public securityGuard;\n    uint public absoluteMinTimeLock;\n    uint public timeLock;\n    uint public maxSecurityGuardDelay;\n\n    /// @dev The white list of approved addresses allowed to set up && receive\n    ///  payments from this vault\n    mapping (address => bool) public allowedSpenders;\n\n    /// @dev The address assigned the role of `securityGuard` is the only\n    ///  addresses that can call a function with this modifier\n    modifier onlySecurityGuard { if (msg.sender != securityGuard) throw; _; }\n\n    // @dev Events to make the payment movements easy to find on the blockchain\n    event PaymentAuthorized(uint indexed idPayment, address indexed recipient, uint amount);\n    event PaymentExecuted(uint indexed idPayment, address indexed recipient, uint amount);\n    event PaymentCanceled(uint indexed idPayment);\n    event EtherReceived(address indexed from, uint amount);\n    event SpenderAuthorization(address indexed spender, bool authorized);\n\n/////////\n// Constructor\n/////////\n\n    /// @notice The Constructor creates the Vault on the blockchain\n    /// @param _escapeHatchCaller The address of a trusted account or contract to\n    ///  call `escapeHatch()` to send the ether in this contract to the\n    ///  `escapeHatchDestination` it would be ideal if `escapeHatchCaller` cannot move\n    ///  funds out of `escapeHatchDestination`\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether held in this contract in an emergency\n    /// @param _absoluteMinTimeLock The minimum number of seconds `timelock` can\n    ///  be set to, if set to 0 the `owner` can remove the `timeLock` completely\n    /// @param _timeLock Initial number of seconds that payments are delayed\n    ///  after they are authorized (a security precaution)\n    /// @param _securityGuard Address that will be able to delay the payments\n    ///  beyond the initial timelock requirements; can be set to 0x0 to remove\n    ///  the `securityGuard` functionality\n    /// @param _maxSecurityGuardDelay The maximum number of seconds in total\n    ///   that `securityGuard` can delay a payment so that the owner can cancel\n    ///   the payment if needed\n    function Vault(\n        address _escapeHatchCaller,\n        address _escapeHatchDestination,\n        uint _absoluteMinTimeLock,\n        uint _timeLock,\n        address _securityGuard,\n        uint _maxSecurityGuardDelay) Escapable(_escapeHatchCaller, _escapeHatchDestination)\n    {\n        absoluteMinTimeLock = _absoluteMinTimeLock;\n        timeLock = _timeLock;\n        securityGuard = _securityGuard;\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n\n/////////\n// Helper functions\n/////////\n\n    /// @notice States the total number of authorized payments in this contract\n    /// @return The number of payments ever authorized even if they were canceled\n    function numberOfAuthorizedPayments() constant returns (uint) {\n        return authorizedPayments.length;\n    }\n\n//////\n// Receive Ether\n//////\n\n    /// @notice Called anytime ether is sent to the contract && creates an event\n    /// to more easily track the incoming transactions\n    function receiveEther() payable {\n        EtherReceived(msg.sender, msg.value);\n    }\n\n    /// @notice The fall back function is called whenever ether is sent to this\n    ///  contract\n    function () payable {\n        receiveEther();\n    }\n\n////////\n// Spender Interface\n////////\n\n    /// @notice only `allowedSpenders[]` Creates a new `Payment`\n    /// @param _name Brief description of the payment that is authorized\n    /// @param _reference External reference of the payment\n    /// @param _recipient Destination of the payment\n    /// @param _amount Amount to be paid in wei\n    /// @param _paymentDelay Number of seconds the payment is to be delayed, if\n    ///  this value is below `timeLock` then the `timeLock` determines the delay\n    /// @return The Payment ID number for the new authorized payment\n    function authorizePayment(\n        string _name,\n        bytes32 _reference,\n        address _recipient,\n        uint _amount,\n        uint _paymentDelay\n    ) returns(uint) {\n\n        // Fail if you arent on the `allowedSpenders` white list\n        if (!allowedSpenders[msg.sender] ) throw;\n        uint idPayment = authorizedPayments.length;       // Unique Payment ID\n        authorizedPayments.length++;\n\n        // The following lines fill out the payment struct\n        Payment p = authorizedPayments[idPayment];\n        p.spender = msg.sender;\n\n        // Overflow protection\n        if (_paymentDelay > 10**18) throw;\n\n        // Determines the earliest the recipient can receive payment (Unix time)\n        p.earliestPayTime = _paymentDelay >= timeLock ?\n                                now + _paymentDelay :\n                                now + timeLock;\n        p.recipient = _recipient;\n        p.amount = _amount;\n        p.name = _name;\n        p.reference = _reference;\n        PaymentAuthorized(idPayment, p.recipient, p.amount);\n        return idPayment;\n    }\n\n    /// @notice only `allowedSpenders[]` The recipient of a payment calls this\n    ///  function to send themselves the ether after the `earliestPayTime` has\n    ///  expired\n    /// @param _idPayment The payment ID to be executed\n    function collectAuthorizedPayment(uint _idPayment) {\n\n        // Check that the `_idPayment` has been added to the payments struct\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n        // Checking for reasons not to execute the payment\n        if (msg.sender != p.recipient) throw;\n        if (!allowedSpenders[p.spender]) throw;\n        if (now < p.earliestPayTime) throw;\n        if (p.canceled) throw;\n        if (p.paid) throw;\n        if (this.balance < p.amount) throw;\n\n        p.paid = true; // Set the payment to being paid\n        if (!p.recipient.send(p.amount)) {  // Make the payment\n            throw;\n        }\n        PaymentExecuted(_idPayment, p.recipient, p.amount);\n     }\n\n/////////\n// SecurityGuard Interface\n/////////\n\n    /// @notice `onlySecurityGuard` Delays a payment for a set number of seconds\n    /// @param _idPayment ID of the payment to be delayed\n    /// @param _delay The number of seconds to delay the payment\n    function delayPayment(uint _idPayment, uint _delay) onlySecurityGuard {\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        // Overflow test\n        if (_delay > 10**18) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n        if ((p.securityGuardDelay + _delay > maxSecurityGuardDelay) ||\n            (p.paid) ||\n            (p.canceled))\n            throw;\n\n        p.securityGuardDelay += _delay;\n        p.earliestPayTime += _delay;\n    }\n\n////////\n// Owner Interface\n///////\n\n    /// @notice `onlyOwner` Cancel a payment all together\n    /// @param _idPayment ID of the payment to be canceled.\n    function cancelPayment(uint _idPayment) onlyOwner {\n        if (_idPayment >= authorizedPayments.length) throw;\n\n        Payment p = authorizedPayments[_idPayment];\n\n\n        if (p.canceled) throw;\n        if (p.paid) throw;\n\n        p.canceled = true;\n        PaymentCanceled(_idPayment);\n    }\n\n    /// @notice `onlyOwner` Adds a spender to the `allowedSpenders[]` white list\n    /// @param _spender The address of the contract being authorized/unauthorized\n    /// @param _authorize `true` if authorizing and `false` if unauthorizing\n    function authorizeSpender(address _spender, bool _authorize) onlyOwner {\n        allowedSpenders[_spender] = _authorize;\n        SpenderAuthorization(_spender, _authorize);\n    }\n\n    /// @notice `onlyOwner` Sets the address of `securityGuard`\n    /// @param _newSecurityGuard Address of the new security guard\n    function setSecurityGuard(address _newSecurityGuard) onlyOwner {\n        securityGuard = _newSecurityGuard;\n    }\n\n    /// @notice `onlyOwner` Changes `timeLock`; the new `timeLock` cannot be\n    ///  lower than `absoluteMinTimeLock`\n    /// @param _newTimeLock Sets the new minimum default `timeLock` in seconds;\n    ///  pending payments maintain their `earliestPayTime`\n    function setTimelock(uint _newTimeLock) onlyOwner {\n        if (_newTimeLock < absoluteMinTimeLock) throw;\n        timeLock = _newTimeLock;\n    }\n\n    /// @notice `onlyOwner` Changes the maximum number of seconds\n    /// `securityGuard` can delay a payment\n    /// @param _maxSecurityGuardDelay The new maximum delay in seconds that\n    ///  `securityGuard` can delay the payment's execution in total\n    function setMaxSecurityGuardDelay(uint _maxSecurityGuardDelay) onlyOwner {\n        maxSecurityGuardDelay = _maxSecurityGuardDelay;\n    }\n}",
        "debug": "storage_3: 0xe0800000000003ffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Vault_4 + calldata_Vault_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_Vault_32 + 100: 0x0\nstorage_6: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Vault_0: 0x20ea253300000000000000000000000000000000000000000000000000000000\ncalldatasize_Vault: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `authorizePayment(string,bytes32,address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x598ab825d607ace3b00d8714c0a141c7ae2e6822.sol",
        "function": "authorizePayment(string,bytes32,address,uint256,uint256)",
        "lineno": 87,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}