{
  "contract": "0x92ccac0fa81d538d280755e30746aa0e21cb2da8",
  "tool": "mythril",
  "start": 1563550134.7499819,
  "end": 1563551677.3510633,
  "duration": 1542.6010813713074,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1332,
        "code": "erviceId].serviceName = _serviceName;\n        serviceConfgMap[_serviceId].price = _price;\n        serviceConfgMap[_serviceId].discount = _discount;\n        serviceConfgMap[_serviceId].fitAddr = _fitAddr;\n        serviceConfgMap[_serviceId].detail = _desc;\n        return true;\n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u4ef7\u683c\n    function configOf(uint64 _serviceId) public view returns (string serviceName, uint256 price, uint256 discount, address addr, string desc){\n        serviceName = serviceConfgMap[_serviceId].serviceName;\n        price = serviceConfgMap[_serviceId].price;\n        discou",
        "debug": "calldata_EIP20Interface_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_EIP20Interface_0: 0x4dea4d1500000000000000000000000000000000000000000000000000000000\ncalldatasize_EIP20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setConfig(uint64,string,uint256,uint256,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x92ccac0fa81d538d280755e30746aa0e21cb2da8.sol",
        "function": "setConfig(uint64,string,uint256,uint256,address,string)",
        "lineno": 157,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4354,
        "code": "e-line indent, no-unuse",
        "debug": "calldata_EIP20Interface_32 + 36: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EIP20Interface_32_+_4: 0xc050fffff320c00020003d81af848540000000000000040000110001bd062022\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_EIP20Interface_4: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\ncalldata_EIP20Interface_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_EIP20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x92ccac0fa81d538d280755e30746aa0e21cb2da8.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 130,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11080,
        "code": "ate MAX_UINT256 = 2**256 - 1;\n    //\u521b\u59cb\u8005\n    address public god;\n    // \u70b9\u5361\u4f59\u989d\n    mapping (address => uint256) public balances;\n    // \u70b9\u5361\u6388\u6743\u7ef4\u62a4\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    //\u670d\u52a1\u8282\u70b9\n    struct ServiceStat {\n        address user;\n        uint64 serviceId;\n        string serviceName;\n        uint256 timestamp; \n    }\n\n    //\u6bcf\u4e2a\u7528\u6237\u72b6\u6001\u72b6\u6001\n    mapping (address => mapping (uint64 => ServiceStat)) public serviceStatMap;\n\n    //\u670d\u52a1\u4ef7\u683c\n    struct ServiceConfig{\n        uint64 serviceId;\n        string serviceName;\n        uint256 price;\n        uint256 discount;\n        address fitAddr;\n        string detail;\n    }\n    //\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    mapping (uint64 => ServiceConfig) public serviceConfgMap;\n    mapping (uint64 => uint256) public serviceWin;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n    //\u5151\u6362\u6bd4\u4f8b\n    uint256 public tokenPrice;\n    \n    //\u4ee5\u4e0b\u4e3aERC20\u7684\u89c4\u8303\n    constructor(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n    ) public {\n        god = msg.sender;\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    //\u4ee5\u4e0b\u4e3a\u670d\u52a1\u76f8\u5173\n    function getMsgSender() public view returns(address sender){\n        return msg.sender;\n    }\n\n    //\u8bbe\u7f6e\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    function setConfig(uint64 _serviceId, string _serviceName, uint256 _price, uint256 _discount, address _fitAddr, string _desc) public returns (bool success){\n        require(msg.sender==god);\n        serviceConfgMap[_serviceId].serviceId = _serviceId;\n        serviceConfgMap[_serviceId].serviceName = _serviceName;\n        serviceConfgMap[_serviceId].price = _price;\n        serviceConfgMap[_serviceId].discount = _discount;\n        serviceConfgMap[_serviceId].fitAddr = _fitAddr;\n        serviceConfgMap[_serviceId].detail = _desc;\n        return true;\n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u4ef7\u683c\n    function configOf(uint64 _serviceId) public view returns (string serviceName, uint256 price, uint256 discount, address addr, string desc){\n        serviceName = serviceConfgMap[_serviceId].serviceName;\n        price = serviceConfgMap[_serviceId].price;\n        discount = serviceConfgMap[_serviceId].discount;\n        addr = serviceConfgMap[_serviceId].fitAddr;\n        desc = serviceConfgMap[_serviceId].detail;\n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyService(uint64 _serviceId,uint64 _count) public returns (uint256 cost, uint256 timestamp){\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        //require(balances[msg.sender]>need);\n        if( transfer(fitAddr,cost ) == true ){\n            uint256 timeEx = serviceStatMap[msg.sender][_serviceId].timestamp;\n            if(timeEx == 0){\n                serviceStatMap[msg.sender][_serviceId].serviceId = _serviceId;\n                serviceStatMap[msg.sender][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n                serviceStatMap[msg.sender][_serviceId].user = msg.sender;\n                serviceStatMap[msg.sender][_serviceId].timestamp = now + (_count * 86400);\n                serviceWin[_serviceId] += cost;\n                timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n            }else{\n                if(timeEx < now){\n                    timeEx = now;\n                }\n                timeEx += (_count * 86400);\n                serviceStatMap[msg.sender][_serviceId].timestamp = timeEx;\n                timestamp = timeEx;\n            }\n        }else{\n            timestamp = 0;\n        }\n        \n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyServiceByAdmin(uint64 _serviceId,uint64 _count,address addr) public returns (uint256 cost, uint256 timestamp){\n        require(msg.sender==god);\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        timestamp = 0;\n        require(balances[addr] >= cost);\n        balances[fitAddr] += cost;\n        balances[addr] -= cost;\n        emit Transfer(addr, fitAddr, cost); \n\n        uint256 timeEx = serviceStatMap[addr][_serviceId].timestamp;\n        if(timeEx == 0){\n            serviceStatMap[addr][_serviceId].serviceId = _serviceId;\n            serviceStatMap[addr][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n            serviceStatMap[addr][_serviceId].user = addr;\n            serviceStatMap[addr][_serviceId].timestamp = now + (_count * 86400); \n            serviceWin[_serviceId] += cost;\n            timestamp = serviceStatMap[addr][_serviceId].timestamp;\n        }else{\n            if(timeEx < now){\n                timeEx = now;\n            }\n            timeEx += (_count * 86400);\n            serviceStatMap[addr][_serviceId].timestamp = timeEx;\n            timestamp = timeEx;\n        }    \n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStat(uint64 _serviceId) public view returns (uint256 timestamp){\n        timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n    }\n    \n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStatByAddr(uint64 _serviceId,address addr) public view returns (uint256 timestamp){\n        require(msg.sender==god);\n        timestamp = serviceStatMap[addr][_serviceId].timestamp;\n    }\n\n    //admin\n    function getWin(uint64 _serviceId) public view returns (uint256 win){\n        require(msg.sender==god);\n        win = serviceWin[_serviceId];\n        return win;\n    }\n    //\u8bbe\u7f6etoken price\n    function setPrice(uint256 _price) public returns (bool success){\n        require(msg.sender==god);\n        tokenPrice = _price;\n        return true;\n    }\n\n    //get token price\n    function getPrice() public view returns (uint256 _price){\n        require(msg.sender==god);\n        _price = tokenPrice;\n        return tokenPrice;\n    }\n}",
        "debug": "keccac_1_+\nkeccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_EIP20Interface_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_EIP20Interface_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EIP20Interface_0: 0x4dea4d1500000000000000000000000000000000000000000000000000000000\ncalldatasize_EIP20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setConfig(uint64,string,uint256,uint256,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x92ccac0fa81d538d280755e30746aa0e21cb2da8.sol",
        "function": "setConfig(uint64,string,uint256,uint256,address,string)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11109,
        "code": "ate MAX_UINT256 = 2**256 - 1;\n    //\u521b\u59cb\u8005\n    address public god;\n    // \u70b9\u5361\u4f59\u989d\n    mapping (address => uint256) public balances;\n    // \u70b9\u5361\u6388\u6743\u7ef4\u62a4\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    //\u670d\u52a1\u8282\u70b9\n    struct ServiceStat {\n        address user;\n        uint64 serviceId;\n        string serviceName;\n        uint256 timestamp; \n    }\n\n    //\u6bcf\u4e2a\u7528\u6237\u72b6\u6001\u72b6\u6001\n    mapping (address => mapping (uint64 => ServiceStat)) public serviceStatMap;\n\n    //\u670d\u52a1\u4ef7\u683c\n    struct ServiceConfig{\n        uint64 serviceId;\n        string serviceName;\n        uint256 price;\n        uint256 discount;\n        address fitAddr;\n        string detail;\n    }\n    //\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    mapping (uint64 => ServiceConfig) public serviceConfgMap;\n    mapping (uint64 => uint256) public serviceWin;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n    //\u5151\u6362\u6bd4\u4f8b\n    uint256 public tokenPrice;\n    \n    //\u4ee5\u4e0b\u4e3aERC20\u7684\u89c4\u8303\n    constructor(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n    ) public {\n        god = msg.sender;\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    //\u4ee5\u4e0b\u4e3a\u670d\u52a1\u76f8\u5173\n    function getMsgSender() public view returns(address sender){\n        return msg.sender;\n    }\n\n    //\u8bbe\u7f6e\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    function setConfig(uint64 _serviceId, string _serviceName, uint256 _price, uint256 _discount, address _fitAddr, string _desc) public returns (bool success){\n        require(msg.sender==god);\n        serviceConfgMap[_serviceId].serviceId = _serviceId;\n        serviceConfgMap[_serviceId].serviceName = _serviceName;\n        serviceConfgMap[_serviceId].price = _price;\n        serviceConfgMap[_serviceId].discount = _discount;\n        serviceConfgMap[_serviceId].fitAddr = _fitAddr;\n        serviceConfgMap[_serviceId].detail = _desc;\n        return true;\n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u4ef7\u683c\n    function configOf(uint64 _serviceId) public view returns (string serviceName, uint256 price, uint256 discount, address addr, string desc){\n        serviceName = serviceConfgMap[_serviceId].serviceName;\n        price = serviceConfgMap[_serviceId].price;\n        discount = serviceConfgMap[_serviceId].discount;\n        addr = serviceConfgMap[_serviceId].fitAddr;\n        desc = serviceConfgMap[_serviceId].detail;\n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyService(uint64 _serviceId,uint64 _count) public returns (uint256 cost, uint256 timestamp){\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        //require(balances[msg.sender]>need);\n        if( transfer(fitAddr,cost ) == true ){\n            uint256 timeEx = serviceStatMap[msg.sender][_serviceId].timestamp;\n            if(timeEx == 0){\n                serviceStatMap[msg.sender][_serviceId].serviceId = _serviceId;\n                serviceStatMap[msg.sender][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n                serviceStatMap[msg.sender][_serviceId].user = msg.sender;\n                serviceStatMap[msg.sender][_serviceId].timestamp = now + (_count * 86400);\n                serviceWin[_serviceId] += cost;\n                timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n            }else{\n                if(timeEx < now){\n                    timeEx = now;\n                }\n                timeEx += (_count * 86400);\n                serviceStatMap[msg.sender][_serviceId].timestamp = timeEx;\n                timestamp = timeEx;\n            }\n        }else{\n            timestamp = 0;\n        }\n        \n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyServiceByAdmin(uint64 _serviceId,uint64 _count,address addr) public returns (uint256 cost, uint256 timestamp){\n        require(msg.sender==god);\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        timestamp = 0;\n        require(balances[addr] >= cost);\n        balances[fitAddr] += cost;\n        balances[addr] -= cost;\n        emit Transfer(addr, fitAddr, cost); \n\n        uint256 timeEx = serviceStatMap[addr][_serviceId].timestamp;\n        if(timeEx == 0){\n            serviceStatMap[addr][_serviceId].serviceId = _serviceId;\n            serviceStatMap[addr][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n            serviceStatMap[addr][_serviceId].user = addr;\n            serviceStatMap[addr][_serviceId].timestamp = now + (_count * 86400); \n            serviceWin[_serviceId] += cost;\n            timestamp = serviceStatMap[addr][_serviceId].timestamp;\n        }else{\n            if(timeEx < now){\n                timeEx = now;\n            }\n            timeEx += (_count * 86400);\n            serviceStatMap[addr][_serviceId].timestamp = timeEx;\n            timestamp = timeEx;\n        }    \n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStat(uint64 _serviceId) public view returns (uint256 timestamp){\n        timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n    }\n    \n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStatByAddr(uint64 _serviceId,address addr) public view returns (uint256 timestamp){\n        require(msg.sender==god);\n        timestamp = serviceStatMap[addr][_serviceId].timestamp;\n    }\n\n    //admin\n    function getWin(uint64 _serviceId) public view returns (uint256 win){\n        require(msg.sender==god);\n        win = serviceWin[_serviceId];\n        return win;\n    }\n    //\u8bbe\u7f6etoken price\n    function setPrice(uint256 _price) public returns (bool success){\n        require(msg.sender==god);\n        tokenPrice = _price;\n        return true;\n    }\n\n    //get token price\n    function getPrice() public view returns (uint256 _price){\n        require(msg.sender==god);\n        _price = tokenPrice;\n        return tokenPrice;\n    }\n}",
        "debug": "keccac_1_+\nkeccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_EIP20Interface_4: 0xfe6c3882c8c219105b1269338c14a907b57fe56d7e7402ce023400000973b6fb\nstorage_1 +\nkeccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_EIP20Interface_4: 0xfde7dbef9fbcee952ba2fefcee7f3f46f6fffcffffffffffffffffffffffffc5\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_EIP20Interface_4 + calldata_EIP20Interface_32 + 4)): 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_EIP20Interface_4 + calldata_EIP20Interface_32 + 4: 0x0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EIP20Interface_0: 0x4dea4d1500000000000000000000000000000000000000000000000000000000\ncalldatasize_EIP20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setConfig(uint64,string,uint256,uint256,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x92ccac0fa81d538d280755e30746aa0e21cb2da8.sol",
        "function": "setConfig(uint64,string,uint256,uint256,address,string)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11123,
        "code": "ate MAX_UINT256 = 2**256 - 1;\n    //\u521b\u59cb\u8005\n    address public god;\n    // \u70b9\u5361\u4f59\u989d\n    mapping (address => uint256) public balances;\n    // \u70b9\u5361\u6388\u6743\u7ef4\u62a4\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    //\u670d\u52a1\u8282\u70b9\n    struct ServiceStat {\n        address user;\n        uint64 serviceId;\n        string serviceName;\n        uint256 timestamp; \n    }\n\n    //\u6bcf\u4e2a\u7528\u6237\u72b6\u6001\u72b6\u6001\n    mapping (address => mapping (uint64 => ServiceStat)) public serviceStatMap;\n\n    //\u670d\u52a1\u4ef7\u683c\n    struct ServiceConfig{\n        uint64 serviceId;\n        string serviceName;\n        uint256 price;\n        uint256 discount;\n        address fitAddr;\n        string detail;\n    }\n    //\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    mapping (uint64 => ServiceConfig) public serviceConfgMap;\n    mapping (uint64 => uint256) public serviceWin;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n    //\u5151\u6362\u6bd4\u4f8b\n    uint256 public tokenPrice;\n    \n    //\u4ee5\u4e0b\u4e3aERC20\u7684\u89c4\u8303\n    constructor(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n    ) public {\n        god = msg.sender;\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    //\u4ee5\u4e0b\u4e3a\u670d\u52a1\u76f8\u5173\n    function getMsgSender() public view returns(address sender){\n        return msg.sender;\n    }\n\n    //\u8bbe\u7f6e\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    function setConfig(uint64 _serviceId, string _serviceName, uint256 _price, uint256 _discount, address _fitAddr, string _desc) public returns (bool success){\n        require(msg.sender==god);\n        serviceConfgMap[_serviceId].serviceId = _serviceId;\n        serviceConfgMap[_serviceId].serviceName = _serviceName;\n        serviceConfgMap[_serviceId].price = _price;\n        serviceConfgMap[_serviceId].discount = _discount;\n        serviceConfgMap[_serviceId].fitAddr = _fitAddr;\n        serviceConfgMap[_serviceId].detail = _desc;\n        return true;\n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u4ef7\u683c\n    function configOf(uint64 _serviceId) public view returns (string serviceName, uint256 price, uint256 discount, address addr, string desc){\n        serviceName = serviceConfgMap[_serviceId].serviceName;\n        price = serviceConfgMap[_serviceId].price;\n        discount = serviceConfgMap[_serviceId].discount;\n        addr = serviceConfgMap[_serviceId].fitAddr;\n        desc = serviceConfgMap[_serviceId].detail;\n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyService(uint64 _serviceId,uint64 _count) public returns (uint256 cost, uint256 timestamp){\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        //require(balances[msg.sender]>need);\n        if( transfer(fitAddr,cost ) == true ){\n            uint256 timeEx = serviceStatMap[msg.sender][_serviceId].timestamp;\n            if(timeEx == 0){\n                serviceStatMap[msg.sender][_serviceId].serviceId = _serviceId;\n                serviceStatMap[msg.sender][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n                serviceStatMap[msg.sender][_serviceId].user = msg.sender;\n                serviceStatMap[msg.sender][_serviceId].timestamp = now + (_count * 86400);\n                serviceWin[_serviceId] += cost;\n                timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n            }else{\n                if(timeEx < now){\n                    timeEx = now;\n                }\n                timeEx += (_count * 86400);\n                serviceStatMap[msg.sender][_serviceId].timestamp = timeEx;\n                timestamp = timeEx;\n            }\n        }else{\n            timestamp = 0;\n        }\n        \n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyServiceByAdmin(uint64 _serviceId,uint64 _count,address addr) public returns (uint256 cost, uint256 timestamp){\n        require(msg.sender==god);\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        timestamp = 0;\n        require(balances[addr] >= cost);\n        balances[fitAddr] += cost;\n        balances[addr] -= cost;\n        emit Transfer(addr, fitAddr, cost); \n\n        uint256 timeEx = serviceStatMap[addr][_serviceId].timestamp;\n        if(timeEx == 0){\n            serviceStatMap[addr][_serviceId].serviceId = _serviceId;\n            serviceStatMap[addr][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n            serviceStatMap[addr][_serviceId].user = addr;\n            serviceStatMap[addr][_serviceId].timestamp = now + (_count * 86400); \n            serviceWin[_serviceId] += cost;\n            timestamp = serviceStatMap[addr][_serviceId].timestamp;\n        }else{\n            if(timeEx < now){\n                timeEx = now;\n            }\n            timeEx += (_count * 86400);\n            serviceStatMap[addr][_serviceId].timestamp = timeEx;\n            timestamp = timeEx;\n        }    \n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStat(uint64 _serviceId) public view returns (uint256 timestamp){\n        timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n    }\n    \n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStatByAddr(uint64 _serviceId,address addr) public view returns (uint256 timestamp){\n        require(msg.sender==god);\n        timestamp = serviceStatMap[addr][_serviceId].timestamp;\n    }\n\n    //admin\n    function getWin(uint64 _serviceId) public view returns (uint256 win){\n        require(msg.sender==god);\n        win = serviceWin[_serviceId];\n        return win;\n    }\n    //\u8bbe\u7f6etoken price\n    function setPrice(uint256 _price) public returns (bool success){\n        require(msg.sender==god);\n        tokenPrice = _price;\n        return true;\n    }\n\n    //get token price\n    function getPrice() public view returns (uint256 _price){\n        require(msg.sender==god);\n        _price = tokenPrice;\n        return tokenPrice;\n    }\n}",
        "debug": "calldata_EIP20Interface_4 + calldata_EIP20Interface_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EIP20Interface_0: 0x4dea4d1500000000000000000000000000000000000000000000000000000000\ncalldatasize_EIP20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setConfig(uint64,string,uint256,uint256,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x92ccac0fa81d538d280755e30746aa0e21cb2da8.sol",
        "function": "setConfig(uint64,string,uint256,uint256,address,string)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11145,
        "code": "ate MAX_UINT256 = 2**256 - 1;\n    //\u521b\u59cb\u8005\n    address public god;\n    // \u70b9\u5361\u4f59\u989d\n    mapping (address => uint256) public balances;\n    // \u70b9\u5361\u6388\u6743\u7ef4\u62a4\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    //\u670d\u52a1\u8282\u70b9\n    struct ServiceStat {\n        address user;\n        uint64 serviceId;\n        string serviceName;\n        uint256 timestamp; \n    }\n\n    //\u6bcf\u4e2a\u7528\u6237\u72b6\u6001\u72b6\u6001\n    mapping (address => mapping (uint64 => ServiceStat)) public serviceStatMap;\n\n    //\u670d\u52a1\u4ef7\u683c\n    struct ServiceConfig{\n        uint64 serviceId;\n        string serviceName;\n        uint256 price;\n        uint256 discount;\n        address fitAddr;\n        string detail;\n    }\n    //\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    mapping (uint64 => ServiceConfig) public serviceConfgMap;\n    mapping (uint64 => uint256) public serviceWin;\n    /*\n    NOTE:\n    The following variables are OPTIONAL vanities. One does not have to include them.\n    They allow one to customise the token contract & in no way influences the core functionality.\n    Some wallets/interfaces might not even bother to look at this information.\n    */\n    string public name;                   //fancy name: eg Simon Bucks\n    uint8 public decimals;                //How many decimals to show.\n    string public symbol;                 //An identifier: eg SBX\n    //\u5151\u6362\u6bd4\u4f8b\n    uint256 public tokenPrice;\n    \n    //\u4ee5\u4e0b\u4e3aERC20\u7684\u89c4\u8303\n    constructor(\n        uint256 _initialAmount,\n        string _tokenName,\n        uint8 _decimalUnits,\n        string _tokenSymbol\n    ) public {\n        god = msg.sender;\n        balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens\n        totalSupply = _initialAmount;                        // Update total supply\n        name = _tokenName;                                   // Set the name for display purposes\n        decimals = _decimalUnits;                            // Amount of decimals for display purposes\n        symbol = _tokenSymbol;                               // Set the symbol for display purposes\n    }\n\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        require(balances[msg.sender] >= _value);\n        balances[msg.sender] -= _value;\n        balances[_to] += _value;\n        emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        uint256 allowance = allowed[_from][msg.sender];\n        require(balances[_from] >= _value && allowance >= _value);\n        balances[_to] += _value;\n        balances[_from] -= _value;\n        if (allowance < MAX_UINT256) {\n            allowed[_from][msg.sender] -= _value;\n        }\n        emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    //\u4ee5\u4e0b\u4e3a\u670d\u52a1\u76f8\u5173\n    function getMsgSender() public view returns(address sender){\n        return msg.sender;\n    }\n\n    //\u8bbe\u7f6e\u670d\u52a1\u4ef7\u683c\u914d\u7f6e\n    function setConfig(uint64 _serviceId, string _serviceName, uint256 _price, uint256 _discount, address _fitAddr, string _desc) public returns (bool success){\n        require(msg.sender==god);\n        serviceConfgMap[_serviceId].serviceId = _serviceId;\n        serviceConfgMap[_serviceId].serviceName = _serviceName;\n        serviceConfgMap[_serviceId].price = _price;\n        serviceConfgMap[_serviceId].discount = _discount;\n        serviceConfgMap[_serviceId].fitAddr = _fitAddr;\n        serviceConfgMap[_serviceId].detail = _desc;\n        return true;\n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u4ef7\u683c\n    function configOf(uint64 _serviceId) public view returns (string serviceName, uint256 price, uint256 discount, address addr, string desc){\n        serviceName = serviceConfgMap[_serviceId].serviceName;\n        price = serviceConfgMap[_serviceId].price;\n        discount = serviceConfgMap[_serviceId].discount;\n        addr = serviceConfgMap[_serviceId].fitAddr;\n        desc = serviceConfgMap[_serviceId].detail;\n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyService(uint64 _serviceId,uint64 _count) public returns (uint256 cost, uint256 timestamp){\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        //require(balances[msg.sender]>need);\n        if( transfer(fitAddr,cost ) == true ){\n            uint256 timeEx = serviceStatMap[msg.sender][_serviceId].timestamp;\n            if(timeEx == 0){\n                serviceStatMap[msg.sender][_serviceId].serviceId = _serviceId;\n                serviceStatMap[msg.sender][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n                serviceStatMap[msg.sender][_serviceId].user = msg.sender;\n                serviceStatMap[msg.sender][_serviceId].timestamp = now + (_count * 86400);\n                serviceWin[_serviceId] += cost;\n                timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n            }else{\n                if(timeEx < now){\n                    timeEx = now;\n                }\n                timeEx += (_count * 86400);\n                serviceStatMap[msg.sender][_serviceId].timestamp = timeEx;\n                timestamp = timeEx;\n            }\n        }else{\n            timestamp = 0;\n        }\n        \n    }\n\n    //\u8d2d\u4e70\u670d\u52a1\n    function buyServiceByAdmin(uint64 _serviceId,uint64 _count,address addr) public returns (uint256 cost, uint256 timestamp){\n        require(msg.sender==god);\n        require(_count >= 1);\n        //\u8ba1\u7b97\u591a\u5c11\u70b9\u5361\n        //ServiceConfig storage config = serviceConfgMap[_serviceId];\n        cost = serviceConfgMap[_serviceId].price * serviceConfgMap[_serviceId].discount * _count / 100;\n        address fitAddr = serviceConfgMap[_serviceId].fitAddr;\n        timestamp = 0;\n        require(balances[addr] >= cost);\n        balances[fitAddr] += cost;\n        balances[addr] -= cost;\n        emit Transfer(addr, fitAddr, cost); \n\n        uint256 timeEx = serviceStatMap[addr][_serviceId].timestamp;\n        if(timeEx == 0){\n            serviceStatMap[addr][_serviceId].serviceId = _serviceId;\n            serviceStatMap[addr][_serviceId].serviceName = serviceConfgMap[_serviceId].serviceName;\n            serviceStatMap[addr][_serviceId].user = addr;\n            serviceStatMap[addr][_serviceId].timestamp = now + (_count * 86400); \n            serviceWin[_serviceId] += cost;\n            timestamp = serviceStatMap[addr][_serviceId].timestamp;\n        }else{\n            if(timeEx < now){\n                timeEx = now;\n            }\n            timeEx += (_count * 86400);\n            serviceStatMap[addr][_serviceId].timestamp = timeEx;\n            timestamp = timeEx;\n        }    \n    }\n\n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStat(uint64 _serviceId) public view returns (uint256 timestamp){\n        timestamp = serviceStatMap[msg.sender][_serviceId].timestamp;\n    }\n    \n    //\u83b7\u53d6\u670d\u52a1\u65f6\u957f\n    function getServiceStatByAddr(uint64 _serviceId,address addr) public view returns (uint256 timestamp){\n        require(msg.sender==god);\n        timestamp = serviceStatMap[addr][_serviceId].timestamp;\n    }\n\n    //admin\n    function getWin(uint64 _serviceId) public view returns (uint256 win){\n        require(msg.sender==god);\n        win = serviceWin[_serviceId];\n        return win;\n    }\n    //\u8bbe\u7f6etoken price\n    function setPrice(uint256 _price) public returns (bool success){\n        require(msg.sender==god);\n        tokenPrice = _price;\n        return true;\n    }\n\n    //get token price\n    function getPrice() public view returns (uint256 _price){\n        require(msg.sender==god);\n        _price = tokenPrice;\n        return tokenPrice;\n    }\n}",
        "debug": "calldata_EIP20Interface_4 + calldata_EIP20Interface_32 + 4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_1_+\nkeccac_18446744073709551615_&\n18446744073709551615_&\n18446744073709551615_&\ncalldata_EIP20Interface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\ncaller: 0x0\ncalldata_EIP20Interface_0: 0x4dea4d1500000000000000000000000000000000000000000000000000000000\ncalldatasize_EIP20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setConfig(uint64,string,uint256,uint256,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x92ccac0fa81d538d280755e30746aa0e21cb2da8.sol",
        "function": "setConfig(uint64,string,uint256,uint256,address,string)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}