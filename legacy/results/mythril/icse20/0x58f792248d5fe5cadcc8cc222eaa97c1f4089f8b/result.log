{"error": null, "issues": [{"address": 1453, "code": "iption = _description;\n        c.hashOfTheDocument = _hashOfTheDocument; \n        c.dateOfProposal = _dateOfProposal;\n        c.lastClientProposalID = _lastClientProposalID;\n        c.orderAmount = _orderAmount;\n        c.dateOfOrder = _dateOfOrder;\n        \n        ProposalCloned(_lastClientProposalID, _proposalID, c.amount, c.description, c.hashOfTheDocument);\n        \n        return true;\n            \n    }\n\n    function initialTokenSupply(\n        address _recipient, \n        uint _quantity) returns (bool success) {\n\n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\n        \n        if (_recipient != 0 && _quantity != 0) {\n            return (createInitialTokens(_recipient, _quantity));\n        }\n            \n    }\n\n    function cloneTokens(\n        uint _from,\n        uint _to) returns (bool success) {\n        \n        if (smartContractStartDate != 0) throw;\n        \n        PassManager _clonedFrom = PassManager(clone", "debug": "calldata_PassManagerInterface_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_PassManagerInterface_0: 0x14b78abb00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)", "lineno": 536, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4574, "code": "struct fundingData {\n      ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_PassManagerInterface_4: 0x0\nstorage_0: 0x0\ncalldata_PassManagerInterface_0: 0x13cf08b00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "_function_0x013cf08b", "lineno": 37, "title": "Exception state", "type": "Informational"}, {"address": 5230, "code": "  function addHolder(a", "debug": "The exception is triggered under the following conditions:\n\ncalldata_PassManagerInterface_32 + 4: 0x0\nstorage_0: 0x0\nstorage_19: 0x0\ncaller: 0x0\nstorage_20: 0x0\ncalldata_PassManagerInterface_0: 0xe88212900000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "order(uint256,uint256,uint256)", "lineno": 682, "title": "Exception state", "type": "Informational"}, {"address": 5254, "code": "  \n        if (holderID[_hol", "debug": "calldata_PassManagerInterface_32 + 36: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_5 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_PassManagerInterface_32 + 4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_PassManagerInterface_32 + 4: 0x0\nstorage_0: 0x1\nstorage_19: 0x0\ncaller: 0x0\nstorage_20: 0x0\ncalldata_PassManagerInterface_0: 0xe88212900000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `order(uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "order(uint256,uint256,uint256)", "lineno": 683, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5305, "code": "  holderID[_holder] = _holderID;\n          ", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "order(uint256,uint256,uint256)", "lineno": 688, "title": "State change after external call", "type": "Warning"}, {"address": 5314, "code": "ed(_holderID, _holde", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "order(uint256,uint256,uint256)", "lineno": 689, "title": "State change after external call", "type": "Warning"}, {"address": 5323, "code": "  }\n        \n    }\n", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "order(uint256,uint256,uint256)", "lineno": 691, "title": "State change after external call", "type": "Warning"}, {"address": 5568, "code": "le {\n        AmountReceived(m", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneTokens(uint256,uint256)", "lineno": 594, "title": "Message call to external contract", "type": "Informational"}, {"address": 5568, "code": "le {\n        AmountReceived(m", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6056\nCall at address: 5764\n", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneTokens(uint256,uint256)", "lineno": 594, "title": "Multiple Calls", "type": "Information"}, {"address": 5764, "code": "wRecipient) onlyContractor {", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneTokens(uint256,uint256)", "lineno": 600, "title": "Message call to external contract", "type": "Informational"}, {"address": 5764, "code": "wRecipient) onlyContractor {", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6056\n", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneTokens(uint256,uint256)", "lineno": 600, "title": "Multiple Calls", "type": "Information"}, {"address": 6056, "code": "ecipientUpdated(recipient, _ne", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneTokens(uint256,uint256)", "lineno": 605, "title": "Message call to external contract", "type": "Informational"}, {"address": 6332, "code": "ction initialToken", "debug": "storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18: 0x0\ncaller: 0x0\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_PassManagerInterface_0: 0x14b78abb00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\nstorage_25: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)", "lineno": 549, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6358, "code": "_recipient, \n        u", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18: 0x0\ncaller: 0x0\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_PassManagerInterface_0: 0x14b78abb00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\nstorage_25: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)", "lineno": 550, "title": "Exception state", "type": "Informational"}, {"address": 6721, "code": " the last Manager before cloning\n ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_PassManagerInterface_4: 0x2\ncalldata_PassManagerInterface_0: 0x185a7daf00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "_function_0x185a7daf", "lineno": 61, "title": "Exception state", "type": "Informational"}, {"address": 9742, "code": "d[_owner][_spender];\n    }\n\n    fu", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "transferFrom(address,address,uint256)", "lineno": 418, "title": "Message call to external contract", "type": "Informational"}, {"address": 10431, "code": "balance) {\n        ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "updateClient(address)", "lineno": 413, "title": "Message call to external contract", "type": "Informational"}, {"address": 17238, "code": "    }\n    \n    function totalSupply() constant external returns (uint256) {\n        return totalTokenSupply;\n    }\n\n     function balanceOf(address _owner) constant external returns (uint256 balance) {\n        return balances[_owner];\n     }\n\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function FundedAmount(uint _proposalID) constant external returns (uint) {\n        return fundedAmount[_proposalID];\n    }\n\n    function priceDivisor(uint _saleDate) constant internal returns (uint) {\n        uint _date = _saleDate;\n        \n        if (_saleDate > FundingRules[0].closingTime) _date = FundingRules[0].closingTime;\n        if (_saleDate < FundingRules[0].startTime) _date = FundingRules[0].startTime;\n\n        return 100 + 100*FundingRules[0].inflationRate*(_date - FundingRules[0].startTime)/(100*365 days);\n    }\n    \n    function actualPriceDivisor() constant external returns (uint) {\n        return priceDivisor(now);\n    }\n\n    function fundingMaxAmount(address _mainPartner) constant external returns (uint) {\n        \n        if (now > FundingRules[0].closingTime\n            || now < FundingRules[0].startTime\n            || _mainPartner != FundingRules[0].mainPartner) {\n            return 0;   \n        } else {\n            return FundingRules[0].maxAmountToFund;\n        }\n        \n    }\n\n    function numberOfHolders() constant returns (uint) {\n        return holders.length - 1;\n    }\n    \n    function HolderAddress(uint _index) constant returns (address) {\n        return holders[_index];\n    }\n\n    function numberOfProposals() constant returns (uint) {\n        return proposals.length - 1;\n    }\n\n// Modifiers\n\n    // Modifier that allows only the client to manage this account manager\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\n    \n    // Modifier that allows only the main partner to manage the actual funding\n    modifier onlyMainPartner {if (msg.sender !=  FundingRules[0].mainPartner) throw; _;}\n    \n    // Modifier that allows only the contractor propose set the token price or withdraw\n    modifier onlyContractor {if (recipient == 0 || (msg.sender != recipient && msg.sender != creator)) throw; _;}\n    \n    // Modifier for Dao functions\n    modifier onlyDao {if (recipient != 0) throw; _;}\n    \n// Constructor function\n\n    function PassManager(\n        address _client,\n        address _daoManager,\n        address _recipient,\n        address _clonedFrom,\n        string _tokenName,\n        string _tokenSymbol,\n        uint8 _tokenDecimals,\n        bool _transferable\n    ) {\n\n        if ((_recipient == 0 && _client == 0)\n            || _client == _recipient) throw;\n\n        creator = msg.sender; \n        client = _client;\n        recipient = _recipient;\n        \n        if (_recipient !=0) daoManager = PassManager(_daoManager);\n\n        clonedFrom = _clonedFrom;            \n        \n        name = _tokenName;\n        symbol = _tokenSymbol;\n        decimals = _tokenDecimals;\n          \n        if (_transferable) {\n            transferable = true;\n            TransferAble();\n        } else {\n            transferable = false;\n            TransferDisable(0);\n        }\n\n        holders.length = 1;\n        proposals.length = 1;\n        \n    }\n\n// Setting functions\n\n    function cloneProposal(\n        uint _amount,\n        string _description,\n        bytes32 _hashOfTheDocument,\n        uint _dateOfProposal,\n        uint _lastClientProposalID,\n        uint _orderAmount,\n        uint _dateOfOrder\n    ) returns (bool success) {\n            \n        if (smartContractStartDate != 0 || recipient == 0\n        || msg.sender != creator) throw;\n        \n        uint _proposalID = proposals.length++;\n        proposal c = proposals[_proposalID];\n\n        c.amount = _amount;\n        c.description = _description;\n        c.hashOfTheDocument = _hashOfTheDocument; \n        c.dateOfProposal = _dateOfProposal;\n        c.lastClientProposalID = _lastClientProposalID;\n        c.orderAmount = _orderAmount;\n        c.dateOfOrder = _dateOfOrder;\n        \n        ProposalCloned(_lastClientProposalID, _proposalID, c.amount, c.description, c.hashOfTheDocument);\n        \n        return true;\n            \n    }\n\n    function initialTokenSupply(\n        address _recipient, \n        uint _quantity) returns (bool success) {\n\n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\n        \n        if (_recipient != 0 && _quantity != 0) {\n            return (createInitialTokens(_recipient, _quantity));\n        }\n            \n    }\n\n    function cloneTokens(\n        uint _from,\n        uint _to) returns (bool success) {\n        \n        if (smartContractStartDate != 0) throw;\n        \n        PassManager _clonedFrom = PassManager(clonedFrom);\n        \n        if (_from < 1 || _to > _clonedFrom.numberOfHolders()) throw;\n\n        address _holder;\n\n        for (uint i = _from; i <= _to; i++) {\n            _holder = _clonedFrom.HolderAddress(i);\n            if (balances[_holder] == 0) {\n                createInitialTokens(_holder, _clonedFrom.balanceOf(_holder));\n            }\n        }\n\n        return true;\n        \n    }\n\n    function closeSetup() {\n        \n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\n\n        smartContractStartDate = now;\n\n    }\n\n// Function to receive payments or deposits\n\n    function () payable {\n        AmountReceived(msg.sender, msg.value);\n    }\n    \n// Contractors Account Management\n\n    function updateRecipient(address _newRecipient) onlyContractor {\n\n        if (_newRecipient == 0 \n            || _newRecipient == client) throw;\n\n        RecipientUpdated(recipient, _newRecipient);\n        recipient = _newRecipient;\n\n    } \n\n    function withdraw(uint _amount) onlyContractor {\n        if (!recipient.send(_amount)) throw;\n        Withdawal(recipient, _amount);\n    }\n    \n// DAO Proposals Management\n\n    function updateClient(address _newClient) onlyClient {\n        \n        if (_newClient == 0 \n            || _newClient == recipient) throw;\n\n        ClientUpdated(client, _newClient);\n        client = _newClient;        \n\n    }\n\n    function newProposal(\n        uint _amount,\n        string _description, \n        bytes32 _hashOfTheDocument\n    ) onlyContractor returns (uint) {\n\n        uint _proposalID = proposals.length++;\n        proposal c = proposals[_proposalID];\n\n        c.amount = _amount;\n        c.description = _description;\n        c.hashOfTheDocument = _hashOfTheDocument; \n        c.dateOfProposal = now;\n        \n        ProposalAdded(_proposalID, c.amount, c.description, c.hashOfTheDocument);\n        \n        return _proposalID;\n        \n    }\n    \n    function order(\n        uint _clientProposalID,\n        uint _proposalID,\n        uint _orderAmount\n    ) external onlyClient returns (bool) {\n    \n        proposal c = proposals[_proposalID];\n        \n        uint _sum = c.orderAmount + _orderAmount;\n        if (_sum > c.amount\n            || _sum < c.orderAmount\n            || _sum < _orderAmount) return; \n\n        c.lastClientProposalID =  _clientProposalID;\n        c.orderAmount = _sum;\n        c.dateOfOrder = now;\n        \n        Order(_clientProposalID, _proposalID, _orderAmount);\n        \n        return true;\n\n    }\n\n    function sendTo(\n        address _recipient,\n        uint _amount\n    ) external onlyClient onlyDao returns (bool) {\n\n        if (_recipient.send(_amount)) return true;\n        else return false;\n\n    }\n    \n// Token Management\n    \n    function addHolder(address _holder) internal {\n        \n        if (holderID[_holder] == 0) {\n            \n            uint _holderID = holders.length++;\n            holders[_holderID] = _holder;\n            holderID[_holder] = _holderID;\n            holderAdded(_holderID, _holder);\n\n        }\n        \n    }\n    \n    function createInitialTokens(\n        address _holder, \n        uint _quantity\n    ) internal returns (bool success) {\n\n        if (_quantity > 0 && balances[_holder] == 0) {\n            addHolder(_holder);\n            balances[_holder] = _quantity; \n            totalTokenSupply += _quantity;\n            TokensCreated(msg.sender, _holder, _quantity);\n            return true;\n        }\n        \n    }\n    \n    function setTokenPriceProposal(        \n        uint _initialPriceMultiplier, \n        uint _inflationRate,\n        uint _closingTime\n    ) onlyContractor {\n        \n        if (_closingTime < now \n            || now < FundingRules[1].closingTime) throw;\n        \n        FundingRules[1].initialPriceMultiplier = _initialPriceMultiplier;\n        FundingRules[1].inflationRate = _inflationRate;\n        FundingRules[1].startTime = now;\n        FundingRules[1].closingTime = _closingTime;\n        \n        TokenPriceProposalSet(_initialPriceMultiplier, _inflationRate, _closingTime);\n    }\n    \n    function setFundingRules(\n        address _mainPartner,\n        bool _publicCreation, \n        uint _initialPriceMultiplier,\n        uint _maxAmountToFund, \n        uint _minutesFundingPeriod, \n        uint _inflationRate,\n        uint _proposalID\n    ) external onlyClient {\n\n        if (now < FundingRules[0].closingTime\n            || _mainPartner == address(this)\n            || _mainPartner == client\n            || (!_publicCreation && _mainPartner == 0)\n            || (_publicCreation && _mainPartner != 0)\n            || (recipient == 0 && _initialPriceMultiplier == 0)\n            || (recipient != 0 \n                && (FundingRules[1].initialPriceMultiplier == 0\n                    || _inflationRate < FundingRules[1].inflationRate\n                    || now < FundingRules[1].startTime\n                    || FundingRules[1].closingTime < now + (_minutesFundingPeriod * 1 minutes)))\n            || _maxAmountToFund == 0\n            || _minutesFundingPeriod == 0\n            ) throw;\n\n        FundingRules[0].startTime = now;\n        FundingRules[0].closingTime = now + _minutesFundingPeriod * 1 minutes;\n            \n        FundingRules[0].mainPartner = _mainPartner;\n        FundingRules[0].publicCreation = _publicCreation;\n        \n        if (recipient == 0) FundingRules[0].initialPriceMultiplier = _initialPriceMultiplier;\n        else FundingRules[0].initialPriceMultiplier = FundingRules[1].initialPriceMultiplier;\n        \n        if (recipient == 0) FundingRules[0].inflationRate = _inflationRate;\n        else FundingRules[0].inflationRate = FundingRules[1].inflationRate;\n        \n        FundingRules[0].fundedAmount = 0;\n        FundingRules[0].maxAmountToFund = _maxAmountToFund;\n\n        FundingRules[0].proposalID = _proposalID;\n\n        FundingRulesSet(_mainPartner, _proposalID, FundingRules[0].startTime, FundingRules[0].closingTime);\n            \n    } \n    \n    function createToken(\n        address _recipient, \n        uint _amount,\n        uint _saleDate\n    ) internal returns (bool success) {\n\n        if (now > FundingRules[0].closingTime\n            || now < FundingRules[0].startTime\n            ||_saleDate > FundingRules[0].closingTime\n            || _saleDate < FundingRules[0].startTime\n            || FundingRules[0].fundedAmount + _amount > FundingRules[0].maxAmountToFund) return;\n\n        uint _a = _amount*FundingRules[0].initialPriceMultiplier;\n        uint _multiplier = 100*_a;\n        uint _quantity = _multiplier/priceDivisor(_saleDate);\n        if (_a/_amount != FundingRules[0].initialPriceMultiplier\n            || _multiplier/100 != _a\n            || totalTokenSupply + _quantity <= totalTokenSupply \n            || totalTokenSupply + _quantity <= _quantity) return;\n\n        addHolder(_recipient);\n        balances[_recipient] += _quantity;\n        totalTokenSupply += _quantity;\n        FundingRules[0].fundedAmount += _amount;\n\n        TokensCreated(msg.sender, _recipient, _quantity);\n        \n        if (FundingRules[0].fundedAmount == FundingRules[0].maxAmountToFund) closeFunding();\n        \n        return true;\n\n    }\n\n    function setFundingStartTime(uint _startTime) external onlyMainPartner {\n        if (now > FundingRules[0].closingTime) throw;\n        FundingRules[0].startTime = _startTime;\n    }\n    \n    function rewardToken(\n        address _recipient, \n        uint _amount,\n        uint _date\n        ) external onlyMainPartner {\n\n        uint _saleDate;\n        if (_date == 0) _saleDate = now; else _saleDate = _date;\n\n        if (!createToken(_recipient, _amount, _saleDate)) throw;\n\n    }\n\n    function closeFunding() internal {\n        if (recipient == 0) fundedAmount[FundingRules[0].proposalID] = FundingRules[0].fundedAmount;\n        FundingRules[0].closingTime = now;\n    }\n    \n    function setFundingFueled() external onlyMainPartner {\n        if (now > FundingRules[0].closingTime) throw;\n        closeFunding();\n        if (recipient == 0) FundingFueled(FundingRules[0].proposalID, FundingRules[0].fundedAmount);\n    }\n    \n    function ableTransfer() onlyClient {\n        if (!transferable) {\n            transferable = true;\n            closingTimeForCloning = 0;\n            TransferAble();\n        }\n    }\n\n    function disableTransfer(uint _closingTime) onlyClient {\n        if (transferable && _closingTime == 0) transferable = false;\n        else closingTimeForCloning = _closingTime;\n            \n        TransferDisable(_closingTime);\n    }\n    \n    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyDao {\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\n            blockedDeadLine[_shareHolder] = _deadLine;\n        }\n    }\n    \n    function buyShares() payable {\n        buySharesFor(msg.sender);\n    } \n    \n    function buySharesFor(address _recipient) payable onlyDao {\n        \n        if (!FundingRules[0].publicCreation \n            || !createToken(_recipient, msg.value, now)) throw;\n\n    }\n    \n    function transferFromTo(\n        address _from,\n        address _to, \n        uint256 _value\n        ) internal returns (bool success) {  \n\n        if ((transferable && now > ClosingTimeForCloning())\n            && now > blockedDeadLine[_from]\n            && now > blockedDeadLine[_to]\n            && _to != address(this)\n            && balances[_from] >= _value\n            && balances[_to] + _value > balances[_to]\n            && balances[_to] + _value >= _value\n        ) {\n            balances[_from] -= _value;\n            balances[_to] += _value;\n            Transfer(_from, _to, _value);\n            addHolder(_to);\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n\n    function transfer(address _to, uint256 _value) returns (bool success) {  \n        if (!transferFromTo(msg.sender, _to, _value)) throw;\n        return true;\n    }\n\n    function transferFrom(\n        address _from, \n        address _to, \n        uint256 _value\n        ) returns (bool success) { \n        \n        if (allowed[_from][msg.sender] < _value\n            || !transferFromTo(_from, _to, _value)) throw;\n            \n        allowed[_from][msg.sender] -= _value;\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        return true;\n    }\n    \n}    \n\npragma solidity ^0.4.6;\n\n/*\nThis file is part of Pass DAO.\n\nPass DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nPass DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with Pass DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\nSmart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n/// @title Pass Decentralized Autonomous Organisation\ncontract PassDaoInterface {\n\n    struc", "debug": "storage_0: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_PassManagerInterface_4 + calldata_PassManagerInterface_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_18: 0x0\ncaller: 0x0\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_PassManagerInterface_0: 0x14b78abb00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\nstorage_25: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)", "lineno": 407, "title": "Integer Overflow ", "type": "Warning"}, {"address": 17252, "code": "    }\n    \n    function totalSupply() constant external returns (uint256) {\n        return totalTokenSupply;\n    }\n\n     function balanceOf(address _owner) constant external returns (uint256 balance) {\n        return balances[_owner];\n     }\n\n    function allowance(address _owner, address _spender) constant external returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function FundedAmount(uint _proposalID) constant external returns (uint) {\n        return fundedAmount[_proposalID];\n    }\n\n    function priceDivisor(uint _saleDate) constant internal returns (uint) {\n        uint _date = _saleDate;\n        \n        if (_saleDate > FundingRules[0].closingTime) _date = FundingRules[0].closingTime;\n        if (_saleDate < FundingRules[0].startTime) _date = FundingRules[0].startTime;\n\n        return 100 + 100*FundingRules[0].inflationRate*(_date - FundingRules[0].startTime)/(100*365 days);\n    }\n    \n    function actualPriceDivisor() constant external returns (uint) {\n        return priceDivisor(now);\n    }\n\n    function fundingMaxAmount(address _mainPartner) constant external returns (uint) {\n        \n        if (now > FundingRules[0].closingTime\n            || now < FundingRules[0].startTime\n            || _mainPartner != FundingRules[0].mainPartner) {\n            return 0;   \n        } else {\n            return FundingRules[0].maxAmountToFund;\n        }\n        \n    }\n\n    function numberOfHolders() constant returns (uint) {\n        return holders.length - 1;\n    }\n    \n    function HolderAddress(uint _index) constant returns (address) {\n        return holders[_index];\n    }\n\n    function numberOfProposals() constant returns (uint) {\n        return proposals.length - 1;\n    }\n\n// Modifiers\n\n    // Modifier that allows only the client to manage this account manager\n    modifier onlyClient {if (msg.sender != Client()) throw; _;}\n    \n    // Modifier that allows only the main partner to manage the actual funding\n    modifier onlyMainPartner {if (msg.sender !=  FundingRules[0].mainPartner) throw; _;}\n    \n    // Modifier that allows only the contractor propose set the token price or withdraw\n    modifier onlyContractor {if (recipient == 0 || (msg.sender != recipient && msg.sender != creator)) throw; _;}\n    \n    // Modifier for Dao functions\n    modifier onlyDao {if (recipient != 0) throw; _;}\n    \n// Constructor function\n\n    function PassManager(\n        address _client,\n        address _daoManager,\n        address _recipient,\n        address _clonedFrom,\n        string _tokenName,\n        string _tokenSymbol,\n        uint8 _tokenDecimals,\n        bool _transferable\n    ) {\n\n        if ((_recipient == 0 && _client == 0)\n            || _client == _recipient) throw;\n\n        creator = msg.sender; \n        client = _client;\n        recipient = _recipient;\n        \n        if (_recipient !=0) daoManager = PassManager(_daoManager);\n\n        clonedFrom = _clonedFrom;            \n        \n        name = _tokenName;\n        symbol = _tokenSymbol;\n        decimals = _tokenDecimals;\n          \n        if (_transferable) {\n            transferable = true;\n            TransferAble();\n        } else {\n            transferable = false;\n            TransferDisable(0);\n        }\n\n        holders.length = 1;\n        proposals.length = 1;\n        \n    }\n\n// Setting functions\n\n    function cloneProposal(\n        uint _amount,\n        string _description,\n        bytes32 _hashOfTheDocument,\n        uint _dateOfProposal,\n        uint _lastClientProposalID,\n        uint _orderAmount,\n        uint _dateOfOrder\n    ) returns (bool success) {\n            \n        if (smartContractStartDate != 0 || recipient == 0\n        || msg.sender != creator) throw;\n        \n        uint _proposalID = proposals.length++;\n        proposal c = proposals[_proposalID];\n\n        c.amount = _amount;\n        c.description = _description;\n        c.hashOfTheDocument = _hashOfTheDocument; \n        c.dateOfProposal = _dateOfProposal;\n        c.lastClientProposalID = _lastClientProposalID;\n        c.orderAmount = _orderAmount;\n        c.dateOfOrder = _dateOfOrder;\n        \n        ProposalCloned(_lastClientProposalID, _proposalID, c.amount, c.description, c.hashOfTheDocument);\n        \n        return true;\n            \n    }\n\n    function initialTokenSupply(\n        address _recipient, \n        uint _quantity) returns (bool success) {\n\n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\n        \n        if (_recipient != 0 && _quantity != 0) {\n            return (createInitialTokens(_recipient, _quantity));\n        }\n            \n    }\n\n    function cloneTokens(\n        uint _from,\n        uint _to) returns (bool success) {\n        \n        if (smartContractStartDate != 0) throw;\n        \n        PassManager _clonedFrom = PassManager(clonedFrom);\n        \n        if (_from < 1 || _to > _clonedFrom.numberOfHolders()) throw;\n\n        address _holder;\n\n        for (uint i = _from; i <= _to; i++) {\n            _holder = _clonedFrom.HolderAddress(i);\n            if (balances[_holder] == 0) {\n                createInitialTokens(_holder, _clonedFrom.balanceOf(_holder));\n            }\n        }\n\n        return true;\n        \n    }\n\n    function closeSetup() {\n        \n        if (smartContractStartDate != 0 || msg.sender != creator) throw;\n\n        smartContractStartDate = now;\n\n    }\n\n// Function to receive payments or deposits\n\n    function () payable {\n        AmountReceived(msg.sender, msg.value);\n    }\n    \n// Contractors Account Management\n\n    function updateRecipient(address _newRecipient) onlyContractor {\n\n        if (_newRecipient == 0 \n            || _newRecipient == client) throw;\n\n        RecipientUpdated(recipient, _newRecipient);\n        recipient = _newRecipient;\n\n    } \n\n    function withdraw(uint _amount) onlyContractor {\n        if (!recipient.send(_amount)) throw;\n        Withdawal(recipient, _amount);\n    }\n    \n// DAO Proposals Management\n\n    function updateClient(address _newClient) onlyClient {\n        \n        if (_newClient == 0 \n            || _newClient == recipient) throw;\n\n        ClientUpdated(client, _newClient);\n        client = _newClient;        \n\n    }\n\n    function newProposal(\n        uint _amount,\n        string _description, \n        bytes32 _hashOfTheDocument\n    ) onlyContractor returns (uint) {\n\n        uint _proposalID = proposals.length++;\n        proposal c = proposals[_proposalID];\n\n        c.amount = _amount;\n        c.description = _description;\n        c.hashOfTheDocument = _hashOfTheDocument; \n        c.dateOfProposal = now;\n        \n        ProposalAdded(_proposalID, c.amount, c.description, c.hashOfTheDocument);\n        \n        return _proposalID;\n        \n    }\n    \n    function order(\n        uint _clientProposalID,\n        uint _proposalID,\n        uint _orderAmount\n    ) external onlyClient returns (bool) {\n    \n        proposal c = proposals[_proposalID];\n        \n        uint _sum = c.orderAmount + _orderAmount;\n        if (_sum > c.amount\n            || _sum < c.orderAmount\n            || _sum < _orderAmount) return; \n\n        c.lastClientProposalID =  _clientProposalID;\n        c.orderAmount = _sum;\n        c.dateOfOrder = now;\n        \n        Order(_clientProposalID, _proposalID, _orderAmount);\n        \n        return true;\n\n    }\n\n    function sendTo(\n        address _recipient,\n        uint _amount\n    ) external onlyClient onlyDao returns (bool) {\n\n        if (_recipient.send(_amount)) return true;\n        else return false;\n\n    }\n    \n// Token Management\n    \n    function addHolder(address _holder) internal {\n        \n        if (holderID[_holder] == 0) {\n            \n            uint _holderID = holders.length++;\n            holders[_holderID] = _holder;\n            holderID[_holder] = _holderID;\n            holderAdded(_holderID, _holder);\n\n        }\n        \n    }\n    \n    function createInitialTokens(\n        address _holder, \n        uint _quantity\n    ) internal returns (bool success) {\n\n        if (_quantity > 0 && balances[_holder] == 0) {\n            addHolder(_holder);\n            balances[_holder] = _quantity; \n            totalTokenSupply += _quantity;\n            TokensCreated(msg.sender, _holder, _quantity);\n            return true;\n        }\n        \n    }\n    \n    function setTokenPriceProposal(        \n        uint _initialPriceMultiplier, \n        uint _inflationRate,\n        uint _closingTime\n    ) onlyContractor {\n        \n        if (_closingTime < now \n            || now < FundingRules[1].closingTime) throw;\n        \n        FundingRules[1].initialPriceMultiplier = _initialPriceMultiplier;\n        FundingRules[1].inflationRate = _inflationRate;\n        FundingRules[1].startTime = now;\n        FundingRules[1].closingTime = _closingTime;\n        \n        TokenPriceProposalSet(_initialPriceMultiplier, _inflationRate, _closingTime);\n    }\n    \n    function setFundingRules(\n        address _mainPartner,\n        bool _publicCreation, \n        uint _initialPriceMultiplier,\n        uint _maxAmountToFund, \n        uint _minutesFundingPeriod, \n        uint _inflationRate,\n        uint _proposalID\n    ) external onlyClient {\n\n        if (now < FundingRules[0].closingTime\n            || _mainPartner == address(this)\n            || _mainPartner == client\n            || (!_publicCreation && _mainPartner == 0)\n            || (_publicCreation && _mainPartner != 0)\n            || (recipient == 0 && _initialPriceMultiplier == 0)\n            || (recipient != 0 \n                && (FundingRules[1].initialPriceMultiplier == 0\n                    || _inflationRate < FundingRules[1].inflationRate\n                    || now < FundingRules[1].startTime\n                    || FundingRules[1].closingTime < now + (_minutesFundingPeriod * 1 minutes)))\n            || _maxAmountToFund == 0\n            || _minutesFundingPeriod == 0\n            ) throw;\n\n        FundingRules[0].startTime = now;\n        FundingRules[0].closingTime = now + _minutesFundingPeriod * 1 minutes;\n            \n        FundingRules[0].mainPartner = _mainPartner;\n        FundingRules[0].publicCreation = _publicCreation;\n        \n        if (recipient == 0) FundingRules[0].initialPriceMultiplier = _initialPriceMultiplier;\n        else FundingRules[0].initialPriceMultiplier = FundingRules[1].initialPriceMultiplier;\n        \n        if (recipient == 0) FundingRules[0].inflationRate = _inflationRate;\n        else FundingRules[0].inflationRate = FundingRules[1].inflationRate;\n        \n        FundingRules[0].fundedAmount = 0;\n        FundingRules[0].maxAmountToFund = _maxAmountToFund;\n\n        FundingRules[0].proposalID = _proposalID;\n\n        FundingRulesSet(_mainPartner, _proposalID, FundingRules[0].startTime, FundingRules[0].closingTime);\n            \n    } \n    \n    function createToken(\n        address _recipient, \n        uint _amount,\n        uint _saleDate\n    ) internal returns (bool success) {\n\n        if (now > FundingRules[0].closingTime\n            || now < FundingRules[0].startTime\n            ||_saleDate > FundingRules[0].closingTime\n            || _saleDate < FundingRules[0].startTime\n            || FundingRules[0].fundedAmount + _amount > FundingRules[0].maxAmountToFund) return;\n\n        uint _a = _amount*FundingRules[0].initialPriceMultiplier;\n        uint _multiplier = 100*_a;\n        uint _quantity = _multiplier/priceDivisor(_saleDate);\n        if (_a/_amount != FundingRules[0].initialPriceMultiplier\n            || _multiplier/100 != _a\n            || totalTokenSupply + _quantity <= totalTokenSupply \n            || totalTokenSupply + _quantity <= _quantity) return;\n\n        addHolder(_recipient);\n        balances[_recipient] += _quantity;\n        totalTokenSupply += _quantity;\n        FundingRules[0].fundedAmount += _amount;\n\n        TokensCreated(msg.sender, _recipient, _quantity);\n        \n        if (FundingRules[0].fundedAmount == FundingRules[0].maxAmountToFund) closeFunding();\n        \n        return true;\n\n    }\n\n    function setFundingStartTime(uint _startTime) external onlyMainPartner {\n        if (now > FundingRules[0].closingTime) throw;\n        FundingRules[0].startTime = _startTime;\n    }\n    \n    function rewardToken(\n        address _recipient, \n        uint _amount,\n        uint _date\n        ) external onlyMainPartner {\n\n        uint _saleDate;\n        if (_date == 0) _saleDate = now; else _saleDate = _date;\n\n        if (!createToken(_recipient, _amount, _saleDate)) throw;\n\n    }\n\n    function closeFunding() internal {\n        if (recipient == 0) fundedAmount[FundingRules[0].proposalID] = FundingRules[0].fundedAmount;\n        FundingRules[0].closingTime = now;\n    }\n    \n    function setFundingFueled() external onlyMainPartner {\n        if (now > FundingRules[0].closingTime) throw;\n        closeFunding();\n        if (recipient == 0) FundingFueled(FundingRules[0].proposalID, FundingRules[0].fundedAmount);\n    }\n    \n    function ableTransfer() onlyClient {\n        if (!transferable) {\n            transferable = true;\n            closingTimeForCloning = 0;\n            TransferAble();\n        }\n    }\n\n    function disableTransfer(uint _closingTime) onlyClient {\n        if (transferable && _closingTime == 0) transferable = false;\n        else closingTimeForCloning = _closingTime;\n            \n        TransferDisable(_closingTime);\n    }\n    \n    function blockTransfer(address _shareHolder, uint _deadLine) external onlyClient onlyDao {\n        if (_deadLine > blockedDeadLine[_shareHolder]) {\n            blockedDeadLine[_shareHolder] = _deadLine;\n        }\n    }\n    \n    function buyShares() payable {\n        buySharesFor(msg.sender);\n    } \n    \n    function buySharesFor(address _recipient) payable onlyDao {\n        \n        if (!FundingRules[0].publicCreation \n            || !createToken(_recipient, msg.value, now)) throw;\n\n    }\n    \n    function transferFromTo(\n        address _from,\n        address _to, \n        uint256 _value\n        ) internal returns (bool success) {  \n\n        if ((transferable && now > ClosingTimeForCloning())\n            && now > blockedDeadLine[_from]\n            && now > blockedDeadLine[_to]\n            && _to != address(this)\n            && balances[_from] >= _value\n            && balances[_to] + _value > balances[_to]\n            && balances[_to] + _value >= _value\n        ) {\n            balances[_from] -= _value;\n            balances[_to] += _value;\n            Transfer(_from, _to, _value);\n            addHolder(_to);\n            return true;\n        } else {\n            return false;\n        }\n        \n    }\n\n    function transfer(address _to, uint256 _value) returns (bool success) {  \n        if (!transferFromTo(msg.sender, _to, _value)) throw;\n        return true;\n    }\n\n    function transferFrom(\n        address _from, \n        address _to, \n        uint256 _value\n        ) returns (bool success) { \n        \n        if (allowed[_from][msg.sender] < _value\n            || !transferFromTo(_from, _to, _value)) throw;\n            \n        allowed[_from][msg.sender] -= _value;\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) returns (bool success) {\n        allowed[msg.sender][_spender] = _value;\n        return true;\n    }\n    \n}    \n\npragma solidity ^0.4.6;\n\n/*\nThis file is part of Pass DAO.\n\nPass DAO is free software: you can redistribute it and/or modify\nit under the terms of the GNU lesser General Public License as published by\nthe Free Software Foundation, either version 3 of the License, or\n(at your option) any later version.\n\nPass DAO is distributed in the hope that it will be useful,\nbut WITHOUT ANY WARRANTY; without even the implied warranty of\nMERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\nGNU lesser General Public License for more details.\n\nYou should have received a copy of the GNU lesser General Public License\nalong with Pass DAO.  If not, see <http://www.gnu.org/licenses/>.\n*/\n\n/*\nSmart contract for a Decentralized Autonomous Organization (DAO)\nto automate organizational governance and decision-making.\n*/\n\n/// @title Pass Decentralized Autonomous Organisation\ncontract PassDaoInterface {\n\n    struc", "debug": "storage_0: 0x3164cdbbd7715000000000000000000000000000000000000000000000000000\ncalldata_PassManagerInterface_4 + calldata_PassManagerInterface_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_18: 0x0\ncaller: 0x0\nstorage_20: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_PassManagerInterface_0: 0x14b78abb00000000000000000000000000000000000000000000000000000000\ncalldatasize_PassManagerInterface: 0x4\nstorage_25: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x58f792248d5fe5cadcc8cc222eaa97c1f4089f8b.sol", "function": "cloneProposal(uint256,string,bytes32,uint256,uint256,uint256,uint256)", "lineno": 407, "title": "Integer Overflow ", "type": "Warning"}], "success": true}