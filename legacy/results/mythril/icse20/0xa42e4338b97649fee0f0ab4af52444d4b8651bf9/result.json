{
  "contract": "0xa42e4338b97649fee0f0ab4af52444d4b8651bf9",
  "tool": "mythril",
  "start": 1563636751.4270117,
  "end": 1563637272.5006568,
  "duration": 521.0736451148987,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 5093,
        "code": "ublic owners;\n\taddress[",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_MultiSigERC20Token_4: 0x0\nstorage_4: 0x0\ncalldata_MultiSigERC20Token_0: 0x25e7c2700000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "_function_0x025e7c27",
        "lineno": 12,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5313,
        "code": "blic admins;\n\t\n\t// Vari",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_MultiSigERC20Token_4: 0x0\nstorage_5: 0x0\ncalldata_MultiSigERC20Token_0: 0x14bfd6d000000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "_function_0x14bfd6d0",
        "lineno": 13,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 11978,
        "code": "dd Owner\n        {\n            Submission(transactionId,\"Add Owner\", source, destination, value, reason);\n        }\n        else if(operation == 2) // Operation 2 is Remove Owner\n        {\n            Submission(transactionId,\"Remove Owner\", sourc",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x28a92ef700000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestRemoveAdmin(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestRemoveAdmin(address,string)",
        "lineno": 349,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 12004,
        "code": ", reason);\n        }\n",
        "debug": "storage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5 + keccac_storage_7: 0xdd83f7f8af5940bbbafeca9a46defb91bd4a9c9c8467e400400300002000f0c5\nkeccac_5_+_keccac_storage_7: 0xfe300e18c158ec412f5c4ede49124210c0840a26d60f2007ff5ff3ffff7ffd4e\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x22aef13c00000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestChangeRequirement(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestChangeRequirement(uint256,string)",
        "lineno": 355,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23195,
        "code": "ntract MultiSigERC20Token\n{\n    uint constant public MAX_OWNER_COUNT = 50;\n\t\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\taddress[] public owners;\n\taddress[] public admins;\n\t\n\t// Variables for multisig\n\tuint256 public required;\n    uint public transactionCount;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n\tevent Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event AdminAddition(address indexed admin);\n    event AdminRemoval(address indexed admin);\n    event RequirementChange(uint required);\n\t\n\t// Mappings\n    mapping (uint => MetaTransaction) public transactions;\n    mapping (address => uint256) public withdrawalLimit;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n\tmapping (address => bool) public frozenAccount;\n\tmapping (address => bool) public isAdmin;\n    mapping (address => uint256) public balanceOf;\n\n    // Meta data for pending and executed Transactions\n    struct MetaTransaction {\n        address source;\n        address destination;\n        uint value;\n        bool executed;\n        uint operation;\n        string reason;\n    }\n\n    // Modifiers\n    modifier ownerDoesNotExist(address owner) {\n        require (!isOwner[owner]);\n        _;\n    }\n    \n    modifier adminDoesNotExist(address admin) {\n        require (!isAdmin[admin]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require (isOwner[owner]);\n        _;\n    }\n    \n    modifier adminExists(address admin) {\n        require (isAdmin[admin] || isOwner[admin]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require (transactions[transactionId].operation != 0);\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require (confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require (!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require (!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require (_address != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() payable public\n    {\n        if (msg.value > 0)\n        {\n            Deposit(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the contract and sets owner to the \n     * creator of the contract\n     */\n    function MultiSigERC20Token(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\t\tisOwner[msg.sender] = true;                         // Set Owner to Contract Creator\n\t\tisAdmin[msg.sender] = true;\n\t\trequired = 1;\n\t\towners.push(msg.sender);\n\t\tadmins.push(msg.sender);\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check if the sender is frozen\n        require(!frozenAccount[_from]);\n        // Check if the recipient is frozen\n        require(!frozenAccount[_to]);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\t\n\t\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n    /// @param target Address to be frozen\n    /// @param freeze either to freeze it or not\n    function freezeAccount(address target, bool freeze) internal {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        internal\n        ownerDoesNotExist(owner)\n        notNull(owner)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        required = required + 1;\n        OwnerAddition(owner);\n    }\n    \n    /// @dev Allows to add a new admin. Transaction has to be sent by wallet.\n    /// @param admin Address of new admin.\n    function addAdmin(address admin)\n        internal\n        adminDoesNotExist(admin)\n        notNull(admin)\n    {\n        isAdmin[admin] = true;\n        admins.push(admin);\n        AdminAddition(admin);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        internal\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        OwnerRemoval(owner);\n    }\n    \n    \n    /// @dev Allows to remove an admin. Transaction has to be sent by wallet.\n    /// @param admin Address of admin.\n    function removeAdmin(address admin)\n        internal\n        adminExists(admin)\n    {\n        isAdmin[admin] = false;\n        for (uint i=0; i<admins.length - 1; i++)\n            if (admins[i] == admin) {\n                admins[i] = admins[admins.length - 1];\n                break;\n            }\n        admins.length -= 1;\n        AdminRemoval(admin);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param owner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        internal\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        OwnerRemoval(owner);\n        OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        internal\n    {\n        required = _required;\n        RequirementChange(_required);\n    }\n    \n    function requestAddOwner(address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(newOwner,newOwner,0,1,reason);\n    }\n\n    function requestRemoveOwner(address oldOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,oldOwner,0,2,reason);\n    }\n    \n    function requestReplaceOwner(address oldOwner,address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,newOwner,0,3,reason);\n    }\n    \n    function requestFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,4,reason);\n    }\n    \n    function requestUnFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,5,reason);\n    }\n    \n    function requestChangeRequirement(uint _requirement, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender,msg.sender,_requirement,6,reason);\n    }\n    \n    function requestTokenIssue(address account, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,amount,7,reason);\n    }\n    \n    function requestAdminTokenTransfer(address source,address destination, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(source, destination, amount,8,reason);\n    }\n    \n    function requestSetWithdrawalLimit(address owner,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(owner, owner, amount,9,reason);\n    }\n    \n    function requestWithdrawalFromLimit(uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender, msg.sender, amount,10,reason);\n    }\n    \n    function requestWithdrawal(address account,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, amount,11,reason);\n    }\n    \n    function requestAddAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,12,reason);\n    }\n    \n    function requestRemoveAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,13,reason);\n    }\n    \n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @return Returns transaction ID.\n    function submitTransaction(address source, address destination, uint256 value, uint operation, string reason)\n        internal\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = MetaTransaction({\n            source: source,\n            destination: destination,\n            value: value,\n            operation: operation,\n            executed: false,\n            reason: reason\n        });\n        \n        transactionCount += 1;\n        \n        if(operation == 1) // Operation 1 is Add Owner\n        {\n            Submission(transactionId,\"Add Owner\", source, destination, value, reason);\n        }\n        else if(operation == 2) // Operation 2 is Remove Owner\n        {\n            Submission(transactionId,\"Remove Owner\", source, destination, value, reason);\n        }\n        else if(operation == 3) // Operation 3 is Replace Owner\n        {\n            Submission(transactionId,\"Replace Owner\", source, destination, value, reason);\n        }\n        else if(operation == 4) // Operation 4 is Freeze Account\n        {\n            Submission(transactionId,\"Freeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 5) // Operation 5 is UnFreeze Account\n        {\n            Submission(transactionId,\"UnFreeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 6) // Operation 6 is change rquirement\n        {\n            Submission(transactionId,\"Change Requirement\", source, destination, value, reason);\n        }\n        else if(operation == 7) // Operation 7 is Issue Tokens from Contract\n        {\n            Submission(transactionId,\"Issue Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 8) // Operation 8 is Admin Transfer Tokens\n        {\n            Submission(transactionId,\"Admin Transfer Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n        {\n            Submission(transactionId,\"Set Unsigned Ethereum Withdrawal Limit\", source, destination, value, reason);\n        }\n        else if(operation == 10) // Operation 10 is Admin Withdraw Ether without multisig\n        {\n            require(isOwner[destination]);\n            require(withdrawalLimit[destination] > value);\n            \n            Submission(transactionId,\"Unsigned Ethereum Withdrawal\", source, destination, value, reason);\n            \n            var newValue = withdrawalLimit[destination] - value;\n            withdrawalLimit[destination] = newValue;\n            \n            destination.transfer(value);\n            transactions[transactionId].executed = true;\n            Execution(transactionId);\n        }\n        else if(operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n        {\n            Submission(transactionId,\"Withdraw Ethereum\", source, destination, value, reason);\n        }\n        else if(operation == 12) // Operation 12 is Add Admin\n        {\n            Submission(transactionId,\"Add Admin\", source, destination, value, reason);\n        }\n        else if(operation == 13) // Operation 13 is Remove Admin\n        {\n            Submission(transactionId,\"Remove Admin\", source, destination, value, reason);\n        }\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n    \n    /// @dev Allows an owner to confirm a transaction.\n    /// @param startTransactionId the first transaction to approve\n    /// @param endTransactionId the last transaction to approve.\n    function confirmMultipleTransactions(uint startTransactionId, uint endTransactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(endTransactionId)\n    {\n        for(var i=startTransactionId;i<=endTransactionId;i++)\n        {\n            require(transactions[i].operation != 0);\n            require(!confirmations[i][msg.sender]);\n            confirmations[i][msg.sender] = true;\n            Confirmation(msg.sender, i);\n            executeTransaction(i);\n        }\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        internal\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            var transaction = transactions[transactionId];\n\n            if(transaction.operation == 1) // Operation 1 is Add Owner\n            {\n                addOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 2) // Operation 2 is Remove Owner\n            {\n                removeOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 3) // Operation 3 is Replace Owner\n            {\n                replaceOwner(transaction.source,transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 4) // Operation 4 is Freeze Account\n            {\n                freezeAccount(transaction.destination,true);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 5) // Operation 5 is UnFreeze Account\n            {\n                freezeAccount(transaction.destination, false);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 6) // Operation 6 is change requirement Account\n            {\n                changeRequirement(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 7) // Operation 7 is Issue Tokens from Contract\n            {\n                _transfer(this,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 8) // Operation 8 is Admin Transfer Tokens\n            {\n                _transfer(transaction.source,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n            {\n                require(isOwner[transaction.destination]);\n                withdrawalLimit[transaction.destination] = transaction.value;\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n            {\n                require(isOwner[transaction.destination]);\n                \n                transaction.destination.transfer(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 12) // Operation 12 is add Admin\n            {\n                addAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 13) // Operation 13 is remove Admin\n            {\n                removeAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n        }\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        constant\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n   \n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        constant\n        returns (address[])\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        constant\n        returns (address[] _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        constant\n        returns (uint[] _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}",
        "debug": "storage_5 + keccac_storage_7: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_5_+_keccac_storage_7: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x28a92ef700000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestRemoveAdmin(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestRemoveAdmin(address,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23224,
        "code": "ntract MultiSigERC20Token\n{\n    uint constant public MAX_OWNER_COUNT = 50;\n\t\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\taddress[] public owners;\n\taddress[] public admins;\n\t\n\t// Variables for multisig\n\tuint256 public required;\n    uint public transactionCount;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n\tevent Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event AdminAddition(address indexed admin);\n    event AdminRemoval(address indexed admin);\n    event RequirementChange(uint required);\n\t\n\t// Mappings\n    mapping (uint => MetaTransaction) public transactions;\n    mapping (address => uint256) public withdrawalLimit;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n\tmapping (address => bool) public frozenAccount;\n\tmapping (address => bool) public isAdmin;\n    mapping (address => uint256) public balanceOf;\n\n    // Meta data for pending and executed Transactions\n    struct MetaTransaction {\n        address source;\n        address destination;\n        uint value;\n        bool executed;\n        uint operation;\n        string reason;\n    }\n\n    // Modifiers\n    modifier ownerDoesNotExist(address owner) {\n        require (!isOwner[owner]);\n        _;\n    }\n    \n    modifier adminDoesNotExist(address admin) {\n        require (!isAdmin[admin]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require (isOwner[owner]);\n        _;\n    }\n    \n    modifier adminExists(address admin) {\n        require (isAdmin[admin] || isOwner[admin]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require (transactions[transactionId].operation != 0);\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require (confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require (!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require (!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require (_address != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() payable public\n    {\n        if (msg.value > 0)\n        {\n            Deposit(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the contract and sets owner to the \n     * creator of the contract\n     */\n    function MultiSigERC20Token(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\t\tisOwner[msg.sender] = true;                         // Set Owner to Contract Creator\n\t\tisAdmin[msg.sender] = true;\n\t\trequired = 1;\n\t\towners.push(msg.sender);\n\t\tadmins.push(msg.sender);\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check if the sender is frozen\n        require(!frozenAccount[_from]);\n        // Check if the recipient is frozen\n        require(!frozenAccount[_to]);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\t\n\t\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n    /// @param target Address to be frozen\n    /// @param freeze either to freeze it or not\n    function freezeAccount(address target, bool freeze) internal {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        internal\n        ownerDoesNotExist(owner)\n        notNull(owner)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        required = required + 1;\n        OwnerAddition(owner);\n    }\n    \n    /// @dev Allows to add a new admin. Transaction has to be sent by wallet.\n    /// @param admin Address of new admin.\n    function addAdmin(address admin)\n        internal\n        adminDoesNotExist(admin)\n        notNull(admin)\n    {\n        isAdmin[admin] = true;\n        admins.push(admin);\n        AdminAddition(admin);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        internal\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        OwnerRemoval(owner);\n    }\n    \n    \n    /// @dev Allows to remove an admin. Transaction has to be sent by wallet.\n    /// @param admin Address of admin.\n    function removeAdmin(address admin)\n        internal\n        adminExists(admin)\n    {\n        isAdmin[admin] = false;\n        for (uint i=0; i<admins.length - 1; i++)\n            if (admins[i] == admin) {\n                admins[i] = admins[admins.length - 1];\n                break;\n            }\n        admins.length -= 1;\n        AdminRemoval(admin);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param owner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        internal\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        OwnerRemoval(owner);\n        OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        internal\n    {\n        required = _required;\n        RequirementChange(_required);\n    }\n    \n    function requestAddOwner(address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(newOwner,newOwner,0,1,reason);\n    }\n\n    function requestRemoveOwner(address oldOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,oldOwner,0,2,reason);\n    }\n    \n    function requestReplaceOwner(address oldOwner,address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,newOwner,0,3,reason);\n    }\n    \n    function requestFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,4,reason);\n    }\n    \n    function requestUnFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,5,reason);\n    }\n    \n    function requestChangeRequirement(uint _requirement, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender,msg.sender,_requirement,6,reason);\n    }\n    \n    function requestTokenIssue(address account, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,amount,7,reason);\n    }\n    \n    function requestAdminTokenTransfer(address source,address destination, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(source, destination, amount,8,reason);\n    }\n    \n    function requestSetWithdrawalLimit(address owner,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(owner, owner, amount,9,reason);\n    }\n    \n    function requestWithdrawalFromLimit(uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender, msg.sender, amount,10,reason);\n    }\n    \n    function requestWithdrawal(address account,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, amount,11,reason);\n    }\n    \n    function requestAddAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,12,reason);\n    }\n    \n    function requestRemoveAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,13,reason);\n    }\n    \n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @return Returns transaction ID.\n    function submitTransaction(address source, address destination, uint256 value, uint operation, string reason)\n        internal\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = MetaTransaction({\n            source: source,\n            destination: destination,\n            value: value,\n            operation: operation,\n            executed: false,\n            reason: reason\n        });\n        \n        transactionCount += 1;\n        \n        if(operation == 1) // Operation 1 is Add Owner\n        {\n            Submission(transactionId,\"Add Owner\", source, destination, value, reason);\n        }\n        else if(operation == 2) // Operation 2 is Remove Owner\n        {\n            Submission(transactionId,\"Remove Owner\", source, destination, value, reason);\n        }\n        else if(operation == 3) // Operation 3 is Replace Owner\n        {\n            Submission(transactionId,\"Replace Owner\", source, destination, value, reason);\n        }\n        else if(operation == 4) // Operation 4 is Freeze Account\n        {\n            Submission(transactionId,\"Freeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 5) // Operation 5 is UnFreeze Account\n        {\n            Submission(transactionId,\"UnFreeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 6) // Operation 6 is change rquirement\n        {\n            Submission(transactionId,\"Change Requirement\", source, destination, value, reason);\n        }\n        else if(operation == 7) // Operation 7 is Issue Tokens from Contract\n        {\n            Submission(transactionId,\"Issue Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 8) // Operation 8 is Admin Transfer Tokens\n        {\n            Submission(transactionId,\"Admin Transfer Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n        {\n            Submission(transactionId,\"Set Unsigned Ethereum Withdrawal Limit\", source, destination, value, reason);\n        }\n        else if(operation == 10) // Operation 10 is Admin Withdraw Ether without multisig\n        {\n            require(isOwner[destination]);\n            require(withdrawalLimit[destination] > value);\n            \n            Submission(transactionId,\"Unsigned Ethereum Withdrawal\", source, destination, value, reason);\n            \n            var newValue = withdrawalLimit[destination] - value;\n            withdrawalLimit[destination] = newValue;\n            \n            destination.transfer(value);\n            transactions[transactionId].executed = true;\n            Execution(transactionId);\n        }\n        else if(operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n        {\n            Submission(transactionId,\"Withdraw Ethereum\", source, destination, value, reason);\n        }\n        else if(operation == 12) // Operation 12 is Add Admin\n        {\n            Submission(transactionId,\"Add Admin\", source, destination, value, reason);\n        }\n        else if(operation == 13) // Operation 13 is Remove Admin\n        {\n            Submission(transactionId,\"Remove Admin\", source, destination, value, reason);\n        }\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n    \n    /// @dev Allows an owner to confirm a transaction.\n    /// @param startTransactionId the first transaction to approve\n    /// @param endTransactionId the last transaction to approve.\n    function confirmMultipleTransactions(uint startTransactionId, uint endTransactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(endTransactionId)\n    {\n        for(var i=startTransactionId;i<=endTransactionId;i++)\n        {\n            require(transactions[i].operation != 0);\n            require(!confirmations[i][msg.sender]);\n            confirmations[i][msg.sender] = true;\n            Confirmation(msg.sender, i);\n            executeTransaction(i);\n        }\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        internal\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            var transaction = transactions[transactionId];\n\n            if(transaction.operation == 1) // Operation 1 is Add Owner\n            {\n                addOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 2) // Operation 2 is Remove Owner\n            {\n                removeOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 3) // Operation 3 is Replace Owner\n            {\n                replaceOwner(transaction.source,transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 4) // Operation 4 is Freeze Account\n            {\n                freezeAccount(transaction.destination,true);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 5) // Operation 5 is UnFreeze Account\n            {\n                freezeAccount(transaction.destination, false);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 6) // Operation 6 is change requirement Account\n            {\n                changeRequirement(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 7) // Operation 7 is Issue Tokens from Contract\n            {\n                _transfer(this,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 8) // Operation 8 is Admin Transfer Tokens\n            {\n                _transfer(transaction.source,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n            {\n                require(isOwner[transaction.destination]);\n                withdrawalLimit[transaction.destination] = transaction.value;\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n            {\n                require(isOwner[transaction.destination]);\n                \n                transaction.destination.transfer(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 12) // Operation 12 is add Admin\n            {\n                addAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 13) // Operation 13 is remove Admin\n            {\n                removeAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n        }\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        constant\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n   \n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        constant\n        returns (address[])\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        constant\n        returns (address[] _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        constant\n        returns (uint[] _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x28a92ef700000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestRemoveAdmin(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestRemoveAdmin(address,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23238,
        "code": "ntract MultiSigERC20Token\n{\n    uint constant public MAX_OWNER_COUNT = 50;\n\t\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\taddress[] public owners;\n\taddress[] public admins;\n\t\n\t// Variables for multisig\n\tuint256 public required;\n    uint public transactionCount;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n\tevent Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event AdminAddition(address indexed admin);\n    event AdminRemoval(address indexed admin);\n    event RequirementChange(uint required);\n\t\n\t// Mappings\n    mapping (uint => MetaTransaction) public transactions;\n    mapping (address => uint256) public withdrawalLimit;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n\tmapping (address => bool) public frozenAccount;\n\tmapping (address => bool) public isAdmin;\n    mapping (address => uint256) public balanceOf;\n\n    // Meta data for pending and executed Transactions\n    struct MetaTransaction {\n        address source;\n        address destination;\n        uint value;\n        bool executed;\n        uint operation;\n        string reason;\n    }\n\n    // Modifiers\n    modifier ownerDoesNotExist(address owner) {\n        require (!isOwner[owner]);\n        _;\n    }\n    \n    modifier adminDoesNotExist(address admin) {\n        require (!isAdmin[admin]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require (isOwner[owner]);\n        _;\n    }\n    \n    modifier adminExists(address admin) {\n        require (isAdmin[admin] || isOwner[admin]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require (transactions[transactionId].operation != 0);\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require (confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require (!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require (!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require (_address != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() payable public\n    {\n        if (msg.value > 0)\n        {\n            Deposit(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the contract and sets owner to the \n     * creator of the contract\n     */\n    function MultiSigERC20Token(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\t\tisOwner[msg.sender] = true;                         // Set Owner to Contract Creator\n\t\tisAdmin[msg.sender] = true;\n\t\trequired = 1;\n\t\towners.push(msg.sender);\n\t\tadmins.push(msg.sender);\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check if the sender is frozen\n        require(!frozenAccount[_from]);\n        // Check if the recipient is frozen\n        require(!frozenAccount[_to]);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\t\n\t\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n    /// @param target Address to be frozen\n    /// @param freeze either to freeze it or not\n    function freezeAccount(address target, bool freeze) internal {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        internal\n        ownerDoesNotExist(owner)\n        notNull(owner)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        required = required + 1;\n        OwnerAddition(owner);\n    }\n    \n    /// @dev Allows to add a new admin. Transaction has to be sent by wallet.\n    /// @param admin Address of new admin.\n    function addAdmin(address admin)\n        internal\n        adminDoesNotExist(admin)\n        notNull(admin)\n    {\n        isAdmin[admin] = true;\n        admins.push(admin);\n        AdminAddition(admin);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        internal\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        OwnerRemoval(owner);\n    }\n    \n    \n    /// @dev Allows to remove an admin. Transaction has to be sent by wallet.\n    /// @param admin Address of admin.\n    function removeAdmin(address admin)\n        internal\n        adminExists(admin)\n    {\n        isAdmin[admin] = false;\n        for (uint i=0; i<admins.length - 1; i++)\n            if (admins[i] == admin) {\n                admins[i] = admins[admins.length - 1];\n                break;\n            }\n        admins.length -= 1;\n        AdminRemoval(admin);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param owner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        internal\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        OwnerRemoval(owner);\n        OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        internal\n    {\n        required = _required;\n        RequirementChange(_required);\n    }\n    \n    function requestAddOwner(address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(newOwner,newOwner,0,1,reason);\n    }\n\n    function requestRemoveOwner(address oldOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,oldOwner,0,2,reason);\n    }\n    \n    function requestReplaceOwner(address oldOwner,address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,newOwner,0,3,reason);\n    }\n    \n    function requestFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,4,reason);\n    }\n    \n    function requestUnFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,5,reason);\n    }\n    \n    function requestChangeRequirement(uint _requirement, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender,msg.sender,_requirement,6,reason);\n    }\n    \n    function requestTokenIssue(address account, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,amount,7,reason);\n    }\n    \n    function requestAdminTokenTransfer(address source,address destination, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(source, destination, amount,8,reason);\n    }\n    \n    function requestSetWithdrawalLimit(address owner,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(owner, owner, amount,9,reason);\n    }\n    \n    function requestWithdrawalFromLimit(uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender, msg.sender, amount,10,reason);\n    }\n    \n    function requestWithdrawal(address account,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, amount,11,reason);\n    }\n    \n    function requestAddAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,12,reason);\n    }\n    \n    function requestRemoveAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,13,reason);\n    }\n    \n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @return Returns transaction ID.\n    function submitTransaction(address source, address destination, uint256 value, uint operation, string reason)\n        internal\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = MetaTransaction({\n            source: source,\n            destination: destination,\n            value: value,\n            operation: operation,\n            executed: false,\n            reason: reason\n        });\n        \n        transactionCount += 1;\n        \n        if(operation == 1) // Operation 1 is Add Owner\n        {\n            Submission(transactionId,\"Add Owner\", source, destination, value, reason);\n        }\n        else if(operation == 2) // Operation 2 is Remove Owner\n        {\n            Submission(transactionId,\"Remove Owner\", source, destination, value, reason);\n        }\n        else if(operation == 3) // Operation 3 is Replace Owner\n        {\n            Submission(transactionId,\"Replace Owner\", source, destination, value, reason);\n        }\n        else if(operation == 4) // Operation 4 is Freeze Account\n        {\n            Submission(transactionId,\"Freeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 5) // Operation 5 is UnFreeze Account\n        {\n            Submission(transactionId,\"UnFreeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 6) // Operation 6 is change rquirement\n        {\n            Submission(transactionId,\"Change Requirement\", source, destination, value, reason);\n        }\n        else if(operation == 7) // Operation 7 is Issue Tokens from Contract\n        {\n            Submission(transactionId,\"Issue Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 8) // Operation 8 is Admin Transfer Tokens\n        {\n            Submission(transactionId,\"Admin Transfer Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n        {\n            Submission(transactionId,\"Set Unsigned Ethereum Withdrawal Limit\", source, destination, value, reason);\n        }\n        else if(operation == 10) // Operation 10 is Admin Withdraw Ether without multisig\n        {\n            require(isOwner[destination]);\n            require(withdrawalLimit[destination] > value);\n            \n            Submission(transactionId,\"Unsigned Ethereum Withdrawal\", source, destination, value, reason);\n            \n            var newValue = withdrawalLimit[destination] - value;\n            withdrawalLimit[destination] = newValue;\n            \n            destination.transfer(value);\n            transactions[transactionId].executed = true;\n            Execution(transactionId);\n        }\n        else if(operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n        {\n            Submission(transactionId,\"Withdraw Ethereum\", source, destination, value, reason);\n        }\n        else if(operation == 12) // Operation 12 is Add Admin\n        {\n            Submission(transactionId,\"Add Admin\", source, destination, value, reason);\n        }\n        else if(operation == 13) // Operation 13 is Remove Admin\n        {\n            Submission(transactionId,\"Remove Admin\", source, destination, value, reason);\n        }\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n    \n    /// @dev Allows an owner to confirm a transaction.\n    /// @param startTransactionId the first transaction to approve\n    /// @param endTransactionId the last transaction to approve.\n    function confirmMultipleTransactions(uint startTransactionId, uint endTransactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(endTransactionId)\n    {\n        for(var i=startTransactionId;i<=endTransactionId;i++)\n        {\n            require(transactions[i].operation != 0);\n            require(!confirmations[i][msg.sender]);\n            confirmations[i][msg.sender] = true;\n            Confirmation(msg.sender, i);\n            executeTransaction(i);\n        }\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        internal\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            var transaction = transactions[transactionId];\n\n            if(transaction.operation == 1) // Operation 1 is Add Owner\n            {\n                addOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 2) // Operation 2 is Remove Owner\n            {\n                removeOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 3) // Operation 3 is Replace Owner\n            {\n                replaceOwner(transaction.source,transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 4) // Operation 4 is Freeze Account\n            {\n                freezeAccount(transaction.destination,true);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 5) // Operation 5 is UnFreeze Account\n            {\n                freezeAccount(transaction.destination, false);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 6) // Operation 6 is change requirement Account\n            {\n                changeRequirement(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 7) // Operation 7 is Issue Tokens from Contract\n            {\n                _transfer(this,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 8) // Operation 8 is Admin Transfer Tokens\n            {\n                _transfer(transaction.source,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n            {\n                require(isOwner[transaction.destination]);\n                withdrawalLimit[transaction.destination] = transaction.value;\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n            {\n                require(isOwner[transaction.destination]);\n                \n                transaction.destination.transfer(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 12) // Operation 12 is add Admin\n            {\n                addAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 13) // Operation 13 is remove Admin\n            {\n                removeAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n        }\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        constant\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n   \n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        constant\n        returns (address[])\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        constant\n        returns (address[] _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        constant\n        returns (uint[] _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x28a92ef700000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestRemoveAdmin(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestRemoveAdmin(address,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23255,
        "code": "ntract MultiSigERC20Token\n{\n    uint constant public MAX_OWNER_COUNT = 50;\n\t\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\taddress[] public owners;\n\taddress[] public admins;\n\t\n\t// Variables for multisig\n\tuint256 public required;\n    uint public transactionCount;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n\tevent Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event AdminAddition(address indexed admin);\n    event AdminRemoval(address indexed admin);\n    event RequirementChange(uint required);\n\t\n\t// Mappings\n    mapping (uint => MetaTransaction) public transactions;\n    mapping (address => uint256) public withdrawalLimit;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n\tmapping (address => bool) public frozenAccount;\n\tmapping (address => bool) public isAdmin;\n    mapping (address => uint256) public balanceOf;\n\n    // Meta data for pending and executed Transactions\n    struct MetaTransaction {\n        address source;\n        address destination;\n        uint value;\n        bool executed;\n        uint operation;\n        string reason;\n    }\n\n    // Modifiers\n    modifier ownerDoesNotExist(address owner) {\n        require (!isOwner[owner]);\n        _;\n    }\n    \n    modifier adminDoesNotExist(address admin) {\n        require (!isAdmin[admin]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require (isOwner[owner]);\n        _;\n    }\n    \n    modifier adminExists(address admin) {\n        require (isAdmin[admin] || isOwner[admin]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require (transactions[transactionId].operation != 0);\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require (confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require (!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require (!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require (_address != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() payable public\n    {\n        if (msg.value > 0)\n        {\n            Deposit(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the contract and sets owner to the \n     * creator of the contract\n     */\n    function MultiSigERC20Token(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\t\tisOwner[msg.sender] = true;                         // Set Owner to Contract Creator\n\t\tisAdmin[msg.sender] = true;\n\t\trequired = 1;\n\t\towners.push(msg.sender);\n\t\tadmins.push(msg.sender);\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check if the sender is frozen\n        require(!frozenAccount[_from]);\n        // Check if the recipient is frozen\n        require(!frozenAccount[_to]);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\t\n\t\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n    /// @param target Address to be frozen\n    /// @param freeze either to freeze it or not\n    function freezeAccount(address target, bool freeze) internal {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        internal\n        ownerDoesNotExist(owner)\n        notNull(owner)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        required = required + 1;\n        OwnerAddition(owner);\n    }\n    \n    /// @dev Allows to add a new admin. Transaction has to be sent by wallet.\n    /// @param admin Address of new admin.\n    function addAdmin(address admin)\n        internal\n        adminDoesNotExist(admin)\n        notNull(admin)\n    {\n        isAdmin[admin] = true;\n        admins.push(admin);\n        AdminAddition(admin);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        internal\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        OwnerRemoval(owner);\n    }\n    \n    \n    /// @dev Allows to remove an admin. Transaction has to be sent by wallet.\n    /// @param admin Address of admin.\n    function removeAdmin(address admin)\n        internal\n        adminExists(admin)\n    {\n        isAdmin[admin] = false;\n        for (uint i=0; i<admins.length - 1; i++)\n            if (admins[i] == admin) {\n                admins[i] = admins[admins.length - 1];\n                break;\n            }\n        admins.length -= 1;\n        AdminRemoval(admin);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param owner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        internal\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        OwnerRemoval(owner);\n        OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        internal\n    {\n        required = _required;\n        RequirementChange(_required);\n    }\n    \n    function requestAddOwner(address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(newOwner,newOwner,0,1,reason);\n    }\n\n    function requestRemoveOwner(address oldOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,oldOwner,0,2,reason);\n    }\n    \n    function requestReplaceOwner(address oldOwner,address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,newOwner,0,3,reason);\n    }\n    \n    function requestFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,4,reason);\n    }\n    \n    function requestUnFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,5,reason);\n    }\n    \n    function requestChangeRequirement(uint _requirement, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender,msg.sender,_requirement,6,reason);\n    }\n    \n    function requestTokenIssue(address account, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,amount,7,reason);\n    }\n    \n    function requestAdminTokenTransfer(address source,address destination, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(source, destination, amount,8,reason);\n    }\n    \n    function requestSetWithdrawalLimit(address owner,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(owner, owner, amount,9,reason);\n    }\n    \n    function requestWithdrawalFromLimit(uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender, msg.sender, amount,10,reason);\n    }\n    \n    function requestWithdrawal(address account,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, amount,11,reason);\n    }\n    \n    function requestAddAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,12,reason);\n    }\n    \n    function requestRemoveAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,13,reason);\n    }\n    \n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @return Returns transaction ID.\n    function submitTransaction(address source, address destination, uint256 value, uint operation, string reason)\n        internal\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = MetaTransaction({\n            source: source,\n            destination: destination,\n            value: value,\n            operation: operation,\n            executed: false,\n            reason: reason\n        });\n        \n        transactionCount += 1;\n        \n        if(operation == 1) // Operation 1 is Add Owner\n        {\n            Submission(transactionId,\"Add Owner\", source, destination, value, reason);\n        }\n        else if(operation == 2) // Operation 2 is Remove Owner\n        {\n            Submission(transactionId,\"Remove Owner\", source, destination, value, reason);\n        }\n        else if(operation == 3) // Operation 3 is Replace Owner\n        {\n            Submission(transactionId,\"Replace Owner\", source, destination, value, reason);\n        }\n        else if(operation == 4) // Operation 4 is Freeze Account\n        {\n            Submission(transactionId,\"Freeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 5) // Operation 5 is UnFreeze Account\n        {\n            Submission(transactionId,\"UnFreeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 6) // Operation 6 is change rquirement\n        {\n            Submission(transactionId,\"Change Requirement\", source, destination, value, reason);\n        }\n        else if(operation == 7) // Operation 7 is Issue Tokens from Contract\n        {\n            Submission(transactionId,\"Issue Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 8) // Operation 8 is Admin Transfer Tokens\n        {\n            Submission(transactionId,\"Admin Transfer Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n        {\n            Submission(transactionId,\"Set Unsigned Ethereum Withdrawal Limit\", source, destination, value, reason);\n        }\n        else if(operation == 10) // Operation 10 is Admin Withdraw Ether without multisig\n        {\n            require(isOwner[destination]);\n            require(withdrawalLimit[destination] > value);\n            \n            Submission(transactionId,\"Unsigned Ethereum Withdrawal\", source, destination, value, reason);\n            \n            var newValue = withdrawalLimit[destination] - value;\n            withdrawalLimit[destination] = newValue;\n            \n            destination.transfer(value);\n            transactions[transactionId].executed = true;\n            Execution(transactionId);\n        }\n        else if(operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n        {\n            Submission(transactionId,\"Withdraw Ethereum\", source, destination, value, reason);\n        }\n        else if(operation == 12) // Operation 12 is Add Admin\n        {\n            Submission(transactionId,\"Add Admin\", source, destination, value, reason);\n        }\n        else if(operation == 13) // Operation 13 is Remove Admin\n        {\n            Submission(transactionId,\"Remove Admin\", source, destination, value, reason);\n        }\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n    \n    /// @dev Allows an owner to confirm a transaction.\n    /// @param startTransactionId the first transaction to approve\n    /// @param endTransactionId the last transaction to approve.\n    function confirmMultipleTransactions(uint startTransactionId, uint endTransactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(endTransactionId)\n    {\n        for(var i=startTransactionId;i<=endTransactionId;i++)\n        {\n            require(transactions[i].operation != 0);\n            require(!confirmations[i][msg.sender]);\n            confirmations[i][msg.sender] = true;\n            Confirmation(msg.sender, i);\n            executeTransaction(i);\n        }\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        internal\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            var transaction = transactions[transactionId];\n\n            if(transaction.operation == 1) // Operation 1 is Add Owner\n            {\n                addOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 2) // Operation 2 is Remove Owner\n            {\n                removeOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 3) // Operation 3 is Replace Owner\n            {\n                replaceOwner(transaction.source,transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 4) // Operation 4 is Freeze Account\n            {\n                freezeAccount(transaction.destination,true);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 5) // Operation 5 is UnFreeze Account\n            {\n                freezeAccount(transaction.destination, false);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 6) // Operation 6 is change requirement Account\n            {\n                changeRequirement(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 7) // Operation 7 is Issue Tokens from Contract\n            {\n                _transfer(this,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 8) // Operation 8 is Admin Transfer Tokens\n            {\n                _transfer(transaction.source,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n            {\n                require(isOwner[transaction.destination]);\n                withdrawalLimit[transaction.destination] = transaction.value;\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n            {\n                require(isOwner[transaction.destination]);\n                \n                transaction.destination.transfer(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 12) // Operation 12 is add Admin\n            {\n                addAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 13) // Operation 13 is remove Admin\n            {\n                removeAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n        }\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        constant\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n   \n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        constant\n        returns (address[])\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        constant\n        returns (address[] _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        constant\n        returns (uint[] _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0x25\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x22aef13c00000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestChangeRequirement(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestChangeRequirement(uint256,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 23260,
        "code": "ntract MultiSigERC20Token\n{\n    uint constant public MAX_OWNER_COUNT = 50;\n\t\n    // Public variables of the token\n    string public name;\n    string public symbol;\n    uint8 public decimals = 8;\n    uint256 public totalSupply;\n\taddress[] public owners;\n\taddress[] public admins;\n\t\n\t// Variables for multisig\n\tuint256 public required;\n    uint public transactionCount;\n\n    // Events\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event FrozenFunds(address target, bool frozen);\n\tevent Confirmation(address indexed sender, uint indexed transactionId);\n    event Revocation(address indexed sender, uint indexed transactionId);\n    event Submission(uint indexed transactionId,string operation, address source, address destination, uint256 value, string reason);\n    event Execution(uint indexed transactionId);\n    event ExecutionFailure(uint indexed transactionId);\n    event Deposit(address indexed sender, uint value);\n    event OwnerAddition(address indexed owner);\n    event OwnerRemoval(address indexed owner);\n    event AdminAddition(address indexed admin);\n    event AdminRemoval(address indexed admin);\n    event RequirementChange(uint required);\n\t\n\t// Mappings\n    mapping (uint => MetaTransaction) public transactions;\n    mapping (address => uint256) public withdrawalLimit;\n    mapping (uint => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n\tmapping (address => bool) public frozenAccount;\n\tmapping (address => bool) public isAdmin;\n    mapping (address => uint256) public balanceOf;\n\n    // Meta data for pending and executed Transactions\n    struct MetaTransaction {\n        address source;\n        address destination;\n        uint value;\n        bool executed;\n        uint operation;\n        string reason;\n    }\n\n    // Modifiers\n    modifier ownerDoesNotExist(address owner) {\n        require (!isOwner[owner]);\n        _;\n    }\n    \n    modifier adminDoesNotExist(address admin) {\n        require (!isAdmin[admin]);\n        _;\n    }\n\n    modifier ownerExists(address owner) {\n        require (isOwner[owner]);\n        _;\n    }\n    \n    modifier adminExists(address admin) {\n        require (isAdmin[admin] || isOwner[admin]);\n        _;\n    }\n\n    modifier transactionExists(uint transactionId) {\n        require (transactions[transactionId].operation != 0);\n        _;\n    }\n\n    modifier confirmed(uint transactionId, address owner) {\n        require (confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notConfirmed(uint transactionId, address owner) {\n        require (!confirmations[transactionId][owner]);\n        _;\n    }\n\n    modifier notExecuted(uint transactionId) {\n        require (!transactions[transactionId].executed);\n        _;\n    }\n\n    modifier notNull(address _address) {\n        require (_address != 0);\n        _;\n    }\n\n    /// @dev Fallback function allows to deposit ether.\n    function() payable public\n    {\n        if (msg.value > 0)\n        {\n            Deposit(msg.sender, msg.value);\n        }\n    }\n\n    /**\n     * Constrctor function\n     *\n     * Initializes contract with initial supply tokens to the contract and sets owner to the \n     * creator of the contract\n     */\n    function MultiSigERC20Token(\n        uint256 initialSupply,\n        string tokenName,\n        string tokenSymbol\n    ) public {\n        totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount\n        balanceOf[this] = totalSupply;                      // Give the contract all initial tokens\n        name = tokenName;                                   // Set the name for display purposes\n        symbol = tokenSymbol;                               // Set the symbol for display purposes\n\t\tisOwner[msg.sender] = true;                         // Set Owner to Contract Creator\n\t\tisAdmin[msg.sender] = true;\n\t\trequired = 1;\n\t\towners.push(msg.sender);\n\t\tadmins.push(msg.sender);\n    }\n\n    /**\n     * Internal transfer, only can be called by this contract\n     */\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check if the sender is frozen\n        require(!frozenAccount[_from]);\n        // Check if the recipient is frozen\n        require(!frozenAccount[_to]);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    /**\n     * Transfer tokens\n     *\n     * Send `_value` tokens to `_to` from your account\n     *\n     * @param _to The address of the recipient\n     * @param _value the amount to send\n     */\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\t\n\t\n    /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens\n    /// @param target Address to be frozen\n    /// @param freeze either to freeze it or not\n    function freezeAccount(address target, bool freeze) internal {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n    /// @dev Allows to add a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of new owner.\n    function addOwner(address owner)\n        internal\n        ownerDoesNotExist(owner)\n        notNull(owner)\n    {\n        isOwner[owner] = true;\n        owners.push(owner);\n        required = required + 1;\n        OwnerAddition(owner);\n    }\n    \n    /// @dev Allows to add a new admin. Transaction has to be sent by wallet.\n    /// @param admin Address of new admin.\n    function addAdmin(address admin)\n        internal\n        adminDoesNotExist(admin)\n        notNull(admin)\n    {\n        isAdmin[admin] = true;\n        admins.push(admin);\n        AdminAddition(admin);\n    }\n\n    /// @dev Allows to remove an owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner.\n    function removeOwner(address owner)\n        internal\n        ownerExists(owner)\n    {\n        isOwner[owner] = false;\n        for (uint i=0; i<owners.length - 1; i++)\n            if (owners[i] == owner) {\n                owners[i] = owners[owners.length - 1];\n                break;\n            }\n        owners.length -= 1;\n        if (required > owners.length)\n            changeRequirement(owners.length);\n        OwnerRemoval(owner);\n    }\n    \n    \n    /// @dev Allows to remove an admin. Transaction has to be sent by wallet.\n    /// @param admin Address of admin.\n    function removeAdmin(address admin)\n        internal\n        adminExists(admin)\n    {\n        isAdmin[admin] = false;\n        for (uint i=0; i<admins.length - 1; i++)\n            if (admins[i] == admin) {\n                admins[i] = admins[admins.length - 1];\n                break;\n            }\n        admins.length -= 1;\n        AdminRemoval(admin);\n    }\n\n    /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet.\n    /// @param owner Address of owner to be replaced.\n    /// @param owner Address of new owner.\n    function replaceOwner(address owner, address newOwner)\n        internal\n        ownerExists(owner)\n        ownerDoesNotExist(newOwner)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (owners[i] == owner) {\n                owners[i] = newOwner;\n                break;\n            }\n        isOwner[owner] = false;\n        isOwner[newOwner] = true;\n        OwnerRemoval(owner);\n        OwnerAddition(newOwner);\n    }\n\n    /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet.\n    /// @param _required Number of required confirmations.\n    function changeRequirement(uint256 _required)\n        internal\n    {\n        required = _required;\n        RequirementChange(_required);\n    }\n    \n    function requestAddOwner(address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(newOwner,newOwner,0,1,reason);\n    }\n\n    function requestRemoveOwner(address oldOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,oldOwner,0,2,reason);\n    }\n    \n    function requestReplaceOwner(address oldOwner,address newOwner, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(oldOwner,newOwner,0,3,reason);\n    }\n    \n    function requestFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,4,reason);\n    }\n    \n    function requestUnFreezeAccount(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,0,5,reason);\n    }\n    \n    function requestChangeRequirement(uint _requirement, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender,msg.sender,_requirement,6,reason);\n    }\n    \n    function requestTokenIssue(address account, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account,account,amount,7,reason);\n    }\n    \n    function requestAdminTokenTransfer(address source,address destination, uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(source, destination, amount,8,reason);\n    }\n    \n    function requestSetWithdrawalLimit(address owner,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(owner, owner, amount,9,reason);\n    }\n    \n    function requestWithdrawalFromLimit(uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(msg.sender, msg.sender, amount,10,reason);\n    }\n    \n    function requestWithdrawal(address account,uint256 amount, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, amount,11,reason);\n    }\n    \n    function requestAddAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,12,reason);\n    }\n    \n    function requestRemoveAdmin(address account, string reason) public adminExists(msg.sender) returns (uint transactionId)\n    {\n        transactionId = submitTransaction(account, account, 0,13,reason);\n    }\n    \n    /// @dev Allows an owner to submit and confirm a transaction.\n    /// @param destination Transaction target address.\n    /// @param value Transaction ether value.\n    /// @return Returns transaction ID.\n    function submitTransaction(address source, address destination, uint256 value, uint operation, string reason)\n        internal\n        returns (uint transactionId)\n    {\n        transactionId = transactionCount;\n        transactions[transactionId] = MetaTransaction({\n            source: source,\n            destination: destination,\n            value: value,\n            operation: operation,\n            executed: false,\n            reason: reason\n        });\n        \n        transactionCount += 1;\n        \n        if(operation == 1) // Operation 1 is Add Owner\n        {\n            Submission(transactionId,\"Add Owner\", source, destination, value, reason);\n        }\n        else if(operation == 2) // Operation 2 is Remove Owner\n        {\n            Submission(transactionId,\"Remove Owner\", source, destination, value, reason);\n        }\n        else if(operation == 3) // Operation 3 is Replace Owner\n        {\n            Submission(transactionId,\"Replace Owner\", source, destination, value, reason);\n        }\n        else if(operation == 4) // Operation 4 is Freeze Account\n        {\n            Submission(transactionId,\"Freeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 5) // Operation 5 is UnFreeze Account\n        {\n            Submission(transactionId,\"UnFreeze Account\", source, destination, value, reason);\n        }\n        else if(operation == 6) // Operation 6 is change rquirement\n        {\n            Submission(transactionId,\"Change Requirement\", source, destination, value, reason);\n        }\n        else if(operation == 7) // Operation 7 is Issue Tokens from Contract\n        {\n            Submission(transactionId,\"Issue Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 8) // Operation 8 is Admin Transfer Tokens\n        {\n            Submission(transactionId,\"Admin Transfer Tokens\", source, destination, value, reason);\n        }\n        else if(operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n        {\n            Submission(transactionId,\"Set Unsigned Ethereum Withdrawal Limit\", source, destination, value, reason);\n        }\n        else if(operation == 10) // Operation 10 is Admin Withdraw Ether without multisig\n        {\n            require(isOwner[destination]);\n            require(withdrawalLimit[destination] > value);\n            \n            Submission(transactionId,\"Unsigned Ethereum Withdrawal\", source, destination, value, reason);\n            \n            var newValue = withdrawalLimit[destination] - value;\n            withdrawalLimit[destination] = newValue;\n            \n            destination.transfer(value);\n            transactions[transactionId].executed = true;\n            Execution(transactionId);\n        }\n        else if(operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n        {\n            Submission(transactionId,\"Withdraw Ethereum\", source, destination, value, reason);\n        }\n        else if(operation == 12) // Operation 12 is Add Admin\n        {\n            Submission(transactionId,\"Add Admin\", source, destination, value, reason);\n        }\n        else if(operation == 13) // Operation 13 is Remove Admin\n        {\n            Submission(transactionId,\"Remove Admin\", source, destination, value, reason);\n        }\n    }\n\n    /// @dev Allows an owner to confirm a transaction.\n    /// @param transactionId Transaction ID.\n    function confirmTransaction(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(transactionId)\n        notConfirmed(transactionId, msg.sender)\n    {\n        confirmations[transactionId][msg.sender] = true;\n        Confirmation(msg.sender, transactionId);\n        executeTransaction(transactionId);\n    }\n    \n    /// @dev Allows an owner to confirm a transaction.\n    /// @param startTransactionId the first transaction to approve\n    /// @param endTransactionId the last transaction to approve.\n    function confirmMultipleTransactions(uint startTransactionId, uint endTransactionId)\n        public\n        ownerExists(msg.sender)\n        transactionExists(endTransactionId)\n    {\n        for(var i=startTransactionId;i<=endTransactionId;i++)\n        {\n            require(transactions[i].operation != 0);\n            require(!confirmations[i][msg.sender]);\n            confirmations[i][msg.sender] = true;\n            Confirmation(msg.sender, i);\n            executeTransaction(i);\n        }\n    }\n\n    /// @dev Allows an owner to revoke a confirmation for a transaction.\n    /// @param transactionId Transaction ID.\n    function revokeConfirmation(uint transactionId)\n        public\n        ownerExists(msg.sender)\n        confirmed(transactionId, msg.sender)\n        notExecuted(transactionId)\n    {\n        confirmations[transactionId][msg.sender] = false;\n        Revocation(msg.sender, transactionId);\n    }\n\n    /// @dev Allows anyone to execute a confirmed transaction.\n    /// @param transactionId Transaction ID.\n    function executeTransaction(uint transactionId)\n        internal\n        notExecuted(transactionId)\n    {\n        if (isConfirmed(transactionId)) {\n            var transaction = transactions[transactionId];\n\n            if(transaction.operation == 1) // Operation 1 is Add Owner\n            {\n                addOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 2) // Operation 2 is Remove Owner\n            {\n                removeOwner(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 3) // Operation 3 is Replace Owner\n            {\n                replaceOwner(transaction.source,transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 4) // Operation 4 is Freeze Account\n            {\n                freezeAccount(transaction.destination,true);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 5) // Operation 5 is UnFreeze Account\n            {\n                freezeAccount(transaction.destination, false);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 6) // Operation 6 is change requirement Account\n            {\n                changeRequirement(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 7) // Operation 7 is Issue Tokens from Contract\n            {\n                _transfer(this,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 8) // Operation 8 is Admin Transfer Tokens\n            {\n                _transfer(transaction.source,transaction.destination,transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 9) // Operation 9 is Set Owners Unsigned Withdrawal Limit\n            {\n                require(isOwner[transaction.destination]);\n                withdrawalLimit[transaction.destination] = transaction.value;\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 11) // Operation 11 is Admin Withdraw Ether with multisig\n            {\n                require(isOwner[transaction.destination]);\n                \n                transaction.destination.transfer(transaction.value);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 12) // Operation 12 is add Admin\n            {\n                addAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n            else if(transaction.operation == 13) // Operation 13 is remove Admin\n            {\n                removeAdmin(transaction.destination);\n                \n                transaction.executed = true;\n                Execution(transactionId);\n            }\n        }\n    }\n\n    /// @dev Returns the confirmation status of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Confirmation status.\n    function isConfirmed(uint transactionId)\n        public\n        constant\n        returns (bool)\n    {\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++) {\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n            if (count == required)\n                return true;\n        }\n    }\n\n    /*\n     * Internal functions\n     */\n   \n    /*\n     * Web3 call functions\n     */\n    /// @dev Returns number of confirmations of a transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Number of confirmations.\n    function getConfirmationCount(uint transactionId)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]])\n                count += 1;\n    }\n\n    /// @dev Returns total number of transactions after filers are applied.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Total number of transactions after filters are applied.\n    function getTransactionCount(bool pending, bool executed)\n        public\n        constant\n        returns (uint count)\n    {\n        for (uint i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n                count += 1;\n    }\n\n    /// @dev Returns list of owners.\n    /// @return List of owner addresses.\n    function getOwners()\n        public\n        constant\n        returns (address[])\n    {\n        return owners;\n    }\n\n    /// @dev Returns array with owner addresses, which confirmed transaction.\n    /// @param transactionId Transaction ID.\n    /// @return Returns array of owner addresses.\n    function getConfirmations(uint transactionId)\n        public\n        constant\n        returns (address[] _confirmations)\n    {\n        address[] memory confirmationsTemp = new address[](owners.length);\n        uint count = 0;\n        uint i;\n        for (i=0; i<owners.length; i++)\n            if (confirmations[transactionId][owners[i]]) {\n                confirmationsTemp[count] = owners[i];\n                count += 1;\n            }\n        _confirmations = new address[](count);\n        for (i=0; i<count; i++)\n            _confirmations[i] = confirmationsTemp[i];\n    }\n\n    /// @dev Returns list of transaction IDs in defined range.\n    /// @param from Index start position of transaction array.\n    /// @param to Index end position of transaction array.\n    /// @param pending Include pending transactions.\n    /// @param executed Include executed transactions.\n    /// @return Returns array of transaction IDs.\n    function getTransactionIds(uint from, uint to, bool pending, bool executed)\n        public\n        constant\n        returns (uint[] _transactionIds)\n    {\n        uint[] memory transactionIdsTemp = new uint[](transactionCount);\n        uint count = 0;\n        uint i;\n        for (i=0; i<transactionCount; i++)\n            if (   pending && !transactions[i].executed\n                || executed && transactions[i].executed)\n            {\n                transactionIdsTemp[count] = i;\n                count += 1;\n            }\n        _transactionIds = new uint[](to - from);\n        for (i=from; i<to; i++)\n            _transactionIds[i - from] = transactionIdsTemp[i];\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_MultiSigERC20Token_4 + calldata_MultiSigERC20Token_32 + 4)) +\n160: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nkeccac_5_+_keccac_storage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_MultiSigERC20Token_0: 0x22aef13c00000000000000000000000000000000000000000000000000000000\ncalldatasize_MultiSigERC20Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestChangeRequirement(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa42e4338b97649fee0f0ab4af52444d4b8651bf9.sol",
        "function": "requestChangeRequirement(uint256,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}