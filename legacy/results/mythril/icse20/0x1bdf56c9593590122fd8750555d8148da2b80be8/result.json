{
  "contract": "0x1bdf56c9593590122fd8750555d8148da2b80be8",
  "tool": "mythril",
  "start": 1563478504.2557483,
  "end": 1563478582.0118973,
  "duration": 77.75614905357361,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 3405,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "clear(uint256,uint256)",
        "lineno": 323,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 3405,
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3554\n",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "clear(uint256,uint256)",
        "lineno": 323,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 3554,
        "debug": "",
        "description": "In the function `clear(uint256,uint256)` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "clear(uint256,uint256)",
        "lineno": 323,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 3778,
        "code": "ceiverAddr.transfer(",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_6: 0x0\ncalldata_ShareTokenSale_4: 0x0\nstorage_14: 0x0\ncalldata_ShareTokenSale_32 + 4: 0x1\nstorage_0: 0x0\ncaller: 0x0\ntimestamp: 0x1\ncalldata_ShareTokenSale_0: 0x5d977c0200000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "withdrawalFor(uint256,uint256)",
        "lineno": 320,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3870,
        "code": "\n    }\n    mapping(ad",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ShareTokenSale_4: 0x0\nstorage_12: 0x0\ncalldata_ShareTokenSale_0: 0x845ddcb200000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "_function_0x845ddcb2",
        "lineno": 153,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3927,
        "code": "AutoWithdrawalTime {\n         ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ShareTokenSale_4: 0x0\nstorage_14: 0x0\ncalldata_ShareTokenSale_0: 0x8815ee8600000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "_function_0x8815ee86",
        "lineno": 164,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4623,
        "code": " return purchaser",
        "debug": "timestamp: 0x7fffffffffffffffffffffffffffffffdff80000000007fffffffffffffffffe\nstorage_6: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_5: 0x8000000000000000000\nstorage_12: 0x0\ncallvalue: 0x16345785d8a0000\ncalldatasize_ShareTokenSale: 0x3\n",
        "description": "A possible integer underflow exists in the function `fallback`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "fallback",
        "lineno": 236,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4650,
        "code": "oportion(",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_12: 0x0\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffefffffffffffffffff\nstorage_6: 0xfffffffffffffffffffffffffffffffffffffffffffffff00000000000000000\nstorage_5: 0x1\ncallvalue: 0x16345785d8a0000\ncalldatasize_ShareTokenSale: 0x3\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "fallback",
        "lineno": 240,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5099,
        "code": "}\n}\n\n",
        "debug": "storage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ShareTokenSale_4: 0x0\nstorage_6: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_84800337471693920904250232874319843718400766719524250287777680170677855896573_+\ncalldata_ShareTokenSale_4,\n_____256): 0x0\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896573 +\ncalldata_ShareTokenSale_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_14: 0x1\ncalldata_ShareTokenSale_32 + 4: 0x1\nstorage_0: 0x0\ncaller: 0x0\ntimestamp: 0x1\ncalldata_ShareTokenSale_0: 0x5d977c0200000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\n",
        "description": "A possible integer overflow exists in the function `withdrawalFor(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "withdrawalFor(uint256,uint256)",
        "lineno": 47,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5112,
        "code": " @title Ownabl",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ShareTokenSale_4: 0x0\nstorage_6: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_84800337471693920904250232874319843718400766719524250287777680170677855896573_+\ncalldata_ShareTokenSale_4,\n_____256): 0x0\nstorage_84800337471693920904250232874319843718400766719524250287777680170677855896573 +\ncalldata_ShareTokenSale_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_14: 0x1\ncalldata_ShareTokenSale_32 + 4: 0x1\nstorage_0: 0x0\ncaller: 0x0\ntimestamp: 0x1\ncalldata_ShareTokenSale_0: 0x5d977c0200000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "withdrawalFor(uint256,uint256)",
        "lineno": 52,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6142,
        "code": "dr;\n    uint256 public totalSaleAmount;\n    uint256 public totalWannaBuyAmount; \n    uint256 public startTime;\n    uint256 public endTime;\n    uint256 public userWithdrawalStartTime;\n    uint256 public clearStartTime;\n    uint256 public withdrawn;\n    uint256 public proportion = 1 ether;\n    mapping(uint256 => uint256) public globalAmounts;    \n\n\n    struct Stage {\n        uint256 rate;\n        uint256 duration;\n        uint256 startTime;       \n    }\n    Stage[] public stages;    \n\n\n    struct PurchaserInfo {\n        bool withdrew;\n        bool recorded;\n        mapping(uint256 => uint256) amounts;\n    }\n    mapping(address => PurchaserInfo) public purchaserMapping;\n    address[] public purchaserList;\n\n    modifier onlyOpenTime {\n        require(isStarted());\n        require(!isEnded());\n        _;\n    }\n\n    modifier onlyAutoWithdrawalTime {\n         require(isEnded());\n        _;\n    }\n\n    modifier onlyUserWithdrawalTime {\n        require(isUserWithdrawalTime());\n        _;\n    }\n\n    modifier purchasersAllWithdrawn {\n        require(withdrawn==purchaserList.length);\n        _;\n    }\n\n    modifier onlyClearTime {\n        require(isClearTime());\n        _;\n    }\n\n    function ShareTokenSale(address _receiverAddr, address _tokenAddr, uint256 _totalSaleAmount, uint256 _startTime) public {\n        require(_receiverAddr != address(0));\n        require(_tokenAddr != address(0));\n        require(_totalSaleAmount > 0);\n        require(_startTime > 0);\n        receiverAddr = _receiverAddr;\n        token = ERC20(_tokenAddr);\n        totalSaleAmount = _totalSaleAmount;       \n        startTime = _startTime;        \n    }\n\n    function isStarted() public view returns(bool) {\n        return 0 < startTime && startTime <= now && endTime != 0;\n    }   \n\n    function isEnded() public view returns(bool) {\n        return now > endTime;\n    }\n\n    function isUserWithdrawalTime() public view returns(bool) {\n        return now > userWithdrawalStartTime;\n    }\n\n    function isClearTime() public view returns(bool) {\n        return now > clearStartTime;\n    }\n    \n    function startSale(uint256[] rates, uint256[] durations, uint256 userWithdrawalDelaySec, uint256 clearDelaySec) public onlyOwner {\n        require(endTime == 0);\n        require(durations.length == rates.length);\n        delete stages;\n        endTime = startTime;\n        for (uint256 i = 0; i < durations.length; i++) {\n            uint256 rate = rates[i];\n            uint256 duration = durations[i];            \n            stages.push(Stage({rate: rate, duration: duration, startTime:endTime}));\n            endTime = endTime.add(duration);\n        }\n        userWithdrawalStartTime = endTime.add(userWithdrawalDelaySec);\n        clearStartTime = endTime.add(clearDelaySec);\n    }\n    \n    function getCurrentStage() public onlyOpenTime view returns(uint256) {\n        for (uint256 i = stages.length - 1; i >= 0; i--) {\n            if (now >= stages[i].startTime) {\n                return i;\n            }\n        }\n        revert();\n    }\n\n    function getPurchaserCount() public view returns(uint256) {\n        return purchaserList.length;\n    }\n\n\n    function _calcProportion() internal {\n        if (totalWannaBuyAmount == 0 || totalSaleAmount >= totalWannaBuyAmount) {\n            proportion = 1 ether;\n            return;\n        }\n        proportion = totalSaleAmount.mul(1 ether).div(totalWannaBuyAmount);        \n    }\n\n    function getSaleInfo(address purchaser) public view returns (uint256, uint256, uint256) {\n        PurchaserInfo storage pi = purchaserMapping[purchaser];\n        uint256 sendEther = 0;\n        uint256 usedEther = 0;\n        uint256 getToken = 0;        \n        for (uint256 i = 0; i < stages.length; i++) {\n            sendEther = sendEther.add(pi.amounts[i]);\n            uint256 stageUsedEther = pi.amounts[i].mul(proportion).div(1 ether);\n            uint256 stageGetToken = stageUsedEther.mul(stages[i].rate);\n            if (stageGetToken > 0) {         \n                getToken = getToken.add(stageGetToken);\n                usedEther = usedEther.add(stageUsedEther);\n            }\n        }        \n        return (sendEther, usedEther, getToken);\n    }\n    \n    function () payable public {        \n        buy();\n    }\n    \n    function buy() payable public onlyOpenTime {\n        require(msg.value >= 0.1 ether);\n        uint256 stageIndex = getCurrentStage();\n        uint256 amount = msg.value;\n        PurchaserInfo storage pi = purchaserMapping[msg.sender];\n        if (!pi.recorded) {\n            pi.recorded = true;\n            purchaserList.push(msg.sender);\n        }\n        pi.amounts[stageIndex] = pi.amounts[stageIndex].add(amount);\n        globalAmounts[stageIndex] = globalAmounts[stageIndex].add(amount);\n        totalWannaBuyAmount = totalWannaBuyAmount.add(amount.mul(stages[stageIndex].rate));\n        _calcProportion();\n    }\n    \n    function _withdrawal(address purchaser) internal {\n        require(purchaser != 0x0);\n        PurchaserInfo storage pi = purchaserMapping[purchaser];        \n        if (pi.withdrew) {\n            return;\n        }\n        pi.withdrew = true;\n        withdrawn = withdrawn.add(1);\n        var (sendEther, usedEther, getToken) = getSaleInfo(purchaser);\n        if (usedEther > 0 && getToken > 0) {\n            receiverAddr.transfer(usedEther);\n            token.transfer(purchaser, getToken);\n            if (sendEther.sub(usedEther) > 0) {                \n                purchaser.transfer(sendEther.sub(usedEther));   \n            }           \n        } else {\n            purchaser.transfer(sendEther);\n        }\n        return;\n    }\n    \n    function withdrawal() payable public onlyUserWithdrawalTime {\n        _withdrawal(msg.sender);\n    }\n    \n    function withdrawalFor(uint256 index, uint256 stop) payable public onlyAutoWithdrawalTime onlyOwner {\n        for (; index < stop; index++) {\n            _withdrawal(purchaserList[index]);\n        }\n    }\n    \n    function clear(uint256 tokenAmount, uint256 etherAmount) payable public purchasersAllWithdrawn onlyClearTime onlyOwner {\n        if (tokenAmount > 0) {\n            token.transfer(receiverAddr, tokenAmount);\n        }\n        if (etherAmount > 0) {\n            receiverAddr.transfer(etherAmount);\n        }        \n    }\n}",
        "debug": "storage_12: 0xfefeeefeeeffffffffffffffffcc5ffe000001ee94fecc37e3ef3fdfff0000aa\nstorage_0: 0x0\ncaller: 0x0\ncalldata_ShareTokenSale_0: 0x23aedc6200000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\ncalldata_ShareTokenSale_4 + calldata_ShareTokenSale_4: 0x0\nmem_128 +\n32 +\n32*calldata_ShareTokenSale_4 + calldata_ShareTokenSale_4: 0x0\nstorage_6: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `startSale(uint256[],uint256[],uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "startSale(uint256[],uint256[],uint256,uint256)",
        "lineno": 130,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6154,
        "code": "dr;\n    uint256 public totalSaleAmount;\n    uint256 public totalWannaBuyAmount; \n    uint256 public startTime;\n    uint256 public endTime;\n    uint256 public userWithdrawalStartTime;\n    uint256 public clearStartTime;\n    uint256 public withdrawn;\n    uint256 public proportion = 1 ether;\n    mapping(uint256 => uint256) public globalAmounts;    \n\n\n    struct Stage {\n        uint256 rate;\n        uint256 duration;\n        uint256 startTime;       \n    }\n    Stage[] public stages;    \n\n\n    struct PurchaserInfo {\n        bool withdrew;\n        bool recorded;\n        mapping(uint256 => uint256) amounts;\n    }\n    mapping(address => PurchaserInfo) public purchaserMapping;\n    address[] public purchaserList;\n\n    modifier onlyOpenTime {\n        require(isStarted());\n        require(!isEnded());\n        _;\n    }\n\n    modifier onlyAutoWithdrawalTime {\n         require(isEnded());\n        _;\n    }\n\n    modifier onlyUserWithdrawalTime {\n        require(isUserWithdrawalTime());\n        _;\n    }\n\n    modifier purchasersAllWithdrawn {\n        require(withdrawn==purchaserList.length);\n        _;\n    }\n\n    modifier onlyClearTime {\n        require(isClearTime());\n        _;\n    }\n\n    function ShareTokenSale(address _receiverAddr, address _tokenAddr, uint256 _totalSaleAmount, uint256 _startTime) public {\n        require(_receiverAddr != address(0));\n        require(_tokenAddr != address(0));\n        require(_totalSaleAmount > 0);\n        require(_startTime > 0);\n        receiverAddr = _receiverAddr;\n        token = ERC20(_tokenAddr);\n        totalSaleAmount = _totalSaleAmount;       \n        startTime = _startTime;        \n    }\n\n    function isStarted() public view returns(bool) {\n        return 0 < startTime && startTime <= now && endTime != 0;\n    }   \n\n    function isEnded() public view returns(bool) {\n        return now > endTime;\n    }\n\n    function isUserWithdrawalTime() public view returns(bool) {\n        return now > userWithdrawalStartTime;\n    }\n\n    function isClearTime() public view returns(bool) {\n        return now > clearStartTime;\n    }\n    \n    function startSale(uint256[] rates, uint256[] durations, uint256 userWithdrawalDelaySec, uint256 clearDelaySec) public onlyOwner {\n        require(endTime == 0);\n        require(durations.length == rates.length);\n        delete stages;\n        endTime = startTime;\n        for (uint256 i = 0; i < durations.length; i++) {\n            uint256 rate = rates[i];\n            uint256 duration = durations[i];            \n            stages.push(Stage({rate: rate, duration: duration, startTime:endTime}));\n            endTime = endTime.add(duration);\n        }\n        userWithdrawalStartTime = endTime.add(userWithdrawalDelaySec);\n        clearStartTime = endTime.add(clearDelaySec);\n    }\n    \n    function getCurrentStage() public onlyOpenTime view returns(uint256) {\n        for (uint256 i = stages.length - 1; i >= 0; i--) {\n            if (now >= stages[i].startTime) {\n                return i;\n            }\n        }\n        revert();\n    }\n\n    function getPurchaserCount() public view returns(uint256) {\n        return purchaserList.length;\n    }\n\n\n    function _calcProportion() internal {\n        if (totalWannaBuyAmount == 0 || totalSaleAmount >= totalWannaBuyAmount) {\n            proportion = 1 ether;\n            return;\n        }\n        proportion = totalSaleAmount.mul(1 ether).div(totalWannaBuyAmount);        \n    }\n\n    function getSaleInfo(address purchaser) public view returns (uint256, uint256, uint256) {\n        PurchaserInfo storage pi = purchaserMapping[purchaser];\n        uint256 sendEther = 0;\n        uint256 usedEther = 0;\n        uint256 getToken = 0;        \n        for (uint256 i = 0; i < stages.length; i++) {\n            sendEther = sendEther.add(pi.amounts[i]);\n            uint256 stageUsedEther = pi.amounts[i].mul(proportion).div(1 ether);\n            uint256 stageGetToken = stageUsedEther.mul(stages[i].rate);\n            if (stageGetToken > 0) {         \n                getToken = getToken.add(stageGetToken);\n                usedEther = usedEther.add(stageUsedEther);\n            }\n        }        \n        return (sendEther, usedEther, getToken);\n    }\n    \n    function () payable public {        \n        buy();\n    }\n    \n    function buy() payable public onlyOpenTime {\n        require(msg.value >= 0.1 ether);\n        uint256 stageIndex = getCurrentStage();\n        uint256 amount = msg.value;\n        PurchaserInfo storage pi = purchaserMapping[msg.sender];\n        if (!pi.recorded) {\n            pi.recorded = true;\n            purchaserList.push(msg.sender);\n        }\n        pi.amounts[stageIndex] = pi.amounts[stageIndex].add(amount);\n        globalAmounts[stageIndex] = globalAmounts[stageIndex].add(amount);\n        totalWannaBuyAmount = totalWannaBuyAmount.add(amount.mul(stages[stageIndex].rate));\n        _calcProportion();\n    }\n    \n    function _withdrawal(address purchaser) internal {\n        require(purchaser != 0x0);\n        PurchaserInfo storage pi = purchaserMapping[purchaser];        \n        if (pi.withdrew) {\n            return;\n        }\n        pi.withdrew = true;\n        withdrawn = withdrawn.add(1);\n        var (sendEther, usedEther, getToken) = getSaleInfo(purchaser);\n        if (usedEther > 0 && getToken > 0) {\n            receiverAddr.transfer(usedEther);\n            token.transfer(purchaser, getToken);\n            if (sendEther.sub(usedEther) > 0) {                \n                purchaser.transfer(sendEther.sub(usedEther));   \n            }           \n        } else {\n            purchaser.transfer(sendEther);\n        }\n        return;\n    }\n    \n    function withdrawal() payable public onlyUserWithdrawalTime {\n        _withdrawal(msg.sender);\n    }\n    \n    function withdrawalFor(uint256 index, uint256 stop) payable public onlyAutoWithdrawalTime onlyOwner {\n        for (; index < stop; index++) {\n            _withdrawal(purchaserList[index]);\n        }\n    }\n    \n    function clear(uint256 tokenAmount, uint256 etherAmount) payable public purchasersAllWithdrawn onlyClearTime onlyOwner {\n        if (tokenAmount > 0) {\n            token.transfer(receiverAddr, tokenAmount);\n        }\n        if (etherAmount > 0) {\n            receiverAddr.transfer(etherAmount);\n        }        \n    }\n}",
        "debug": "storage_12: 0x8201d80384ff0000c7c7318a08a28121454a23e5c8a9c6b01423c555a6015473\nstorage_0: 0x0\ncaller: 0x0\ncalldata_ShareTokenSale_0: 0x23aedc6200000000000000000000000000000000000000000000000000000000\ncalldatasize_ShareTokenSale: 0x4\ncalldata_ShareTokenSale_4 + calldata_ShareTokenSale_4: 0x0\nmem_128 +\n32 +\n32*calldata_ShareTokenSale_4 + calldata_ShareTokenSale_4: 0x0\nstorage_6: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `startSale(uint256[],uint256[],uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/2/0x1bdf56c9593590122fd8750555d8148da2b80be8.sol",
        "function": "startSale(uint256[],uint256[],uint256,uint256)",
        "lineno": 130,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}