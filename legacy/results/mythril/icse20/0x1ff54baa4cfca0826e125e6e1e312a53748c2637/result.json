{
  "contract": "0x1ff54baa4cfca0826e125e6e1e312a53748c2637",
  "tool": "mythril",
  "start": 1563523403.6046433,
  "end": 1563525104.503372,
  "duration": 1700.898728609085,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 612,
        "code": " 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new addres",
        "debug": "mem_128 +\n32 +\n32*\nstorage_4 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4: 0x800000000000000000000000000000000000000000000000000000000000000\nstorage_4 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4: 0x1\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\ncalldata_LimeEyes_0: 0x7315acc800000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllShareholdersOfArtwork(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllShareholdersOfArtwork(uint256)",
        "lineno": 315,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 878,
        "code": "artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_128 + 32 + 32*storage_1: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_LimeEyes_0: 0x9c0cc30c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\nstorage_1: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllArtworks()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllArtworks()",
        "lineno": 330,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 944,
        "code": "artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_128 + 32 + 32*storage_1: 0x1\nmem_160 + 32*storage_1 + 32 + 32*storage_1: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_LimeEyes_0: 0x9c0cc30c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\nstorage_1: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllArtworks()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllArtworks()",
        "lineno": 330,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1111,
        "code": "artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_128 + 32 + 32*storage_1: 0x0\nmem_160 + 32*storage_1 + 32 + 32*storage_1: 0x0\nmem_224 + 96*storage_1 + 32 + 32*storage_1: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_LimeEyes_0: 0x9c0cc30c00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\nmem_192 + 64*storage_1 + 32 + 32*storage_1: 0x0\nstorage_1: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllArtworks()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllArtworks()",
        "lineno": 330,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1499,
        "code": "orks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible ",
        "debug": "calldata_LimeEyes_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_LimeEyes_0: 0xf5ff897700000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `renameArtwork(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "renameArtwork(uint256,string)",
        "lineno": 147,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1732,
        "code": "idends au",
        "debug": "",
        "description": "Function purchaseSharesOfArtwork(uint256) retrieves the transaction origin (tx.origin) using the ORIGIN opcode. Use msg.sender instead.\nSee also: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "purchaseSharesOfArtwork(uint256)",
        "lineno": 208,
        "title": "Use of tx.origin",
        "type": "Warning"
      },
      {
        "address": 3597,
        "code": "). the formula for finding the nth triangular",
        "debug": "storage_80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4 +\n0: 0x20\nstorage_80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4 +\n4: 0x800001f0842ba1ef7be0000000007c5d201c7813e45f105c1c9364d54b80000\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\ncalldata_LimeEyes_0: 0x167ddf6e00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getArtwork(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getArtwork(uint256)",
        "lineno": 264,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3599,
        "code": "). the formula for finding the nth triangular",
        "debug": "storage_80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4 +\n0: 0x20\nstorage_80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4 +\n4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\ncalldata_LimeEyes_0: 0x167ddf6e00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getArtwork(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getArtwork(uint256)",
        "lineno": 264,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4219,
        "code": "ks() public view returns (bytes32[] titles,",
        "debug": "storage_4 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\ncalldata_LimeEyes_0: 0x7315acc800000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllShareholdersOfArtwork(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllShareholdersOfArtwork(uint256)",
        "lineno": 327,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4222,
        "code": "ks() public view returns (bytes32[] titles,",
        "debug": "storage_4 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\ncalldata_LimeEyes_0: 0x7315acc800000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllShareholdersOfArtwork(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllShareholdersOfArtwork(uint256)",
        "lineno": 327,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4224,
        "code": "ks() public view returns (bytes32[] titles,",
        "debug": "storage_4 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\ncalldata_LimeEyes_0: 0x7315acc800000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getAllShareholdersOfArtwork(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "getAllShareholdersOfArtwork(uint256)",
        "lineno": 327,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5608,
        "code": ";\n\n//\n// LimeEyes\n",
        "debug": "storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5660,
        "code": ",\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner]",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 128,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7195,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "storage_0 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*storage_1: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n7*storage_1: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7224,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7238,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7255,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0x25\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7260,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_LimeEyes_4 + calldata_LimeEyes_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nkeccac_0_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n7*storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_LimeEyes_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0x9e67fa6a00000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createArtwork(string,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "createArtwork(string,address,uint256)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7461,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "storage_0 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n7*calldata_LimeEyes_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+\n80084422859880547211683076133703299733277748156566366325829078699459944778998_+\n7*calldata_LimeEyes_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0xf5ff897700000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `renameArtwork(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "renameArtwork(uint256,string)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7490,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "calldata_LimeEyes_4 + calldata_LimeEyes_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0xf5ff897700000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `renameArtwork(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "renameArtwork(uint256,string)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7504,
        "code": "///////////////////////\n\t//  Variables, Storage and Events\n\n\n\taddress private _dev;\n\n\tstruct Artwork {\n\t\tstring _title;\n\t\taddress _owner;\n\t\tbool _visible;\n\t\tuint256 _basePrice;\n\t\tuint256 _purchases;\n\t\taddress[] _shareholders;\n\t\tmapping (address => bool) _hasShares;\n\t\tmapping (address => uint256) _shares;\n\t}\n\tArtwork[] private _artworks;\n\n\tevent ArtworkCreated(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress owner,\n\t\tuint256 basePrice);\n\tevent ArtworkSharesPurchased(\n\t\tuint256 artworkId,\n\t\tstring title,\n\t\taddress buyer,\n\t\tuint256 sharesBought);\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Constructor and Admin Functions\n\n\n\tfunction LimeEyes() public {\n\t\t_dev = msg.sender;\n\t}\n\n\tmodifier onlyDev() {\n\t\trequire(msg.sender == _dev);\n\t\t_;\n\t}\n\n\t// This function will create a new artwork within the contract,\n\t// the title is changeable later by the dev but the owner and\n\t// basePrice cannot be changed once it's been created.\n\t// The owner of the artwork will start off with 1 share and any\n\t// other addresses may now purchase shares for it.\n\tfunction createArtwork(string title, address owner, uint256 basePrice) public onlyDev {\n\n\t\trequire(basePrice != 0);\n\t\t_artworks.push(Artwork({\n\t\t\t_title: title,\n\t\t\t_owner: owner,\n\t\t\t_visible: true,\n\t\t\t_basePrice: basePrice,\n\t\t\t_purchases: 0,\n\t\t\t_shareholders: new address[](0)\n\t\t}));\n\t\tuint256 artworkId = _artworks.length - 1;\n\t\tArtwork storage newArtwork = _artworks[artworkId];\n\t\tnewArtwork._hasShares[owner] = true;\n\t\tnewArtwork._shareholders.push(owner);\n\t\tnewArtwork._shares[owner] = 1;\n\n\t\tArtworkCreated(artworkId, title, owner, basePrice);\n\n\t}\n\n\t// Simple renaming function for the artworks, it is good to\n\t// keep in mind that when the website syncs with the blockchain,\n\t// any titles over 32 characters will be clipped.\n\tfunction renameArtwork(uint256 artworkId, string newTitle) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._title = newTitle;\n\n\t}\n\n\t// This function is only for the website and whether or not\n\t// it displays a certain artwork, any user may still buy shares\n\t// for an invisible artwork although it's not really art unless\n\t// you can view it.\n\t// This is exclusively reserved for copyright cases should any\n\t// artworks be flagged as such.\n\tfunction toggleArtworkVisibility(uint256 artworkId) public onlyDev {\n\t\t\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\t\tartwork._visible = !artwork._visible;\n\n\t}\n\n\t// The two withdrawal functions below are here so that the dev\n\t// can access the dividends of the contract if it owns any\n\t// artworks. As all ETH is transferred straight away upon the\n\t// purchasing of shares, the only ETH left in the contract will\n\t// be from dividends or the rounding errors (although the error\n\t// will only be a few wei each transaction) due to the nature\n\t// of dividing and working with integers.\n\tfunction withdrawAmount(uint256 amount, address toAddress) public onlyDev {\n\n\t\trequire(amount != 0);\n\t\trequire(amount <= this.balance);\n\t\ttoAddress.transfer(amount);\n\n\t}\n\n\t// Used to empty the contracts balance to an address.\n\tfunction withdrawAll(address toAddress) public onlyDev {\n\t\ttoAddress.transfer(this.balance);\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Main Artwork Share Purchasing Function\n\n\n\t// This is the main point of interaction in this contract,\n\t// it will allow a user to purchase shares in an artwork\n\t// and hence with their investment, they pay dividends to\n\t// all the current shareholders and then the user themselves\n\t// will become a shareholder and earn dividends on any future\n\t// purchases of shares.\n\t// See the getArtwork() function for more information on pricing\n\t// and how shares work.\n\tfunction purchaseSharesOfArtwork(uint256 artworkId) public payable {\n\n\t\t// This makes sure only people, and not contracts, can buy shares.\n\t\trequire(msg.sender == tx.origin);\n\n\t\trequire(_exists(artworkId));\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\t// The artwork owner is not allowed to purchase shares of their\n\t\t// own art, instead they will earn dividends automatically.\n\t\trequire(msg.sender != artwork._owner);\n\n\t\tuint256 totalShares;\n\t\tuint256[3] memory prices;\n\t\t( , , , prices, totalShares, , ) = getArtwork(artworkId);\n\t\tuint256 currentPrice = prices[1];\n\n\t\t// Make sure the buyer sent enough ETH\n\t\trequire(msg.value >= currentPrice);\n\n\t\t// Send back the excess if there's any.\n\t\tuint256 purchaseExcess = msg.value - currentPrice;\n\t\tif (purchaseExcess > 0)\n\t\t\tmsg.sender.transfer(purchaseExcess);\n\n\t\t// Now pay all the shareholders accordingly.\n\t\t// (this will potentially cost a lot of gas)\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tif (shareholder != address(this)) { // transfer ETH if the shareholder isn't this contract\n\t\t\t\tshareholder.transfer((currentPrice * artwork._shares[shareholder]) / totalShares);\n\t\t\t}\n\t\t}\n\n\t\t// Add the buyer to the registry.\n\t\tif (!artwork._hasShares[msg.sender]) {\n\t\t\tartwork._hasShares[msg.sender] = true;\n\t\t\tartwork._shareholders.push(msg.sender);\n\t\t}\n\n\t\tartwork._purchases++; // track our purchase\n\t\tartwork._shares[msg.sender] += artwork._purchases; // add the shares to the sender\n\t\tartwork._shares[artwork._owner] = artwork._purchases + 1; // set the owners next shares\n\n\t\tArtworkSharesPurchased(artworkId, artwork._title, msg.sender, artwork._purchases);\n\t\t\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////\n\t//  Getters\n\n\n\tfunction _exists(uint256 artworkId) private view returns (bool) {\n\t\treturn artworkId < _artworks.length;\n\t}\n\n\tfunction getArtwork(uint256 artworkId) public view returns (string artworkTitle, address ownerAddress, bool isVisible, uint256[3] artworkPrices, uint256 artworkShares, uint256 artworkPurchases, uint256 artworkShareholders) {\n\t\t\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork memory artwork = _artworks[artworkId];\n\n\t\t// As at each step we are simply increasing the number of shares given by 1, the resulting\n\t\t// total from adding up consecutive numbers from 1 is the same as the triangular number\n\t\t// series (1 + 2 + 3 + ...). the formula for finding the nth triangular number is as follows;\n\t\t// Tn = (n * (n + 1)) / 2\n\t\t// For example the 10th triangular number is (10 * 11) / 2 = 55\n\t\t// In our case however, the owner of the artwork always inherits the shares being bought\n\t\t// before transferring them to the buyer but the owner cannot buy shares of their own artwork.\n\t\t// This means that when calculating how many shares, we need to add 1 to the total purchases\n\t\t// in order to accommodate for the owner. from here we just need to adjust the triangular\n\t\t// number formula slightly to get;\n\t\t// Shares After n Purchases = ((n + 1) * (n + 2)) / 2\n\t\t// Let's say the art is being purchased for a second time which means the purchaser is\n\t\t// buying 3 shares and therefore the owner will get 3 shares worth of dividends from the\n\t\t// overall purchase value. As it's the 2nd purchase, there are (3 * 4) / 2 = 6 shares total\n\t\t// according to our formula which is as expected.\n\t\tuint256 totalShares = ((artwork._purchases + 1) * (artwork._purchases + 2)) / 2;\n\n\t\t// Set up our prices array;\n\t\t// 0: base price\n\t\t// 1: current price\n\t\t// 2: next price\n\t\tuint256[3] memory prices;\n\t\tprices[0] = artwork._basePrice;\n\t\t// The current price is also directly related the total number of shares, it simply treats\n\t\t// the total number of shares as a percentage and adds that much on top of the base price.\n\t\t// For example if the base price was 0.01 ETH and there were 250 shares total it would mean\n\t\t// that the price would gain 250% of it's value = 0.035 ETH (100% + 250%);\n\t\t// Current Price = (Base Price * (100 + Total Shares)) / 100\n\t\tprices[1] = (prices[0] * (100 + totalShares)) / 100;\n\t\t// The next price would just be the same as the current price but we have a few extra shares.\n\t\t// If there are 0 purchases then you are buying 1 share (purchases + 1) so the next buyer would\n\t\t// be purchasing 2 shares (purchases + 2) so therefore;\n\t\tprices[2] = (prices[0] * (100 + totalShares + (artwork._purchases + 2))) / 100;\n\n\t\treturn (\n\t\t\t\tartwork._title,\n\t\t\t\tartwork._owner,\n\t\t\t\tartwork._visible,\n\t\t\t\tprices,\n\t\t\t\ttotalShares,\n\t\t\t\tartwork._purchases,\n\t\t\t\tartwork._shareholders.length\n\t\t\t);\n\n\t}\n\n\tfunction getAllShareholdersOfArtwork(uint256 artworkId) public view returns (address[] shareholders, uint256[] shares) {\n\n\t\trequire(_exists(artworkId));\n\n\t\tArtwork storage artwork = _artworks[artworkId];\n\n\t\tuint256[] memory shareholderShares = new uint256[](artwork._shareholders.length);\n\t\tfor (uint256 i = 0; i < artwork._shareholders.length; i++) {\n\t\t\taddress shareholder = artwork._shareholders[i];\n\t\t\tshareholderShares[i] = artwork._shares[shareholder];\n\t\t}\n\n\t\treturn (\n\t\t\t\tartwork._shareholders,\n\t\t\t\tshareholderShares\n\t\t\t);\n\n\t}\n\n\tfunction getAllArtworks() public view returns (bytes32[] titles, address[] owners, bool[] isVisible, uint256[3][] artworkPrices, uint256[] artworkShares, uint256[] artworkPurchases, uint256[] artworkShareholders) {\n\n\t\tbytes32[] memory allTitles = new bytes32[](_artworks.length);\n\t\taddress[] memory allOwners = new address[](_artworks.length);\n\t\tbool[] memory allIsVisible = new bool[](_artworks.length);\n\t\tuint256[3][] memory allPrices = new uint256[3][](_artworks.length);\n\t\tuint256[] memory allShares = new uint256[](_artworks.length);\n\t\tuint256[] memory allPurchases = new uint256[](_artworks.length);\n\t\tuint256[] memory allShareholders = new uint256[](_artworks.length);\n\n\t\tfor (uint256 i = 0; i < _artworks.length; i++) {\n\t\t\tstring memory tmpTitle;\n\t\t\t(tmpTitle, allOwners[i], allIsVisible[i], allPrices[i], allShares[i], allPurchases[i], allShareholders[i]) = getArtwork(i);\n\t\t\tallTitles[i] = stringToBytes32(tmpTitle);\n\t\t}\n\n\t\treturn (\n\t\t\t\tallTitles,\n\t\t\t\tallOwners,\n\t\t\t\tallIsVisible,\n\t\t\t\tallPrices,\n\t\t\t\tallShares,\n\t\t\t\tallPurchases,\n\t\t\t\tallShareholders\n\t\t\t);\n\n\t}\n\n\tfunction stringToBytes32(string memory source) internal pure returns (bytes32 result) {\n\t\tbytes memory tmpEmptyStringTest = bytes(source);\n\t\tif (tmpEmptyStringTest.length == 0) {\n\t\t\treturn 0x0;\n\t\t}\n\n\t\tassembly {\n\t\t\tresult := mload(add(source, 32))\n\t\t}\n\t}\n\n\t\n\t//////////////////////////////////////////////////////////////////////\n\n}",
        "debug": "calldata_LimeEyes_4 + calldata_LimeEyes_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_LimeEyes_4: 0x0\nstorage_1: 0x1\nstorage_0: 0x0\ncaller: 0x0\ncalldata_LimeEyes_0: 0xf5ff897700000000000000000000000000000000000000000000000000000000\ncalldatasize_LimeEyes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `renameArtwork(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x1ff54baa4cfca0826e125e6e1e312a53748c2637.sol",
        "function": "renameArtwork(uint256,string)",
        "lineno": 72,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}