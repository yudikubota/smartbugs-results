{"error": null, "issues": [{"address": 2721, "code": "   herosForSale[_", "debug": "storage_1 + keccac_calldata_SuperHeroes_4: 0x22222225c761bccd1f6c220023fbd66fdbcc1c4556175964555555641fffc1d\nstorage_0: 0x800000000000000000000000000000000000000000\ncallvalue: 0x22222225c761bccd1f6c220023fbd66fdbcc1c4556175964555555641fffc1d\ncalldata_SuperHeroes_0: 0x24edd7500000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n", "description": "A possible integer overflow exists in the function `buyHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "buyHero(uint256)", "lineno": 280, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2748, "code": "d];\n  }\n\n  ", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0xffffffffffffefffffffffffffffffffffffff0000\ncalldata_SuperHeroes_4: 0x0\nstorage_1 + keccac_calldata_SuperHeroes_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x24edd7500000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "buyHero(uint256)", "lineno": 280, "title": "Exception state", "type": "Informational"}, {"address": 3798, "code": "unt);\n  }\n}", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x0\nstorage_keccac_calldata_SuperHeroes_4: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x51d5f44f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "saleHero(uint256)", "lineno": 289, "title": "Exception state", "type": "Informational"}, {"address": 4090, "code": "g.value - r", "debug": "The exception is triggered under the following conditions:\n\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x0\nstorage_0: 0x0\ncalldata_SuperHeroes_0: 0x642c7aa200000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "snatchHero(uint256)", "lineno": 256, "title": "Exception state", "type": "Informational"}, {"address": 6612, "code": "nIndexToApproved[_tokenId]", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SuperHeroes_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\ncaller: 0x0\nstorage_keccac_calldata_SuperHeroes_32_+_36: 0x0\ncalldata_SuperHeroes_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "transferFrom(address,address,uint256)", "lineno": 158, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6828, "code": "56 tokenId) {\n    require(to", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SuperHeroes_4: 0x0\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_SuperHeroes_32_+_36: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_SuperHeroes_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `transferFrom(address,address,uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "transferFrom(address,address,uint256)", "lineno": 162, "title": "Integer Underflow", "type": "Warning"}, {"address": 7160, "code": "balanceOf(address ", "debug": "mem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_3: 0xf9\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x56b01ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "mint(string,uint256)", "lineno": 179, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7859, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "keccac_keccac_calldata_SuperHeroes_4_+_0: 0xff0037d24081fefffbfffedffffffffe07ff638f017ffffffffbfbfffc000000\nstorage_keccac_calldata_SuperHeroes_4 + 0: 0x9ecf649f363f3c965beeb73ffbfbbf3df6dabbfb51ffffd6fefeffffffffffc1\nstorage_0: 0x8000000000000000000000000000000000000000\ncalldata_SuperHeroes_4: 0x0\nstorage_1 + keccac_calldata_SuperHeroes_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x24edd7500000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n", "description": "A possible integer overflow exists in the function `buyHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "buyHero(uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7913, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "storage_0 + keccac_calldata_SuperHeroes_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+_keccac_calldata_SuperHeroes_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x1\nstorage_keccac_calldata_SuperHeroes_4: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x51d5f44f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `saleHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "saleHero(uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7963, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "storage_87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_SuperHeroes_4 +\n0: 0x918a1f6ed1bfdbce3d7ffd7ffffffffffc1e22000000062635087fd990f70a01\nkeccac_87903029871075914254377627908054574944891091886930582284385770809450030037083_+\n3*calldata_SuperHeroes_4_+\n0: 0xfeb9d071e446c0400040000400000000000004e4248b6c5c8a034473fb1fad52\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x1\nstorage_keccac_calldata_SuperHeroes_4: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x51d5f44f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `saleHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "saleHero(uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8082, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "storage_0 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*storage_3: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+\n87903029871075914254377627908054574944891091886930582284385770809450030037083_+\n3*storage_3: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_3: 0xf9\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x56b01ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "mint(string,uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8111, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "mem_mem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_3: 0xf9\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x56b01ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "mint(string,uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8125, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "mem_mem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nstorage_3: 0xf9\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x56b01ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "mint(string,uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8142, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "mem_mem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0x25\nmem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nstorage_3: 0xf9\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x56b01ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "mint(string,uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8147, "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}", "debug": "mem_mem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nmem_256 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SuperHeroes_4 + calldata_SuperHeroes_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nkeccac_0_+\n87903029871075914254377627908054574944891091886930582284385770809450030037083_+\n3*storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0xf9\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x56b01ce00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0373ead1b067793d8338ba4d21782dd082c02a00.sol", "function": "mint(string,uint256)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}], "success": true}