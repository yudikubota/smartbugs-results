{
  "contract": "0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591",
  "tool": "mythril",
  "start": 1563600005.6978028,
  "end": 1563600129.3347228,
  "duration": 123.63691997528076,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1974,
        "code": "t _colourB) {\n        _colourR = pixels[_pixelId].colourR;\n        _colourG = pixels[_pixelId].colourG;\n        _c",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_etherdoodleToken_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_etherdoodleToken_0: 0x5fa382ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getPixelsOwned(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "getPixelsOwned(address)",
        "lineno": 426,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5067,
        "code": ");\n        _createPixel((_pixelId), _colou",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function payout(address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "payout(address)",
        "lineno": 445,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 5845,
        "code": "elId].pixelText;",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_etherdoodleToken_4: 0xf4240\ncalldata_etherdoodleToken_0: 0x5840b0f800000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "getPixelData(uint256)",
        "lineno": 401,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6280,
        "code": "ixels[_pixelId].colourG;\n  ",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_etherdoodleToken_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_etherdoodleToken_0: 0x5fa382ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getPixelsOwned(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "getPixelsOwned(address)",
        "lineno": 428,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6282,
        "code": "ixels[_pixelId].colourG;\n  ",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_etherdoodleToken_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_etherdoodleToken_0: 0x5fa382ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getPixelsOwned(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "getPixelsOwned(address)",
        "lineno": 428,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6415,
        "code": "thing at start\n ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_etherdoodleToken_4: 0xf4240\ncalldata_etherdoodleToken_0: 0x642fd0f600000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "getPixelColour(uint256)",
        "lineno": 441,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10601,
        "code": "ToPixel[_fr",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_etherdoodleToken_4: 0xf4240\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 654,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10760,
        "code": "ToPixel[_from].length; i++) {\n                if (ownerToPixel[_fr",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_etherdoodleToken_4: 0xf423f\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `promoPurchase(uint32,uint8,uint8,uint8,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 654,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15627,
        "code": "9e5ba;\n\n\n//EVENTS\n// @dev fired when a pixel's colour is changed\n    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n\n// @dev fired when a pixel's price is changed\n    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n\n// @dev fired when a pixel's text is changed\n    event TextChanged(uint pixelId, string textChanged);\n\n//@dev name for ERC-721\n    string constant public name = \"etherdoodle\";\n\n//@dev symbol for ERC-721\n    string constant public symbol = \"etherdoodle\";\n\n//@dev Starting pixel price\n    uint constant public startingPrice = 0.0025 ether;\n\n//@dev Total number of promo pixels\n    uint private constant PROMO_LIMIT = 1000;\n\n//@dev Switch from 3x to 1.5x per transaction\n    uint private constant stepAt = 0.24862 ether;\n\n//@dev The addresses of the accounts \n    address public ceoAddress;\n\n//@dev number of promo pixels purchased\n    uint public promoCount;\n\n//DATA STRUCTURES\n//@dev struct representation of a pixel\n    struct Pixel {\n        uint32 id;\n        uint8 colourR;\n        uint8 colourG;\n        uint8 colourB;\n        string pixelText;\n    }\n\n//@dev array holding all pixels\n    Pixel[1000000] public pixels;\n\n//MAPPINGS\n//@dev mapping from a pixel to its owner\n    mapping (uint => address) private pixelToOwner;\n\n//@dev mapping from owner to all of their pixels;\n    mapping (address => uint[]) private ownerToPixel;\n\n//@dev mapping from an address to the count of pixels\n    mapping (address => uint) private ownerPixelCount;\n\n//@dev mapping from a pixelId to the price of that pixel\n    mapping (uint => uint ) private pixelToPrice;\n\n//@dev mapping from a pixel to an approved account for transfer\n    mapping(uint => address) public pixelToApproved;\n\n//@dev mapping from an address to another mapping that determines if an operator is approved\n    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n\n//MODIFIERS\n//@dev access modifiers for ceo\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n//@dev used to verify ownership\n    modifier onlyOwnerOf(uint _pixelId) {\n        require(msg.sender == ownerOf(_pixelId));\n        _;\n    }\n\n//@dev used to allow operators to transfer and to manage the pixels\n    modifier canManageAndTransfer(uint _pixelId) {\n        require(isApprovedOrOwner(msg.sender, _pixelId));\n        _;\n    }\n\n//@dev make sure that the recipient address is notNull\n    modifier notNull(address _to) {\n        require(_to != address(0));\n        _;\n    }\n\n//Constructor\n    constructor () public {\n        ceoAddress = msg.sender;\n    }\n///////\n// External functions\n/////\n//@dev function to assign a new CEO\n    function assignCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n        ceoAddress = _newCEO;\n    }\n\n//@Update All a selected pixels details, can be done by the operator, or the owner\n    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n    external canManageAndTransfer(_pixelId) {\n        require(_price <= pixelToPrice[_pixelId]);\n        require(_price >= 0.0025 ether);\n        require(bytes(_text).length < 101);\n        bool colourChangedBool = false;\n        if(pixelToPrice[_pixelId] != _price){\n            pixelToPrice[_pixelId] = _price;\n            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n        }\n        if(pixels[_pixelId].colourR != _colourR){\n            pixels[_pixelId].colourR = _colourR;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourG != _colourG){\n            pixels[_pixelId].colourG = _colourG;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourB != _colourB){\n            pixels[_pixelId].colourB = _colourB;\n            colourChangedBool = true;\n        }\n        if (colourChangedBool){\n            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n        }\n        \n        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n            pixels[_pixelId].pixelText = _text;\n            emit TextChanged(_pixelId,_text);\n        }\n    }\n\n//@dev add an address to a pixel's approved list\n    function approve(address _to, uint _pixelId) public  {\n        address owner = ownerOf(_pixelId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n            pixelToApproved[_pixelId] = _to;\n            emit Approval(msg.sender, _to, _pixelId);\n        }\n        \n    }\n\n//@dev returns approved Addresses\n    function getApproved(uint _pixelId) public view returns(address){\n        return pixelToApproved[_pixelId];\n    }\n\n//@dev approve all an owner's pixels to be managed by an address\n    function setApprovalForAll(address _to,bool _approved) public{\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n \n\n///////////////////\n///Public functions\n///////////////////\n\n//@dev returns if a pixel has already been purchased\n    function exists(uint256 _pixelId) public view returns (bool) {\n        address owner = pixelToOwner[_pixelId];\n        return owner != address(0);\n    }\n\n//@dev returns if an address is approved to manage all another address' pixels\n    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n//@dev returns the number of pixels an address owns\n    function balanceOf(address _owner) public view returns (uint) {\n        return ownerPixelCount[_owner];\n    }\n\n\n//@dev returns the owner of a pixel\n    function ownerOf(uint _pixelId)  public view returns (address) {\n        address owner = pixelToOwner[_pixelId];\n        return owner;\n    }\n\n//@dev internal function to determine if its approved or an owner\n    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n        address owner = ownerOf(_pixelId);\n        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n    }\n\n//@dev internal function to remove approval on a pixel\n    function clearApproval(address _owner, uint256 _pixelId) internal {\n        require(ownerOf(_pixelId) == _owner);\n        if(pixelToApproved[_pixelId] != address(0)) {\n            pixelToApproved[_pixelId] = address(0);\n            emit Approval(_owner,address(0),_pixelId);\n        }\n    }\n\n//@dev returns the total number of pixels generated\n    function totalSupply() public view returns (uint) {\n        return pixels.length;\n    }\n\n//@dev ERC 721 transfer from\n    function transferFrom(address _from, address _to, uint _pixelId) public \n    canManageAndTransfer(_pixelId) {\n        require(_from != address(0));\n        require(_to != address(0));\n        clearApproval(_from,_pixelId);\n        _transfer(_from, _to, _pixelId);\n    }\n//@dev ERC 721 safeTransfer from functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n        safeTransferFrom(_from,_to,_pixelId,\"\");\n    }\n\n//@dev ERC 721 safeTransferFrom functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n        transferFrom(_from,_to,_pixelId);\n        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n    }\n\n//@dev TRANSFER\n    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n        _transfer(msg.sender, _to, _pixelId);\n    }\n\n//@dev returns all pixel's data\n    function getPixelData(uint _pixelId) public view returns \n    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n        Pixel storage pixel = pixels[_pixelId];\n        _id = pixel.id;\n        _price = getPixelPrice(_pixelId);\n        _owner = pixelToOwner[_pixelId];\n        _colourR = pixel.colourR;\n        _colourG = pixel.colourG;\n        _colourB = pixel.colourB;\n        _text = pixel.pixelText;\n    }\n\n//@dev Returns only Text\n    function getPixelText(uint _pixelId)public view returns(string) {\n        return pixels[_pixelId].pixelText;\n    }\n\n//@dev Returns the priceof a pixel\n    function getPixelPrice(uint _pixelId) public view returns(uint) {\n        uint price = pixelToPrice[_pixelId];\n        if (price != 0) {\n            return price;\n        } else {\n            return 1000000000000000;\n            }\n        \n    } \n\n    //@dev return the pixels owned by an address\n    function getPixelsOwned(address _owner) public view returns(uint[]) {\n        return ownerToPixel[_owner];\n    }\n\n    //@dev return number of pixels owned by an address\n    function getOwnerPixelCount(address _owner) public view returns(uint) {\n        return ownerPixelCount[_owner];\n    }\n\n    //@dev  return colour\n    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n        _colourR = pixels[_pixelId].colourR;\n        _colourG = pixels[_pixelId].colourG;\n        _colourB = pixels[_pixelId].colourB;\n    }\n\n    //@dev payout function to dev\n    function payout(address _to) public onlyCEO {\n        if (_to == address(0)) {\n            ceoAddress.transfer(address(this).balance);\n        } else {\n            _to.transfer(address(this).balance);\n        }  \n    }\n\n    //@dev purchase promo pixels that cost nothing at start\n    function promoPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text) public {\n        require(ownerOf(_pixelId) == (address(0)));\n        require(promoCount<PROMO_LIMIT);\n        require(bytes(_text).length < 101);\n        _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        _transfer(address(0),msg.sender,_pixelId);      \n        promoCount++;\n    }\n        \n    //@dev purchase multiple pixels at the same time\n    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n        require(bytes(_text).length < 101);\n        address newOwner = msg.sender;\n        uint totalPrice = 0;\n        uint excessValue = msg.value;\n        \n        for(uint i = 0; i < _Id.length; i++){\n            address oldOwner = ownerOf(_Id[i]);\n            require(ownerOf(_Id[i]) != newOwner);\n            require(!isInvulnerableByArea(_Id[i]));\n            \n            uint tempPrice = getPixelPrice(_Id[i]);\n            totalPrice = SafeMath.add(totalPrice,tempPrice);\n            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n           \n            if(i == _Id.length-1) {\n                require(msg.value >= totalPrice);\n                msg.sender.transfer(excessValue);\n                }   \n        }\n        \n    } \n\n    //@dev helper function for processing multiple purchases\n    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n        uint payment; // payment to previous owner\n        uint purchaseExcess; // excess purchase value\n        uint sellingPrice = getPixelPrice(_pixelId);\n        if(_oldOwner == address(0)) {\n            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        } else {\n            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n            purchaseExcess = SafeMath.sub(value,sellingPrice);\n            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n                _changeText(_pixelId,_text);\n            clearApproval(_oldOwner,_pixelId);\n        }\n        if(sellingPrice < stepAt) {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n        } else {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n        }\n        _transfer(_oldOwner, _newOwner,_pixelId);\n     \n        if(_oldOwner != address(this)) {\n            _oldOwner.transfer(payment); \n        }\n        return purchaseExcess;\n    }\n    \n    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n        pixels[_pixelId].colourR = _colourR;\n        pixels[_pixelId].colourG = _colourG;\n        pixels[_pixelId].colourB = _colourB;\n        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n    }\n    function _changeText(uint _pixelId, string _text) private{\n        require(bytes(_text).length < 101);\n        pixels[_pixelId].pixelText = _text;\n        emit TextChanged(_pixelId,_text);\n    }\n    \n\n//@dev Invulnerability logic check \n    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n        require(_pixelId >= 0 && _pixelId <= 999999);\n        if (ownerOf(_pixelId) == address(0)) {\n            return false;\n        }\n        uint256 counter = 0;\n \n        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n            return false;\n        }\n\n        if (_pixelId < 1000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnder(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnderRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1); \n            }\n            if (_checkPixelUnderLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAbove(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999 && _pixelId < 999000) {\n            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n                if (_pixelId%1000 == 0) {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                } else {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                }\n            } else {\n                if (_checkPixelAbove(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnder(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n            }\n        }\n        return counter >= 5;\n    }\n\n   \n\n   \n\n////////////////////\n///Private functions\n////////////////////\n//@dev create a pixel\n    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n        pixelToPrice[_id] = startingPrice;\n        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n        return _id;\n    }\n\n//@dev private function to transfer a pixel from an old address to a new one\n    function _transfer(address _from, address _to, uint _pixelId) private {\n  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n        ownerToPixel[_to].push(_pixelId);\n        if (_from != address(0)) {\n            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n                if (ownerToPixel[_from][i] == _pixelId) {\n                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n                }\n            }\n            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n        }\n        pixelToOwner[_pixelId] = _to;\n        emit Transfer(_from, _to, _pixelId);\n    }\n\n//@dev helper functions to check for if a pixel purchase is valid\n    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n            return true;\n        } else { \n            return false;\n        }\n    }\n    \n    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n            return true;\n        } else {  \n            return false; \n        }\n    }\n\n//@dev ERC721 compliance to check what address it is being sent to\n    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        _from, _pixelId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n}",
        "debug": "storage_1 +\n2 +\n2*Concat(0, Extract(31, 0, calldata_etherdoodleToken_4)): 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_1_+\n2_+\n2*Concat(0,_Extract(31,_0,_calldata_etherdoodleToken_4)): 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_etherdoodleToken_4: 0xf423f\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `promoPurchase(uint32,uint8,uint8,uint8,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 153,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15656,
        "code": "9e5ba;\n\n\n//EVENTS\n// @dev fired when a pixel's colour is changed\n    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n\n// @dev fired when a pixel's price is changed\n    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n\n// @dev fired when a pixel's text is changed\n    event TextChanged(uint pixelId, string textChanged);\n\n//@dev name for ERC-721\n    string constant public name = \"etherdoodle\";\n\n//@dev symbol for ERC-721\n    string constant public symbol = \"etherdoodle\";\n\n//@dev Starting pixel price\n    uint constant public startingPrice = 0.0025 ether;\n\n//@dev Total number of promo pixels\n    uint private constant PROMO_LIMIT = 1000;\n\n//@dev Switch from 3x to 1.5x per transaction\n    uint private constant stepAt = 0.24862 ether;\n\n//@dev The addresses of the accounts \n    address public ceoAddress;\n\n//@dev number of promo pixels purchased\n    uint public promoCount;\n\n//DATA STRUCTURES\n//@dev struct representation of a pixel\n    struct Pixel {\n        uint32 id;\n        uint8 colourR;\n        uint8 colourG;\n        uint8 colourB;\n        string pixelText;\n    }\n\n//@dev array holding all pixels\n    Pixel[1000000] public pixels;\n\n//MAPPINGS\n//@dev mapping from a pixel to its owner\n    mapping (uint => address) private pixelToOwner;\n\n//@dev mapping from owner to all of their pixels;\n    mapping (address => uint[]) private ownerToPixel;\n\n//@dev mapping from an address to the count of pixels\n    mapping (address => uint) private ownerPixelCount;\n\n//@dev mapping from a pixelId to the price of that pixel\n    mapping (uint => uint ) private pixelToPrice;\n\n//@dev mapping from a pixel to an approved account for transfer\n    mapping(uint => address) public pixelToApproved;\n\n//@dev mapping from an address to another mapping that determines if an operator is approved\n    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n\n//MODIFIERS\n//@dev access modifiers for ceo\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n//@dev used to verify ownership\n    modifier onlyOwnerOf(uint _pixelId) {\n        require(msg.sender == ownerOf(_pixelId));\n        _;\n    }\n\n//@dev used to allow operators to transfer and to manage the pixels\n    modifier canManageAndTransfer(uint _pixelId) {\n        require(isApprovedOrOwner(msg.sender, _pixelId));\n        _;\n    }\n\n//@dev make sure that the recipient address is notNull\n    modifier notNull(address _to) {\n        require(_to != address(0));\n        _;\n    }\n\n//Constructor\n    constructor () public {\n        ceoAddress = msg.sender;\n    }\n///////\n// External functions\n/////\n//@dev function to assign a new CEO\n    function assignCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n        ceoAddress = _newCEO;\n    }\n\n//@Update All a selected pixels details, can be done by the operator, or the owner\n    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n    external canManageAndTransfer(_pixelId) {\n        require(_price <= pixelToPrice[_pixelId]);\n        require(_price >= 0.0025 ether);\n        require(bytes(_text).length < 101);\n        bool colourChangedBool = false;\n        if(pixelToPrice[_pixelId] != _price){\n            pixelToPrice[_pixelId] = _price;\n            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n        }\n        if(pixels[_pixelId].colourR != _colourR){\n            pixels[_pixelId].colourR = _colourR;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourG != _colourG){\n            pixels[_pixelId].colourG = _colourG;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourB != _colourB){\n            pixels[_pixelId].colourB = _colourB;\n            colourChangedBool = true;\n        }\n        if (colourChangedBool){\n            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n        }\n        \n        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n            pixels[_pixelId].pixelText = _text;\n            emit TextChanged(_pixelId,_text);\n        }\n    }\n\n//@dev add an address to a pixel's approved list\n    function approve(address _to, uint _pixelId) public  {\n        address owner = ownerOf(_pixelId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n            pixelToApproved[_pixelId] = _to;\n            emit Approval(msg.sender, _to, _pixelId);\n        }\n        \n    }\n\n//@dev returns approved Addresses\n    function getApproved(uint _pixelId) public view returns(address){\n        return pixelToApproved[_pixelId];\n    }\n\n//@dev approve all an owner's pixels to be managed by an address\n    function setApprovalForAll(address _to,bool _approved) public{\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n \n\n///////////////////\n///Public functions\n///////////////////\n\n//@dev returns if a pixel has already been purchased\n    function exists(uint256 _pixelId) public view returns (bool) {\n        address owner = pixelToOwner[_pixelId];\n        return owner != address(0);\n    }\n\n//@dev returns if an address is approved to manage all another address' pixels\n    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n//@dev returns the number of pixels an address owns\n    function balanceOf(address _owner) public view returns (uint) {\n        return ownerPixelCount[_owner];\n    }\n\n\n//@dev returns the owner of a pixel\n    function ownerOf(uint _pixelId)  public view returns (address) {\n        address owner = pixelToOwner[_pixelId];\n        return owner;\n    }\n\n//@dev internal function to determine if its approved or an owner\n    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n        address owner = ownerOf(_pixelId);\n        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n    }\n\n//@dev internal function to remove approval on a pixel\n    function clearApproval(address _owner, uint256 _pixelId) internal {\n        require(ownerOf(_pixelId) == _owner);\n        if(pixelToApproved[_pixelId] != address(0)) {\n            pixelToApproved[_pixelId] = address(0);\n            emit Approval(_owner,address(0),_pixelId);\n        }\n    }\n\n//@dev returns the total number of pixels generated\n    function totalSupply() public view returns (uint) {\n        return pixels.length;\n    }\n\n//@dev ERC 721 transfer from\n    function transferFrom(address _from, address _to, uint _pixelId) public \n    canManageAndTransfer(_pixelId) {\n        require(_from != address(0));\n        require(_to != address(0));\n        clearApproval(_from,_pixelId);\n        _transfer(_from, _to, _pixelId);\n    }\n//@dev ERC 721 safeTransfer from functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n        safeTransferFrom(_from,_to,_pixelId,\"\");\n    }\n\n//@dev ERC 721 safeTransferFrom functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n        transferFrom(_from,_to,_pixelId);\n        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n    }\n\n//@dev TRANSFER\n    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n        _transfer(msg.sender, _to, _pixelId);\n    }\n\n//@dev returns all pixel's data\n    function getPixelData(uint _pixelId) public view returns \n    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n        Pixel storage pixel = pixels[_pixelId];\n        _id = pixel.id;\n        _price = getPixelPrice(_pixelId);\n        _owner = pixelToOwner[_pixelId];\n        _colourR = pixel.colourR;\n        _colourG = pixel.colourG;\n        _colourB = pixel.colourB;\n        _text = pixel.pixelText;\n    }\n\n//@dev Returns only Text\n    function getPixelText(uint _pixelId)public view returns(string) {\n        return pixels[_pixelId].pixelText;\n    }\n\n//@dev Returns the priceof a pixel\n    function getPixelPrice(uint _pixelId) public view returns(uint) {\n        uint price = pixelToPrice[_pixelId];\n        if (price != 0) {\n            return price;\n        } else {\n            return 1000000000000000;\n            }\n        \n    } \n\n    //@dev return the pixels owned by an address\n    function getPixelsOwned(address _owner) public view returns(uint[]) {\n        return ownerToPixel[_owner];\n    }\n\n    //@dev return number of pixels owned by an address\n    function getOwnerPixelCount(address _owner) public view returns(uint) {\n        return ownerPixelCount[_owner];\n    }\n\n    //@dev  return colour\n    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n        _colourR = pixels[_pixelId].colourR;\n        _colourG = pixels[_pixelId].colourG;\n        _colourB = pixels[_pixelId].colourB;\n    }\n\n    //@dev payout function to dev\n    function payout(address _to) public onlyCEO {\n        if (_to == address(0)) {\n            ceoAddress.transfer(address(this).balance);\n        } else {\n            _to.transfer(address(this).balance);\n        }  \n    }\n\n    //@dev purchase promo pixels that cost nothing at start\n    function promoPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text) public {\n        require(ownerOf(_pixelId) == (address(0)));\n        require(promoCount<PROMO_LIMIT);\n        require(bytes(_text).length < 101);\n        _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        _transfer(address(0),msg.sender,_pixelId);      \n        promoCount++;\n    }\n        \n    //@dev purchase multiple pixels at the same time\n    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n        require(bytes(_text).length < 101);\n        address newOwner = msg.sender;\n        uint totalPrice = 0;\n        uint excessValue = msg.value;\n        \n        for(uint i = 0; i < _Id.length; i++){\n            address oldOwner = ownerOf(_Id[i]);\n            require(ownerOf(_Id[i]) != newOwner);\n            require(!isInvulnerableByArea(_Id[i]));\n            \n            uint tempPrice = getPixelPrice(_Id[i]);\n            totalPrice = SafeMath.add(totalPrice,tempPrice);\n            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n           \n            if(i == _Id.length-1) {\n                require(msg.value >= totalPrice);\n                msg.sender.transfer(excessValue);\n                }   \n        }\n        \n    } \n\n    //@dev helper function for processing multiple purchases\n    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n        uint payment; // payment to previous owner\n        uint purchaseExcess; // excess purchase value\n        uint sellingPrice = getPixelPrice(_pixelId);\n        if(_oldOwner == address(0)) {\n            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        } else {\n            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n            purchaseExcess = SafeMath.sub(value,sellingPrice);\n            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n                _changeText(_pixelId,_text);\n            clearApproval(_oldOwner,_pixelId);\n        }\n        if(sellingPrice < stepAt) {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n        } else {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n        }\n        _transfer(_oldOwner, _newOwner,_pixelId);\n     \n        if(_oldOwner != address(this)) {\n            _oldOwner.transfer(payment); \n        }\n        return purchaseExcess;\n    }\n    \n    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n        pixels[_pixelId].colourR = _colourR;\n        pixels[_pixelId].colourG = _colourG;\n        pixels[_pixelId].colourB = _colourB;\n        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n    }\n    function _changeText(uint _pixelId, string _text) private{\n        require(bytes(_text).length < 101);\n        pixels[_pixelId].pixelText = _text;\n        emit TextChanged(_pixelId,_text);\n    }\n    \n\n//@dev Invulnerability logic check \n    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n        require(_pixelId >= 0 && _pixelId <= 999999);\n        if (ownerOf(_pixelId) == address(0)) {\n            return false;\n        }\n        uint256 counter = 0;\n \n        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n            return false;\n        }\n\n        if (_pixelId < 1000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnder(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnderRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1); \n            }\n            if (_checkPixelUnderLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAbove(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999 && _pixelId < 999000) {\n            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n                if (_pixelId%1000 == 0) {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                } else {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                }\n            } else {\n                if (_checkPixelAbove(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnder(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n            }\n        }\n        return counter >= 5;\n    }\n\n   \n\n   \n\n////////////////////\n///Private functions\n////////////////////\n//@dev create a pixel\n    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n        pixelToPrice[_id] = startingPrice;\n        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n        return _id;\n    }\n\n//@dev private function to transfer a pixel from an old address to a new one\n    function _transfer(address _from, address _to, uint _pixelId) private {\n  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n        ownerToPixel[_to].push(_pixelId);\n        if (_from != address(0)) {\n            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n                if (ownerToPixel[_from][i] == _pixelId) {\n                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n                }\n            }\n            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n        }\n        pixelToOwner[_pixelId] = _to;\n        emit Transfer(_from, _to, _pixelId);\n    }\n\n//@dev helper functions to check for if a pixel purchase is valid\n    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n            return true;\n        } else { \n            return false;\n        }\n    }\n    \n    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n            return true;\n        } else {  \n            return false; \n        }\n    }\n\n//@dev ERC721 compliance to check what address it is being sent to\n    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        _from, _pixelId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_etherdoodleToken_4: 0xf423f\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `promoPurchase(uint32,uint8,uint8,uint8,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 153,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15670,
        "code": "9e5ba;\n\n\n//EVENTS\n// @dev fired when a pixel's colour is changed\n    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n\n// @dev fired when a pixel's price is changed\n    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n\n// @dev fired when a pixel's text is changed\n    event TextChanged(uint pixelId, string textChanged);\n\n//@dev name for ERC-721\n    string constant public name = \"etherdoodle\";\n\n//@dev symbol for ERC-721\n    string constant public symbol = \"etherdoodle\";\n\n//@dev Starting pixel price\n    uint constant public startingPrice = 0.0025 ether;\n\n//@dev Total number of promo pixels\n    uint private constant PROMO_LIMIT = 1000;\n\n//@dev Switch from 3x to 1.5x per transaction\n    uint private constant stepAt = 0.24862 ether;\n\n//@dev The addresses of the accounts \n    address public ceoAddress;\n\n//@dev number of promo pixels purchased\n    uint public promoCount;\n\n//DATA STRUCTURES\n//@dev struct representation of a pixel\n    struct Pixel {\n        uint32 id;\n        uint8 colourR;\n        uint8 colourG;\n        uint8 colourB;\n        string pixelText;\n    }\n\n//@dev array holding all pixels\n    Pixel[1000000] public pixels;\n\n//MAPPINGS\n//@dev mapping from a pixel to its owner\n    mapping (uint => address) private pixelToOwner;\n\n//@dev mapping from owner to all of their pixels;\n    mapping (address => uint[]) private ownerToPixel;\n\n//@dev mapping from an address to the count of pixels\n    mapping (address => uint) private ownerPixelCount;\n\n//@dev mapping from a pixelId to the price of that pixel\n    mapping (uint => uint ) private pixelToPrice;\n\n//@dev mapping from a pixel to an approved account for transfer\n    mapping(uint => address) public pixelToApproved;\n\n//@dev mapping from an address to another mapping that determines if an operator is approved\n    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n\n//MODIFIERS\n//@dev access modifiers for ceo\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n//@dev used to verify ownership\n    modifier onlyOwnerOf(uint _pixelId) {\n        require(msg.sender == ownerOf(_pixelId));\n        _;\n    }\n\n//@dev used to allow operators to transfer and to manage the pixels\n    modifier canManageAndTransfer(uint _pixelId) {\n        require(isApprovedOrOwner(msg.sender, _pixelId));\n        _;\n    }\n\n//@dev make sure that the recipient address is notNull\n    modifier notNull(address _to) {\n        require(_to != address(0));\n        _;\n    }\n\n//Constructor\n    constructor () public {\n        ceoAddress = msg.sender;\n    }\n///////\n// External functions\n/////\n//@dev function to assign a new CEO\n    function assignCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n        ceoAddress = _newCEO;\n    }\n\n//@Update All a selected pixels details, can be done by the operator, or the owner\n    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n    external canManageAndTransfer(_pixelId) {\n        require(_price <= pixelToPrice[_pixelId]);\n        require(_price >= 0.0025 ether);\n        require(bytes(_text).length < 101);\n        bool colourChangedBool = false;\n        if(pixelToPrice[_pixelId] != _price){\n            pixelToPrice[_pixelId] = _price;\n            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n        }\n        if(pixels[_pixelId].colourR != _colourR){\n            pixels[_pixelId].colourR = _colourR;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourG != _colourG){\n            pixels[_pixelId].colourG = _colourG;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourB != _colourB){\n            pixels[_pixelId].colourB = _colourB;\n            colourChangedBool = true;\n        }\n        if (colourChangedBool){\n            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n        }\n        \n        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n            pixels[_pixelId].pixelText = _text;\n            emit TextChanged(_pixelId,_text);\n        }\n    }\n\n//@dev add an address to a pixel's approved list\n    function approve(address _to, uint _pixelId) public  {\n        address owner = ownerOf(_pixelId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n            pixelToApproved[_pixelId] = _to;\n            emit Approval(msg.sender, _to, _pixelId);\n        }\n        \n    }\n\n//@dev returns approved Addresses\n    function getApproved(uint _pixelId) public view returns(address){\n        return pixelToApproved[_pixelId];\n    }\n\n//@dev approve all an owner's pixels to be managed by an address\n    function setApprovalForAll(address _to,bool _approved) public{\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n \n\n///////////////////\n///Public functions\n///////////////////\n\n//@dev returns if a pixel has already been purchased\n    function exists(uint256 _pixelId) public view returns (bool) {\n        address owner = pixelToOwner[_pixelId];\n        return owner != address(0);\n    }\n\n//@dev returns if an address is approved to manage all another address' pixels\n    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n//@dev returns the number of pixels an address owns\n    function balanceOf(address _owner) public view returns (uint) {\n        return ownerPixelCount[_owner];\n    }\n\n\n//@dev returns the owner of a pixel\n    function ownerOf(uint _pixelId)  public view returns (address) {\n        address owner = pixelToOwner[_pixelId];\n        return owner;\n    }\n\n//@dev internal function to determine if its approved or an owner\n    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n        address owner = ownerOf(_pixelId);\n        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n    }\n\n//@dev internal function to remove approval on a pixel\n    function clearApproval(address _owner, uint256 _pixelId) internal {\n        require(ownerOf(_pixelId) == _owner);\n        if(pixelToApproved[_pixelId] != address(0)) {\n            pixelToApproved[_pixelId] = address(0);\n            emit Approval(_owner,address(0),_pixelId);\n        }\n    }\n\n//@dev returns the total number of pixels generated\n    function totalSupply() public view returns (uint) {\n        return pixels.length;\n    }\n\n//@dev ERC 721 transfer from\n    function transferFrom(address _from, address _to, uint _pixelId) public \n    canManageAndTransfer(_pixelId) {\n        require(_from != address(0));\n        require(_to != address(0));\n        clearApproval(_from,_pixelId);\n        _transfer(_from, _to, _pixelId);\n    }\n//@dev ERC 721 safeTransfer from functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n        safeTransferFrom(_from,_to,_pixelId,\"\");\n    }\n\n//@dev ERC 721 safeTransferFrom functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n        transferFrom(_from,_to,_pixelId);\n        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n    }\n\n//@dev TRANSFER\n    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n        _transfer(msg.sender, _to, _pixelId);\n    }\n\n//@dev returns all pixel's data\n    function getPixelData(uint _pixelId) public view returns \n    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n        Pixel storage pixel = pixels[_pixelId];\n        _id = pixel.id;\n        _price = getPixelPrice(_pixelId);\n        _owner = pixelToOwner[_pixelId];\n        _colourR = pixel.colourR;\n        _colourG = pixel.colourG;\n        _colourB = pixel.colourB;\n        _text = pixel.pixelText;\n    }\n\n//@dev Returns only Text\n    function getPixelText(uint _pixelId)public view returns(string) {\n        return pixels[_pixelId].pixelText;\n    }\n\n//@dev Returns the priceof a pixel\n    function getPixelPrice(uint _pixelId) public view returns(uint) {\n        uint price = pixelToPrice[_pixelId];\n        if (price != 0) {\n            return price;\n        } else {\n            return 1000000000000000;\n            }\n        \n    } \n\n    //@dev return the pixels owned by an address\n    function getPixelsOwned(address _owner) public view returns(uint[]) {\n        return ownerToPixel[_owner];\n    }\n\n    //@dev return number of pixels owned by an address\n    function getOwnerPixelCount(address _owner) public view returns(uint) {\n        return ownerPixelCount[_owner];\n    }\n\n    //@dev  return colour\n    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n        _colourR = pixels[_pixelId].colourR;\n        _colourG = pixels[_pixelId].colourG;\n        _colourB = pixels[_pixelId].colourB;\n    }\n\n    //@dev payout function to dev\n    function payout(address _to) public onlyCEO {\n        if (_to == address(0)) {\n            ceoAddress.transfer(address(this).balance);\n        } else {\n            _to.transfer(address(this).balance);\n        }  \n    }\n\n    //@dev purchase promo pixels that cost nothing at start\n    function promoPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text) public {\n        require(ownerOf(_pixelId) == (address(0)));\n        require(promoCount<PROMO_LIMIT);\n        require(bytes(_text).length < 101);\n        _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        _transfer(address(0),msg.sender,_pixelId);      \n        promoCount++;\n    }\n        \n    //@dev purchase multiple pixels at the same time\n    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n        require(bytes(_text).length < 101);\n        address newOwner = msg.sender;\n        uint totalPrice = 0;\n        uint excessValue = msg.value;\n        \n        for(uint i = 0; i < _Id.length; i++){\n            address oldOwner = ownerOf(_Id[i]);\n            require(ownerOf(_Id[i]) != newOwner);\n            require(!isInvulnerableByArea(_Id[i]));\n            \n            uint tempPrice = getPixelPrice(_Id[i]);\n            totalPrice = SafeMath.add(totalPrice,tempPrice);\n            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n           \n            if(i == _Id.length-1) {\n                require(msg.value >= totalPrice);\n                msg.sender.transfer(excessValue);\n                }   \n        }\n        \n    } \n\n    //@dev helper function for processing multiple purchases\n    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n        uint payment; // payment to previous owner\n        uint purchaseExcess; // excess purchase value\n        uint sellingPrice = getPixelPrice(_pixelId);\n        if(_oldOwner == address(0)) {\n            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        } else {\n            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n            purchaseExcess = SafeMath.sub(value,sellingPrice);\n            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n                _changeText(_pixelId,_text);\n            clearApproval(_oldOwner,_pixelId);\n        }\n        if(sellingPrice < stepAt) {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n        } else {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n        }\n        _transfer(_oldOwner, _newOwner,_pixelId);\n     \n        if(_oldOwner != address(this)) {\n            _oldOwner.transfer(payment); \n        }\n        return purchaseExcess;\n    }\n    \n    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n        pixels[_pixelId].colourR = _colourR;\n        pixels[_pixelId].colourG = _colourG;\n        pixels[_pixelId].colourB = _colourB;\n        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n    }\n    function _changeText(uint _pixelId, string _text) private{\n        require(bytes(_text).length < 101);\n        pixels[_pixelId].pixelText = _text;\n        emit TextChanged(_pixelId,_text);\n    }\n    \n\n//@dev Invulnerability logic check \n    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n        require(_pixelId >= 0 && _pixelId <= 999999);\n        if (ownerOf(_pixelId) == address(0)) {\n            return false;\n        }\n        uint256 counter = 0;\n \n        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n            return false;\n        }\n\n        if (_pixelId < 1000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnder(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnderRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1); \n            }\n            if (_checkPixelUnderLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAbove(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999 && _pixelId < 999000) {\n            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n                if (_pixelId%1000 == 0) {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                } else {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                }\n            } else {\n                if (_checkPixelAbove(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnder(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n            }\n        }\n        return counter >= 5;\n    }\n\n   \n\n   \n\n////////////////////\n///Private functions\n////////////////////\n//@dev create a pixel\n    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n        pixelToPrice[_id] = startingPrice;\n        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n        return _id;\n    }\n\n//@dev private function to transfer a pixel from an old address to a new one\n    function _transfer(address _from, address _to, uint _pixelId) private {\n  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n        ownerToPixel[_to].push(_pixelId);\n        if (_from != address(0)) {\n            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n                if (ownerToPixel[_from][i] == _pixelId) {\n                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n                }\n            }\n            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n        }\n        pixelToOwner[_pixelId] = _to;\n        emit Transfer(_from, _to, _pixelId);\n    }\n\n//@dev helper functions to check for if a pixel purchase is valid\n    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n            return true;\n        } else { \n            return false;\n        }\n    }\n    \n    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n            return true;\n        } else {  \n            return false; \n        }\n    }\n\n//@dev ERC721 compliance to check what address it is being sent to\n    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        _from, _pixelId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\ncalldata_etherdoodleToken_4: 0xf423f\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `promoPurchase(uint32,uint8,uint8,uint8,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 153,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15687,
        "code": "9e5ba;\n\n\n//EVENTS\n// @dev fired when a pixel's colour is changed\n    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n\n// @dev fired when a pixel's price is changed\n    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n\n// @dev fired when a pixel's text is changed\n    event TextChanged(uint pixelId, string textChanged);\n\n//@dev name for ERC-721\n    string constant public name = \"etherdoodle\";\n\n//@dev symbol for ERC-721\n    string constant public symbol = \"etherdoodle\";\n\n//@dev Starting pixel price\n    uint constant public startingPrice = 0.0025 ether;\n\n//@dev Total number of promo pixels\n    uint private constant PROMO_LIMIT = 1000;\n\n//@dev Switch from 3x to 1.5x per transaction\n    uint private constant stepAt = 0.24862 ether;\n\n//@dev The addresses of the accounts \n    address public ceoAddress;\n\n//@dev number of promo pixels purchased\n    uint public promoCount;\n\n//DATA STRUCTURES\n//@dev struct representation of a pixel\n    struct Pixel {\n        uint32 id;\n        uint8 colourR;\n        uint8 colourG;\n        uint8 colourB;\n        string pixelText;\n    }\n\n//@dev array holding all pixels\n    Pixel[1000000] public pixels;\n\n//MAPPINGS\n//@dev mapping from a pixel to its owner\n    mapping (uint => address) private pixelToOwner;\n\n//@dev mapping from owner to all of their pixels;\n    mapping (address => uint[]) private ownerToPixel;\n\n//@dev mapping from an address to the count of pixels\n    mapping (address => uint) private ownerPixelCount;\n\n//@dev mapping from a pixelId to the price of that pixel\n    mapping (uint => uint ) private pixelToPrice;\n\n//@dev mapping from a pixel to an approved account for transfer\n    mapping(uint => address) public pixelToApproved;\n\n//@dev mapping from an address to another mapping that determines if an operator is approved\n    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n\n//MODIFIERS\n//@dev access modifiers for ceo\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n//@dev used to verify ownership\n    modifier onlyOwnerOf(uint _pixelId) {\n        require(msg.sender == ownerOf(_pixelId));\n        _;\n    }\n\n//@dev used to allow operators to transfer and to manage the pixels\n    modifier canManageAndTransfer(uint _pixelId) {\n        require(isApprovedOrOwner(msg.sender, _pixelId));\n        _;\n    }\n\n//@dev make sure that the recipient address is notNull\n    modifier notNull(address _to) {\n        require(_to != address(0));\n        _;\n    }\n\n//Constructor\n    constructor () public {\n        ceoAddress = msg.sender;\n    }\n///////\n// External functions\n/////\n//@dev function to assign a new CEO\n    function assignCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n        ceoAddress = _newCEO;\n    }\n\n//@Update All a selected pixels details, can be done by the operator, or the owner\n    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n    external canManageAndTransfer(_pixelId) {\n        require(_price <= pixelToPrice[_pixelId]);\n        require(_price >= 0.0025 ether);\n        require(bytes(_text).length < 101);\n        bool colourChangedBool = false;\n        if(pixelToPrice[_pixelId] != _price){\n            pixelToPrice[_pixelId] = _price;\n            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n        }\n        if(pixels[_pixelId].colourR != _colourR){\n            pixels[_pixelId].colourR = _colourR;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourG != _colourG){\n            pixels[_pixelId].colourG = _colourG;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourB != _colourB){\n            pixels[_pixelId].colourB = _colourB;\n            colourChangedBool = true;\n        }\n        if (colourChangedBool){\n            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n        }\n        \n        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n            pixels[_pixelId].pixelText = _text;\n            emit TextChanged(_pixelId,_text);\n        }\n    }\n\n//@dev add an address to a pixel's approved list\n    function approve(address _to, uint _pixelId) public  {\n        address owner = ownerOf(_pixelId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n            pixelToApproved[_pixelId] = _to;\n            emit Approval(msg.sender, _to, _pixelId);\n        }\n        \n    }\n\n//@dev returns approved Addresses\n    function getApproved(uint _pixelId) public view returns(address){\n        return pixelToApproved[_pixelId];\n    }\n\n//@dev approve all an owner's pixels to be managed by an address\n    function setApprovalForAll(address _to,bool _approved) public{\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n \n\n///////////////////\n///Public functions\n///////////////////\n\n//@dev returns if a pixel has already been purchased\n    function exists(uint256 _pixelId) public view returns (bool) {\n        address owner = pixelToOwner[_pixelId];\n        return owner != address(0);\n    }\n\n//@dev returns if an address is approved to manage all another address' pixels\n    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n//@dev returns the number of pixels an address owns\n    function balanceOf(address _owner) public view returns (uint) {\n        return ownerPixelCount[_owner];\n    }\n\n\n//@dev returns the owner of a pixel\n    function ownerOf(uint _pixelId)  public view returns (address) {\n        address owner = pixelToOwner[_pixelId];\n        return owner;\n    }\n\n//@dev internal function to determine if its approved or an owner\n    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n        address owner = ownerOf(_pixelId);\n        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n    }\n\n//@dev internal function to remove approval on a pixel\n    function clearApproval(address _owner, uint256 _pixelId) internal {\n        require(ownerOf(_pixelId) == _owner);\n        if(pixelToApproved[_pixelId] != address(0)) {\n            pixelToApproved[_pixelId] = address(0);\n            emit Approval(_owner,address(0),_pixelId);\n        }\n    }\n\n//@dev returns the total number of pixels generated\n    function totalSupply() public view returns (uint) {\n        return pixels.length;\n    }\n\n//@dev ERC 721 transfer from\n    function transferFrom(address _from, address _to, uint _pixelId) public \n    canManageAndTransfer(_pixelId) {\n        require(_from != address(0));\n        require(_to != address(0));\n        clearApproval(_from,_pixelId);\n        _transfer(_from, _to, _pixelId);\n    }\n//@dev ERC 721 safeTransfer from functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n        safeTransferFrom(_from,_to,_pixelId,\"\");\n    }\n\n//@dev ERC 721 safeTransferFrom functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n        transferFrom(_from,_to,_pixelId);\n        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n    }\n\n//@dev TRANSFER\n    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n        _transfer(msg.sender, _to, _pixelId);\n    }\n\n//@dev returns all pixel's data\n    function getPixelData(uint _pixelId) public view returns \n    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n        Pixel storage pixel = pixels[_pixelId];\n        _id = pixel.id;\n        _price = getPixelPrice(_pixelId);\n        _owner = pixelToOwner[_pixelId];\n        _colourR = pixel.colourR;\n        _colourG = pixel.colourG;\n        _colourB = pixel.colourB;\n        _text = pixel.pixelText;\n    }\n\n//@dev Returns only Text\n    function getPixelText(uint _pixelId)public view returns(string) {\n        return pixels[_pixelId].pixelText;\n    }\n\n//@dev Returns the priceof a pixel\n    function getPixelPrice(uint _pixelId) public view returns(uint) {\n        uint price = pixelToPrice[_pixelId];\n        if (price != 0) {\n            return price;\n        } else {\n            return 1000000000000000;\n            }\n        \n    } \n\n    //@dev return the pixels owned by an address\n    function getPixelsOwned(address _owner) public view returns(uint[]) {\n        return ownerToPixel[_owner];\n    }\n\n    //@dev return number of pixels owned by an address\n    function getOwnerPixelCount(address _owner) public view returns(uint) {\n        return ownerPixelCount[_owner];\n    }\n\n    //@dev  return colour\n    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n        _colourR = pixels[_pixelId].colourR;\n        _colourG = pixels[_pixelId].colourG;\n        _colourB = pixels[_pixelId].colourB;\n    }\n\n    //@dev payout function to dev\n    function payout(address _to) public onlyCEO {\n        if (_to == address(0)) {\n            ceoAddress.transfer(address(this).balance);\n        } else {\n            _to.transfer(address(this).balance);\n        }  \n    }\n\n    //@dev purchase promo pixels that cost nothing at start\n    function promoPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text) public {\n        require(ownerOf(_pixelId) == (address(0)));\n        require(promoCount<PROMO_LIMIT);\n        require(bytes(_text).length < 101);\n        _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        _transfer(address(0),msg.sender,_pixelId);      \n        promoCount++;\n    }\n        \n    //@dev purchase multiple pixels at the same time\n    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n        require(bytes(_text).length < 101);\n        address newOwner = msg.sender;\n        uint totalPrice = 0;\n        uint excessValue = msg.value;\n        \n        for(uint i = 0; i < _Id.length; i++){\n            address oldOwner = ownerOf(_Id[i]);\n            require(ownerOf(_Id[i]) != newOwner);\n            require(!isInvulnerableByArea(_Id[i]));\n            \n            uint tempPrice = getPixelPrice(_Id[i]);\n            totalPrice = SafeMath.add(totalPrice,tempPrice);\n            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n           \n            if(i == _Id.length-1) {\n                require(msg.value >= totalPrice);\n                msg.sender.transfer(excessValue);\n                }   \n        }\n        \n    } \n\n    //@dev helper function for processing multiple purchases\n    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n        uint payment; // payment to previous owner\n        uint purchaseExcess; // excess purchase value\n        uint sellingPrice = getPixelPrice(_pixelId);\n        if(_oldOwner == address(0)) {\n            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        } else {\n            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n            purchaseExcess = SafeMath.sub(value,sellingPrice);\n            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n                _changeText(_pixelId,_text);\n            clearApproval(_oldOwner,_pixelId);\n        }\n        if(sellingPrice < stepAt) {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n        } else {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n        }\n        _transfer(_oldOwner, _newOwner,_pixelId);\n     \n        if(_oldOwner != address(this)) {\n            _oldOwner.transfer(payment); \n        }\n        return purchaseExcess;\n    }\n    \n    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n        pixels[_pixelId].colourR = _colourR;\n        pixels[_pixelId].colourG = _colourG;\n        pixels[_pixelId].colourB = _colourB;\n        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n    }\n    function _changeText(uint _pixelId, string _text) private{\n        require(bytes(_text).length < 101);\n        pixels[_pixelId].pixelText = _text;\n        emit TextChanged(_pixelId,_text);\n    }\n    \n\n//@dev Invulnerability logic check \n    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n        require(_pixelId >= 0 && _pixelId <= 999999);\n        if (ownerOf(_pixelId) == address(0)) {\n            return false;\n        }\n        uint256 counter = 0;\n \n        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n            return false;\n        }\n\n        if (_pixelId < 1000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnder(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnderRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1); \n            }\n            if (_checkPixelUnderLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAbove(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999 && _pixelId < 999000) {\n            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n                if (_pixelId%1000 == 0) {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                } else {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                }\n            } else {\n                if (_checkPixelAbove(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnder(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n            }\n        }\n        return counter >= 5;\n    }\n\n   \n\n   \n\n////////////////////\n///Private functions\n////////////////////\n//@dev create a pixel\n    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n        pixelToPrice[_id] = startingPrice;\n        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n        return _id;\n    }\n\n//@dev private function to transfer a pixel from an old address to a new one\n    function _transfer(address _from, address _to, uint _pixelId) private {\n  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n        ownerToPixel[_to].push(_pixelId);\n        if (_from != address(0)) {\n            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n                if (ownerToPixel[_from][i] == _pixelId) {\n                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n                }\n            }\n            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n        }\n        pixelToOwner[_pixelId] = _to;\n        emit Transfer(_from, _to, _pixelId);\n    }\n\n//@dev helper functions to check for if a pixel purchase is valid\n    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n            return true;\n        } else { \n            return false;\n        }\n    }\n    \n    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n            return true;\n        } else {  \n            return false; \n        }\n    }\n\n//@dev ERC721 compliance to check what address it is being sent to\n    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        _from, _pixelId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0x25\ncalldata_etherdoodleToken_4: 0xf423f\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `promoPurchase(uint32,uint8,uint8,uint8,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 153,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 15692,
        "code": "9e5ba;\n\n\n//EVENTS\n// @dev fired when a pixel's colour is changed\n    event ColourChanged(uint pixelId, uint8 colourR, uint8 colourG, uint8 colourB);\n\n// @dev fired when a pixel's price is changed\n    event PriceChanged(uint pixelId, uint oldPrice, uint newPrice);\n\n// @dev fired when a pixel's text is changed\n    event TextChanged(uint pixelId, string textChanged);\n\n//@dev name for ERC-721\n    string constant public name = \"etherdoodle\";\n\n//@dev symbol for ERC-721\n    string constant public symbol = \"etherdoodle\";\n\n//@dev Starting pixel price\n    uint constant public startingPrice = 0.0025 ether;\n\n//@dev Total number of promo pixels\n    uint private constant PROMO_LIMIT = 1000;\n\n//@dev Switch from 3x to 1.5x per transaction\n    uint private constant stepAt = 0.24862 ether;\n\n//@dev The addresses of the accounts \n    address public ceoAddress;\n\n//@dev number of promo pixels purchased\n    uint public promoCount;\n\n//DATA STRUCTURES\n//@dev struct representation of a pixel\n    struct Pixel {\n        uint32 id;\n        uint8 colourR;\n        uint8 colourG;\n        uint8 colourB;\n        string pixelText;\n    }\n\n//@dev array holding all pixels\n    Pixel[1000000] public pixels;\n\n//MAPPINGS\n//@dev mapping from a pixel to its owner\n    mapping (uint => address) private pixelToOwner;\n\n//@dev mapping from owner to all of their pixels;\n    mapping (address => uint[]) private ownerToPixel;\n\n//@dev mapping from an address to the count of pixels\n    mapping (address => uint) private ownerPixelCount;\n\n//@dev mapping from a pixelId to the price of that pixel\n    mapping (uint => uint ) private pixelToPrice;\n\n//@dev mapping from a pixel to an approved account for transfer\n    mapping(uint => address) public pixelToApproved;\n\n//@dev mapping from an address to another mapping that determines if an operator is approved\n    mapping(address => mapping(address=>bool)) internal operatorApprovals;\n\n//MODIFIERS\n//@dev access modifiers for ceo\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n//@dev used to verify ownership\n    modifier onlyOwnerOf(uint _pixelId) {\n        require(msg.sender == ownerOf(_pixelId));\n        _;\n    }\n\n//@dev used to allow operators to transfer and to manage the pixels\n    modifier canManageAndTransfer(uint _pixelId) {\n        require(isApprovedOrOwner(msg.sender, _pixelId));\n        _;\n    }\n\n//@dev make sure that the recipient address is notNull\n    modifier notNull(address _to) {\n        require(_to != address(0));\n        _;\n    }\n\n//Constructor\n    constructor () public {\n        ceoAddress = msg.sender;\n    }\n///////\n// External functions\n/////\n//@dev function to assign a new CEO\n    function assignCEO(address _newCEO) external onlyCEO {\n        require(_newCEO != address(0));\n        ceoAddress = _newCEO;\n    }\n\n//@Update All a selected pixels details, can be done by the operator, or the owner\n    function updateAllPixelDetails(uint _pixelId, uint8 _colourR, uint8 _colourG, uint8 _colourB,uint _price,string _text) \n    external canManageAndTransfer(_pixelId) {\n        require(_price <= pixelToPrice[_pixelId]);\n        require(_price >= 0.0025 ether);\n        require(bytes(_text).length < 101);\n        bool colourChangedBool = false;\n        if(pixelToPrice[_pixelId] != _price){\n            pixelToPrice[_pixelId] = _price;\n            emit PriceChanged(_pixelId,pixelToPrice[_pixelId],_price);\n        }\n        if(pixels[_pixelId].colourR != _colourR){\n            pixels[_pixelId].colourR = _colourR;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourG != _colourG){\n            pixels[_pixelId].colourG = _colourG;\n            colourChangedBool = true;\n        }\n        if(pixels[_pixelId].colourB != _colourB){\n            pixels[_pixelId].colourB = _colourB;\n            colourChangedBool = true;\n        }\n        if (colourChangedBool){\n            emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n        }\n        \n        if(keccak256(getPixelText(_pixelId)) != keccak256(_text) ){\n            pixels[_pixelId].pixelText = _text;\n            emit TextChanged(_pixelId,_text);\n        }\n    }\n\n//@dev add an address to a pixel's approved list\n    function approve(address _to, uint _pixelId) public  {\n        address owner = ownerOf(_pixelId);\n        require(_to != owner);\n        require(msg.sender == owner || isApprovedForAll(owner,msg.sender));\n        if(getApproved(_pixelId) != address(0) || _to != address(0)) {\n            pixelToApproved[_pixelId] = _to;\n            emit Approval(msg.sender, _to, _pixelId);\n        }\n        \n    }\n\n//@dev returns approved Addresses\n    function getApproved(uint _pixelId) public view returns(address){\n        return pixelToApproved[_pixelId];\n    }\n\n//@dev approve all an owner's pixels to be managed by an address\n    function setApprovalForAll(address _to,bool _approved) public{\n        require(_to != msg.sender);\n        operatorApprovals[msg.sender][_to] = _approved;\n        emit ApprovalForAll(msg.sender, _to, _approved);\n    }\n \n\n///////////////////\n///Public functions\n///////////////////\n\n//@dev returns if a pixel has already been purchased\n    function exists(uint256 _pixelId) public view returns (bool) {\n        address owner = pixelToOwner[_pixelId];\n        return owner != address(0);\n    }\n\n//@dev returns if an address is approved to manage all another address' pixels\n    function isApprovedForAll(address _owner, address _operator) public view returns(bool) {\n        return operatorApprovals[_owner][_operator];\n    }\n\n//@dev returns the number of pixels an address owns\n    function balanceOf(address _owner) public view returns (uint) {\n        return ownerPixelCount[_owner];\n    }\n\n\n//@dev returns the owner of a pixel\n    function ownerOf(uint _pixelId)  public view returns (address) {\n        address owner = pixelToOwner[_pixelId];\n        return owner;\n    }\n\n//@dev internal function to determine if its approved or an owner\n    function isApprovedOrOwner(address _spender, uint _pixelId)internal view returns (bool) {\n        address owner = ownerOf(_pixelId);\n        return(_spender == owner || getApproved(_pixelId) == _spender || isApprovedForAll(owner,_spender));\n    }\n\n//@dev internal function to remove approval on a pixel\n    function clearApproval(address _owner, uint256 _pixelId) internal {\n        require(ownerOf(_pixelId) == _owner);\n        if(pixelToApproved[_pixelId] != address(0)) {\n            pixelToApproved[_pixelId] = address(0);\n            emit Approval(_owner,address(0),_pixelId);\n        }\n    }\n\n//@dev returns the total number of pixels generated\n    function totalSupply() public view returns (uint) {\n        return pixels.length;\n    }\n\n//@dev ERC 721 transfer from\n    function transferFrom(address _from, address _to, uint _pixelId) public \n    canManageAndTransfer(_pixelId) {\n        require(_from != address(0));\n        require(_to != address(0));\n        clearApproval(_from,_pixelId);\n        _transfer(_from, _to, _pixelId);\n    }\n//@dev ERC 721 safeTransfer from functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId) public canManageAndTransfer(_pixelId){\n        safeTransferFrom(_from,_to,_pixelId,\"\");\n    }\n\n//@dev ERC 721 safeTransferFrom functions\n    function safeTransferFrom(address _from, address _to, uint _pixelId,bytes _data) public canManageAndTransfer(_pixelId){\n        transferFrom(_from,_to,_pixelId);\n        require(checkAndCallSafeTransfer(_from,_to,_pixelId,_data));\n    }\n\n//@dev TRANSFER\n    function transfer(address _to, uint _pixelId) public canManageAndTransfer(_pixelId) notNull(_to) {\n        _transfer(msg.sender, _to, _pixelId);\n    }\n\n//@dev returns all pixel's data\n    function getPixelData(uint _pixelId) public view returns \n    (uint32 _id, address _owner, uint8 _colourR, uint8 _colourG, uint8 _colourB, uint _price,string _text) {\n        Pixel storage pixel = pixels[_pixelId];\n        _id = pixel.id;\n        _price = getPixelPrice(_pixelId);\n        _owner = pixelToOwner[_pixelId];\n        _colourR = pixel.colourR;\n        _colourG = pixel.colourG;\n        _colourB = pixel.colourB;\n        _text = pixel.pixelText;\n    }\n\n//@dev Returns only Text\n    function getPixelText(uint _pixelId)public view returns(string) {\n        return pixels[_pixelId].pixelText;\n    }\n\n//@dev Returns the priceof a pixel\n    function getPixelPrice(uint _pixelId) public view returns(uint) {\n        uint price = pixelToPrice[_pixelId];\n        if (price != 0) {\n            return price;\n        } else {\n            return 1000000000000000;\n            }\n        \n    } \n\n    //@dev return the pixels owned by an address\n    function getPixelsOwned(address _owner) public view returns(uint[]) {\n        return ownerToPixel[_owner];\n    }\n\n    //@dev return number of pixels owned by an address\n    function getOwnerPixelCount(address _owner) public view returns(uint) {\n        return ownerPixelCount[_owner];\n    }\n\n    //@dev  return colour\n    function getPixelColour(uint _pixelId) public view returns (uint _colourR, uint _colourG, uint _colourB) {\n        _colourR = pixels[_pixelId].colourR;\n        _colourG = pixels[_pixelId].colourG;\n        _colourB = pixels[_pixelId].colourB;\n    }\n\n    //@dev payout function to dev\n    function payout(address _to) public onlyCEO {\n        if (_to == address(0)) {\n            ceoAddress.transfer(address(this).balance);\n        } else {\n            _to.transfer(address(this).balance);\n        }  \n    }\n\n    //@dev purchase promo pixels that cost nothing at start\n    function promoPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text) public {\n        require(ownerOf(_pixelId) == (address(0)));\n        require(promoCount<PROMO_LIMIT);\n        require(bytes(_text).length < 101);\n        _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        _transfer(address(0),msg.sender,_pixelId);      \n        promoCount++;\n    }\n        \n    //@dev purchase multiple pixels at the same time\n    function multiPurchase(uint32[] _Id, uint8[] _R,uint8[] _G,uint8[] _B,string _text) public payable {\n        require(_Id.length == _R.length && _Id.length == _G.length && _Id.length == _B.length);\n        require(bytes(_text).length < 101);\n        address newOwner = msg.sender;\n        uint totalPrice = 0;\n        uint excessValue = msg.value;\n        \n        for(uint i = 0; i < _Id.length; i++){\n            address oldOwner = ownerOf(_Id[i]);\n            require(ownerOf(_Id[i]) != newOwner);\n            require(!isInvulnerableByArea(_Id[i]));\n            \n            uint tempPrice = getPixelPrice(_Id[i]);\n            totalPrice = SafeMath.add(totalPrice,tempPrice);\n            excessValue = processMultiPurchase(_Id[i],_R[i],_G[i],_B[i],_text,oldOwner,newOwner,excessValue);\n           \n            if(i == _Id.length-1) {\n                require(msg.value >= totalPrice);\n                msg.sender.transfer(excessValue);\n                }   \n        }\n        \n    } \n\n    //@dev helper function for processing multiple purchases\n    function processMultiPurchase(uint32 _pixelId,uint8 _colourR,uint8 _colourG,uint8 _colourB,string _text, // solium-disable-line\n        address _oldOwner,address _newOwner,uint value) private returns (uint excess) {\n        uint payment; // payment to previous owner\n        uint purchaseExcess; // excess purchase value\n        uint sellingPrice = getPixelPrice(_pixelId);\n        if(_oldOwner == address(0)) {\n            purchaseExcess = uint(SafeMath.sub(value,startingPrice));\n            _createPixel((_pixelId), _colourR, _colourG, _colourB,_text);\n        } else {\n            payment = uint(SafeMath.div(SafeMath.mul(sellingPrice,95), 100));\n            purchaseExcess = SafeMath.sub(value,sellingPrice);\n            if(pixels[_pixelId].colourR != _colourR || pixels[_pixelId].colourG != _colourG || pixels[_pixelId].colourB != _colourB)\n                _changeColour(_pixelId,_colourR,_colourG,_colourB);\n            if(keccak256(getPixelText(_pixelId)) != keccak256(_text))\n                _changeText(_pixelId,_text);\n            clearApproval(_oldOwner,_pixelId);\n        }\n        if(sellingPrice < stepAt) {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,300),95);\n        } else {\n            pixelToPrice[_pixelId] = SafeMath.div(SafeMath.mul(sellingPrice,150),95);\n        }\n        _transfer(_oldOwner, _newOwner,_pixelId);\n     \n        if(_oldOwner != address(this)) {\n            _oldOwner.transfer(payment); \n        }\n        return purchaseExcess;\n    }\n    \n    function _changeColour(uint _pixelId,uint8 _colourR,uint8 _colourG, uint8 _colourB) private {\n        pixels[_pixelId].colourR = _colourR;\n        pixels[_pixelId].colourG = _colourG;\n        pixels[_pixelId].colourB = _colourB;\n        emit ColourChanged(_pixelId, _colourR, _colourG, _colourB);\n    }\n    function _changeText(uint _pixelId, string _text) private{\n        require(bytes(_text).length < 101);\n        pixels[_pixelId].pixelText = _text;\n        emit TextChanged(_pixelId,_text);\n    }\n    \n\n//@dev Invulnerability logic check \n    function isInvulnerableByArea(uint _pixelId) public view returns (bool) {\n        require(_pixelId >= 0 && _pixelId <= 999999);\n        if (ownerOf(_pixelId) == address(0)) {\n            return false;\n        }\n        uint256 counter = 0;\n \n        if (_pixelId == 0 || _pixelId == 999 || _pixelId == 999000 || _pixelId == 999999) {\n            return false;\n        }\n\n        if (_pixelId < 1000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnder(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelUnderRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1); \n            }\n            if (_checkPixelUnderLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999000) {\n            if (_checkPixelRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAbove(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveRight(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n            if (_checkPixelAboveLeft(_pixelId)) {\n                counter = SafeMath.add(counter, 1);\n            }\n        }\n\n        if (_pixelId > 999 && _pixelId < 999000) {\n            if (_pixelId%1000 == 0 || _pixelId%1000 == 999) {\n                if (_pixelId%1000 == 0) {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderRight(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                } else {\n                    if (_checkPixelAbove(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelAboveLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnder(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                    if (_checkPixelUnderLeft(_pixelId)) {\n                        counter = SafeMath.add(counter, 1);\n                    }\n                }\n            } else {\n                if (_checkPixelAbove(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelAboveRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnder(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelUnderLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelRight(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n                if (_checkPixelLeft(_pixelId)) {\n                    counter = SafeMath.add(counter, 1);\n                }\n            }\n        }\n        return counter >= 5;\n    }\n\n   \n\n   \n\n////////////////////\n///Private functions\n////////////////////\n//@dev create a pixel\n    function _createPixel (uint32 _id, uint8 _colourR, uint8 _colourG, uint8 _colourB, string _pixelText) private returns(uint) {\n        pixels[_id] = Pixel(_id, _colourR, _colourG, _colourB, _pixelText);\n        pixelToPrice[_id] = startingPrice;\n        emit ColourChanged(_id, _colourR, _colourG, _colourB);\n        return _id;\n    }\n\n//@dev private function to transfer a pixel from an old address to a new one\n    function _transfer(address _from, address _to, uint _pixelId) private {\n  //increment new owner pixel count and decrement old owner count and add a pixel to the owners array\n        ownerPixelCount[_to] = SafeMath.add(ownerPixelCount[_to], 1);\n        ownerToPixel[_to].push(_pixelId);\n        if (_from != address(0)) {\n            for (uint i = 0; i < ownerToPixel[_from].length; i++) {\n                if (ownerToPixel[_from][i] == _pixelId) {\n                    ownerToPixel[_from][i] = ownerToPixel[_from][ownerToPixel[_from].length-1];\n                    delete ownerToPixel[_from][ownerToPixel[_from].length-1];\n                }\n            }\n            ownerPixelCount[_from] = SafeMath.sub(ownerPixelCount[_from], 1);\n        }\n        pixelToOwner[_pixelId] = _to;\n        emit Transfer(_from, _to, _pixelId);\n    }\n\n//@dev helper functions to check for if a pixel purchase is valid\n    function _checkPixelAbove(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n    \n    function _checkPixelUnder(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1000)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-1001)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelUnderLeft(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+999)) {\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function _checkPixelAboveRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId-999)) {\n            return true;\n        } else { \n            return false;\n        }\n    }\n    \n    function _checkPixelUnderRight(uint _pixelId) private view returns (bool) {\n        if (ownerOf(_pixelId) == ownerOf(_pixelId+1001)) {\n            return true;\n        } else {  \n            return false; \n        }\n    }\n\n//@dev ERC721 compliance to check what address it is being sent to\n    function checkAndCallSafeTransfer(address _from, address _to, uint256 _pixelId, bytes _data)\n    internal\n    returns (bool)\n    {\n        if (!_to.isContract()) {\n            return true;\n        }\n        bytes4 retval = ERC721Receiver(_to).onERC721Received(\n        _from, _pixelId, _data);\n        return (retval == ERC721_RECEIVED);\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nkeccac_1_+\n2_+\n2*Concat(0,_Extract(31,_0,_calldata_etherdoodleToken_4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100)) +\n128: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\ncalldata_etherdoodleToken_4: 0xf423f\ncalldata_etherdoodleToken_4 + calldata_etherdoodleToken_32 + 100: 0x64\nstorage_1: 0x3e7\nstorage_keccac_4294967295_&_4294967295_&_calldata_etherdoodleToken_4: 0x0\ncalldata_etherdoodleToken_0: 0x6e5fe8500000000000000000000000000000000000000000000000000000000\ncalldatasize_etherdoodleToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `promoPurchase(uint32,uint8,uint8,uint8,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0xcf438fb35c4c7131e8846e4ccb5bec3ea60d7591.sol",
        "function": "promoPurchase(uint32,uint8,uint8,uint8,string)",
        "lineno": 153,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}