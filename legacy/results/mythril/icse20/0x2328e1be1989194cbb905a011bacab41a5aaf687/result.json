{
  "contract": "0x2328e1be1989194cbb905a011bacab41a5aaf687",
  "tool": "mythril",
  "start": 1563593727.4099674,
  "end": 1563594018.858958,
  "duration": 291.4489905834198,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 867,
        "code": "        // Do verification first\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            require(_values[i] > 0);\n            require(_values[i] <= balances[msg.sender].tokens[_tokenIds[i]].amount);\n        }\n\n        // Transfer every type of token specified\n        for (i = 0; i < _tokenIds.length; i++) {\n            require(internalTransfer(msg.sender, _to, _tokenIds[i], _values[i]));\n            emit TokenTransfer(msg.sender, _to, _tokenIds[i], _values[i]);\n            emit Transfer(msg.sender, _to, _values[i]);\n        }\n    \n        return true; \n    }\n\n    /**\n    * @dev Transfers the given number of tokens regardless of how they are stamped\n    * @param _from address The address to transfer from\n    * @param _to address The address to transfer to\n    * @param _value uint256 The number of tokens to send\n    */\n    f",
        "debug": "calldata_TestCoin_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TestCoin_0: 0x1cb0d48100000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferTokens(address,uint256[],uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "transferTokens(address,uint256[],uint256[])",
        "lineno": 257,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1125,
        "code": " @param _to address The address to transfer tokens to\n    * @param _value unit256 The amount to be transferred\n    */\n    functio",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_TestCoin_0: 0x21cda79000000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `tokensOwned(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "tokensOwned(address)",
        "lineno": 206,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4531,
        "code": "mount to be transferred\n    */\n   ",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_TestCoin_0: 0x21cda79000000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `tokensOwned(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "tokensOwned(address)",
        "lineno": 207,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4533,
        "code": "mount to be transferred\n    */\n   ",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_TestCoin_0: 0x21cda79000000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `tokensOwned(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "tokensOwned(address)",
        "lineno": 207,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9044,
        "code": "\n            balances[_owner].tokens[lastCoin].index = index;\n     ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_TestCoin_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 129,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9137,
        "code": "[_owner].tokenIndex.length--;\n    ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x200\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffff7ffffffffffffffffffffffffffffffffe0004000000000000000000000\nstorage_1 + keccac_calldata_TestCoin_32_+_4: 0xfffff7ffffffffffffffffffffffffffffffffe0004000000000000000000000\ncalldata_TestCoin_32 + 68: 0x200\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0x200\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 131,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9610,
        "code": ";\n\n// File: deploy",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000000000000000000007fffffffffffffffffffffeffc00e122\ncalldata_TestCoin_32 + 68: 0x3440c40000000000000000008000000080000000000000000400000000010004\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xaa86c37f7c000000000000007fffffffffffffffffffffffffffffebdffffec2\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_0 + keccac_calldata_TestCoin_32_+_36: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `mintTransfer(address,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9644,
        "code": "token\n        balances[_owner].tokens[_token",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_TestCoin_32 + 68: 0x0\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffeffffffffffffffffffe\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_0 + keccac_calldata_TestCoin_32_+_36: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `mintTransfer(address,uint256,uint256,uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 111,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 10133,
        "code": " a);\n        r",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe67b7fffe7fe00000001606170202020e000076e0001fe07dc\ncalldata_TestCoin_32 + 36: 0x200000000000000000002008200808082000008000002000800\nstorage_0 + keccac_calldata_TestCoin_4: 0x200000000000000000002008200808082000008000002000800\ncalldata_TestCoin_0: 0x6d0e5c0300000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "_function_0x6d0e5c03",
        "lineno": 12,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10243,
        "code": "        } else {\n            ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TestCoin_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestCoin_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 293,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10441,
        "code": "ssert",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xf4e8e842fc6b98fbfdedfe07002a7bf35df67fff6d29d800000008070070ffd3\ncalldata_TestCoin_32 + 68: 0x66b26092b060a29950081c520a6803ae588677dc0d10904bde19726aaef4d791\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xaec0fb7d761db74b294d1fd4ea0023ad5d13e77c9da410e17e1bb783003ef110\nstorage_0 + keccac_calldata_TestCoin_32_+_36: 0xeee4def6f9e9575d6c75df99db4ffb4f4f9653b27c782a67908952ee84f6b316\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `mintTransfer(address,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 18,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10454,
        "code": "       return ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbff9c810b8e2e0bf3d1c46072b4102e67c8f41ab0e89840c324015d000038004\ncalldata_TestCoin_32 + 68: 0xa3f51410b8e20c00a2204502030000111825493a3e2ac5dc44c1558bf0452975\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xb433c5983dfc400065f00000000000000f73725542820de7322ab9bfc01b2bc3\nstorage_0 + keccac_calldata_TestCoin_32_+_36: 0xc2bc1410f862040028e3e8fbf9ffffec68af5322c593821e4d4011cb45c45562\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 19,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10491,
        "code": "s track of allowances for particular address. - ERC20 Method\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    event TokenTransfer (address indexed from, address indexed to, uint256 tokenId, uint256 value);\n    event MintTransfer  (address indexed from, address indexed to, uint256 originalTokenId, uint256 tokenId, uint256 value);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * The constructor for the TestCoin token\n    */\n    function TestCoin() public {\n        owner = 0x8aBF67F3d00091FA2C6D7abBe0de891311111111;\n        name = \"TestCoinFC\";\n        symbol = \"TCFC\";\n        decimals = 4;\n        \n        // Total supply is one billion tokens\n        totalSupply = 6e8 * uint256(10) ** decimals; \n\n        // Add the owner to the stamping whitelist\n        stampingWhitelist[owner] = true;\n\n        // Initially give all of the tokens to the owner\n        addToken(owner, 0, totalSupply);\n    }\n\n    /** ERC 20\n    * @dev Retrieves the balance of a specified address\n    * @param _owner address The address to query the balance of.\n    * @return A uint256 representing the amount owned by the _owner\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return ownershipCount[_owner];\n    }\n\n    /**\n    * @dev Retrieves the balance of a specified address for a specific token\n    * @param _owner address The address to query the balance of\n    * @param _tokenId uint256 The token being queried\n    * @return A uint256 representing the amount owned by the _owner\n    */\n    function balanceOfToken(address _owner, uint256 _tokenId) public view returns (uint256 balance) {\n        return balances[_owner].tokens[_tokenId].amount;\n    }\n\n    /**\n    * @dev Returns all of the tokens owned by a particular address\n    * @param _owner address The address to query\n    * @return A uint256 array representing the tokens owned\n    */\n    function tokensOwned(address _owner) public view returns (uint256[] tokens) {\n        return balances[_owner].tokenIndex;\n    }\n\n    /** ERC 20\n    * @dev Transfers tokens to a specific address\n    * @param _to address The address to transfer tokens to\n    * @param _value unit256 The amount to be transferred\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= totalSupply);\n        require(_value <= ownershipCount[msg.sender]);\n\n        // Cast the value as the ERC20 standard uses uint256\n        uint256 _tokensToTransfer = uint256(_value);\n\n        // Do the transfer\n        require(transferAny(msg.sender, _to, _tokensToTransfer));\n\n        // Notify that a transfer has occurred\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n    * @dev Transfer a specific kind of token to another address\n    * @param _to address The address to transfer to\n    * @param _tokenId address The type of token to transfer\n    * @param _value uint256 The number of tokens to transfer\n    */\n    function transferToken(address _to, uint256 _tokenId, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender].tokens[_tokenId].amount);\n        \n        // Do the transfer\n        internalTransfer(msg.sender, _to, _tokenId, _value);\n        \n        // Notify that a transfer happened\n        emit TokenTransfer(msg.sender, _to, _tokenId, _value);\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n    * @dev Transfer a list of token kinds and values to another address\n    * @param _to address The address to transfer to\n    * @param _tokenIds uint256[] The list of tokens to transfer\n    * @param _values uint256[] The list of amounts to transfer\n    */\n    function transferTokens(address _to, uint256[] _tokenIds, uint256[] _values) public returns (bool) {\n        require(_to != address(0));\n        require(_tokenIds.length == _values.length);\n        require(_tokenIds.length < 100); // Arbitrary limit\n\n        // Do verification first\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            require(_values[i] > 0);\n            require(_values[i] <= balances[msg.sender].tokens[_tokenIds[i]].amount);\n        }\n\n        // Transfer every type of token specified\n        for (i = 0; i < _tokenIds.length; i++) {\n            require(internalTransfer(msg.sender, _to, _tokenIds[i], _values[i]));\n            emit TokenTransfer(msg.sender, _to, _tokenIds[i], _values[i]);\n            emit Transfer(msg.sender, _to, _values[i]);\n        }\n    \n        return true; \n    }\n\n    /**\n    * @dev Transfers the given number of tokens regardless of how they are stamped\n    * @param _from address The address to transfer from\n    * @param _to address The address to transfer to\n    * @param _value uint256 The number of tokens to send\n    */\n    function transferAny(address _from, address _to, uint256 _value) private returns (bool) {\n        // Iterate through all of the tokens owned, and transfer either the\n        // current balance of that token, or the remaining total amount to be \n        // transferred (`_value`), whichever is smaller. Because tokens are completely removed \n        // as their balances reach 0, we just run the loop until we have transferred all \n        // of the tokens we need to\n        uint256 _tokensToTransfer = _value;\n        while (_tokensToTransfer > 0) {\n            uint256 tokenId = balances[_from].tokenIndex[0];\n            uint256 tokenBalance = balances[_from].tokens[tokenId].amount;\n\n            if (tokenBalance >= _tokensToTransfer) {\n                require(internalTransfer(_from, _to, tokenId, _tokensToTransfer));\n                _tokensToTransfer = 0;\n            } else {\n                _tokensToTransfer = _tokensToTransfer - tokenBalance;\n                require(internalTransfer(_from, _to, tokenId, tokenBalance));\n            }\n        }\n\n        return true;\n    }\n\n    /**\n    * Internal function for transferring a specific type of token\n    */\n    function internalTransfer(address _from, address _to, uint256 _tokenId, uint256 _value) private returns (bool) {\n        // Decrease the amount being sent first\n        removeToken(_from, _tokenId, _value);\n\n        // Increase receivers token balances\n        addToken(_to, _tokenId, _value);\n\n        return true;\n    }\n\n    /** ERC 20\n    * @dev Transfer on behalf of another address\n    * @param _from address The address to send tokens from\n    * @param _to address The address to send tokens to\n    * @param _value uint256 The amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= ownershipCount[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        // Get the uint256 version of value\n        uint256 _castValue = uint256(_value);\n\n        // Decrease the spending limit\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        // Actually perform the transfer\n        require(transferAny(_from, _to, _castValue));\n\n        // Notify that a transfer has occurred\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n    * @dev Transfer and stamp tokens from a mint in one step\n    * @param _to address To send the tokens to\n    * @param _tokenToStamp uint256 The token to stamp (0 is unstamped tokens)\n    * @param _stamp uint256 The new stamp to apply\n    * @param _amount uint256 The number of tokens to stamp and transfer\n    */\n    function mintTransfer(address _to, uint256 _tokenToStamp, uint256 _stamp, uint256 _amount) public \n        onlyStampingWhitelisted returns (bool) {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender].tokens[_tokenToStamp].amount);\n\n        // Decrease the amount being sent first\n        removeToken(msg.sender, _tokenToStamp, _amount);\n\n        // Increase receivers token balances\n        addToken(_to, _stamp, _amount);\n\n        emit MintTransfer(msg.sender, _to, _tokenToStamp, _stamp, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Add an address to the whitelist\n     * @param _addr address The address to add\n     */\n    function addToWhitelist(address _addr) public\n        onlyOwner {\n        stampingWhitelist[_addr] = true;\n    }\n\n    /**\n     * @dev Remove an address from the whitelist\n     * @param _addr address The address to remove\n     */\n    function removeFromWhitelist(address _addr) public\n        onlyOwner {\n        stampingWhitelist[_addr] = false;\n    }\n\n    /** ERC 20\n    * @dev Approve sent address to spend the specified amount of tokens on\n    * behalf of msg.sender\n    *\n    * See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * for any potential security concerns\n    *\n    * @param _spender address The address that will spend funds\n    * @param _value uint256 The number of tokens they are allowed to spend\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(allowed[msg.sender][_spender] == 0);\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /** ERC 20\n    * @dev Returns the amount a spender is allowed to spend for a particular\n    * address\n    * @param _owner address The address which owns the funds\n    * @param _spender address The address which will spend the funds.\n    * @return uint256 The number of tokens still available for the spender\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /** ERC 20\n    * @dev Increases the number of tokens a spender is allowed to spend for\n    * `msg.sender`\n    * @param _spender address The address of the spender\n    * @param _addedValue uint256 The amount to increase the spenders approval by\n    */\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /** ERC 20\n    * @dev Decreases the number of tokens a spender is allowed to spend for\n    * `msg.sender`\n    * @param _spender address The address of the spender\n    * @param _subtractedValue uint256 The amount to decrease the spenders approval by\n    */\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n        uint _value = allowed[msg.sender][_spender];\n        if (_subtractedValue > _value) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = _value.sub(_subtractedValue);\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffbffffffffffffffffff\nkeccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8a4525145841ff18479ee501009eb20700c8bf9feffd9d97ffbffffff5107171\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x824113251e500058177efad397a800042205290c000001080008000000000000\nstorage_1 + keccac_calldata_TestCoin_32_+_4: 0x824113251e500058177efad397a800042205290c000001080007ffffffffffff\ncalldata_TestCoin_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffbffffffffffffffffff\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xfffffffffffffffffffffffffffffffffffffffffffffbffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `mintTransfer(address,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 146,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10493,
        "code": "s track of allowances for particular address. - ERC20 Method\n    mapping (address => mapping (address => uint256)) public allowed;\n\n    event TokenTransfer (address indexed from, address indexed to, uint256 tokenId, uint256 value);\n    event MintTransfer  (address indexed from, address indexed to, uint256 originalTokenId, uint256 tokenId, uint256 value);\n\n    modifier onlyOwner {\n        require(msg.sender == owner);\n        _;\n    }\n\n    /**\n    * The constructor for the TestCoin token\n    */\n    function TestCoin() public {\n        owner = 0x8aBF67F3d00091FA2C6D7abBe0de891311111111;\n        name = \"TestCoinFC\";\n        symbol = \"TCFC\";\n        decimals = 4;\n        \n        // Total supply is one billion tokens\n        totalSupply = 6e8 * uint256(10) ** decimals; \n\n        // Add the owner to the stamping whitelist\n        stampingWhitelist[owner] = true;\n\n        // Initially give all of the tokens to the owner\n        addToken(owner, 0, totalSupply);\n    }\n\n    /** ERC 20\n    * @dev Retrieves the balance of a specified address\n    * @param _owner address The address to query the balance of.\n    * @return A uint256 representing the amount owned by the _owner\n    */\n    function balanceOf(address _owner) public view returns (uint256 balance) {\n        return ownershipCount[_owner];\n    }\n\n    /**\n    * @dev Retrieves the balance of a specified address for a specific token\n    * @param _owner address The address to query the balance of\n    * @param _tokenId uint256 The token being queried\n    * @return A uint256 representing the amount owned by the _owner\n    */\n    function balanceOfToken(address _owner, uint256 _tokenId) public view returns (uint256 balance) {\n        return balances[_owner].tokens[_tokenId].amount;\n    }\n\n    /**\n    * @dev Returns all of the tokens owned by a particular address\n    * @param _owner address The address to query\n    * @return A uint256 array representing the tokens owned\n    */\n    function tokensOwned(address _owner) public view returns (uint256[] tokens) {\n        return balances[_owner].tokenIndex;\n    }\n\n    /** ERC 20\n    * @dev Transfers tokens to a specific address\n    * @param _to address The address to transfer tokens to\n    * @param _value unit256 The amount to be transferred\n    */\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= totalSupply);\n        require(_value <= ownershipCount[msg.sender]);\n\n        // Cast the value as the ERC20 standard uses uint256\n        uint256 _tokensToTransfer = uint256(_value);\n\n        // Do the transfer\n        require(transferAny(msg.sender, _to, _tokensToTransfer));\n\n        // Notify that a transfer has occurred\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n    * @dev Transfer a specific kind of token to another address\n    * @param _to address The address to transfer to\n    * @param _tokenId address The type of token to transfer\n    * @param _value uint256 The number of tokens to transfer\n    */\n    function transferToken(address _to, uint256 _tokenId, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= balances[msg.sender].tokens[_tokenId].amount);\n        \n        // Do the transfer\n        internalTransfer(msg.sender, _to, _tokenId, _value);\n        \n        // Notify that a transfer happened\n        emit TokenTransfer(msg.sender, _to, _tokenId, _value);\n        emit Transfer(msg.sender, _to, _value);\n\n        return true;\n    }\n\n    /**\n    * @dev Transfer a list of token kinds and values to another address\n    * @param _to address The address to transfer to\n    * @param _tokenIds uint256[] The list of tokens to transfer\n    * @param _values uint256[] The list of amounts to transfer\n    */\n    function transferTokens(address _to, uint256[] _tokenIds, uint256[] _values) public returns (bool) {\n        require(_to != address(0));\n        require(_tokenIds.length == _values.length);\n        require(_tokenIds.length < 100); // Arbitrary limit\n\n        // Do verification first\n        for (uint i = 0; i < _tokenIds.length; i++) {\n            require(_values[i] > 0);\n            require(_values[i] <= balances[msg.sender].tokens[_tokenIds[i]].amount);\n        }\n\n        // Transfer every type of token specified\n        for (i = 0; i < _tokenIds.length; i++) {\n            require(internalTransfer(msg.sender, _to, _tokenIds[i], _values[i]));\n            emit TokenTransfer(msg.sender, _to, _tokenIds[i], _values[i]);\n            emit Transfer(msg.sender, _to, _values[i]);\n        }\n    \n        return true; \n    }\n\n    /**\n    * @dev Transfers the given number of tokens regardless of how they are stamped\n    * @param _from address The address to transfer from\n    * @param _to address The address to transfer to\n    * @param _value uint256 The number of tokens to send\n    */\n    function transferAny(address _from, address _to, uint256 _value) private returns (bool) {\n        // Iterate through all of the tokens owned, and transfer either the\n        // current balance of that token, or the remaining total amount to be \n        // transferred (`_value`), whichever is smaller. Because tokens are completely removed \n        // as their balances reach 0, we just run the loop until we have transferred all \n        // of the tokens we need to\n        uint256 _tokensToTransfer = _value;\n        while (_tokensToTransfer > 0) {\n            uint256 tokenId = balances[_from].tokenIndex[0];\n            uint256 tokenBalance = balances[_from].tokens[tokenId].amount;\n\n            if (tokenBalance >= _tokensToTransfer) {\n                require(internalTransfer(_from, _to, tokenId, _tokensToTransfer));\n                _tokensToTransfer = 0;\n            } else {\n                _tokensToTransfer = _tokensToTransfer - tokenBalance;\n                require(internalTransfer(_from, _to, tokenId, tokenBalance));\n            }\n        }\n\n        return true;\n    }\n\n    /**\n    * Internal function for transferring a specific type of token\n    */\n    function internalTransfer(address _from, address _to, uint256 _tokenId, uint256 _value) private returns (bool) {\n        // Decrease the amount being sent first\n        removeToken(_from, _tokenId, _value);\n\n        // Increase receivers token balances\n        addToken(_to, _tokenId, _value);\n\n        return true;\n    }\n\n    /** ERC 20\n    * @dev Transfer on behalf of another address\n    * @param _from address The address to send tokens from\n    * @param _to address The address to send tokens to\n    * @param _value uint256 The amount of tokens to be transferred\n    */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        require(_to != address(0));\n        require(_value <= ownershipCount[_from]);\n        require(_value <= allowed[_from][msg.sender]);\n\n        // Get the uint256 version of value\n        uint256 _castValue = uint256(_value);\n\n        // Decrease the spending limit\n        allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\n        // Actually perform the transfer\n        require(transferAny(_from, _to, _castValue));\n\n        // Notify that a transfer has occurred\n        emit Transfer(_from, _to, _value);\n\n        return true;\n    }\n\n    /**\n    * @dev Transfer and stamp tokens from a mint in one step\n    * @param _to address To send the tokens to\n    * @param _tokenToStamp uint256 The token to stamp (0 is unstamped tokens)\n    * @param _stamp uint256 The new stamp to apply\n    * @param _amount uint256 The number of tokens to stamp and transfer\n    */\n    function mintTransfer(address _to, uint256 _tokenToStamp, uint256 _stamp, uint256 _amount) public \n        onlyStampingWhitelisted returns (bool) {\n        require(_to != address(0));\n        require(_amount <= balances[msg.sender].tokens[_tokenToStamp].amount);\n\n        // Decrease the amount being sent first\n        removeToken(msg.sender, _tokenToStamp, _amount);\n\n        // Increase receivers token balances\n        addToken(_to, _stamp, _amount);\n\n        emit MintTransfer(msg.sender, _to, _tokenToStamp, _stamp, _amount);\n        emit Transfer(msg.sender, _to, _amount);\n\n        return true;\n    }\n\n    /**\n     * @dev Add an address to the whitelist\n     * @param _addr address The address to add\n     */\n    function addToWhitelist(address _addr) public\n        onlyOwner {\n        stampingWhitelist[_addr] = true;\n    }\n\n    /**\n     * @dev Remove an address from the whitelist\n     * @param _addr address The address to remove\n     */\n    function removeFromWhitelist(address _addr) public\n        onlyOwner {\n        stampingWhitelist[_addr] = false;\n    }\n\n    /** ERC 20\n    * @dev Approve sent address to spend the specified amount of tokens on\n    * behalf of msg.sender\n    *\n    * See https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    * for any potential security concerns\n    *\n    * @param _spender address The address that will spend funds\n    * @param _value uint256 The number of tokens they are allowed to spend\n    */\n    function approve(address _spender, uint256 _value) public returns (bool) {\n        require(allowed[msg.sender][_spender] == 0);\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    /** ERC 20\n    * @dev Returns the amount a spender is allowed to spend for a particular\n    * address\n    * @param _owner address The address which owns the funds\n    * @param _spender address The address which will spend the funds.\n    * @return uint256 The number of tokens still available for the spender\n    */\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n\n    /** ERC 20\n    * @dev Increases the number of tokens a spender is allowed to spend for\n    * `msg.sender`\n    * @param _spender address The address of the spender\n    * @param _addedValue uint256 The amount to increase the spenders approval by\n    */\n    function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) {\n        allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue);\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    /** ERC 20\n    * @dev Decreases the number of tokens a spender is allowed to spend for\n    * `msg.sender`\n    * @param _spender address The address of the spender\n    * @param _subtractedValue uint256 The amount to decrease the spenders approval by\n    */\n    function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) {\n        uint _value = allowed[msg.sender][_spender];\n        if (_subtractedValue > _value) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = _value.sub(_subtractedValue);\n        }\n\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffe0000000000000000000000000000000\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x10000000000000000000000000000000000000000000000\nstorage_1 + keccac_calldata_TestCoin_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TestCoin_0: 0x73b423d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestCoin: 0x4\nstorage_0 + keccac_calldata_TestCoin_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `mintTransfer(address,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0x2328e1be1989194cbb905a011bacab41a5aaf687.sol",
        "function": "mintTransfer(address,uint256,uint256,uint256)",
        "lineno": 146,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}