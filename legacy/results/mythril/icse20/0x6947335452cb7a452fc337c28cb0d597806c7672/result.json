{
  "contract": "0x6947335452cb7a452fc337c28cb0d597806c7672",
  "tool": "mythril",
  "start": 1563638834.0322707,
  "end": 1563639584.9246857,
  "duration": 750.8924150466919,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 712,
        "code": "ned == false, \"Written contract ipfs hash can not be changed. Both spouses have already signed it!\");\n\n\t\t// Update written contract ipfs hash\n\t\twrittenContractIpfsHash = _writtenContractIpfsHash;\n\n\t\temit WrittenContractProposed(now, _writtenContractIpfsHash, msg.sender);\n\n\t\t// Revoke previous signatures\n\t\tif (hasSigned[husbandAddress] == true) {\n\t\t\thasSigned[husbandAddress] = false;\n\t\t}\n\t\tif (hasSigned[wifeAddress] == true) {\n\t\t\thasSigned[wifeAddress] = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sign the contract.\n\t */\n\tfunction signContract() external onlySpouse {\n\t\trequire(isSameString(writt",
        "debug": "calldata_SmartWeddingContract_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SmartWeddingContract_0: 0x1148da2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartWeddingContract: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `proposeWrittenContract(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x6947335452cb7a452fc337c28cb0d597806c7672.sol",
        "function": "proposeWrittenContract(string)",
        "lineno": 102,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 718,
        "code": "ned == false, \"Written contract ipfs hash can not be changed. Both spouses have already signed it!\");\n\n\t\t// Update written contract ipfs hash\n\t\twrittenContractIpfsHash = _writtenContractIpfsHash;\n\n\t\temit WrittenContractProposed(now, _writtenContractIpfsHash, msg.sender);\n\n\t\t// Revoke previous signatures\n\t\tif (hasSigned[husbandAddress] == true) {\n\t\t\thasSigned[husbandAddress] = false;\n\t\t}\n\t\tif (hasSigned[wifeAddress] == true) {\n\t\t\thasSigned[wifeAddress] = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sign the contract.\n\t */\n\tfunction signContract() external onlySpouse {\n\t\trequire(isSameString(writt",
        "debug": "calldata_SmartWeddingContract_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_SmartWeddingContract_0: 0x1148da2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartWeddingContract: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `proposeWrittenContract(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x6947335452cb7a452fc337c28cb0d597806c7672.sol",
        "function": "proposeWrittenContract(string)",
        "lineno": 102,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9793,
        "code": "fier that only allows",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SmartWeddingContract_4: 0x0\nstorage_6: 0x0\ncalldata_SmartWeddingContract_0: 0xcf35bdd000000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartWeddingContract: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0x6947335452cb7a452fc337c28cb0d597806c7672.sol",
        "function": "_function_0xcf35bdd0",
        "lineno": 46,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 14751,
        "code": " SmartWeddingContract {\n\tevent WrittenContractProposed(uint timestamp, string ipfsHash, address wallet);\n\tevent Signed(uint timestamp, address wallet);\n\tevent ContractSigned(uint timestamp);\n\tevent AssetProposed(uint timestamp, string asset, address wallet);\n\tevent AssetAddApproved(uint timestamp, string asset, address wallet);\n\tevent AssetAdded(uint timestamp, string asset);\n\tevent AssetRemoveApproved(uint timestamp, string asset, address wallet);\n\tevent AssetRemoved(uint timestamp, string asset);\n\tevent DivorceApproved(uint timestamp, address wallet);\n\tevent Divorced(uint timestamp);\n\tevent FundsSent(uint timestamp, address wallet, uint amount);\n\tevent FundsReceived(uint timestamp, address wallet, uint amount);\n\n\tbool public signed = false;\n\tbool public divorced = false;\n\n\tmapping (address => bool) private hasSigned;\n\tmapping (address => bool) private hasDivorced;\n\n\taddress public husbandAddress;\n\taddress public wifeAddress;\n\tstring public writtenContractIpfsHash;\n\n\tstruct Asset {\n\t\tstring data;\n\t\tuint husbandAllocation;\n\t\tuint wifeAllocation;\n\t\tbool added;\n\t\tbool removed;\n\t\tmapping (address => bool) hasApprovedAdd;\n\t\tmapping (address => bool) hasApprovedRemove;\n\t}\n\n\tAsset[] public assets;\n\n\t/**\n\t * @dev Modifier that only allows spouse execution.\n \t */\n\tmodifier onlySpouse() {\n\t\trequire(msg.sender == husbandAddress || msg.sender == wifeAddress, \"Sender is not a spouse!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that checks if the contract has been signed by both spouses.\n \t */\n\tmodifier isSigned() {\n\t\trequire(signed == true, \"Contract has not been signed by both spouses yet!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that only allows execution if the spouses have not been divorced.\n \t */\n\tmodifier isNotDivorced() {\n\t\trequire(divorced == false, \"Can not be called after spouses agreed to divorce!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Private helper function to check if a string is the same as another.\n\t */\n\tfunction isSameString(string memory string1, string memory string2) private pure returns (bool) {\n\t\treturn keccak256(abi.encodePacked(string1)) != keccak256(abi.encodePacked(string2));\n\t}\n\n\t/**\n\t * @dev Constructor: Set the wallet addresses of both spouses.\n\t * @param _husbandAddress Wallet address of the husband.\n\t * @param _wifeAddress Wallet address of the wife.\n\t */\n\tconstructor(address _husbandAddress, address _wifeAddress) public {\n\t\trequire(_husbandAddress != address(0), \"Husband address must not be zero!\");\n\t\trequire(_wifeAddress != address(0), \"Wife address must not be zero!\");\n\t\trequire(_husbandAddress != _wifeAddress, \"Husband address must not equal wife address!\");\n\n\t\thusbandAddress = _husbandAddress;\n\t\twifeAddress = _wifeAddress;\n\t}\n\n\t/**\n\t * @dev Default function to enable the contract to receive funds.\n \t */\n\tfunction() external payable isSigned isNotDivorced {\n\t\temit FundsReceived(now, msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @dev Propose a written contract (update).\n\t * @param _writtenContractIpfsHash IPFS hash of the written contract PDF.\n\t */\n\tfunction proposeWrittenContract(string _writtenContractIpfsHash) external onlySpouse {\n\t\trequire(signed == false, \"Written contract ipfs hash can not be changed. Both spouses have already signed it!\");\n\n\t\t// Update written contract ipfs hash\n\t\twrittenContractIpfsHash = _writtenContractIpfsHash;\n\n\t\temit WrittenContractProposed(now, _writtenContractIpfsHash, msg.sender);\n\n\t\t// Revoke previous signatures\n\t\tif (hasSigned[husbandAddress] == true) {\n\t\t\thasSigned[husbandAddress] = false;\n\t\t}\n\t\tif (hasSigned[wifeAddress] == true) {\n\t\t\thasSigned[wifeAddress] = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sign the contract.\n\t */\n\tfunction signContract() external onlySpouse {\n\t\trequire(isSameString(writtenContractIpfsHash, \"\"), \"Written contract ipfs hash has been proposed yet!\");\n\t\trequire(hasSigned[msg.sender] == false, \"Spouse has already signed the contract!\");\n\n\t\t// Sender signed\n\t\thasSigned[msg.sender] = true;\n\n\t\temit Signed(now, msg.sender);\n\n\t\t// Check if both spouses have signed\n\t\tif (hasSigned[husbandAddress] && hasSigned[wifeAddress]) {\n\t\t\tsigned = true;\n\t\t\temit ContractSigned(now);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Send ETH to a target address.\n\t * @param _to Destination wallet address.\n\t * @param _amount Amount of ETH to send.\n\t */\n\tfunction pay(address _to, uint _amount) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_to != address(0), \"Sending funds to address zero is prohibited!\");\n\t\trequire(_amount <= address(this).balance, \"Not enough balance available!\");\n\n\t\t// Send funds to the destination address\n\t\t_to.transfer(_amount);\n\n\t\temit FundsSent(now, _to, _amount);\n\t}\n\n\t/**\n\t * @dev Propose an asset to add. The other spouse needs to approve this action.\n\t * @param _data The asset represented as a string.\n\t * @param _husbandAllocation Allocation of the husband.\n\t * @param _wifeAllocation Allocation of the wife.\n\t */\n\tfunction proposeAsset(string _data, uint _husbandAllocation, uint _wifeAllocation) external onlySpouse isSigned isNotDivorced {\n\t\trequire(isSameString(_data, \"\"), \"No asset data provided!\");\n\t\trequire(_husbandAllocation >= 0, \"Husband allocation invalid!\");\n\t\trequire(_wifeAllocation >= 0, \"Wife allocation invalid!\");\n\t\trequire((_husbandAllocation + _wifeAllocation) == 100, \"Total allocation must be equal to 100%!\");\n\n\t\t// Add new asset\n\t\tAsset memory newAsset = Asset({\n\t\t\tdata: _data,\n\t\t\thusbandAllocation: _husbandAllocation,\n\t\t\twifeAllocation: _wifeAllocation,\n\t\t\tadded: false,\n\t\t\tremoved: false\n\t\t});\n\t\tuint newAssetId = assets.push(newAsset);\n\n\t\temit AssetProposed(now, _data, msg.sender);\n\n\t\t// Map to a storage object (otherwise mappings could not be accessed)\n\t\tAsset storage asset = assets[newAssetId - 1];\n\n\t\t// Instantly approve it by the sender\n\t\tasset.hasApprovedAdd[msg.sender] = true;\n\n\t\temit AssetAddApproved(now, _data, msg.sender);\n\t}\n\n\t/**\n\t * @dev Approve the addition of a prior proposed asset. The other spouse needs to approve this action.\n\t * @param _assetId The id of the asset that should be approved.\n\t */\n\tfunction approveAsset(uint _assetId) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_assetId > 0 && _assetId <= assets.length, \"Invalid asset id!\");\n\n\t\tAsset storage asset = assets[_assetId - 1];\n\n\t\trequire(asset.added == false, \"Asset has already been added!\");\n\t\trequire(asset.removed == false, \"Asset has already been removed!\");\n\t\trequire(asset.hasApprovedAdd[msg.sender] == false, \"Asset has already approved by sender!\");\n\n\t\t// Sender approved\n\t\tasset.hasApprovedAdd[msg.sender] = true;\n\n\t\temit AssetAddApproved(now, asset.data, msg.sender);\n\n\t\t// Check if both spouses have approved\n\t\tif (asset.hasApprovedAdd[husbandAddress] && asset.hasApprovedAdd[wifeAddress]) {\n\t\t\tasset.added = true;\n\t\t\temit AssetAdded(now, asset.data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Approve the removal of a prior proposed/already added asset. The other spouse needs to approve this action.\n\t * @param _assetId The id of the asset that should be removed.\n\t */\n\tfunction removeAsset(uint _assetId) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_assetId > 0 && _assetId <= assets.length, \"Invalid asset id!\");\n\n\t\tAsset storage asset = assets[_assetId - 1];\n\n\t\trequire(asset.added, \"Asset has not been added yet!\");\n\t\trequire(asset.removed == false, \"Asset has already been removed!\");\n\t\trequire(asset.hasApprovedRemove[msg.sender] == false, \"Removing the asset has already been approved by the sender!\");\n\n\t\t// Approve removal by the sender\n\t\tasset.hasApprovedRemove[msg.sender] = true;\n\n\t\temit AssetRemoveApproved(now, asset.data, msg.sender);\n\n\t\t// Check if both spouses have approved the removal of the asset\n\t\tif (asset.hasApprovedRemove[husbandAddress] && asset.hasApprovedRemove[wifeAddress]) {\n\t\t\tasset.removed = true;\n\t\t\temit AssetRemoved(now, asset.data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Request to divorce. The other spouse needs to approve this action.\n\t */\n\tfunction divorce() external onlySpouse isSigned isNotDivorced {\n\t\trequire(hasDivorced[msg.sender] == false, \"Sender has already approved to divorce!\");\n\n\t\t// Sender approved\n\t\thasDivorced[msg.sender] = true;\n\n\t\temit DivorceApproved(now, msg.sender);\n\n\t\t// Check if both spouses have approved to divorce\n\t\tif (hasDivorced[husbandAddress] && hasDivorced[wifeAddress]) {\n\t\t\tdivorced = true;\n\t\t\temit Divorced(now);\n\n\t\t\t// Get the contracts balance\n\t\t\tuint balance = address(this).balance;\n\n\t\t\t// Split the remaining balance half-half\n\t\t\tif (balance != 0) {\n\t\t\t\tuint balancePerSpouse = balance / 2;\n\n\t\t\t\t// Send transfer to the husband\n\t\t\t\thusbandAddress.transfer(balancePerSpouse);\n\t\t\t\temit FundsSent(now, husbandAddress, balancePerSpouse);\n\n\t\t\t\t// Send transfer to the wife\n\t\t\t\twifeAddress.transfer(balancePerSpouse);\n\t\t\t\temit FundsSent(now, wifeAddress, balancePerSpouse);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Return a list of all asset ids.\n\t */\n\tfunction getAssetIds() external view returns (uint[]) {\n\t\tuint assetCount = assets.length;\n\t\tuint[] memory assetIds = new uint[](assetCount);\n\n\t\t// Get all asset ids\n\t\tfor (uint i = 1; i <= assetCount; i++) { assetIds[i - 1] = i; }\n\n\t\treturn assetIds;\n\t}\n}",
        "debug": "calldata_SmartWeddingContract_4 + calldata_SmartWeddingContract_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\nstorage_4: 0x0\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_SmartWeddingContract_0: 0x1148da2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartWeddingContract: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `proposeWrittenContract(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x6947335452cb7a452fc337c28cb0d597806c7672.sol",
        "function": "proposeWrittenContract(string)",
        "lineno": 9,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 14765,
        "code": " SmartWeddingContract {\n\tevent WrittenContractProposed(uint timestamp, string ipfsHash, address wallet);\n\tevent Signed(uint timestamp, address wallet);\n\tevent ContractSigned(uint timestamp);\n\tevent AssetProposed(uint timestamp, string asset, address wallet);\n\tevent AssetAddApproved(uint timestamp, string asset, address wallet);\n\tevent AssetAdded(uint timestamp, string asset);\n\tevent AssetRemoveApproved(uint timestamp, string asset, address wallet);\n\tevent AssetRemoved(uint timestamp, string asset);\n\tevent DivorceApproved(uint timestamp, address wallet);\n\tevent Divorced(uint timestamp);\n\tevent FundsSent(uint timestamp, address wallet, uint amount);\n\tevent FundsReceived(uint timestamp, address wallet, uint amount);\n\n\tbool public signed = false;\n\tbool public divorced = false;\n\n\tmapping (address => bool) private hasSigned;\n\tmapping (address => bool) private hasDivorced;\n\n\taddress public husbandAddress;\n\taddress public wifeAddress;\n\tstring public writtenContractIpfsHash;\n\n\tstruct Asset {\n\t\tstring data;\n\t\tuint husbandAllocation;\n\t\tuint wifeAllocation;\n\t\tbool added;\n\t\tbool removed;\n\t\tmapping (address => bool) hasApprovedAdd;\n\t\tmapping (address => bool) hasApprovedRemove;\n\t}\n\n\tAsset[] public assets;\n\n\t/**\n\t * @dev Modifier that only allows spouse execution.\n \t */\n\tmodifier onlySpouse() {\n\t\trequire(msg.sender == husbandAddress || msg.sender == wifeAddress, \"Sender is not a spouse!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that checks if the contract has been signed by both spouses.\n \t */\n\tmodifier isSigned() {\n\t\trequire(signed == true, \"Contract has not been signed by both spouses yet!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that only allows execution if the spouses have not been divorced.\n \t */\n\tmodifier isNotDivorced() {\n\t\trequire(divorced == false, \"Can not be called after spouses agreed to divorce!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Private helper function to check if a string is the same as another.\n\t */\n\tfunction isSameString(string memory string1, string memory string2) private pure returns (bool) {\n\t\treturn keccak256(abi.encodePacked(string1)) != keccak256(abi.encodePacked(string2));\n\t}\n\n\t/**\n\t * @dev Constructor: Set the wallet addresses of both spouses.\n\t * @param _husbandAddress Wallet address of the husband.\n\t * @param _wifeAddress Wallet address of the wife.\n\t */\n\tconstructor(address _husbandAddress, address _wifeAddress) public {\n\t\trequire(_husbandAddress != address(0), \"Husband address must not be zero!\");\n\t\trequire(_wifeAddress != address(0), \"Wife address must not be zero!\");\n\t\trequire(_husbandAddress != _wifeAddress, \"Husband address must not equal wife address!\");\n\n\t\thusbandAddress = _husbandAddress;\n\t\twifeAddress = _wifeAddress;\n\t}\n\n\t/**\n\t * @dev Default function to enable the contract to receive funds.\n \t */\n\tfunction() external payable isSigned isNotDivorced {\n\t\temit FundsReceived(now, msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @dev Propose a written contract (update).\n\t * @param _writtenContractIpfsHash IPFS hash of the written contract PDF.\n\t */\n\tfunction proposeWrittenContract(string _writtenContractIpfsHash) external onlySpouse {\n\t\trequire(signed == false, \"Written contract ipfs hash can not be changed. Both spouses have already signed it!\");\n\n\t\t// Update written contract ipfs hash\n\t\twrittenContractIpfsHash = _writtenContractIpfsHash;\n\n\t\temit WrittenContractProposed(now, _writtenContractIpfsHash, msg.sender);\n\n\t\t// Revoke previous signatures\n\t\tif (hasSigned[husbandAddress] == true) {\n\t\t\thasSigned[husbandAddress] = false;\n\t\t}\n\t\tif (hasSigned[wifeAddress] == true) {\n\t\t\thasSigned[wifeAddress] = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sign the contract.\n\t */\n\tfunction signContract() external onlySpouse {\n\t\trequire(isSameString(writtenContractIpfsHash, \"\"), \"Written contract ipfs hash has been proposed yet!\");\n\t\trequire(hasSigned[msg.sender] == false, \"Spouse has already signed the contract!\");\n\n\t\t// Sender signed\n\t\thasSigned[msg.sender] = true;\n\n\t\temit Signed(now, msg.sender);\n\n\t\t// Check if both spouses have signed\n\t\tif (hasSigned[husbandAddress] && hasSigned[wifeAddress]) {\n\t\t\tsigned = true;\n\t\t\temit ContractSigned(now);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Send ETH to a target address.\n\t * @param _to Destination wallet address.\n\t * @param _amount Amount of ETH to send.\n\t */\n\tfunction pay(address _to, uint _amount) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_to != address(0), \"Sending funds to address zero is prohibited!\");\n\t\trequire(_amount <= address(this).balance, \"Not enough balance available!\");\n\n\t\t// Send funds to the destination address\n\t\t_to.transfer(_amount);\n\n\t\temit FundsSent(now, _to, _amount);\n\t}\n\n\t/**\n\t * @dev Propose an asset to add. The other spouse needs to approve this action.\n\t * @param _data The asset represented as a string.\n\t * @param _husbandAllocation Allocation of the husband.\n\t * @param _wifeAllocation Allocation of the wife.\n\t */\n\tfunction proposeAsset(string _data, uint _husbandAllocation, uint _wifeAllocation) external onlySpouse isSigned isNotDivorced {\n\t\trequire(isSameString(_data, \"\"), \"No asset data provided!\");\n\t\trequire(_husbandAllocation >= 0, \"Husband allocation invalid!\");\n\t\trequire(_wifeAllocation >= 0, \"Wife allocation invalid!\");\n\t\trequire((_husbandAllocation + _wifeAllocation) == 100, \"Total allocation must be equal to 100%!\");\n\n\t\t// Add new asset\n\t\tAsset memory newAsset = Asset({\n\t\t\tdata: _data,\n\t\t\thusbandAllocation: _husbandAllocation,\n\t\t\twifeAllocation: _wifeAllocation,\n\t\t\tadded: false,\n\t\t\tremoved: false\n\t\t});\n\t\tuint newAssetId = assets.push(newAsset);\n\n\t\temit AssetProposed(now, _data, msg.sender);\n\n\t\t// Map to a storage object (otherwise mappings could not be accessed)\n\t\tAsset storage asset = assets[newAssetId - 1];\n\n\t\t// Instantly approve it by the sender\n\t\tasset.hasApprovedAdd[msg.sender] = true;\n\n\t\temit AssetAddApproved(now, _data, msg.sender);\n\t}\n\n\t/**\n\t * @dev Approve the addition of a prior proposed asset. The other spouse needs to approve this action.\n\t * @param _assetId The id of the asset that should be approved.\n\t */\n\tfunction approveAsset(uint _assetId) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_assetId > 0 && _assetId <= assets.length, \"Invalid asset id!\");\n\n\t\tAsset storage asset = assets[_assetId - 1];\n\n\t\trequire(asset.added == false, \"Asset has already been added!\");\n\t\trequire(asset.removed == false, \"Asset has already been removed!\");\n\t\trequire(asset.hasApprovedAdd[msg.sender] == false, \"Asset has already approved by sender!\");\n\n\t\t// Sender approved\n\t\tasset.hasApprovedAdd[msg.sender] = true;\n\n\t\temit AssetAddApproved(now, asset.data, msg.sender);\n\n\t\t// Check if both spouses have approved\n\t\tif (asset.hasApprovedAdd[husbandAddress] && asset.hasApprovedAdd[wifeAddress]) {\n\t\t\tasset.added = true;\n\t\t\temit AssetAdded(now, asset.data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Approve the removal of a prior proposed/already added asset. The other spouse needs to approve this action.\n\t * @param _assetId The id of the asset that should be removed.\n\t */\n\tfunction removeAsset(uint _assetId) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_assetId > 0 && _assetId <= assets.length, \"Invalid asset id!\");\n\n\t\tAsset storage asset = assets[_assetId - 1];\n\n\t\trequire(asset.added, \"Asset has not been added yet!\");\n\t\trequire(asset.removed == false, \"Asset has already been removed!\");\n\t\trequire(asset.hasApprovedRemove[msg.sender] == false, \"Removing the asset has already been approved by the sender!\");\n\n\t\t// Approve removal by the sender\n\t\tasset.hasApprovedRemove[msg.sender] = true;\n\n\t\temit AssetRemoveApproved(now, asset.data, msg.sender);\n\n\t\t// Check if both spouses have approved the removal of the asset\n\t\tif (asset.hasApprovedRemove[husbandAddress] && asset.hasApprovedRemove[wifeAddress]) {\n\t\t\tasset.removed = true;\n\t\t\temit AssetRemoved(now, asset.data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Request to divorce. The other spouse needs to approve this action.\n\t */\n\tfunction divorce() external onlySpouse isSigned isNotDivorced {\n\t\trequire(hasDivorced[msg.sender] == false, \"Sender has already approved to divorce!\");\n\n\t\t// Sender approved\n\t\thasDivorced[msg.sender] = true;\n\n\t\temit DivorceApproved(now, msg.sender);\n\n\t\t// Check if both spouses have approved to divorce\n\t\tif (hasDivorced[husbandAddress] && hasDivorced[wifeAddress]) {\n\t\t\tdivorced = true;\n\t\t\temit Divorced(now);\n\n\t\t\t// Get the contracts balance\n\t\t\tuint balance = address(this).balance;\n\n\t\t\t// Split the remaining balance half-half\n\t\t\tif (balance != 0) {\n\t\t\t\tuint balancePerSpouse = balance / 2;\n\n\t\t\t\t// Send transfer to the husband\n\t\t\t\thusbandAddress.transfer(balancePerSpouse);\n\t\t\t\temit FundsSent(now, husbandAddress, balancePerSpouse);\n\n\t\t\t\t// Send transfer to the wife\n\t\t\t\twifeAddress.transfer(balancePerSpouse);\n\t\t\t\temit FundsSent(now, wifeAddress, balancePerSpouse);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Return a list of all asset ids.\n\t */\n\tfunction getAssetIds() external view returns (uint[]) {\n\t\tuint assetCount = assets.length;\n\t\tuint[] memory assetIds = new uint[](assetCount);\n\n\t\t// Get all asset ids\n\t\tfor (uint i = 1; i <= assetCount; i++) { assetIds[i - 1] = i; }\n\n\t\treturn assetIds;\n\t}\n}",
        "debug": "calldata_SmartWeddingContract_4: 0xda439b2041c8c00602000000000000000000000000000000000000000000001a\ncalldata_SmartWeddingContract_4 + calldata_SmartWeddingContract_4: 0x98b80124e0c0001a297fffffffffffffffffffffffffffffffffffffffffffc4\nstorage_0: 0x0\nstorage_4: 0x0\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_SmartWeddingContract_0: 0x1148da2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartWeddingContract: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `proposeWrittenContract(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x6947335452cb7a452fc337c28cb0d597806c7672.sol",
        "function": "proposeWrittenContract(string)",
        "lineno": 9,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 14782,
        "code": " SmartWeddingContract {\n\tevent WrittenContractProposed(uint timestamp, string ipfsHash, address wallet);\n\tevent Signed(uint timestamp, address wallet);\n\tevent ContractSigned(uint timestamp);\n\tevent AssetProposed(uint timestamp, string asset, address wallet);\n\tevent AssetAddApproved(uint timestamp, string asset, address wallet);\n\tevent AssetAdded(uint timestamp, string asset);\n\tevent AssetRemoveApproved(uint timestamp, string asset, address wallet);\n\tevent AssetRemoved(uint timestamp, string asset);\n\tevent DivorceApproved(uint timestamp, address wallet);\n\tevent Divorced(uint timestamp);\n\tevent FundsSent(uint timestamp, address wallet, uint amount);\n\tevent FundsReceived(uint timestamp, address wallet, uint amount);\n\n\tbool public signed = false;\n\tbool public divorced = false;\n\n\tmapping (address => bool) private hasSigned;\n\tmapping (address => bool) private hasDivorced;\n\n\taddress public husbandAddress;\n\taddress public wifeAddress;\n\tstring public writtenContractIpfsHash;\n\n\tstruct Asset {\n\t\tstring data;\n\t\tuint husbandAllocation;\n\t\tuint wifeAllocation;\n\t\tbool added;\n\t\tbool removed;\n\t\tmapping (address => bool) hasApprovedAdd;\n\t\tmapping (address => bool) hasApprovedRemove;\n\t}\n\n\tAsset[] public assets;\n\n\t/**\n\t * @dev Modifier that only allows spouse execution.\n \t */\n\tmodifier onlySpouse() {\n\t\trequire(msg.sender == husbandAddress || msg.sender == wifeAddress, \"Sender is not a spouse!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that checks if the contract has been signed by both spouses.\n \t */\n\tmodifier isSigned() {\n\t\trequire(signed == true, \"Contract has not been signed by both spouses yet!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Modifier that only allows execution if the spouses have not been divorced.\n \t */\n\tmodifier isNotDivorced() {\n\t\trequire(divorced == false, \"Can not be called after spouses agreed to divorce!\");\n\t\t_;\n\t}\n\n\t/**\n\t * @dev Private helper function to check if a string is the same as another.\n\t */\n\tfunction isSameString(string memory string1, string memory string2) private pure returns (bool) {\n\t\treturn keccak256(abi.encodePacked(string1)) != keccak256(abi.encodePacked(string2));\n\t}\n\n\t/**\n\t * @dev Constructor: Set the wallet addresses of both spouses.\n\t * @param _husbandAddress Wallet address of the husband.\n\t * @param _wifeAddress Wallet address of the wife.\n\t */\n\tconstructor(address _husbandAddress, address _wifeAddress) public {\n\t\trequire(_husbandAddress != address(0), \"Husband address must not be zero!\");\n\t\trequire(_wifeAddress != address(0), \"Wife address must not be zero!\");\n\t\trequire(_husbandAddress != _wifeAddress, \"Husband address must not equal wife address!\");\n\n\t\thusbandAddress = _husbandAddress;\n\t\twifeAddress = _wifeAddress;\n\t}\n\n\t/**\n\t * @dev Default function to enable the contract to receive funds.\n \t */\n\tfunction() external payable isSigned isNotDivorced {\n\t\temit FundsReceived(now, msg.sender, msg.value);\n\t}\n\n\t/**\n\t * @dev Propose a written contract (update).\n\t * @param _writtenContractIpfsHash IPFS hash of the written contract PDF.\n\t */\n\tfunction proposeWrittenContract(string _writtenContractIpfsHash) external onlySpouse {\n\t\trequire(signed == false, \"Written contract ipfs hash can not be changed. Both spouses have already signed it!\");\n\n\t\t// Update written contract ipfs hash\n\t\twrittenContractIpfsHash = _writtenContractIpfsHash;\n\n\t\temit WrittenContractProposed(now, _writtenContractIpfsHash, msg.sender);\n\n\t\t// Revoke previous signatures\n\t\tif (hasSigned[husbandAddress] == true) {\n\t\t\thasSigned[husbandAddress] = false;\n\t\t}\n\t\tif (hasSigned[wifeAddress] == true) {\n\t\t\thasSigned[wifeAddress] = false;\n\t\t}\n\t}\n\n\t/**\n\t * @dev Sign the contract.\n\t */\n\tfunction signContract() external onlySpouse {\n\t\trequire(isSameString(writtenContractIpfsHash, \"\"), \"Written contract ipfs hash has been proposed yet!\");\n\t\trequire(hasSigned[msg.sender] == false, \"Spouse has already signed the contract!\");\n\n\t\t// Sender signed\n\t\thasSigned[msg.sender] = true;\n\n\t\temit Signed(now, msg.sender);\n\n\t\t// Check if both spouses have signed\n\t\tif (hasSigned[husbandAddress] && hasSigned[wifeAddress]) {\n\t\t\tsigned = true;\n\t\t\temit ContractSigned(now);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Send ETH to a target address.\n\t * @param _to Destination wallet address.\n\t * @param _amount Amount of ETH to send.\n\t */\n\tfunction pay(address _to, uint _amount) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_to != address(0), \"Sending funds to address zero is prohibited!\");\n\t\trequire(_amount <= address(this).balance, \"Not enough balance available!\");\n\n\t\t// Send funds to the destination address\n\t\t_to.transfer(_amount);\n\n\t\temit FundsSent(now, _to, _amount);\n\t}\n\n\t/**\n\t * @dev Propose an asset to add. The other spouse needs to approve this action.\n\t * @param _data The asset represented as a string.\n\t * @param _husbandAllocation Allocation of the husband.\n\t * @param _wifeAllocation Allocation of the wife.\n\t */\n\tfunction proposeAsset(string _data, uint _husbandAllocation, uint _wifeAllocation) external onlySpouse isSigned isNotDivorced {\n\t\trequire(isSameString(_data, \"\"), \"No asset data provided!\");\n\t\trequire(_husbandAllocation >= 0, \"Husband allocation invalid!\");\n\t\trequire(_wifeAllocation >= 0, \"Wife allocation invalid!\");\n\t\trequire((_husbandAllocation + _wifeAllocation) == 100, \"Total allocation must be equal to 100%!\");\n\n\t\t// Add new asset\n\t\tAsset memory newAsset = Asset({\n\t\t\tdata: _data,\n\t\t\thusbandAllocation: _husbandAllocation,\n\t\t\twifeAllocation: _wifeAllocation,\n\t\t\tadded: false,\n\t\t\tremoved: false\n\t\t});\n\t\tuint newAssetId = assets.push(newAsset);\n\n\t\temit AssetProposed(now, _data, msg.sender);\n\n\t\t// Map to a storage object (otherwise mappings could not be accessed)\n\t\tAsset storage asset = assets[newAssetId - 1];\n\n\t\t// Instantly approve it by the sender\n\t\tasset.hasApprovedAdd[msg.sender] = true;\n\n\t\temit AssetAddApproved(now, _data, msg.sender);\n\t}\n\n\t/**\n\t * @dev Approve the addition of a prior proposed asset. The other spouse needs to approve this action.\n\t * @param _assetId The id of the asset that should be approved.\n\t */\n\tfunction approveAsset(uint _assetId) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_assetId > 0 && _assetId <= assets.length, \"Invalid asset id!\");\n\n\t\tAsset storage asset = assets[_assetId - 1];\n\n\t\trequire(asset.added == false, \"Asset has already been added!\");\n\t\trequire(asset.removed == false, \"Asset has already been removed!\");\n\t\trequire(asset.hasApprovedAdd[msg.sender] == false, \"Asset has already approved by sender!\");\n\n\t\t// Sender approved\n\t\tasset.hasApprovedAdd[msg.sender] = true;\n\n\t\temit AssetAddApproved(now, asset.data, msg.sender);\n\n\t\t// Check if both spouses have approved\n\t\tif (asset.hasApprovedAdd[husbandAddress] && asset.hasApprovedAdd[wifeAddress]) {\n\t\t\tasset.added = true;\n\t\t\temit AssetAdded(now, asset.data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Approve the removal of a prior proposed/already added asset. The other spouse needs to approve this action.\n\t * @param _assetId The id of the asset that should be removed.\n\t */\n\tfunction removeAsset(uint _assetId) external onlySpouse isSigned isNotDivorced {\n\t\trequire(_assetId > 0 && _assetId <= assets.length, \"Invalid asset id!\");\n\n\t\tAsset storage asset = assets[_assetId - 1];\n\n\t\trequire(asset.added, \"Asset has not been added yet!\");\n\t\trequire(asset.removed == false, \"Asset has already been removed!\");\n\t\trequire(asset.hasApprovedRemove[msg.sender] == false, \"Removing the asset has already been approved by the sender!\");\n\n\t\t// Approve removal by the sender\n\t\tasset.hasApprovedRemove[msg.sender] = true;\n\n\t\temit AssetRemoveApproved(now, asset.data, msg.sender);\n\n\t\t// Check if both spouses have approved the removal of the asset\n\t\tif (asset.hasApprovedRemove[husbandAddress] && asset.hasApprovedRemove[wifeAddress]) {\n\t\t\tasset.removed = true;\n\t\t\temit AssetRemoved(now, asset.data);\n\t\t}\n\t}\n\n\t/**\n\t * @dev Request to divorce. The other spouse needs to approve this action.\n\t */\n\tfunction divorce() external onlySpouse isSigned isNotDivorced {\n\t\trequire(hasDivorced[msg.sender] == false, \"Sender has already approved to divorce!\");\n\n\t\t// Sender approved\n\t\thasDivorced[msg.sender] = true;\n\n\t\temit DivorceApproved(now, msg.sender);\n\n\t\t// Check if both spouses have approved to divorce\n\t\tif (hasDivorced[husbandAddress] && hasDivorced[wifeAddress]) {\n\t\t\tdivorced = true;\n\t\t\temit Divorced(now);\n\n\t\t\t// Get the contracts balance\n\t\t\tuint balance = address(this).balance;\n\n\t\t\t// Split the remaining balance half-half\n\t\t\tif (balance != 0) {\n\t\t\t\tuint balancePerSpouse = balance / 2;\n\n\t\t\t\t// Send transfer to the husband\n\t\t\t\thusbandAddress.transfer(balancePerSpouse);\n\t\t\t\temit FundsSent(now, husbandAddress, balancePerSpouse);\n\n\t\t\t\t// Send transfer to the wife\n\t\t\t\twifeAddress.transfer(balancePerSpouse);\n\t\t\t\temit FundsSent(now, wifeAddress, balancePerSpouse);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * @dev Return a list of all asset ids.\n\t */\n\tfunction getAssetIds() external view returns (uint[]) {\n\t\tuint assetCount = assets.length;\n\t\tuint[] memory assetIds = new uint[](assetCount);\n\n\t\t// Get all asset ids\n\t\tfor (uint i = 1; i <= assetCount; i++) { assetIds[i - 1] = i; }\n\n\t\treturn assetIds;\n\t}\n}",
        "debug": "calldata_SmartWeddingContract_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c\ncalldata_SmartWeddingContract_4 + calldata_SmartWeddingContract_4: 0x21\nstorage_0: 0x0\nstorage_4: 0x0\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_SmartWeddingContract_0: 0x1148da2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SmartWeddingContract: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `proposeWrittenContract(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x6947335452cb7a452fc337c28cb0d597806c7672.sol",
        "function": "proposeWrittenContract(string)",
        "lineno": 9,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}