{
  "contract": "0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d",
  "tool": "mythril",
  "start": 1563555799.2732651,
  "end": 1563556810.4148214,
  "duration": 1011.14155626297,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 581,
        "code": "leVals;\n  }\n  function userWithdraw(uint256 _value) public{\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DTTtoken.tr",
        "debug": "calldata_NFTToken_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_NFTToken_0: 0x11affa5c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setEggTable(uint16,uint32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setEggTable(uint16,uint32[])",
        "lineno": 109,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 909,
        "code": " return a;\n  }\n  function getCloneArray(uint[] a) private pure returns(uint[]) {\n      return a;\n  }\n  function swap(uint[] a, uint l, uint r) private pure {\n      uin",
        "debug": "calldata_NFTToken_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_NFTToken_0: 0x1e1d237e00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x1e1d237e`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "_function_0x1e1d237e",
        "lineno": 153,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5520,
        "code": "Ttoken.approve(msg.sender, DTTtoken.allowance(this,ms",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 349,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5520,
        "code": "Ttoken.approve(msg.sender, DTTtoken.allowance(this,ms",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 5713\n",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 349,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 5520,
        "code": "Ttoken.approve(msg.sender, DTTtoken.allowance(this,ms",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function buyRareEgg(uint8,uint256,address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 349,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 5713,
        "code": "000000000 * 5 * bonus * _amount);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 10000000000 * 5 * bonus *",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 346,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5713,
        "code": "000000000 * 5 * bonus * _amount);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 10000000000 * 5 * bonus *",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function buyRareEgg(uint8,uint256,address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 346,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 6274,
        "code": "dMod(155) + 101) * 1000000000000;\n",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 353,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 6274,
        "code": "dMod(155) + 101) * 1000000000000;\n",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6467\n",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 353,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 6274,
        "code": "dMod(155) + 101) * 1000000000000;\n",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function buyRareEgg(uint8,uint256,address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 353,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 6467,
        "code": "0000000;\n      genes += (randMod(155) + 101) * 1000000000000;\n      genes += (randMod(155) + 101) * 1000000",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 352,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 6467,
        "code": "0000000;\n      genes += (randMod(155) + 101) * 1000000000000;\n      genes += (randMod(155) + 101) * 1000000",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function buyRareEgg(uint8,uint256,address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 352,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 6789,
        "code": "00000;\n      genes += (randMod(155)",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 355,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 6789,
        "code": "00000;\n      genes += (randMod(155)",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6982\n",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 355,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 6789,
        "code": "00000;\n      genes += (randMod(155)",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function buyRareEgg(uint8,uint256,address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 355,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 6982,
        "code": " += (randMod(155) + 101) * 1000000;\n      genes += (randMod(155) + 101) * 1000;\n      genes += randMod(155) +",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 355,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 6982,
        "code": " += (randMod(155) + 101) * 1000000;\n      genes += (randMod(155) + 101) * 1000;\n      genes += randMod(155) +",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function buyRareEgg(uint8,uint256,address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "buyRareEgg(uint8,uint256,address)",
        "lineno": 355,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 8761,
        "code": "nt256 genes;\n    uint256 hatchTime;\n    uint3",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "userWithdraw(uint256)",
        "lineno": 119,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 8761,
        "code": "nt256 genes;\n    uint256 hatchTime;\n    uint3",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function userWithdraw(uint256). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "userWithdraw(uint256)",
        "lineno": 119,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 9135,
        "code": "n uint(keccak256(now, msg",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_NFTToken_4: 0x0\nstorage_15: 0x0\ncalldata_NFTToken_0: 0x571a26a000000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "_function_0x571a26a0",
        "lineno": 143,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9483,
        "code": "skills);\n    return mo",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setNewMonster(uint256,uint32,address,string,string)",
        "lineno": 94,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 9483,
        "code": "skills);\n    return mo",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function setNewMonster(uint256,uint32,address,string,string). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setNewMonster(uint256,uint32,address,string,string)",
        "lineno": 94,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 19172,
        "code": "}\n      uint",
        "debug": "calldata_NFTToken_4 + calldata_NFTToken_4: 0x0\ncalldata_NFTToken_0: 0x1e1d237e00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `_function_0x1e1d237e`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "_function_0x1e1d237e",
        "lineno": 186,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 19590,
        "code": "    ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_NFTToken_0: 0x1e1d237e00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncalldata_NFTToken_4 + calldata_NFTToken_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "_function_0x1e1d237e",
        "lineno": 198,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 20065,
        "code": "256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event Hatch(address indexed _owner, uint16 _tableId);\n\n  address public thisAddress;\n  address public dragonTreasureToken;\n  address public databaseContract;\n  address public ERC721Contract;\n  uint256 public totalClass;\n  uint256 public totalMonster;\n  uint256 public totalAuction;\n  uint256 private increaseRate = 0.1 ether;\n  uint64 public cooldownTime = 2 hours;\n  mapping (address => address) public masterToReferral;\n  mapping (uint16 => uint32[]) private EggTable;\n  mapping (uint8 => uint256) public EggTotal;\n  function setNewMonster(uint256 _genes,uint32 _classId,address _master,string _name,string _skills) onlyModerators public returns(uint64 _monsterId) {\n    DataBase data = DataBase(databaseContract);\n    uint64 monsterId = data.getTotalMonster() + 1;\n    data.addMonsterObj(monsterId,_genes,_classId,_master,_name,_skills);\n    return monsterId;\n  }\n  function setMasterToReferral(address _master, address _referral) onlyOwner public{\n    masterToReferral[_master] = _referral;\n  }\n  function setEggTotal(uint8 _tableNum,uint256 _tableVal) onlyOwner public{\n    EggTotal[_tableNum] = _tableVal;\n  }\n  function setAddresses(address _dragonTreasureToken,address _databaseContract,address _ERC721Contract) onlyOwner public{\n    dragonTreasureToken = _dragonTreasureToken;\n    databaseContract = _databaseContract;\n    ERC721Contract = _ERC721Contract;\n  }\n  function setEggTable(uint16 _tableNum,uint32[] _tableVals) onlyOwner public{\n    EggTable[_tableNum] = _tableVals;\n  }\n  function userWithdraw(uint256 _value) public{\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DTTtoken.transferFrom(this,msg.sender,_value);\n  }\n\n  struct Egg {\n    uint8 tableId;\n    uint32 classId;\n    uint256 genes;\n    uint256 hatchTime;\n    uint32 matronId;\n    uint32 sireId;\n    uint16 generation;\n    address master;\n  }\n\n  struct Auction {\n    uint256 classId;\n    uint256 monsterId;\n    uint256 price;\n    uint256 endTime;\n    uint8 rarity;\n    address bidder;\n  }\n\n  Egg[] public eggs;\n  Auction[] public auctions;\n\n\n  uint randNonce = 0;\n  function randMod(uint _modulus) internal returns(uint) {\n    randNonce++;\n    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;\n  }\n\n  function setCooldown(uint64 _time) onlyOwner public{\n    cooldownTime = _time;\n  }\n\n  function getSortedArray(uint[] storageInt) public pure returns(uint[]) {\n      uint[] memory a = getCloneArray(storageInt);\n      quicksort(a);\n      return a;\n  }\n  function getCloneArray(uint[] a) private pure returns(uint[]) {\n      return a;\n  }\n  function swap(uint[] a, uint l, uint r) private pure {\n      uint t = a[l];\n      a[l] = a[r];\n      a[r] = t;\n  }\n  function getPivot(uint a, uint b, uint c) private pure returns(uint) {\n      if(a > b){\n          if(b > c){\n              return b;\n          }else{\n              return a > c ? c : a ;\n          }\n      }else{\n          if(a > c){\n              return a;\n          }else{\n              return b > c ? c : b ;\n          }\n      }\n  }\n  function quicksort(uint[] a) private pure {\n      uint left = 0;\n      uint right = a.length - 1;\n      quicksort_core(a, left, right);\n  }\n  function quicksort_core(uint[] a, uint left, uint right) private pure {\n      if(right <= left){\n          return;\n      }\n      uint l = left;\n      uint r = right;\n      uint p = getPivot(a[l], a[l+1], a[r]);\n      while(true){\n          while(a[l] < p){\n              l++;\n          }\n          while(p < a[r]){\n              r--;\n          }\n          if(r <= l){\n              break;\n          }\n          swap(a, l, r);\n          l++;\n          r--;\n      }\n      quicksort_core(a, left, l-1);\n      quicksort_core(a, r+1, right);\n  }\n\n  /* Withdraw */\n  /*\n    NOTICE: These functions withdraw the developer's cut which is left\n    in the contract by `buy`. User funds are immediately sent to the old\n    owner in `buy`, no user funds are left in the contract.\n  */\n  function withdrawAll () onlyOwner public {\n    msg.sender.transfer(this.balance);\n  }\n\n  function withdrawAmount (uint256 _amount) onlyOwner public {\n    msg.sender.transfer(_amount);\n  }\n\n\n  function addAuction(uint32 _classId, uint256 _monsterId, uint256 _price, uint8 _rarity, uint8 _endTime) onlyOwner public {\n    Auction memory auction = Auction({\n      classId: _classId,\n      monsterId: _monsterId,\n      price: _price,\n      rarity: _rarity,\n      endTime: 86400 * _endTime + now,\n      bidder: msg.sender\n    });\n    auctions.push(auction);\n    totalAuction += 1;\n  }\n\n  function burnAuction() onlyOwner external {\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n      if(auctions[i].endTime < now - 86400 * 3){\n        delete auctions[i];\n        counter++;\n      }\n    }\n    totalAuction -= counter;\n  }\n\n  /* Buying */\n\n  function ceil(uint a) public pure returns (uint ) {\n    return uint(int(a * 100) / 100);\n  }\n  /*\n     Buy a country directly from the contract for the calculated price\n     which ensures that the owner gets a profit.  All countries that\n     have been listed can be bought by this method. User funds are sent\n     directly to the previous owner and are never stored in the contract.\n  */\n  function setGenes(uint256 _price, uint256 _monsterId) internal{\n    DataBase data = DataBase(databaseContract);\n    uint256 gene = _price / 10000000000000000;\n    if(gene > 255)\n      gene = 255;\n    uint256 genes = 0;\n    genes += gene * 1000000000000000;\n    genes += gene * 1000000000000;\n    genes += gene * 1000000000;\n    genes += gene * 1000000;\n    genes += gene * 1000;\n    genes += gene;\n    if(genes > 255255255255255255)\n      genes = 255255255255255255;\n    data.setMonsterGene(uint64(_monsterId),genes);\n  }\n\n  function buy (uint256 _auctionId, address _referral) payable public {\n    NFTToken CNDERC721 = NFTToken(ERC721Contract);\n    require(auctions[_auctionId].endTime > now);\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != address(0));\n    require(ceil(msg.value) >= ceil(auctions[_auctionId].price + increaseRate));\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != msg.sender);\n    require(!isContract(msg.sender));\n    require(msg.sender != address(0));\n    address oldOwner = CNDERC721.ownerOf(auctions[_auctionId].monsterId);\n    address newOwner = msg.sender;\n    uint256 oldPrice = auctions[_auctionId].price;\n    uint256 price = ceil(msg.value);\n    setGenes(price,auctions[_auctionId].monsterId);\n    CNDERC721.transferAuction(oldOwner, newOwner, auctions[_auctionId].monsterId);\n    auctions[_auctionId].price = ceil(price);\n    auctions[_auctionId].bidder = msg.sender;\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 1000000000 * 5);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 1000000000 * 5);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 1000000000 * 5);\n    if(oldPrice > 0)\n      oldOwner.transfer(oldPrice);\n    Bought(auctions[_auctionId].monsterId, newOwner, price);\n    Sold(auctions[_auctionId].monsterId, oldOwner, price);\n  }\n\n  function buyBlueStarEgg(address _sender, uint256 _tokens, uint16 _amount) isActive public returns(uint256) {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = ceil(5 * 10**8);\n    if (_tokens < price)\n        revert();\n    DataBase data = DataBase(databaseContract);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(205) + 51) * 1000000000000000;\n      genes += (randMod(205) + 51) * 1000000000000;\n      genes += (randMod(205) + 51) * 1000000000;\n      genes += (randMod(205) + 51) * 1000000;\n      genes += (randMod(205) + 51) * 1000;\n      genes += randMod(205) + 51;\n      uint32 classId = EggTable[1][randMod(EggTable[1].length)];\n      EggTotal[1] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,_sender,\"\",\"\");\n    }\n    Hatch(msg.sender, 1);\n    return price * _amount;\n  }\n\n  function buyRareEgg(uint8 _table, uint _amount, address _referral) isActive payable public {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = 0.1 ether;\n    if(EggTotal[_table] > 0)\n    price += uint((int(EggTotal[_table] / 500) * 10**18) / 20);\n    require(msg.value >= price * _amount);\n\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DataBase data = DataBase(databaseContract);\n    uint256 bonus = 10;\n    if(_amount >= 10){\n      bonus = 12;\n    }\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 10000000000 * 5 * bonus * _amount);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 10000000000 * 5 * bonus * _amount);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 10000000000 * 5 * bonus * _amount);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(155) + 101) * 1000000000000000;\n      genes += (randMod(155) + 101) * 1000000000000;\n      genes += (randMod(155) + 101) * 1000000000;\n      genes += (randMod(155) + 101) * 1000000;\n      genes += (randMod(155) + 101) * 1000;\n      genes += randMod(155) + 101;\n      uint32 classId = EggTable[_table][randMod(EggTable[_table].length)];\n      EggTotal[_table] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,msg.sender,\"\",\"\");\n    }\n    Hatch(msg.sender, _table);\n  }\n\n  function hatchEgg(uint256 _eggId, string _name) public{\n    require(eggs[_eggId].hatchTime <= now);\n    require(eggs[_eggId].classId != 0 && eggs[_eggId].master == msg.sender);\n    DataBase CNDDB = DataBase(databaseContract);\n    uint64 monsterId = CNDDB.getTotalMonster() + 1;\n    string memory skills = \"0:0:0:0\";\n    CNDDB.addMonsterObj(monsterId,eggs[_eggId].genes,eggs[_eggId].classId,msg.sender,_name,skills);\n    eggs[_eggId].classId = 0;\n    eggs[_eggId].master = address(0);\n  }\n\n  function monstersForSale (uint8 optSort) external view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](totalAuction);\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n        mcount[counter] = i;\n        counter++;\n    }\n    if(optSort != 0){\n      sortAuction(mcount);\n    }\n    return mcount;\n  }\n  function sortAuction (uint256[] _mcount) public view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](_mcount.length);\n    for(uint256 i = 0; i < _mcount.length; i++){\n      mcount[i] = auctions[i].price * 10000000000 + i;\n    }\n    uint256[] memory tmps = getSortedArray(_mcount);\n    uint256[] memory result = new uint256[](tmps.length);\n    for(uint256 i2 = 0; i2 < tmps.length; i2++){\n      result[i2] = tmps[i2] % 10000000000;\n    }\n    return result;\n  }\n\n  /* Util */\n  function isContract(address addr) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) } // solium-disable-line\n    return size > 0;\n  }\n}",
        "debug": "storage_keccac_65535_&_65535_&_65535_&_calldata_NFTToken_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffd\nstorage_0: 0x0\ncaller: 0x0\ncalldata_NFTToken_0: 0x11affa5c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setEggTable(uint16,uint32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setEggTable(uint16,uint32[])",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 20071,
        "code": "256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event Hatch(address indexed _owner, uint16 _tableId);\n\n  address public thisAddress;\n  address public dragonTreasureToken;\n  address public databaseContract;\n  address public ERC721Contract;\n  uint256 public totalClass;\n  uint256 public totalMonster;\n  uint256 public totalAuction;\n  uint256 private increaseRate = 0.1 ether;\n  uint64 public cooldownTime = 2 hours;\n  mapping (address => address) public masterToReferral;\n  mapping (uint16 => uint32[]) private EggTable;\n  mapping (uint8 => uint256) public EggTotal;\n  function setNewMonster(uint256 _genes,uint32 _classId,address _master,string _name,string _skills) onlyModerators public returns(uint64 _monsterId) {\n    DataBase data = DataBase(databaseContract);\n    uint64 monsterId = data.getTotalMonster() + 1;\n    data.addMonsterObj(monsterId,_genes,_classId,_master,_name,_skills);\n    return monsterId;\n  }\n  function setMasterToReferral(address _master, address _referral) onlyOwner public{\n    masterToReferral[_master] = _referral;\n  }\n  function setEggTotal(uint8 _tableNum,uint256 _tableVal) onlyOwner public{\n    EggTotal[_tableNum] = _tableVal;\n  }\n  function setAddresses(address _dragonTreasureToken,address _databaseContract,address _ERC721Contract) onlyOwner public{\n    dragonTreasureToken = _dragonTreasureToken;\n    databaseContract = _databaseContract;\n    ERC721Contract = _ERC721Contract;\n  }\n  function setEggTable(uint16 _tableNum,uint32[] _tableVals) onlyOwner public{\n    EggTable[_tableNum] = _tableVals;\n  }\n  function userWithdraw(uint256 _value) public{\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DTTtoken.transferFrom(this,msg.sender,_value);\n  }\n\n  struct Egg {\n    uint8 tableId;\n    uint32 classId;\n    uint256 genes;\n    uint256 hatchTime;\n    uint32 matronId;\n    uint32 sireId;\n    uint16 generation;\n    address master;\n  }\n\n  struct Auction {\n    uint256 classId;\n    uint256 monsterId;\n    uint256 price;\n    uint256 endTime;\n    uint8 rarity;\n    address bidder;\n  }\n\n  Egg[] public eggs;\n  Auction[] public auctions;\n\n\n  uint randNonce = 0;\n  function randMod(uint _modulus) internal returns(uint) {\n    randNonce++;\n    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;\n  }\n\n  function setCooldown(uint64 _time) onlyOwner public{\n    cooldownTime = _time;\n  }\n\n  function getSortedArray(uint[] storageInt) public pure returns(uint[]) {\n      uint[] memory a = getCloneArray(storageInt);\n      quicksort(a);\n      return a;\n  }\n  function getCloneArray(uint[] a) private pure returns(uint[]) {\n      return a;\n  }\n  function swap(uint[] a, uint l, uint r) private pure {\n      uint t = a[l];\n      a[l] = a[r];\n      a[r] = t;\n  }\n  function getPivot(uint a, uint b, uint c) private pure returns(uint) {\n      if(a > b){\n          if(b > c){\n              return b;\n          }else{\n              return a > c ? c : a ;\n          }\n      }else{\n          if(a > c){\n              return a;\n          }else{\n              return b > c ? c : b ;\n          }\n      }\n  }\n  function quicksort(uint[] a) private pure {\n      uint left = 0;\n      uint right = a.length - 1;\n      quicksort_core(a, left, right);\n  }\n  function quicksort_core(uint[] a, uint left, uint right) private pure {\n      if(right <= left){\n          return;\n      }\n      uint l = left;\n      uint r = right;\n      uint p = getPivot(a[l], a[l+1], a[r]);\n      while(true){\n          while(a[l] < p){\n              l++;\n          }\n          while(p < a[r]){\n              r--;\n          }\n          if(r <= l){\n              break;\n          }\n          swap(a, l, r);\n          l++;\n          r--;\n      }\n      quicksort_core(a, left, l-1);\n      quicksort_core(a, r+1, right);\n  }\n\n  /* Withdraw */\n  /*\n    NOTICE: These functions withdraw the developer's cut which is left\n    in the contract by `buy`. User funds are immediately sent to the old\n    owner in `buy`, no user funds are left in the contract.\n  */\n  function withdrawAll () onlyOwner public {\n    msg.sender.transfer(this.balance);\n  }\n\n  function withdrawAmount (uint256 _amount) onlyOwner public {\n    msg.sender.transfer(_amount);\n  }\n\n\n  function addAuction(uint32 _classId, uint256 _monsterId, uint256 _price, uint8 _rarity, uint8 _endTime) onlyOwner public {\n    Auction memory auction = Auction({\n      classId: _classId,\n      monsterId: _monsterId,\n      price: _price,\n      rarity: _rarity,\n      endTime: 86400 * _endTime + now,\n      bidder: msg.sender\n    });\n    auctions.push(auction);\n    totalAuction += 1;\n  }\n\n  function burnAuction() onlyOwner external {\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n      if(auctions[i].endTime < now - 86400 * 3){\n        delete auctions[i];\n        counter++;\n      }\n    }\n    totalAuction -= counter;\n  }\n\n  /* Buying */\n\n  function ceil(uint a) public pure returns (uint ) {\n    return uint(int(a * 100) / 100);\n  }\n  /*\n     Buy a country directly from the contract for the calculated price\n     which ensures that the owner gets a profit.  All countries that\n     have been listed can be bought by this method. User funds are sent\n     directly to the previous owner and are never stored in the contract.\n  */\n  function setGenes(uint256 _price, uint256 _monsterId) internal{\n    DataBase data = DataBase(databaseContract);\n    uint256 gene = _price / 10000000000000000;\n    if(gene > 255)\n      gene = 255;\n    uint256 genes = 0;\n    genes += gene * 1000000000000000;\n    genes += gene * 1000000000000;\n    genes += gene * 1000000000;\n    genes += gene * 1000000;\n    genes += gene * 1000;\n    genes += gene;\n    if(genes > 255255255255255255)\n      genes = 255255255255255255;\n    data.setMonsterGene(uint64(_monsterId),genes);\n  }\n\n  function buy (uint256 _auctionId, address _referral) payable public {\n    NFTToken CNDERC721 = NFTToken(ERC721Contract);\n    require(auctions[_auctionId].endTime > now);\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != address(0));\n    require(ceil(msg.value) >= ceil(auctions[_auctionId].price + increaseRate));\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != msg.sender);\n    require(!isContract(msg.sender));\n    require(msg.sender != address(0));\n    address oldOwner = CNDERC721.ownerOf(auctions[_auctionId].monsterId);\n    address newOwner = msg.sender;\n    uint256 oldPrice = auctions[_auctionId].price;\n    uint256 price = ceil(msg.value);\n    setGenes(price,auctions[_auctionId].monsterId);\n    CNDERC721.transferAuction(oldOwner, newOwner, auctions[_auctionId].monsterId);\n    auctions[_auctionId].price = ceil(price);\n    auctions[_auctionId].bidder = msg.sender;\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 1000000000 * 5);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 1000000000 * 5);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 1000000000 * 5);\n    if(oldPrice > 0)\n      oldOwner.transfer(oldPrice);\n    Bought(auctions[_auctionId].monsterId, newOwner, price);\n    Sold(auctions[_auctionId].monsterId, oldOwner, price);\n  }\n\n  function buyBlueStarEgg(address _sender, uint256 _tokens, uint16 _amount) isActive public returns(uint256) {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = ceil(5 * 10**8);\n    if (_tokens < price)\n        revert();\n    DataBase data = DataBase(databaseContract);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(205) + 51) * 1000000000000000;\n      genes += (randMod(205) + 51) * 1000000000000;\n      genes += (randMod(205) + 51) * 1000000000;\n      genes += (randMod(205) + 51) * 1000000;\n      genes += (randMod(205) + 51) * 1000;\n      genes += randMod(205) + 51;\n      uint32 classId = EggTable[1][randMod(EggTable[1].length)];\n      EggTotal[1] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,_sender,\"\",\"\");\n    }\n    Hatch(msg.sender, 1);\n    return price * _amount;\n  }\n\n  function buyRareEgg(uint8 _table, uint _amount, address _referral) isActive payable public {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = 0.1 ether;\n    if(EggTotal[_table] > 0)\n    price += uint((int(EggTotal[_table] / 500) * 10**18) / 20);\n    require(msg.value >= price * _amount);\n\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DataBase data = DataBase(databaseContract);\n    uint256 bonus = 10;\n    if(_amount >= 10){\n      bonus = 12;\n    }\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 10000000000 * 5 * bonus * _amount);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 10000000000 * 5 * bonus * _amount);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 10000000000 * 5 * bonus * _amount);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(155) + 101) * 1000000000000000;\n      genes += (randMod(155) + 101) * 1000000000000;\n      genes += (randMod(155) + 101) * 1000000000;\n      genes += (randMod(155) + 101) * 1000000;\n      genes += (randMod(155) + 101) * 1000;\n      genes += randMod(155) + 101;\n      uint32 classId = EggTable[_table][randMod(EggTable[_table].length)];\n      EggTotal[_table] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,msg.sender,\"\",\"\");\n    }\n    Hatch(msg.sender, _table);\n  }\n\n  function hatchEgg(uint256 _eggId, string _name) public{\n    require(eggs[_eggId].hatchTime <= now);\n    require(eggs[_eggId].classId != 0 && eggs[_eggId].master == msg.sender);\n    DataBase CNDDB = DataBase(databaseContract);\n    uint64 monsterId = CNDDB.getTotalMonster() + 1;\n    string memory skills = \"0:0:0:0\";\n    CNDDB.addMonsterObj(monsterId,eggs[_eggId].genes,eggs[_eggId].classId,msg.sender,_name,skills);\n    eggs[_eggId].classId = 0;\n    eggs[_eggId].master = address(0);\n  }\n\n  function monstersForSale (uint8 optSort) external view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](totalAuction);\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n        mcount[counter] = i;\n        counter++;\n    }\n    if(optSort != 0){\n      sortAuction(mcount);\n    }\n    return mcount;\n  }\n  function sortAuction (uint256[] _mcount) public view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](_mcount.length);\n    for(uint256 i = 0; i < _mcount.length; i++){\n      mcount[i] = auctions[i].price * 10000000000 + i;\n    }\n    uint256[] memory tmps = getSortedArray(_mcount);\n    uint256[] memory result = new uint256[](tmps.length);\n    for(uint256 i2 = 0; i2 < tmps.length; i2++){\n      result[i2] = tmps[i2] % 10000000000;\n    }\n    return result;\n  }\n\n  /* Util */\n  function isContract(address addr) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) } // solium-disable-line\n    return size > 0;\n  }\n}",
        "debug": "keccac_keccac_65535_&_65535_&_65535_&_calldata_NFTToken_4: 0xfc86bad100d50b52800f6efd1234d4050f57c97082400704da31e108a9179b67\nstorage_keccac_65535_&_65535_&_65535_&_calldata_NFTToken_4: 0x8688d62877349a8cdb427f083e32bb3afe9fc8f4dbbf9fb719efed749d3c8b41\nstorage_0: 0x0\ncaller: 0x0\ncalldata_NFTToken_0: 0x11affa5c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setEggTable(uint16,uint32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setEggTable(uint16,uint32[])",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 20082,
        "code": "256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event Hatch(address indexed _owner, uint16 _tableId);\n\n  address public thisAddress;\n  address public dragonTreasureToken;\n  address public databaseContract;\n  address public ERC721Contract;\n  uint256 public totalClass;\n  uint256 public totalMonster;\n  uint256 public totalAuction;\n  uint256 private increaseRate = 0.1 ether;\n  uint64 public cooldownTime = 2 hours;\n  mapping (address => address) public masterToReferral;\n  mapping (uint16 => uint32[]) private EggTable;\n  mapping (uint8 => uint256) public EggTotal;\n  function setNewMonster(uint256 _genes,uint32 _classId,address _master,string _name,string _skills) onlyModerators public returns(uint64 _monsterId) {\n    DataBase data = DataBase(databaseContract);\n    uint64 monsterId = data.getTotalMonster() + 1;\n    data.addMonsterObj(monsterId,_genes,_classId,_master,_name,_skills);\n    return monsterId;\n  }\n  function setMasterToReferral(address _master, address _referral) onlyOwner public{\n    masterToReferral[_master] = _referral;\n  }\n  function setEggTotal(uint8 _tableNum,uint256 _tableVal) onlyOwner public{\n    EggTotal[_tableNum] = _tableVal;\n  }\n  function setAddresses(address _dragonTreasureToken,address _databaseContract,address _ERC721Contract) onlyOwner public{\n    dragonTreasureToken = _dragonTreasureToken;\n    databaseContract = _databaseContract;\n    ERC721Contract = _ERC721Contract;\n  }\n  function setEggTable(uint16 _tableNum,uint32[] _tableVals) onlyOwner public{\n    EggTable[_tableNum] = _tableVals;\n  }\n  function userWithdraw(uint256 _value) public{\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DTTtoken.transferFrom(this,msg.sender,_value);\n  }\n\n  struct Egg {\n    uint8 tableId;\n    uint32 classId;\n    uint256 genes;\n    uint256 hatchTime;\n    uint32 matronId;\n    uint32 sireId;\n    uint16 generation;\n    address master;\n  }\n\n  struct Auction {\n    uint256 classId;\n    uint256 monsterId;\n    uint256 price;\n    uint256 endTime;\n    uint8 rarity;\n    address bidder;\n  }\n\n  Egg[] public eggs;\n  Auction[] public auctions;\n\n\n  uint randNonce = 0;\n  function randMod(uint _modulus) internal returns(uint) {\n    randNonce++;\n    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;\n  }\n\n  function setCooldown(uint64 _time) onlyOwner public{\n    cooldownTime = _time;\n  }\n\n  function getSortedArray(uint[] storageInt) public pure returns(uint[]) {\n      uint[] memory a = getCloneArray(storageInt);\n      quicksort(a);\n      return a;\n  }\n  function getCloneArray(uint[] a) private pure returns(uint[]) {\n      return a;\n  }\n  function swap(uint[] a, uint l, uint r) private pure {\n      uint t = a[l];\n      a[l] = a[r];\n      a[r] = t;\n  }\n  function getPivot(uint a, uint b, uint c) private pure returns(uint) {\n      if(a > b){\n          if(b > c){\n              return b;\n          }else{\n              return a > c ? c : a ;\n          }\n      }else{\n          if(a > c){\n              return a;\n          }else{\n              return b > c ? c : b ;\n          }\n      }\n  }\n  function quicksort(uint[] a) private pure {\n      uint left = 0;\n      uint right = a.length - 1;\n      quicksort_core(a, left, right);\n  }\n  function quicksort_core(uint[] a, uint left, uint right) private pure {\n      if(right <= left){\n          return;\n      }\n      uint l = left;\n      uint r = right;\n      uint p = getPivot(a[l], a[l+1], a[r]);\n      while(true){\n          while(a[l] < p){\n              l++;\n          }\n          while(p < a[r]){\n              r--;\n          }\n          if(r <= l){\n              break;\n          }\n          swap(a, l, r);\n          l++;\n          r--;\n      }\n      quicksort_core(a, left, l-1);\n      quicksort_core(a, r+1, right);\n  }\n\n  /* Withdraw */\n  /*\n    NOTICE: These functions withdraw the developer's cut which is left\n    in the contract by `buy`. User funds are immediately sent to the old\n    owner in `buy`, no user funds are left in the contract.\n  */\n  function withdrawAll () onlyOwner public {\n    msg.sender.transfer(this.balance);\n  }\n\n  function withdrawAmount (uint256 _amount) onlyOwner public {\n    msg.sender.transfer(_amount);\n  }\n\n\n  function addAuction(uint32 _classId, uint256 _monsterId, uint256 _price, uint8 _rarity, uint8 _endTime) onlyOwner public {\n    Auction memory auction = Auction({\n      classId: _classId,\n      monsterId: _monsterId,\n      price: _price,\n      rarity: _rarity,\n      endTime: 86400 * _endTime + now,\n      bidder: msg.sender\n    });\n    auctions.push(auction);\n    totalAuction += 1;\n  }\n\n  function burnAuction() onlyOwner external {\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n      if(auctions[i].endTime < now - 86400 * 3){\n        delete auctions[i];\n        counter++;\n      }\n    }\n    totalAuction -= counter;\n  }\n\n  /* Buying */\n\n  function ceil(uint a) public pure returns (uint ) {\n    return uint(int(a * 100) / 100);\n  }\n  /*\n     Buy a country directly from the contract for the calculated price\n     which ensures that the owner gets a profit.  All countries that\n     have been listed can be bought by this method. User funds are sent\n     directly to the previous owner and are never stored in the contract.\n  */\n  function setGenes(uint256 _price, uint256 _monsterId) internal{\n    DataBase data = DataBase(databaseContract);\n    uint256 gene = _price / 10000000000000000;\n    if(gene > 255)\n      gene = 255;\n    uint256 genes = 0;\n    genes += gene * 1000000000000000;\n    genes += gene * 1000000000000;\n    genes += gene * 1000000000;\n    genes += gene * 1000000;\n    genes += gene * 1000;\n    genes += gene;\n    if(genes > 255255255255255255)\n      genes = 255255255255255255;\n    data.setMonsterGene(uint64(_monsterId),genes);\n  }\n\n  function buy (uint256 _auctionId, address _referral) payable public {\n    NFTToken CNDERC721 = NFTToken(ERC721Contract);\n    require(auctions[_auctionId].endTime > now);\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != address(0));\n    require(ceil(msg.value) >= ceil(auctions[_auctionId].price + increaseRate));\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != msg.sender);\n    require(!isContract(msg.sender));\n    require(msg.sender != address(0));\n    address oldOwner = CNDERC721.ownerOf(auctions[_auctionId].monsterId);\n    address newOwner = msg.sender;\n    uint256 oldPrice = auctions[_auctionId].price;\n    uint256 price = ceil(msg.value);\n    setGenes(price,auctions[_auctionId].monsterId);\n    CNDERC721.transferAuction(oldOwner, newOwner, auctions[_auctionId].monsterId);\n    auctions[_auctionId].price = ceil(price);\n    auctions[_auctionId].bidder = msg.sender;\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 1000000000 * 5);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 1000000000 * 5);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 1000000000 * 5);\n    if(oldPrice > 0)\n      oldOwner.transfer(oldPrice);\n    Bought(auctions[_auctionId].monsterId, newOwner, price);\n    Sold(auctions[_auctionId].monsterId, oldOwner, price);\n  }\n\n  function buyBlueStarEgg(address _sender, uint256 _tokens, uint16 _amount) isActive public returns(uint256) {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = ceil(5 * 10**8);\n    if (_tokens < price)\n        revert();\n    DataBase data = DataBase(databaseContract);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(205) + 51) * 1000000000000000;\n      genes += (randMod(205) + 51) * 1000000000000;\n      genes += (randMod(205) + 51) * 1000000000;\n      genes += (randMod(205) + 51) * 1000000;\n      genes += (randMod(205) + 51) * 1000;\n      genes += randMod(205) + 51;\n      uint32 classId = EggTable[1][randMod(EggTable[1].length)];\n      EggTotal[1] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,_sender,\"\",\"\");\n    }\n    Hatch(msg.sender, 1);\n    return price * _amount;\n  }\n\n  function buyRareEgg(uint8 _table, uint _amount, address _referral) isActive payable public {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = 0.1 ether;\n    if(EggTotal[_table] > 0)\n    price += uint((int(EggTotal[_table] / 500) * 10**18) / 20);\n    require(msg.value >= price * _amount);\n\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DataBase data = DataBase(databaseContract);\n    uint256 bonus = 10;\n    if(_amount >= 10){\n      bonus = 12;\n    }\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 10000000000 * 5 * bonus * _amount);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 10000000000 * 5 * bonus * _amount);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 10000000000 * 5 * bonus * _amount);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(155) + 101) * 1000000000000000;\n      genes += (randMod(155) + 101) * 1000000000000;\n      genes += (randMod(155) + 101) * 1000000000;\n      genes += (randMod(155) + 101) * 1000000;\n      genes += (randMod(155) + 101) * 1000;\n      genes += randMod(155) + 101;\n      uint32 classId = EggTable[_table][randMod(EggTable[_table].length)];\n      EggTotal[_table] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,msg.sender,\"\",\"\");\n    }\n    Hatch(msg.sender, _table);\n  }\n\n  function hatchEgg(uint256 _eggId, string _name) public{\n    require(eggs[_eggId].hatchTime <= now);\n    require(eggs[_eggId].classId != 0 && eggs[_eggId].master == msg.sender);\n    DataBase CNDDB = DataBase(databaseContract);\n    uint64 monsterId = CNDDB.getTotalMonster() + 1;\n    string memory skills = \"0:0:0:0\";\n    CNDDB.addMonsterObj(monsterId,eggs[_eggId].genes,eggs[_eggId].classId,msg.sender,_name,skills);\n    eggs[_eggId].classId = 0;\n    eggs[_eggId].master = address(0);\n  }\n\n  function monstersForSale (uint8 optSort) external view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](totalAuction);\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n        mcount[counter] = i;\n        counter++;\n    }\n    if(optSort != 0){\n      sortAuction(mcount);\n    }\n    return mcount;\n  }\n  function sortAuction (uint256[] _mcount) public view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](_mcount.length);\n    for(uint256 i = 0; i < _mcount.length; i++){\n      mcount[i] = auctions[i].price * 10000000000 + i;\n    }\n    uint256[] memory tmps = getSortedArray(_mcount);\n    uint256[] memory result = new uint256[](tmps.length);\n    for(uint256 i2 = 0; i2 < tmps.length; i2++){\n      result[i2] = tmps[i2] % 10000000000;\n    }\n    return result;\n  }\n\n  /* Util */\n  function isContract(address addr) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) } // solium-disable-line\n    return size > 0;\n  }\n}",
        "debug": "calldata_NFTToken_4 + calldata_NFTToken_32 + 4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_0: 0x0\ncaller: 0x0\ncalldata_NFTToken_0: 0x11affa5c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setEggTable(uint16,uint32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setEggTable(uint16,uint32[])",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 20084,
        "code": "256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price);\n  event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n  event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId);\n  event Hatch(address indexed _owner, uint16 _tableId);\n\n  address public thisAddress;\n  address public dragonTreasureToken;\n  address public databaseContract;\n  address public ERC721Contract;\n  uint256 public totalClass;\n  uint256 public totalMonster;\n  uint256 public totalAuction;\n  uint256 private increaseRate = 0.1 ether;\n  uint64 public cooldownTime = 2 hours;\n  mapping (address => address) public masterToReferral;\n  mapping (uint16 => uint32[]) private EggTable;\n  mapping (uint8 => uint256) public EggTotal;\n  function setNewMonster(uint256 _genes,uint32 _classId,address _master,string _name,string _skills) onlyModerators public returns(uint64 _monsterId) {\n    DataBase data = DataBase(databaseContract);\n    uint64 monsterId = data.getTotalMonster() + 1;\n    data.addMonsterObj(monsterId,_genes,_classId,_master,_name,_skills);\n    return monsterId;\n  }\n  function setMasterToReferral(address _master, address _referral) onlyOwner public{\n    masterToReferral[_master] = _referral;\n  }\n  function setEggTotal(uint8 _tableNum,uint256 _tableVal) onlyOwner public{\n    EggTotal[_tableNum] = _tableVal;\n  }\n  function setAddresses(address _dragonTreasureToken,address _databaseContract,address _ERC721Contract) onlyOwner public{\n    dragonTreasureToken = _dragonTreasureToken;\n    databaseContract = _databaseContract;\n    ERC721Contract = _ERC721Contract;\n  }\n  function setEggTable(uint16 _tableNum,uint32[] _tableVals) onlyOwner public{\n    EggTable[_tableNum] = _tableVals;\n  }\n  function userWithdraw(uint256 _value) public{\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DTTtoken.transferFrom(this,msg.sender,_value);\n  }\n\n  struct Egg {\n    uint8 tableId;\n    uint32 classId;\n    uint256 genes;\n    uint256 hatchTime;\n    uint32 matronId;\n    uint32 sireId;\n    uint16 generation;\n    address master;\n  }\n\n  struct Auction {\n    uint256 classId;\n    uint256 monsterId;\n    uint256 price;\n    uint256 endTime;\n    uint8 rarity;\n    address bidder;\n  }\n\n  Egg[] public eggs;\n  Auction[] public auctions;\n\n\n  uint randNonce = 0;\n  function randMod(uint _modulus) internal returns(uint) {\n    randNonce++;\n    return uint(keccak256(now, msg.sender, randNonce)) % _modulus;\n  }\n\n  function setCooldown(uint64 _time) onlyOwner public{\n    cooldownTime = _time;\n  }\n\n  function getSortedArray(uint[] storageInt) public pure returns(uint[]) {\n      uint[] memory a = getCloneArray(storageInt);\n      quicksort(a);\n      return a;\n  }\n  function getCloneArray(uint[] a) private pure returns(uint[]) {\n      return a;\n  }\n  function swap(uint[] a, uint l, uint r) private pure {\n      uint t = a[l];\n      a[l] = a[r];\n      a[r] = t;\n  }\n  function getPivot(uint a, uint b, uint c) private pure returns(uint) {\n      if(a > b){\n          if(b > c){\n              return b;\n          }else{\n              return a > c ? c : a ;\n          }\n      }else{\n          if(a > c){\n              return a;\n          }else{\n              return b > c ? c : b ;\n          }\n      }\n  }\n  function quicksort(uint[] a) private pure {\n      uint left = 0;\n      uint right = a.length - 1;\n      quicksort_core(a, left, right);\n  }\n  function quicksort_core(uint[] a, uint left, uint right) private pure {\n      if(right <= left){\n          return;\n      }\n      uint l = left;\n      uint r = right;\n      uint p = getPivot(a[l], a[l+1], a[r]);\n      while(true){\n          while(a[l] < p){\n              l++;\n          }\n          while(p < a[r]){\n              r--;\n          }\n          if(r <= l){\n              break;\n          }\n          swap(a, l, r);\n          l++;\n          r--;\n      }\n      quicksort_core(a, left, l-1);\n      quicksort_core(a, r+1, right);\n  }\n\n  /* Withdraw */\n  /*\n    NOTICE: These functions withdraw the developer's cut which is left\n    in the contract by `buy`. User funds are immediately sent to the old\n    owner in `buy`, no user funds are left in the contract.\n  */\n  function withdrawAll () onlyOwner public {\n    msg.sender.transfer(this.balance);\n  }\n\n  function withdrawAmount (uint256 _amount) onlyOwner public {\n    msg.sender.transfer(_amount);\n  }\n\n\n  function addAuction(uint32 _classId, uint256 _monsterId, uint256 _price, uint8 _rarity, uint8 _endTime) onlyOwner public {\n    Auction memory auction = Auction({\n      classId: _classId,\n      monsterId: _monsterId,\n      price: _price,\n      rarity: _rarity,\n      endTime: 86400 * _endTime + now,\n      bidder: msg.sender\n    });\n    auctions.push(auction);\n    totalAuction += 1;\n  }\n\n  function burnAuction() onlyOwner external {\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n      if(auctions[i].endTime < now - 86400 * 3){\n        delete auctions[i];\n        counter++;\n      }\n    }\n    totalAuction -= counter;\n  }\n\n  /* Buying */\n\n  function ceil(uint a) public pure returns (uint ) {\n    return uint(int(a * 100) / 100);\n  }\n  /*\n     Buy a country directly from the contract for the calculated price\n     which ensures that the owner gets a profit.  All countries that\n     have been listed can be bought by this method. User funds are sent\n     directly to the previous owner and are never stored in the contract.\n  */\n  function setGenes(uint256 _price, uint256 _monsterId) internal{\n    DataBase data = DataBase(databaseContract);\n    uint256 gene = _price / 10000000000000000;\n    if(gene > 255)\n      gene = 255;\n    uint256 genes = 0;\n    genes += gene * 1000000000000000;\n    genes += gene * 1000000000000;\n    genes += gene * 1000000000;\n    genes += gene * 1000000;\n    genes += gene * 1000;\n    genes += gene;\n    if(genes > 255255255255255255)\n      genes = 255255255255255255;\n    data.setMonsterGene(uint64(_monsterId),genes);\n  }\n\n  function buy (uint256 _auctionId, address _referral) payable public {\n    NFTToken CNDERC721 = NFTToken(ERC721Contract);\n    require(auctions[_auctionId].endTime > now);\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != address(0));\n    require(ceil(msg.value) >= ceil(auctions[_auctionId].price + increaseRate));\n    require(CNDERC721.ownerOf(auctions[_auctionId].monsterId) != msg.sender);\n    require(!isContract(msg.sender));\n    require(msg.sender != address(0));\n    address oldOwner = CNDERC721.ownerOf(auctions[_auctionId].monsterId);\n    address newOwner = msg.sender;\n    uint256 oldPrice = auctions[_auctionId].price;\n    uint256 price = ceil(msg.value);\n    setGenes(price,auctions[_auctionId].monsterId);\n    CNDERC721.transferAuction(oldOwner, newOwner, auctions[_auctionId].monsterId);\n    auctions[_auctionId].price = ceil(price);\n    auctions[_auctionId].bidder = msg.sender;\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 1000000000 * 5);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 1000000000 * 5);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 1000000000 * 5);\n    if(oldPrice > 0)\n      oldOwner.transfer(oldPrice);\n    Bought(auctions[_auctionId].monsterId, newOwner, price);\n    Sold(auctions[_auctionId].monsterId, oldOwner, price);\n  }\n\n  function buyBlueStarEgg(address _sender, uint256 _tokens, uint16 _amount) isActive public returns(uint256) {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = ceil(5 * 10**8);\n    if (_tokens < price)\n        revert();\n    DataBase data = DataBase(databaseContract);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(205) + 51) * 1000000000000000;\n      genes += (randMod(205) + 51) * 1000000000000;\n      genes += (randMod(205) + 51) * 1000000000;\n      genes += (randMod(205) + 51) * 1000000;\n      genes += (randMod(205) + 51) * 1000;\n      genes += randMod(205) + 51;\n      uint32 classId = EggTable[1][randMod(EggTable[1].length)];\n      EggTotal[1] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,_sender,\"\",\"\");\n    }\n    Hatch(msg.sender, 1);\n    return price * _amount;\n  }\n\n  function buyRareEgg(uint8 _table, uint _amount, address _referral) isActive payable public {\n    require(_amount <= 10 && _amount > 0);\n    uint256 price = 0.1 ether;\n    if(EggTotal[_table] > 0)\n    price += uint((int(EggTotal[_table] / 500) * 10**18) / 20);\n    require(msg.value >= price * _amount);\n\n    DTT DTTtoken = DTT(dragonTreasureToken);\n    DataBase data = DataBase(databaseContract);\n    uint256 bonus = 10;\n    if(_amount >= 10){\n      bonus = 12;\n    }\n    if(masterToReferral[msg.sender] != address(0) && masterToReferral[msg.sender] != msg.sender){\n      DTTtoken.approve(masterToReferral[msg.sender], DTTtoken.allowance(this,masterToReferral[msg.sender]) + price / 10000000000 * 5 * bonus * _amount);\n    }else if(_referral != address(0) && _referral != msg.sender){\n      masterToReferral[msg.sender] = _referral;\n      DTTtoken.approve(_referral, DTTtoken.allowance(this,_referral) + price / 10000000000 * 5 * bonus * _amount);\n    }\n\n    DTTtoken.approve(msg.sender, DTTtoken.allowance(this,msg.sender) + price / 10000000000 * 5 * bonus * _amount);\n    for (uint8 i = 0; i < _amount; i++) {\n      uint256 genes = 0;\n      genes += (randMod(155) + 101) * 1000000000000000;\n      genes += (randMod(155) + 101) * 1000000000000;\n      genes += (randMod(155) + 101) * 1000000000;\n      genes += (randMod(155) + 101) * 1000000;\n      genes += (randMod(155) + 101) * 1000;\n      genes += randMod(155) + 101;\n      uint32 classId = EggTable[_table][randMod(EggTable[_table].length)];\n      EggTotal[_table] += 1;\n      uint64 monsterId = data.getTotalMonster() + 1;\n      data.addMonsterObj(monsterId,genes,classId,msg.sender,\"\",\"\");\n    }\n    Hatch(msg.sender, _table);\n  }\n\n  function hatchEgg(uint256 _eggId, string _name) public{\n    require(eggs[_eggId].hatchTime <= now);\n    require(eggs[_eggId].classId != 0 && eggs[_eggId].master == msg.sender);\n    DataBase CNDDB = DataBase(databaseContract);\n    uint64 monsterId = CNDDB.getTotalMonster() + 1;\n    string memory skills = \"0:0:0:0\";\n    CNDDB.addMonsterObj(monsterId,eggs[_eggId].genes,eggs[_eggId].classId,msg.sender,_name,skills);\n    eggs[_eggId].classId = 0;\n    eggs[_eggId].master = address(0);\n  }\n\n  function monstersForSale (uint8 optSort) external view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](totalAuction);\n    uint256 counter = 0;\n    for (uint256 i = 0; i < totalAuction; i++) {\n        mcount[counter] = i;\n        counter++;\n    }\n    if(optSort != 0){\n      sortAuction(mcount);\n    }\n    return mcount;\n  }\n  function sortAuction (uint256[] _mcount) public view returns (uint256[] _monsters){\n    uint256[] memory mcount = new uint256[](_mcount.length);\n    for(uint256 i = 0; i < _mcount.length; i++){\n      mcount[i] = auctions[i].price * 10000000000 + i;\n    }\n    uint256[] memory tmps = getSortedArray(_mcount);\n    uint256[] memory result = new uint256[](tmps.length);\n    for(uint256 i2 = 0; i2 < tmps.length; i2++){\n      result[i2] = tmps[i2] % 10000000000;\n    }\n    return result;\n  }\n\n  /* Util */\n  function isContract(address addr) internal view returns (bool) {\n    uint size;\n    assembly { size := extcodesize(addr) } // solium-disable-line\n    return size > 0;\n  }\n}",
        "debug": "calldata_NFTToken_4 + calldata_NFTToken_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_0: 0x0\ncaller: 0x0\ncalldata_NFTToken_0: 0x11affa5c00000000000000000000000000000000000000000000000000000000\ncalldatasize_NFTToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setEggTable(uint16,uint32[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0xac625cbd6d8628f9de1b69a2e057073e0dca0a0d.sol",
        "function": "setEggTable(uint16,uint32[])",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}