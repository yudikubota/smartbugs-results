{"error": null, "issues": [{"address": 1140, "code": ") {\n        if (componentCount > 65534) revert();\n        var component = components[componentCount];\n        component.name = componentName;\n        component.index = componentCount;\n        component.currentSupport = 0;\n        component.supported = 0;\n        component.undermined = 0;\n        componentCount += 1;\n        return true;\n    }\n    \n    function createAddOn(string addOnName, uint256 threshold) public onlyByOwner() returns (b", "debug": "calldata_BachelorBucks_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_BachelorBucks_0: 0x1b9e9a2700000000000000000000000000000000000000000000000000000000\ncalldatasize_BachelorBucks: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createComponent(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0xb8d9b579c32b88714dfe69c05d87bb3165892b04.sol", "function": "createComponent(string)", "lineno": 90, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1683, "code": " {\n        if (addOnCount > 65534) revert();\n        if (threshold == 0) revert();\n        var addOn = addOns[addOnCount];\n        addOn.name = addOnName;\n        addOn.index = addOnCount;\n        addOn.support = 0;\n        addOn.threshold = threshold;\n        addOn.completed = false;\n        addOn.winner = address(0x0);\n        addOnCount += 1;\n        return true;\n    }\n    \n    function createWildcard(string wildcardName, uint256 cost, uint16 number) public onlyByOwner() returns ", "debug": "calldata_BachelorBucks_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_BachelorBucks_0: 0x3676b34200000000000000000000000000000000000000000000000000000000\ncalldatasize_BachelorBucks: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createAddOn(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0xb8d9b579c32b88714dfe69c05d87bb3165892b04.sol", "function": "createAddOn(string,uint256)", "lineno": 102, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11781, "code": "ntract BachelorBucks {\n    string public standard = 'BBUCK 1.0';\n    string public name = 'BachelorBucks';\n    string public symbol = 'BBUCK';\n    uint8 public decimals = 0;\n    uint256 public totalSupply = 1000000000;\n    uint256 public initialPrice = 1 ether / 1000;\n    uint256 public priceIncreasePerPurchase = 1 ether / 100000;\n    uint256 public currentPrice = initialPrice;\n    \n    address public owner = msg.sender;\n    uint256 public creationTime = now;\n    \n    struct Component {\n        string name;\n        uint16 index;\n        int256 currentSupport;\n        uint256 supported;\n        uint256 undermined;\n    }\n    \n    struct AddOn {\n        string name;\n        uint16 index;\n        uint256 support;\n        uint256 threshold;\n        bool completed;\n        address winner;\n    }\n    \n    struct Wildcard {\n        string name;\n        uint16 index;\n        uint256 cost;\n        uint16 available;\n    }\n    \n    /* Creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    uint16 public componentCount = 0;\n    mapping (uint16 => Component) public components;\n    \n    uint16 public addOnCount = 0;\n    mapping (uint16 => AddOn) public addOns;\n    \n    uint16 public wildcardCount = 0;\n    mapping (uint16 => Wildcard) public wildcards;\n    mapping (address => mapping (uint16 => uint16)) public wildcardsHeld;\n\n    /* Generates a public event on the blockchain that will notify clients of transfers */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* Generates a public event on the blockchain that will notify clients of purchases */\n    event Purchase(address indexed from, uint256 value);\n\n    /* Notifies clients about support for a component */\n    event SupportComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about undermine for a component */\n    event UndermineComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about support for an addOn */\n    event SupportAddOn(uint256 addOnIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about completion for an addOn */\n    event CompleteAddOn(uint256 addOnIdx, address indexed winner);\n\n    /* Notifies clients about wildcard completion */\n    event CompleteWildcard(uint256 wildcardIdx, address indexed caller);\n\n    modifier onlyByOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier neverByOwner() {\n        require(msg.sender != owner);\n        _;\n    }\n    \n    /* Initializes contract with initial supply tokens to me */\n    function BachelorBucks() public {\n        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\n    }\n    \n    function createComponent(string componentName) public onlyByOwner() returns (bool success) {\n        if (componentCount > 65534) revert();\n        var component = components[componentCount];\n        component.name = componentName;\n        component.index = componentCount;\n        component.currentSupport = 0;\n        component.supported = 0;\n        component.undermined = 0;\n        componentCount += 1;\n        return true;\n    }\n    \n    function createAddOn(string addOnName, uint256 threshold) public onlyByOwner() returns (bool success) {\n        if (addOnCount > 65534) revert();\n        if (threshold == 0) revert();\n        var addOn = addOns[addOnCount];\n        addOn.name = addOnName;\n        addOn.index = addOnCount;\n        addOn.support = 0;\n        addOn.threshold = threshold;\n        addOn.completed = false;\n        addOn.winner = address(0x0);\n        addOnCount += 1;\n        return true;\n    }\n    \n    function createWildcard(string wildcardName, uint256 cost, uint16 number) public onlyByOwner() returns (bool success) {\n        if (wildcardCount > 65534) revert();\n        if (number == 0) revert();\n        if (cost == 0) revert();\n        var wildcard = wildcards[wildcardCount];\n        wildcard.name = wildcardName;\n        wildcard.index = wildcardCount;\n        wildcard.available = number;\n        wildcard.cost = cost;\n        wildcardCount += 1;\n        return true;\n    }\n    \n    function giveMeSomeBBUCKs() public payable returns (bool success) {\n        if (msg.value < currentPrice) revert();\n        uint256 amount = (msg.value / currentPrice);\n        if (balanceOf[owner] < amount) revert();\n        balanceOf[owner] -= amount;\n        balanceOf[msg.sender] += amount;\n        if ((currentPrice + priceIncreasePerPurchase) < currentPrice) return true; // Maximum price reached\n        currentPrice += priceIncreasePerPurchase;\n        return true;\n    }\n    \n    function() public payable { }                               // Thanks for the donation!\n    \n    function getBalance() view public returns (uint256) {\n        return balanceOf[msg.sender];\n    }\n    \n    function sweepToOwner() public onlyByOwner() returns (bool success) {\n        owner.transfer(this.balance);\n        return true;\n    }\n    \n    /* Send coins */\n    function transfer(address _to, uint256 _value) public {\n        if (_to == 0x0) revert();                               // Prevent transfer to 0x0 address\n        if (balanceOf[msg.sender] < _value) revert();           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows\n        balanceOf[msg.sender] -= _value;                        // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\n    }\n\n    /* Allow another contract to spend some tokens on my behalf */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (_to == 0x0) revert();                                // Prevent transfer to 0x0 address\n        if (balanceOf[_from] < _value) revert();                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) revert();     // Check allowance\n        balanceOf[_from] -= _value;                              // Subtract from the sender\n        balanceOf[_to] += _value;                                // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n\t/* Add support a component */\n    function supportComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.supported + value) < component.supported) revert();                    // Will adding support wrap the supported counter\n        if ((component.currentSupport + int256(value)) < component.currentSupport) revert();  // Will adding this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport += int256(value);                      // Add support to the component\n        component.supported += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportComponent(component_idx, msg.sender, value);\n        return true;\n    }\n    \n  /* Undermine support for a component */\n    function undermineComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't subtract 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.currentSupport - int256(value)) > component.currentSupport) revert();  // Will subtracting this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport -= int256(value);                      // Subtract support from the component\n        component.undermined += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        UndermineComponent(component_idx, msg.sender, value);\n        return true;\n    }\n\n\t/* Get current component support */\n    function getComponentSupport(uint16 component_idx) view public returns (int256) {\n        if (component_idx >= componentCount) return 0;\n        return components[component_idx].currentSupport;\n    }\n    \n    /* Add support an addOn */\n    function supportAddOn(uint16 addOn_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (addOn_idx >= addOnCount) revert();                          // Check if the addon index is valid\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) revert();\n        if ((addOn.support + value) < addOn.support) revert();          // Will adding support wrap the support counter\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        addOn.support += value;                                         // Add support to the component\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportAddOn(addOn_idx, msg.sender, value);\n        if (addOn.support < addOn.threshold) return true;              // Threshold is not yet met\n        addOn.completed = true;\n        addOn.winner = msg.sender;\n        CompleteAddOn(addOn_idx, addOn.winner);\n        return true;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnSupport(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        return addOns[addOn_idx].support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnNeeded(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) return 0;\n        return addOn.threshold - addOn.support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnComplete(uint16 addOn_idx) view public returns (bool) {\n        if (addOn_idx >= addOnCount) return false;\n        return addOns[addOn_idx].completed;\n    }\n    \n    /* acquire a wildcard */\n    function acquireWildcard(uint16 wildcard_idx) public neverByOwner() returns (bool success) {\n        if (wildcard_idx >= wildcardCount) revert();                    // Check if the wildcard index is valid\n        var wildcard = wildcards[wildcard_idx];\n        if (balanceOf[msg.sender] < wildcard.cost) revert();            // Check if the sender has enough\n        if (wildcard.available < 1) revert();                           // Are there wildcards still available\n        balanceOf[msg.sender] -= wildcard.cost;                         // Subtract from the sender\n        wildcard.available -= 1;                                        // Subtract 1 wildcard from the deck\n        totalSupply -= wildcard.cost;                                   // Remove value from the totalSupply\n        wildcardsHeld[msg.sender][wildcard_idx] += 1;\n        CompleteWildcard(wildcard_idx, msg.sender);\n        return true;\n    }\n    \n    /* Get remaining wildcards */\n    function getWildcardsRemaining(uint16 wildcard_idx) view public returns (uint16) {\n        if (wildcard_idx >= wildcardCount) return 0;\n        return wildcards[wildcard_idx].available;\n    }\n}", "debug": "storage_0 + keccac_65535_&_65535_&_65535_&_UDiv(storage_12,_256): 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+_keccac_65535_&_65535_&_65535_&_UDiv(storage_12,_256): 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_12: 0xfffe00\nstorage_8: 0x0\ncaller: 0x0\ncalldata_BachelorBucks_0: 0x1b9e9a2700000000000000000000000000000000000000000000000000000000\ncalldatasize_BachelorBucks: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createComponent(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0xb8d9b579c32b88714dfe69c05d87bb3165892b04.sol", "function": "createComponent(string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11810, "code": "ntract BachelorBucks {\n    string public standard = 'BBUCK 1.0';\n    string public name = 'BachelorBucks';\n    string public symbol = 'BBUCK';\n    uint8 public decimals = 0;\n    uint256 public totalSupply = 1000000000;\n    uint256 public initialPrice = 1 ether / 1000;\n    uint256 public priceIncreasePerPurchase = 1 ether / 100000;\n    uint256 public currentPrice = initialPrice;\n    \n    address public owner = msg.sender;\n    uint256 public creationTime = now;\n    \n    struct Component {\n        string name;\n        uint16 index;\n        int256 currentSupport;\n        uint256 supported;\n        uint256 undermined;\n    }\n    \n    struct AddOn {\n        string name;\n        uint16 index;\n        uint256 support;\n        uint256 threshold;\n        bool completed;\n        address winner;\n    }\n    \n    struct Wildcard {\n        string name;\n        uint16 index;\n        uint256 cost;\n        uint16 available;\n    }\n    \n    /* Creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    uint16 public componentCount = 0;\n    mapping (uint16 => Component) public components;\n    \n    uint16 public addOnCount = 0;\n    mapping (uint16 => AddOn) public addOns;\n    \n    uint16 public wildcardCount = 0;\n    mapping (uint16 => Wildcard) public wildcards;\n    mapping (address => mapping (uint16 => uint16)) public wildcardsHeld;\n\n    /* Generates a public event on the blockchain that will notify clients of transfers */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* Generates a public event on the blockchain that will notify clients of purchases */\n    event Purchase(address indexed from, uint256 value);\n\n    /* Notifies clients about support for a component */\n    event SupportComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about undermine for a component */\n    event UndermineComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about support for an addOn */\n    event SupportAddOn(uint256 addOnIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about completion for an addOn */\n    event CompleteAddOn(uint256 addOnIdx, address indexed winner);\n\n    /* Notifies clients about wildcard completion */\n    event CompleteWildcard(uint256 wildcardIdx, address indexed caller);\n\n    modifier onlyByOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier neverByOwner() {\n        require(msg.sender != owner);\n        _;\n    }\n    \n    /* Initializes contract with initial supply tokens to me */\n    function BachelorBucks() public {\n        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\n    }\n    \n    function createComponent(string componentName) public onlyByOwner() returns (bool success) {\n        if (componentCount > 65534) revert();\n        var component = components[componentCount];\n        component.name = componentName;\n        component.index = componentCount;\n        component.currentSupport = 0;\n        component.supported = 0;\n        component.undermined = 0;\n        componentCount += 1;\n        return true;\n    }\n    \n    function createAddOn(string addOnName, uint256 threshold) public onlyByOwner() returns (bool success) {\n        if (addOnCount > 65534) revert();\n        if (threshold == 0) revert();\n        var addOn = addOns[addOnCount];\n        addOn.name = addOnName;\n        addOn.index = addOnCount;\n        addOn.support = 0;\n        addOn.threshold = threshold;\n        addOn.completed = false;\n        addOn.winner = address(0x0);\n        addOnCount += 1;\n        return true;\n    }\n    \n    function createWildcard(string wildcardName, uint256 cost, uint16 number) public onlyByOwner() returns (bool success) {\n        if (wildcardCount > 65534) revert();\n        if (number == 0) revert();\n        if (cost == 0) revert();\n        var wildcard = wildcards[wildcardCount];\n        wildcard.name = wildcardName;\n        wildcard.index = wildcardCount;\n        wildcard.available = number;\n        wildcard.cost = cost;\n        wildcardCount += 1;\n        return true;\n    }\n    \n    function giveMeSomeBBUCKs() public payable returns (bool success) {\n        if (msg.value < currentPrice) revert();\n        uint256 amount = (msg.value / currentPrice);\n        if (balanceOf[owner] < amount) revert();\n        balanceOf[owner] -= amount;\n        balanceOf[msg.sender] += amount;\n        if ((currentPrice + priceIncreasePerPurchase) < currentPrice) return true; // Maximum price reached\n        currentPrice += priceIncreasePerPurchase;\n        return true;\n    }\n    \n    function() public payable { }                               // Thanks for the donation!\n    \n    function getBalance() view public returns (uint256) {\n        return balanceOf[msg.sender];\n    }\n    \n    function sweepToOwner() public onlyByOwner() returns (bool success) {\n        owner.transfer(this.balance);\n        return true;\n    }\n    \n    /* Send coins */\n    function transfer(address _to, uint256 _value) public {\n        if (_to == 0x0) revert();                               // Prevent transfer to 0x0 address\n        if (balanceOf[msg.sender] < _value) revert();           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows\n        balanceOf[msg.sender] -= _value;                        // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\n    }\n\n    /* Allow another contract to spend some tokens on my behalf */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (_to == 0x0) revert();                                // Prevent transfer to 0x0 address\n        if (balanceOf[_from] < _value) revert();                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) revert();     // Check allowance\n        balanceOf[_from] -= _value;                              // Subtract from the sender\n        balanceOf[_to] += _value;                                // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n\t/* Add support a component */\n    function supportComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.supported + value) < component.supported) revert();                    // Will adding support wrap the supported counter\n        if ((component.currentSupport + int256(value)) < component.currentSupport) revert();  // Will adding this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport += int256(value);                      // Add support to the component\n        component.supported += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportComponent(component_idx, msg.sender, value);\n        return true;\n    }\n    \n  /* Undermine support for a component */\n    function undermineComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't subtract 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.currentSupport - int256(value)) > component.currentSupport) revert();  // Will subtracting this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport -= int256(value);                      // Subtract support from the component\n        component.undermined += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        UndermineComponent(component_idx, msg.sender, value);\n        return true;\n    }\n\n\t/* Get current component support */\n    function getComponentSupport(uint16 component_idx) view public returns (int256) {\n        if (component_idx >= componentCount) return 0;\n        return components[component_idx].currentSupport;\n    }\n    \n    /* Add support an addOn */\n    function supportAddOn(uint16 addOn_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (addOn_idx >= addOnCount) revert();                          // Check if the addon index is valid\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) revert();\n        if ((addOn.support + value) < addOn.support) revert();          // Will adding support wrap the support counter\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        addOn.support += value;                                         // Add support to the component\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportAddOn(addOn_idx, msg.sender, value);\n        if (addOn.support < addOn.threshold) return true;              // Threshold is not yet met\n        addOn.completed = true;\n        addOn.winner = msg.sender;\n        CompleteAddOn(addOn_idx, addOn.winner);\n        return true;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnSupport(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        return addOns[addOn_idx].support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnNeeded(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) return 0;\n        return addOn.threshold - addOn.support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnComplete(uint16 addOn_idx) view public returns (bool) {\n        if (addOn_idx >= addOnCount) return false;\n        return addOns[addOn_idx].completed;\n    }\n    \n    /* acquire a wildcard */\n    function acquireWildcard(uint16 wildcard_idx) public neverByOwner() returns (bool success) {\n        if (wildcard_idx >= wildcardCount) revert();                    // Check if the wildcard index is valid\n        var wildcard = wildcards[wildcard_idx];\n        if (balanceOf[msg.sender] < wildcard.cost) revert();            // Check if the sender has enough\n        if (wildcard.available < 1) revert();                           // Are there wildcards still available\n        balanceOf[msg.sender] -= wildcard.cost;                         // Subtract from the sender\n        wildcard.available -= 1;                                        // Subtract 1 wildcard from the deck\n        totalSupply -= wildcard.cost;                                   // Remove value from the totalSupply\n        wildcardsHeld[msg.sender][wildcard_idx] += 1;\n        CompleteWildcard(wildcard_idx, msg.sender);\n        return true;\n    }\n    \n    /* Get remaining wildcards */\n    function getWildcardsRemaining(uint16 wildcard_idx) view public returns (uint16) {\n        if (wildcard_idx >= wildcardCount) return 0;\n        return wildcards[wildcard_idx].available;\n    }\n}", "debug": "calldata_BachelorBucks_4 + calldata_BachelorBucks_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_BachelorBucks_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_14: 0xfffe00\nstorage_8: 0x0\ncaller: 0x0\ncalldata_BachelorBucks_0: 0x3676b34200000000000000000000000000000000000000000000000000000000\ncalldatasize_BachelorBucks: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createAddOn(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0xb8d9b579c32b88714dfe69c05d87bb3165892b04.sol", "function": "createAddOn(string,uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11824, "code": "ntract BachelorBucks {\n    string public standard = 'BBUCK 1.0';\n    string public name = 'BachelorBucks';\n    string public symbol = 'BBUCK';\n    uint8 public decimals = 0;\n    uint256 public totalSupply = 1000000000;\n    uint256 public initialPrice = 1 ether / 1000;\n    uint256 public priceIncreasePerPurchase = 1 ether / 100000;\n    uint256 public currentPrice = initialPrice;\n    \n    address public owner = msg.sender;\n    uint256 public creationTime = now;\n    \n    struct Component {\n        string name;\n        uint16 index;\n        int256 currentSupport;\n        uint256 supported;\n        uint256 undermined;\n    }\n    \n    struct AddOn {\n        string name;\n        uint16 index;\n        uint256 support;\n        uint256 threshold;\n        bool completed;\n        address winner;\n    }\n    \n    struct Wildcard {\n        string name;\n        uint16 index;\n        uint256 cost;\n        uint16 available;\n    }\n    \n    /* Creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    uint16 public componentCount = 0;\n    mapping (uint16 => Component) public components;\n    \n    uint16 public addOnCount = 0;\n    mapping (uint16 => AddOn) public addOns;\n    \n    uint16 public wildcardCount = 0;\n    mapping (uint16 => Wildcard) public wildcards;\n    mapping (address => mapping (uint16 => uint16)) public wildcardsHeld;\n\n    /* Generates a public event on the blockchain that will notify clients of transfers */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* Generates a public event on the blockchain that will notify clients of purchases */\n    event Purchase(address indexed from, uint256 value);\n\n    /* Notifies clients about support for a component */\n    event SupportComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about undermine for a component */\n    event UndermineComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about support for an addOn */\n    event SupportAddOn(uint256 addOnIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about completion for an addOn */\n    event CompleteAddOn(uint256 addOnIdx, address indexed winner);\n\n    /* Notifies clients about wildcard completion */\n    event CompleteWildcard(uint256 wildcardIdx, address indexed caller);\n\n    modifier onlyByOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier neverByOwner() {\n        require(msg.sender != owner);\n        _;\n    }\n    \n    /* Initializes contract with initial supply tokens to me */\n    function BachelorBucks() public {\n        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\n    }\n    \n    function createComponent(string componentName) public onlyByOwner() returns (bool success) {\n        if (componentCount > 65534) revert();\n        var component = components[componentCount];\n        component.name = componentName;\n        component.index = componentCount;\n        component.currentSupport = 0;\n        component.supported = 0;\n        component.undermined = 0;\n        componentCount += 1;\n        return true;\n    }\n    \n    function createAddOn(string addOnName, uint256 threshold) public onlyByOwner() returns (bool success) {\n        if (addOnCount > 65534) revert();\n        if (threshold == 0) revert();\n        var addOn = addOns[addOnCount];\n        addOn.name = addOnName;\n        addOn.index = addOnCount;\n        addOn.support = 0;\n        addOn.threshold = threshold;\n        addOn.completed = false;\n        addOn.winner = address(0x0);\n        addOnCount += 1;\n        return true;\n    }\n    \n    function createWildcard(string wildcardName, uint256 cost, uint16 number) public onlyByOwner() returns (bool success) {\n        if (wildcardCount > 65534) revert();\n        if (number == 0) revert();\n        if (cost == 0) revert();\n        var wildcard = wildcards[wildcardCount];\n        wildcard.name = wildcardName;\n        wildcard.index = wildcardCount;\n        wildcard.available = number;\n        wildcard.cost = cost;\n        wildcardCount += 1;\n        return true;\n    }\n    \n    function giveMeSomeBBUCKs() public payable returns (bool success) {\n        if (msg.value < currentPrice) revert();\n        uint256 amount = (msg.value / currentPrice);\n        if (balanceOf[owner] < amount) revert();\n        balanceOf[owner] -= amount;\n        balanceOf[msg.sender] += amount;\n        if ((currentPrice + priceIncreasePerPurchase) < currentPrice) return true; // Maximum price reached\n        currentPrice += priceIncreasePerPurchase;\n        return true;\n    }\n    \n    function() public payable { }                               // Thanks for the donation!\n    \n    function getBalance() view public returns (uint256) {\n        return balanceOf[msg.sender];\n    }\n    \n    function sweepToOwner() public onlyByOwner() returns (bool success) {\n        owner.transfer(this.balance);\n        return true;\n    }\n    \n    /* Send coins */\n    function transfer(address _to, uint256 _value) public {\n        if (_to == 0x0) revert();                               // Prevent transfer to 0x0 address\n        if (balanceOf[msg.sender] < _value) revert();           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows\n        balanceOf[msg.sender] -= _value;                        // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\n    }\n\n    /* Allow another contract to spend some tokens on my behalf */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (_to == 0x0) revert();                                // Prevent transfer to 0x0 address\n        if (balanceOf[_from] < _value) revert();                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) revert();     // Check allowance\n        balanceOf[_from] -= _value;                              // Subtract from the sender\n        balanceOf[_to] += _value;                                // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n\t/* Add support a component */\n    function supportComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.supported + value) < component.supported) revert();                    // Will adding support wrap the supported counter\n        if ((component.currentSupport + int256(value)) < component.currentSupport) revert();  // Will adding this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport += int256(value);                      // Add support to the component\n        component.supported += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportComponent(component_idx, msg.sender, value);\n        return true;\n    }\n    \n  /* Undermine support for a component */\n    function undermineComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't subtract 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.currentSupport - int256(value)) > component.currentSupport) revert();  // Will subtracting this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport -= int256(value);                      // Subtract support from the component\n        component.undermined += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        UndermineComponent(component_idx, msg.sender, value);\n        return true;\n    }\n\n\t/* Get current component support */\n    function getComponentSupport(uint16 component_idx) view public returns (int256) {\n        if (component_idx >= componentCount) return 0;\n        return components[component_idx].currentSupport;\n    }\n    \n    /* Add support an addOn */\n    function supportAddOn(uint16 addOn_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (addOn_idx >= addOnCount) revert();                          // Check if the addon index is valid\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) revert();\n        if ((addOn.support + value) < addOn.support) revert();          // Will adding support wrap the support counter\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        addOn.support += value;                                         // Add support to the component\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportAddOn(addOn_idx, msg.sender, value);\n        if (addOn.support < addOn.threshold) return true;              // Threshold is not yet met\n        addOn.completed = true;\n        addOn.winner = msg.sender;\n        CompleteAddOn(addOn_idx, addOn.winner);\n        return true;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnSupport(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        return addOns[addOn_idx].support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnNeeded(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) return 0;\n        return addOn.threshold - addOn.support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnComplete(uint16 addOn_idx) view public returns (bool) {\n        if (addOn_idx >= addOnCount) return false;\n        return addOns[addOn_idx].completed;\n    }\n    \n    /* acquire a wildcard */\n    function acquireWildcard(uint16 wildcard_idx) public neverByOwner() returns (bool success) {\n        if (wildcard_idx >= wildcardCount) revert();                    // Check if the wildcard index is valid\n        var wildcard = wildcards[wildcard_idx];\n        if (balanceOf[msg.sender] < wildcard.cost) revert();            // Check if the sender has enough\n        if (wildcard.available < 1) revert();                           // Are there wildcards still available\n        balanceOf[msg.sender] -= wildcard.cost;                         // Subtract from the sender\n        wildcard.available -= 1;                                        // Subtract 1 wildcard from the deck\n        totalSupply -= wildcard.cost;                                   // Remove value from the totalSupply\n        wildcardsHeld[msg.sender][wildcard_idx] += 1;\n        CompleteWildcard(wildcard_idx, msg.sender);\n        return true;\n    }\n    \n    /* Get remaining wildcards */\n    function getWildcardsRemaining(uint16 wildcard_idx) view public returns (uint16) {\n        if (wildcard_idx >= wildcardCount) return 0;\n        return wildcards[wildcard_idx].available;\n    }\n}", "debug": "calldata_BachelorBucks_4 + calldata_BachelorBucks_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_12: 0xfffe00\nstorage_8: 0x0\ncaller: 0x0\ncalldata_BachelorBucks_0: 0x1b9e9a2700000000000000000000000000000000000000000000000000000000\ncalldatasize_BachelorBucks: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createComponent(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0xb8d9b579c32b88714dfe69c05d87bb3165892b04.sol", "function": "createComponent(string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11846, "code": "ntract BachelorBucks {\n    string public standard = 'BBUCK 1.0';\n    string public name = 'BachelorBucks';\n    string public symbol = 'BBUCK';\n    uint8 public decimals = 0;\n    uint256 public totalSupply = 1000000000;\n    uint256 public initialPrice = 1 ether / 1000;\n    uint256 public priceIncreasePerPurchase = 1 ether / 100000;\n    uint256 public currentPrice = initialPrice;\n    \n    address public owner = msg.sender;\n    uint256 public creationTime = now;\n    \n    struct Component {\n        string name;\n        uint16 index;\n        int256 currentSupport;\n        uint256 supported;\n        uint256 undermined;\n    }\n    \n    struct AddOn {\n        string name;\n        uint16 index;\n        uint256 support;\n        uint256 threshold;\n        bool completed;\n        address winner;\n    }\n    \n    struct Wildcard {\n        string name;\n        uint16 index;\n        uint256 cost;\n        uint16 available;\n    }\n    \n    /* Creates an array with all balances */\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n    \n    uint16 public componentCount = 0;\n    mapping (uint16 => Component) public components;\n    \n    uint16 public addOnCount = 0;\n    mapping (uint16 => AddOn) public addOns;\n    \n    uint16 public wildcardCount = 0;\n    mapping (uint16 => Wildcard) public wildcards;\n    mapping (address => mapping (uint16 => uint16)) public wildcardsHeld;\n\n    /* Generates a public event on the blockchain that will notify clients of transfers */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    \n    /* Generates a public event on the blockchain that will notify clients of purchases */\n    event Purchase(address indexed from, uint256 value);\n\n    /* Notifies clients about support for a component */\n    event SupportComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about undermine for a component */\n    event UndermineComponent(uint256 componentIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about support for an addOn */\n    event SupportAddOn(uint256 addOnIdx, address indexed from, uint256 value);\n    \n    /* Notifies clients about completion for an addOn */\n    event CompleteAddOn(uint256 addOnIdx, address indexed winner);\n\n    /* Notifies clients about wildcard completion */\n    event CompleteWildcard(uint256 wildcardIdx, address indexed caller);\n\n    modifier onlyByOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    modifier neverByOwner() {\n        require(msg.sender != owner);\n        _;\n    }\n    \n    /* Initializes contract with initial supply tokens to me */\n    function BachelorBucks() public {\n        balanceOf[msg.sender] = totalSupply;                    // Give the creator all initial tokens\n    }\n    \n    function createComponent(string componentName) public onlyByOwner() returns (bool success) {\n        if (componentCount > 65534) revert();\n        var component = components[componentCount];\n        component.name = componentName;\n        component.index = componentCount;\n        component.currentSupport = 0;\n        component.supported = 0;\n        component.undermined = 0;\n        componentCount += 1;\n        return true;\n    }\n    \n    function createAddOn(string addOnName, uint256 threshold) public onlyByOwner() returns (bool success) {\n        if (addOnCount > 65534) revert();\n        if (threshold == 0) revert();\n        var addOn = addOns[addOnCount];\n        addOn.name = addOnName;\n        addOn.index = addOnCount;\n        addOn.support = 0;\n        addOn.threshold = threshold;\n        addOn.completed = false;\n        addOn.winner = address(0x0);\n        addOnCount += 1;\n        return true;\n    }\n    \n    function createWildcard(string wildcardName, uint256 cost, uint16 number) public onlyByOwner() returns (bool success) {\n        if (wildcardCount > 65534) revert();\n        if (number == 0) revert();\n        if (cost == 0) revert();\n        var wildcard = wildcards[wildcardCount];\n        wildcard.name = wildcardName;\n        wildcard.index = wildcardCount;\n        wildcard.available = number;\n        wildcard.cost = cost;\n        wildcardCount += 1;\n        return true;\n    }\n    \n    function giveMeSomeBBUCKs() public payable returns (bool success) {\n        if (msg.value < currentPrice) revert();\n        uint256 amount = (msg.value / currentPrice);\n        if (balanceOf[owner] < amount) revert();\n        balanceOf[owner] -= amount;\n        balanceOf[msg.sender] += amount;\n        if ((currentPrice + priceIncreasePerPurchase) < currentPrice) return true; // Maximum price reached\n        currentPrice += priceIncreasePerPurchase;\n        return true;\n    }\n    \n    function() public payable { }                               // Thanks for the donation!\n    \n    function getBalance() view public returns (uint256) {\n        return balanceOf[msg.sender];\n    }\n    \n    function sweepToOwner() public onlyByOwner() returns (bool success) {\n        owner.transfer(this.balance);\n        return true;\n    }\n    \n    /* Send coins */\n    function transfer(address _to, uint256 _value) public {\n        if (_to == 0x0) revert();                               // Prevent transfer to 0x0 address\n        if (balanceOf[msg.sender] < _value) revert();           // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert(); // Check for overflows\n        balanceOf[msg.sender] -= _value;                        // Subtract from the sender\n        balanceOf[_to] += _value;                               // Add the same to the recipient\n        Transfer(msg.sender, _to, _value);                      // Notify anyone listening that this transfer took place\n    }\n\n    /* Allow another contract to spend some tokens on my behalf */\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert();\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    /* A contract attempts to get the coins */\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        if (_to == 0x0) revert();                                // Prevent transfer to 0x0 address\n        if (balanceOf[_from] < _value) revert();                 // Check if the sender has enough\n        if (balanceOf[_to] + _value < balanceOf[_to]) revert();  // Check for overflows\n        if (_value > allowance[_from][msg.sender]) revert();     // Check allowance\n        balanceOf[_from] -= _value;                              // Subtract from the sender\n        balanceOf[_to] += _value;                                // Add the same to the recipient\n        allowance[_from][msg.sender] -= _value;\n        Transfer(_from, _to, _value);\n        return true;\n    }\n\n\t/* Add support a component */\n    function supportComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.supported + value) < component.supported) revert();                    // Will adding support wrap the supported counter\n        if ((component.currentSupport + int256(value)) < component.currentSupport) revert();  // Will adding this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport += int256(value);                      // Add support to the component\n        component.supported += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportComponent(component_idx, msg.sender, value);\n        return true;\n    }\n    \n  /* Undermine support for a component */\n    function undermineComponent(uint16 component_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't subtract 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (component_idx >= componentCount) revert();                  // Check if the component index is valid\n        var component = components[component_idx];\n        if ((component.currentSupport - int256(value)) > component.currentSupport) revert();  // Will subtracting this much support wrap the component support\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        component.currentSupport -= int256(value);                      // Subtract support from the component\n        component.undermined += value;\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        UndermineComponent(component_idx, msg.sender, value);\n        return true;\n    }\n\n\t/* Get current component support */\n    function getComponentSupport(uint16 component_idx) view public returns (int256) {\n        if (component_idx >= componentCount) return 0;\n        return components[component_idx].currentSupport;\n    }\n    \n    /* Add support an addOn */\n    function supportAddOn(uint16 addOn_idx, uint256 value) public neverByOwner() returns (bool success) {\n        if (value == 0) revert();                                       // Can't add 0 support\n        if (balanceOf[msg.sender] < value) revert();                    // Check if the sender has enough\n        if (addOn_idx >= addOnCount) revert();                          // Check if the addon index is valid\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) revert();\n        if ((addOn.support + value) < addOn.support) revert();          // Will adding support wrap the support counter\n        balanceOf[msg.sender] -= value;                                 // Subtract from the sender\n        addOn.support += value;                                         // Add support to the component\n        totalSupply -= value;                                           // Remove value from the totalSupply\n        SupportAddOn(addOn_idx, msg.sender, value);\n        if (addOn.support < addOn.threshold) return true;              // Threshold is not yet met\n        addOn.completed = true;\n        addOn.winner = msg.sender;\n        CompleteAddOn(addOn_idx, addOn.winner);\n        return true;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnSupport(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        return addOns[addOn_idx].support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnNeeded(uint16 addOn_idx) view public returns (uint256) {\n        if (addOn_idx >= addOnCount) return 0;\n        var addOn = addOns[addOn_idx];\n        if (addOn.completed) return 0;\n        return addOn.threshold - addOn.support;\n    }\n    \n    /* Get current addOn support */\n    function getAddOnComplete(uint16 addOn_idx) view public returns (bool) {\n        if (addOn_idx >= addOnCount) return false;\n        return addOns[addOn_idx].completed;\n    }\n    \n    /* acquire a wildcard */\n    function acquireWildcard(uint16 wildcard_idx) public neverByOwner() returns (bool success) {\n        if (wildcard_idx >= wildcardCount) revert();                    // Check if the wildcard index is valid\n        var wildcard = wildcards[wildcard_idx];\n        if (balanceOf[msg.sender] < wildcard.cost) revert();            // Check if the sender has enough\n        if (wildcard.available < 1) revert();                           // Are there wildcards still available\n        balanceOf[msg.sender] -= wildcard.cost;                         // Subtract from the sender\n        wildcard.available -= 1;                                        // Subtract 1 wildcard from the deck\n        totalSupply -= wildcard.cost;                                   // Remove value from the totalSupply\n        wildcardsHeld[msg.sender][wildcard_idx] += 1;\n        CompleteWildcard(wildcard_idx, msg.sender);\n        return true;\n    }\n    \n    /* Get remaining wildcards */\n    function getWildcardsRemaining(uint16 wildcard_idx) view public returns (uint16) {\n        if (wildcard_idx >= wildcardCount) return 0;\n        return wildcards[wildcard_idx].available;\n    }\n}", "debug": "calldata_BachelorBucks_4 + calldata_BachelorBucks_4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_0_+_keccac_65535_&_65535_&_65535_&_UDiv(storage_12,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_12: 0xfffe00\nstorage_8: 0x0\ncaller: 0x0\ncalldata_BachelorBucks_0: 0x1b9e9a2700000000000000000000000000000000000000000000000000000000\ncalldatasize_BachelorBucks: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createComponent(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/13/0xb8d9b579c32b88714dfe69c05d87bb3165892b04.sol", "function": "createComponent(string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}