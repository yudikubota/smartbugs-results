{
  "contract": "0xdd91fa3b84b1080f3b618cbc47e06c57def689b9",
  "tool": "mythril",
  "start": 1563584757.3905492,
  "end": 1563585197.262281,
  "duration": 439.8717317581177,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1787,
        "code": "ion. The delay of the user who is trying\n    // to cancel must be lower",
        "debug": "",
        "description": "In the function `executeTransaction()` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "executeTransaction()",
        "lineno": 112,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 1787,
        "code": "ion. The delay of the user who is trying\n    // to cancel must be lower",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "executeTransaction()",
        "lineno": 112,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 1787,
        "code": "ion. The delay of the user who is trying\n    // to cancel must be lower",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function executeTransaction(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "executeTransaction()",
        "lineno": 112,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 2127,
        "code": ";\ncontract TrustWa",
        "debug": "storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6 +\n18569430475105882587588266137607568536673111973893317399460219858819262702939 +\n8*storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4 +\n18569430475105882587588266137607568536673111973893317399460219858819262702939 +\n8*storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2260,
        "code": "value: _value,\n            data: _data,\n            initiated_by: msg.sender,\n            time_initiated: now,\n            finalized_by: 0x0,\n            time_finalized: 0,\n            is_executed: false\n        }));\n    }\n\n    // Executes the transaction. The delay of the the transaction\n    // initiated_",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_0: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 86,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2489,
        "code": "modifier onlyActiveUsersAllowe",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TrustWallet_4: 0x0\nstorage_2: 0x0\ncalldata_TrustWallet_0: 0x502c9bd500000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "_function_0x502c9bd5",
        "lineno": 40,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3801,
        "code": "    mapping (address => User) pub",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TrustWallet_4: 0x0\nstorage_0: 0x0\ncalldata_TrustWallet_0: 0x9ace38c200000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "_function_0x9ace38c2",
        "lineno": 37,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5052,
        "code": ";\ncontract TrustWa",
        "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x1\nstorage_5 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0xd301719300000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TrustWallet_4: 0x0\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TrustWallet_4: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addUser(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "addUser(address,uint256)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5312,
        "code": "ontract TrustWallet {\n\n    struct User {\n        // How many seconds the user has to wait between initiating the\n        // transaction and finalizing the transaction. This cannot be\n        // changed.\n        uint delay;\n\n        address added_by;\n        uint time_added;\n\n        address removed_by;\n        uint time_removed;\n\n        // When this user added another user. (This is to prevent a user from\n        // adding many users too quickly).\n        uint time_added_another_user;\n    }\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n\n        address initiated_by;\n        uint time_initiated;\n\n        address finalized_by;\n        uint time_finalized;\n\n        // True if this trasaction was executed. If false, this means it was canceled.\n        bool is_executed;\n    }\n\n    Transaction[] public transactions;\n    mapping (address => User) public users;\n    address[] public userAddresses;\n\n    modifier onlyActiveUsersAllowed() {\n        require(users[msg.sender].time_added != 0);\n        require(users[msg.sender].time_removed == 0);\n        _;\n    }\n\n    modifier transactionMustBePending() {\n        require(isTransactionPending());\n        _;\n    }\n\n    modifier transactionMustNotBePending() {\n        require(!isTransactionPending());\n        _;\n    }\n\n    // Returns true if there is a transaction pending.\n    function isTransactionPending() internal constant returns (bool) {\n        if (transactions.length == 0) return false;\n        return transactions[transactions.length - 1].time_initiated > 0 &&\n            transactions[transactions.length - 1].time_finalized == 0;\n    }\n\n    // Constructor. Creates the first user.\n    function TrustWallet(address first_user) public {\n        users[first_user] = User({\n            delay: 0,\n            time_added: now,\n            added_by: 0x0,\n            time_removed: 0,\n            removed_by: 0x0,\n            time_added_another_user: now\n        });\n        userAddresses.push(first_user);\n    }\n\n    function () public payable {}\n\n    // Initiates a transaction. There must not be any pending transaction.\n    function initiateTransaction(address _destination, uint _value, bytes _data)\n        public\n        onlyActiveUsersAllowed()\n        transactionMustNotBePending()\n    {\n        transactions.push(Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            initiated_by: msg.sender,\n            time_initiated: now,\n            finalized_by: 0x0,\n            time_finalized: 0,\n            is_executed: false\n        }));\n    }\n\n    // Executes the transaction. The delay of the the transaction\n    // initiated_by must have passed in order to call this function. Any active\n    // user is able to call this function.\n    function executeTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(now > transaction.time_initiated + users[transaction.initiated_by].delay);\n        transaction.is_executed = true;\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n\n    // Cancels the transaction. The delay of the user who is trying\n    // to cancel must be lower or equal to the delay of the\n    // transaction initiated_by.\n    function cancelTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        // Either the sender is a higher priority user, or twice the waiting time of\n        // the user trying to cancel has passed. This is to prevent transactions from\n        // getting \"stuck\" if the call() fails when trying to execute the transaction.\n        require(users[msg.sender].delay <= users[transaction.initiated_by].delay ||\n            now - transaction.time_initiated > users[msg.sender].delay * 2);\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n    }\n\n    // Adds a user to the wallet. The waiting time of the new user must\n    // be greater or equal to the delay of the sender. A user that\n    // already exists or was removed cannot be added. To prevent spam,\n    // a user must wait delay before adding another user.\n    function addUser(address new_user, uint new_user_time)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[new_user].time_added == 0);\n        require(users[new_user].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(now > sender.delay + sender.time_added_another_user);\n        require(new_user_time >= sender.delay);\n\n        sender.time_added_another_user = now;\n        users[new_user] = User({\n            delay: new_user_time,\n            time_added: now,\n            added_by: msg.sender,\n            time_removed: 0,\n            removed_by: 0x0,\n            // The new user will have to wait one delay before being\n            // able to add a new user.\n            time_added_another_user: now\n        });\n        userAddresses.push(new_user);\n    }\n\n    // Removes a user. The sender must have a lower or equal delay\n    // as the user that she is trying to remove.\n    function removeUser(address userAddr)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[userAddr].time_added != 0);\n        require(users[userAddr].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(sender.delay <= users[userAddr].delay);\n\n        users[userAddr].removed_by = msg.sender;\n        users[userAddr].time_removed = now;\n    }\n}",
        "debug": "keccac_2_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n8*storage_0: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_2 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n8*storage_0: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_0: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5341,
        "code": "ontract TrustWallet {\n\n    struct User {\n        // How many seconds the user has to wait between initiating the\n        // transaction and finalizing the transaction. This cannot be\n        // changed.\n        uint delay;\n\n        address added_by;\n        uint time_added;\n\n        address removed_by;\n        uint time_removed;\n\n        // When this user added another user. (This is to prevent a user from\n        // adding many users too quickly).\n        uint time_added_another_user;\n    }\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n\n        address initiated_by;\n        uint time_initiated;\n\n        address finalized_by;\n        uint time_finalized;\n\n        // True if this trasaction was executed. If false, this means it was canceled.\n        bool is_executed;\n    }\n\n    Transaction[] public transactions;\n    mapping (address => User) public users;\n    address[] public userAddresses;\n\n    modifier onlyActiveUsersAllowed() {\n        require(users[msg.sender].time_added != 0);\n        require(users[msg.sender].time_removed == 0);\n        _;\n    }\n\n    modifier transactionMustBePending() {\n        require(isTransactionPending());\n        _;\n    }\n\n    modifier transactionMustNotBePending() {\n        require(!isTransactionPending());\n        _;\n    }\n\n    // Returns true if there is a transaction pending.\n    function isTransactionPending() internal constant returns (bool) {\n        if (transactions.length == 0) return false;\n        return transactions[transactions.length - 1].time_initiated > 0 &&\n            transactions[transactions.length - 1].time_finalized == 0;\n    }\n\n    // Constructor. Creates the first user.\n    function TrustWallet(address first_user) public {\n        users[first_user] = User({\n            delay: 0,\n            time_added: now,\n            added_by: 0x0,\n            time_removed: 0,\n            removed_by: 0x0,\n            time_added_another_user: now\n        });\n        userAddresses.push(first_user);\n    }\n\n    function () public payable {}\n\n    // Initiates a transaction. There must not be any pending transaction.\n    function initiateTransaction(address _destination, uint _value, bytes _data)\n        public\n        onlyActiveUsersAllowed()\n        transactionMustNotBePending()\n    {\n        transactions.push(Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            initiated_by: msg.sender,\n            time_initiated: now,\n            finalized_by: 0x0,\n            time_finalized: 0,\n            is_executed: false\n        }));\n    }\n\n    // Executes the transaction. The delay of the the transaction\n    // initiated_by must have passed in order to call this function. Any active\n    // user is able to call this function.\n    function executeTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(now > transaction.time_initiated + users[transaction.initiated_by].delay);\n        transaction.is_executed = true;\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n\n    // Cancels the transaction. The delay of the user who is trying\n    // to cancel must be lower or equal to the delay of the\n    // transaction initiated_by.\n    function cancelTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        // Either the sender is a higher priority user, or twice the waiting time of\n        // the user trying to cancel has passed. This is to prevent transactions from\n        // getting \"stuck\" if the call() fails when trying to execute the transaction.\n        require(users[msg.sender].delay <= users[transaction.initiated_by].delay ||\n            now - transaction.time_initiated > users[msg.sender].delay * 2);\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n    }\n\n    // Adds a user to the wallet. The waiting time of the new user must\n    // be greater or equal to the delay of the sender. A user that\n    // already exists or was removed cannot be added. To prevent spam,\n    // a user must wait delay before adding another user.\n    function addUser(address new_user, uint new_user_time)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[new_user].time_added == 0);\n        require(users[new_user].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(now > sender.delay + sender.time_added_another_user);\n        require(new_user_time >= sender.delay);\n\n        sender.time_added_another_user = now;\n        users[new_user] = User({\n            delay: new_user_time,\n            time_added: now,\n            added_by: msg.sender,\n            time_removed: 0,\n            removed_by: 0x0,\n            // The new user will have to wait one delay before being\n            // able to add a new user.\n            time_added_another_user: now\n        });\n        userAddresses.push(new_user);\n    }\n\n    // Removes a user. The sender must have a lower or equal delay\n    // as the user that she is trying to remove.\n    function removeUser(address userAddr)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[userAddr].time_added != 0);\n        require(users[userAddr].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(sender.delay <= users[userAddr].delay);\n\n        users[userAddr].removed_by = msg.sender;\n        users[userAddr].time_removed = now;\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_0: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5355,
        "code": "ontract TrustWallet {\n\n    struct User {\n        // How many seconds the user has to wait between initiating the\n        // transaction and finalizing the transaction. This cannot be\n        // changed.\n        uint delay;\n\n        address added_by;\n        uint time_added;\n\n        address removed_by;\n        uint time_removed;\n\n        // When this user added another user. (This is to prevent a user from\n        // adding many users too quickly).\n        uint time_added_another_user;\n    }\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n\n        address initiated_by;\n        uint time_initiated;\n\n        address finalized_by;\n        uint time_finalized;\n\n        // True if this trasaction was executed. If false, this means it was canceled.\n        bool is_executed;\n    }\n\n    Transaction[] public transactions;\n    mapping (address => User) public users;\n    address[] public userAddresses;\n\n    modifier onlyActiveUsersAllowed() {\n        require(users[msg.sender].time_added != 0);\n        require(users[msg.sender].time_removed == 0);\n        _;\n    }\n\n    modifier transactionMustBePending() {\n        require(isTransactionPending());\n        _;\n    }\n\n    modifier transactionMustNotBePending() {\n        require(!isTransactionPending());\n        _;\n    }\n\n    // Returns true if there is a transaction pending.\n    function isTransactionPending() internal constant returns (bool) {\n        if (transactions.length == 0) return false;\n        return transactions[transactions.length - 1].time_initiated > 0 &&\n            transactions[transactions.length - 1].time_finalized == 0;\n    }\n\n    // Constructor. Creates the first user.\n    function TrustWallet(address first_user) public {\n        users[first_user] = User({\n            delay: 0,\n            time_added: now,\n            added_by: 0x0,\n            time_removed: 0,\n            removed_by: 0x0,\n            time_added_another_user: now\n        });\n        userAddresses.push(first_user);\n    }\n\n    function () public payable {}\n\n    // Initiates a transaction. There must not be any pending transaction.\n    function initiateTransaction(address _destination, uint _value, bytes _data)\n        public\n        onlyActiveUsersAllowed()\n        transactionMustNotBePending()\n    {\n        transactions.push(Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            initiated_by: msg.sender,\n            time_initiated: now,\n            finalized_by: 0x0,\n            time_finalized: 0,\n            is_executed: false\n        }));\n    }\n\n    // Executes the transaction. The delay of the the transaction\n    // initiated_by must have passed in order to call this function. Any active\n    // user is able to call this function.\n    function executeTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(now > transaction.time_initiated + users[transaction.initiated_by].delay);\n        transaction.is_executed = true;\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n\n    // Cancels the transaction. The delay of the user who is trying\n    // to cancel must be lower or equal to the delay of the\n    // transaction initiated_by.\n    function cancelTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        // Either the sender is a higher priority user, or twice the waiting time of\n        // the user trying to cancel has passed. This is to prevent transactions from\n        // getting \"stuck\" if the call() fails when trying to execute the transaction.\n        require(users[msg.sender].delay <= users[transaction.initiated_by].delay ||\n            now - transaction.time_initiated > users[msg.sender].delay * 2);\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n    }\n\n    // Adds a user to the wallet. The waiting time of the new user must\n    // be greater or equal to the delay of the sender. A user that\n    // already exists or was removed cannot be added. To prevent spam,\n    // a user must wait delay before adding another user.\n    function addUser(address new_user, uint new_user_time)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[new_user].time_added == 0);\n        require(users[new_user].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(now > sender.delay + sender.time_added_another_user);\n        require(new_user_time >= sender.delay);\n\n        sender.time_added_another_user = now;\n        users[new_user] = User({\n            delay: new_user_time,\n            time_added: now,\n            added_by: msg.sender,\n            time_removed: 0,\n            removed_by: 0x0,\n            // The new user will have to wait one delay before being\n            // able to add a new user.\n            time_added_another_user: now\n        });\n        userAddresses.push(new_user);\n    }\n\n    // Removes a user. The sender must have a lower or equal delay\n    // as the user that she is trying to remove.\n    function removeUser(address userAddr)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[userAddr].time_added != 0);\n        require(users[userAddr].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(sender.delay <= users[userAddr].delay);\n\n        users[userAddr].removed_by = msg.sender;\n        users[userAddr].time_removed = now;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_0: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5372,
        "code": "ontract TrustWallet {\n\n    struct User {\n        // How many seconds the user has to wait between initiating the\n        // transaction and finalizing the transaction. This cannot be\n        // changed.\n        uint delay;\n\n        address added_by;\n        uint time_added;\n\n        address removed_by;\n        uint time_removed;\n\n        // When this user added another user. (This is to prevent a user from\n        // adding many users too quickly).\n        uint time_added_another_user;\n    }\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n\n        address initiated_by;\n        uint time_initiated;\n\n        address finalized_by;\n        uint time_finalized;\n\n        // True if this trasaction was executed. If false, this means it was canceled.\n        bool is_executed;\n    }\n\n    Transaction[] public transactions;\n    mapping (address => User) public users;\n    address[] public userAddresses;\n\n    modifier onlyActiveUsersAllowed() {\n        require(users[msg.sender].time_added != 0);\n        require(users[msg.sender].time_removed == 0);\n        _;\n    }\n\n    modifier transactionMustBePending() {\n        require(isTransactionPending());\n        _;\n    }\n\n    modifier transactionMustNotBePending() {\n        require(!isTransactionPending());\n        _;\n    }\n\n    // Returns true if there is a transaction pending.\n    function isTransactionPending() internal constant returns (bool) {\n        if (transactions.length == 0) return false;\n        return transactions[transactions.length - 1].time_initiated > 0 &&\n            transactions[transactions.length - 1].time_finalized == 0;\n    }\n\n    // Constructor. Creates the first user.\n    function TrustWallet(address first_user) public {\n        users[first_user] = User({\n            delay: 0,\n            time_added: now,\n            added_by: 0x0,\n            time_removed: 0,\n            removed_by: 0x0,\n            time_added_another_user: now\n        });\n        userAddresses.push(first_user);\n    }\n\n    function () public payable {}\n\n    // Initiates a transaction. There must not be any pending transaction.\n    function initiateTransaction(address _destination, uint _value, bytes _data)\n        public\n        onlyActiveUsersAllowed()\n        transactionMustNotBePending()\n    {\n        transactions.push(Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            initiated_by: msg.sender,\n            time_initiated: now,\n            finalized_by: 0x0,\n            time_finalized: 0,\n            is_executed: false\n        }));\n    }\n\n    // Executes the transaction. The delay of the the transaction\n    // initiated_by must have passed in order to call this function. Any active\n    // user is able to call this function.\n    function executeTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(now > transaction.time_initiated + users[transaction.initiated_by].delay);\n        transaction.is_executed = true;\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n\n    // Cancels the transaction. The delay of the user who is trying\n    // to cancel must be lower or equal to the delay of the\n    // transaction initiated_by.\n    function cancelTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        // Either the sender is a higher priority user, or twice the waiting time of\n        // the user trying to cancel has passed. This is to prevent transactions from\n        // getting \"stuck\" if the call() fails when trying to execute the transaction.\n        require(users[msg.sender].delay <= users[transaction.initiated_by].delay ||\n            now - transaction.time_initiated > users[msg.sender].delay * 2);\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n    }\n\n    // Adds a user to the wallet. The waiting time of the new user must\n    // be greater or equal to the delay of the sender. A user that\n    // already exists or was removed cannot be added. To prevent spam,\n    // a user must wait delay before adding another user.\n    function addUser(address new_user, uint new_user_time)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[new_user].time_added == 0);\n        require(users[new_user].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(now > sender.delay + sender.time_added_another_user);\n        require(new_user_time >= sender.delay);\n\n        sender.time_added_another_user = now;\n        users[new_user] = User({\n            delay: new_user_time,\n            time_added: now,\n            added_by: msg.sender,\n            time_removed: 0,\n            removed_by: 0x0,\n            // The new user will have to wait one delay before being\n            // able to add a new user.\n            time_added_another_user: now\n        });\n        userAddresses.push(new_user);\n    }\n\n    // Removes a user. The sender must have a lower or equal delay\n    // as the user that she is trying to remove.\n    function removeUser(address userAddr)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[userAddr].time_added != 0);\n        require(users[userAddr].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(sender.delay <= users[userAddr].delay);\n\n        users[userAddr].removed_by = msg.sender;\n        users[userAddr].time_removed = now;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0x25\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_0: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5377,
        "code": "ontract TrustWallet {\n\n    struct User {\n        // How many seconds the user has to wait between initiating the\n        // transaction and finalizing the transaction. This cannot be\n        // changed.\n        uint delay;\n\n        address added_by;\n        uint time_added;\n\n        address removed_by;\n        uint time_removed;\n\n        // When this user added another user. (This is to prevent a user from\n        // adding many users too quickly).\n        uint time_added_another_user;\n    }\n\n    struct Transaction {\n        address destination;\n        uint value;\n        bytes data;\n\n        address initiated_by;\n        uint time_initiated;\n\n        address finalized_by;\n        uint time_finalized;\n\n        // True if this trasaction was executed. If false, this means it was canceled.\n        bool is_executed;\n    }\n\n    Transaction[] public transactions;\n    mapping (address => User) public users;\n    address[] public userAddresses;\n\n    modifier onlyActiveUsersAllowed() {\n        require(users[msg.sender].time_added != 0);\n        require(users[msg.sender].time_removed == 0);\n        _;\n    }\n\n    modifier transactionMustBePending() {\n        require(isTransactionPending());\n        _;\n    }\n\n    modifier transactionMustNotBePending() {\n        require(!isTransactionPending());\n        _;\n    }\n\n    // Returns true if there is a transaction pending.\n    function isTransactionPending() internal constant returns (bool) {\n        if (transactions.length == 0) return false;\n        return transactions[transactions.length - 1].time_initiated > 0 &&\n            transactions[transactions.length - 1].time_finalized == 0;\n    }\n\n    // Constructor. Creates the first user.\n    function TrustWallet(address first_user) public {\n        users[first_user] = User({\n            delay: 0,\n            time_added: now,\n            added_by: 0x0,\n            time_removed: 0,\n            removed_by: 0x0,\n            time_added_another_user: now\n        });\n        userAddresses.push(first_user);\n    }\n\n    function () public payable {}\n\n    // Initiates a transaction. There must not be any pending transaction.\n    function initiateTransaction(address _destination, uint _value, bytes _data)\n        public\n        onlyActiveUsersAllowed()\n        transactionMustNotBePending()\n    {\n        transactions.push(Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            initiated_by: msg.sender,\n            time_initiated: now,\n            finalized_by: 0x0,\n            time_finalized: 0,\n            is_executed: false\n        }));\n    }\n\n    // Executes the transaction. The delay of the the transaction\n    // initiated_by must have passed in order to call this function. Any active\n    // user is able to call this function.\n    function executeTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        require(now > transaction.time_initiated + users[transaction.initiated_by].delay);\n        transaction.is_executed = true;\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n        require(transaction.destination.call.value(transaction.value)(transaction.data));\n    }\n\n    // Cancels the transaction. The delay of the user who is trying\n    // to cancel must be lower or equal to the delay of the\n    // transaction initiated_by.\n    function cancelTransaction()\n        public\n        onlyActiveUsersAllowed()\n        transactionMustBePending()\n    {\n        Transaction storage transaction = transactions[transactions.length - 1];\n        // Either the sender is a higher priority user, or twice the waiting time of\n        // the user trying to cancel has passed. This is to prevent transactions from\n        // getting \"stuck\" if the call() fails when trying to execute the transaction.\n        require(users[msg.sender].delay <= users[transaction.initiated_by].delay ||\n            now - transaction.time_initiated > users[msg.sender].delay * 2);\n        transaction.time_finalized = now;\n        transaction.finalized_by = msg.sender;\n    }\n\n    // Adds a user to the wallet. The waiting time of the new user must\n    // be greater or equal to the delay of the sender. A user that\n    // already exists or was removed cannot be added. To prevent spam,\n    // a user must wait delay before adding another user.\n    function addUser(address new_user, uint new_user_time)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[new_user].time_added == 0);\n        require(users[new_user].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(now > sender.delay + sender.time_added_another_user);\n        require(new_user_time >= sender.delay);\n\n        sender.time_added_another_user = now;\n        users[new_user] = User({\n            delay: new_user_time,\n            time_added: now,\n            added_by: msg.sender,\n            time_removed: 0,\n            removed_by: 0x0,\n            // The new user will have to wait one delay before being\n            // able to add a new user.\n            time_added_another_user: now\n        });\n        userAddresses.push(new_user);\n    }\n\n    // Removes a user. The sender must have a lower or equal delay\n    // as the user that she is trying to remove.\n    function removeUser(address userAddr)\n        public\n        onlyActiveUsersAllowed()\n    {\n        require(users[userAddr].time_added != 0);\n        require(users[userAddr].time_removed == 0);\n\n        User storage sender = users[msg.sender];\n        require(sender.delay <= users[userAddr].delay);\n\n        users[userAddr].removed_by = msg.sender;\n        users[userAddr].time_removed = now;\n    }\n}",
        "debug": "keccac_2_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n8*storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrustWallet_4 + calldata_TrustWallet_32 + 36)) +\n64: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrustWallet_0: 0x263a6d7900000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustWallet: 0x4\nstorage_0: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `initiateTransaction(address,uint256,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/19/0xdd91fa3b84b1080f3b618cbc47e06c57def689b9.sol",
        "function": "initiateTransaction(address,uint256,bytes)",
        "lineno": 2,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}