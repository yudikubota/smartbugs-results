{
  "contract": "0x128eb016a48ea9c451ffd802379d24b60b3da304",
  "tool": "mythril",
  "start": 1563701584.1544502,
  "end": 1563703128.7810755,
  "duration": 1544.6266252994537,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 169,
        "code": "tToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@",
        "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "distributeFixed(uint256,address[],uint256)",
        "lineno": 94,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 181,
        "code": "tToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@",
        "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "distributeFixed(uint256,address[],uint256)",
        "lineno": 94,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 184,
        "code": "tToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@",
        "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "distributeFixed(uint256,address[],uint256)",
        "lineno": 94,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 190,
        "code": "tToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@",
        "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "distributeFixed(uint256,address[],uint256)",
        "lineno": 94,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 580,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 592,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 595,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 601,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 647,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 659,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 662,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 668,
        "code": "drs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified add",
        "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x3a37216edf01e4bff3729856012c233625106ffffffffffffffffffffffffff\ncalldata_Token_4 + calldata_Token_32 + 4: 0x67cfc752d384fdac7c76a8166cd8454d89836fffffffffffffffffffffffffc\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 73,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 746,
        "code": "unt,\n   string _name,\n   uint _countDown,\n   address  _smartContract\n   \n   )\n   public\n   minEth\n   payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount)\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        idCounter = airdrop.id+1;\n   }\n\n    ///@notice  Distirbutes a differen quantity of tokens to ",
        "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 43,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1920,
        "code": " public airdrops;\n    addr",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\ncalldata_Token_0: 0x60db508200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x60db5082",
        "lineno": 11,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3319,
        "code": "ex = airdrops.len",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 55,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 3392,
        "code": "irdrops[lastIndex",
        "debug": "storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_3319: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3419,
        "code": "     airdrop.tokenA",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_3319: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 58,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3446,
        "code": "kenAmount;\n        ai",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 58,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3455,
        "code": "_name;\n        airdrop.countDown=_",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 59,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3489,
        "code": " msg.sender;\n        airdrop",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 61,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3556,
        "code": "Token(_smartContract);\n        i",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 62,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3623,
        "code": "airdrop.id+1;\n   }\n\n    ///@notice  Dis",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 63,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3632,
        "code": "ntity of tok",
        "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18569430475105882587588266137607568536673111973893317399460219858819262702949: 0x8\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4 + calldata_Token_32 + 4: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_4: 0x1\nreturndatasize: 0x20\nretval_3319: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 66,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3637,
        "code": "differen quantity of tok",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 66,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3761,
        "code": "drop is due to ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0xba7bd2aa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "withdrawTokens(uint256,uint256)",
        "lineno": 122,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4358,
        "code": "ted or not.\n    ///@dev Distribution wi",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "withdrawTokens(uint256,uint256)",
        "lineno": 122,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 4576,
        "code": " (false);\n    }",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 129,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4599,
        "code": "true);\n      }else return (false);\n    }",
        "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x533358015344362235a3bbb878130055345dc0c70e060460c00000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0x2ccca7feacbbc9ddca5c444787ecffaacba23f38f1f9fb9f3ffffffffffffed\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 128,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4679,
        "code": "true);\n      }else return (false);\n    }",
        "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x1f0100000000000000000000000000000000000000000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0x60fefffffffffffffffffffffffffffffffffffffffffffffffffffffffffe7\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 128,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4735,
        "code": "true);\n      }else return (false);\n    }",
        "debug": "storage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_Token_4 +\n2: 0xc4f88fdf64030503d7390bd1af2e1acc7ba5930f33de5e7741de7fffffffffc1\ncalldata_Token_4 + calldata_Token_32 + 36: 0x3824840387296c56128b9629800000120304002040000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0x237cf6bd7c1fa121fe27c5bf236de6d2b5fbb5d91ac56041ef885dffffbfff2\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 128,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4759,
        "code": "true);\n      }else return (false);\n    }",
        "debug": "storage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_Token_4 +\n2: 0xf7ffffffffffefffff7efef1dffdffdf7eff97fffffddcb37ffbf7d7f8b3d601\ncalldata_Token_4 + calldata_Token_32 + 36: 0x40a0590f0000000000000000000000000000000000000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0x3f5fa6f0fffffffffffffffffffffffffffffffffffffffffffffffffffffe6\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 128,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5588,
        "code": "wner\n   {\n      r",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "distributeFixed(uint256,address[],uint256)",
        "lineno": 144,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 5661,
        "code": "Axioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\n    modifier minEth {\n        require(msg.value >= 2000); //Change this to amount of eth we want in GWEI!\n        _;\n    }\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n   uint _tokenAmount,\n   string _name,\n   uint _countDown,\n   address  _smartContract\n   \n   )\n   public\n   minEth\n   payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount)\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        idCounter = airdrop.id+1;\n   }\n\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _amount  The value to be distributed to each address in array form.\n    function withdrawTokens(\n        uint index,\n        uint _amount\n    )\n        public\n        onlyOwner\n    {\n        Airdrop memory airdrop = airdrops[index];\n        airdrop.tokenSC.transfer(owner,_amount);\n    }\n    \n    ///@notice  Determines whether an aidrop is due to be distributed or not.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n   function timeGone(uint index) private view returns(bool){\n      Airdrop memory airdrop = airdrops[index];\n      uint timenow=now;\n      if ( airdrop.countDown <timenow){\n          return (true);\n      }else return (false);\n    }\n  \n    ///@notice  Get the balance of a specific token within the smart contracts\n   function getTokensBalance(uint index) private view returns(uint) {\n        Airdrop memory airdrop = airdrops[index];\n        Token t = Token(airdrop.tokenSC);\n        return (t.balanceOf(this));\n    }\n  \n  function withdrawLeftOverEth (\n      uint amount,\n      address receiver\n    )\n      public \n      onlyOwner\n   {\n      receiver.transfer(amount);\n   }\n}",
        "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x73a0050390000c03431011496a80040301e5f9f3a8000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0xc5ffafc6ffff3fcbcefeeb6957ffbfcfe1a060c57ffffffffffffffffffff8\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "_function_0x71784312",
        "lineno": 10,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5841,
        "code": "Axioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\n    modifier minEth {\n        require(msg.value >= 2000); //Change this to amount of eth we want in GWEI!\n        _;\n    }\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n   uint _tokenAmount,\n   string _name,\n   uint _countDown,\n   address  _smartContract\n   \n   )\n   public\n   minEth\n   payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount)\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        idCounter = airdrop.id+1;\n   }\n\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _amount  The value to be distributed to each address in array form.\n    function withdrawTokens(\n        uint index,\n        uint _amount\n    )\n        public\n        onlyOwner\n    {\n        Airdrop memory airdrop = airdrops[index];\n        airdrop.tokenSC.transfer(owner,_amount);\n    }\n    \n    ///@notice  Determines whether an aidrop is due to be distributed or not.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n   function timeGone(uint index) private view returns(bool){\n      Airdrop memory airdrop = airdrops[index];\n      uint timenow=now;\n      if ( airdrop.countDown <timenow){\n          return (true);\n      }else return (false);\n    }\n  \n    ///@notice  Get the balance of a specific token within the smart contracts\n   function getTokensBalance(uint index) private view returns(uint) {\n        Airdrop memory airdrop = airdrops[index];\n        Token t = Token(airdrop.tokenSC);\n        return (t.balanceOf(this));\n    }\n  \n  function withdrawLeftOverEth (\n      uint amount,\n      address receiver\n    )\n      public \n      onlyOwner\n   {\n      receiver.transfer(amount);\n   }\n}",
        "debug": "storage_2 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*storage_0: 0x7403a9bcd8faddf5d1e685cff3ba22e265c519effac9cb3ec6759905c67efc51\nstorage_0: 0x413eb400000002088020000002000010576c118a884fd9a3152000004b020000\nkeccac_2_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n6*storage_0: 0xff8007b08649eba518062bad4024f63b0581e1673f0b574bf7ba80dfcf20ca00\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_3319: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 10,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5870,
        "code": "Axioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\n    modifier minEth {\n        require(msg.value >= 2000); //Change this to amount of eth we want in GWEI!\n        _;\n    }\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n   uint _tokenAmount,\n   string _name,\n   uint _countDown,\n   address  _smartContract\n   \n   )\n   public\n   minEth\n   payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount)\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        idCounter = airdrop.id+1;\n   }\n\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _amount  The value to be distributed to each address in array form.\n    function withdrawTokens(\n        uint index,\n        uint _amount\n    )\n        public\n        onlyOwner\n    {\n        Airdrop memory airdrop = airdrops[index];\n        airdrop.tokenSC.transfer(owner,_amount);\n    }\n    \n    ///@notice  Determines whether an aidrop is due to be distributed or not.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n   function timeGone(uint index) private view returns(bool){\n      Airdrop memory airdrop = airdrops[index];\n      uint timenow=now;\n      if ( airdrop.countDown <timenow){\n          return (true);\n      }else return (false);\n    }\n  \n    ///@notice  Get the balance of a specific token within the smart contracts\n   function getTokensBalance(uint index) private view returns(uint) {\n        Airdrop memory airdrop = airdrops[index];\n        Token t = Token(airdrop.tokenSC);\n        return (t.balanceOf(this));\n    }\n  \n  function withdrawLeftOverEth (\n      uint amount,\n      address receiver\n    )\n      public \n      onlyOwner\n   {\n      receiver.transfer(amount);\n   }\n}",
        "debug": "storage_0: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_4 + calldata_Token_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_3319: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 10,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5875,
        "code": "Axioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\n    modifier minEth {\n        require(msg.value >= 2000); //Change this to amount of eth we want in GWEI!\n        _;\n    }\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n   uint _tokenAmount,\n   string _name,\n   uint _countDown,\n   address  _smartContract\n   \n   )\n   public\n   minEth\n   payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount)\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        idCounter = airdrop.id+1;\n   }\n\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _amount  The value to be distributed to each address in array form.\n    function withdrawTokens(\n        uint index,\n        uint _amount\n    )\n        public\n        onlyOwner\n    {\n        Airdrop memory airdrop = airdrops[index];\n        airdrop.tokenSC.transfer(owner,_amount);\n    }\n    \n    ///@notice  Determines whether an aidrop is due to be distributed or not.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n   function timeGone(uint index) private view returns(bool){\n      Airdrop memory airdrop = airdrops[index];\n      uint timenow=now;\n      if ( airdrop.countDown <timenow){\n          return (true);\n      }else return (false);\n    }\n  \n    ///@notice  Get the balance of a specific token within the smart contracts\n   function getTokensBalance(uint index) private view returns(uint) {\n        Airdrop memory airdrop = airdrops[index];\n        Token t = Token(airdrop.tokenSC);\n        return (t.balanceOf(this));\n    }\n  \n  function withdrawLeftOverEth (\n      uint amount,\n      address receiver\n    )\n      public \n      onlyOwner\n   {\n      receiver.transfer(amount);\n   }\n}",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 10,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 5884,
        "code": "Axioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount fo ether for the function to add and airdrop\n    modifier minEth {\n        require(msg.value >= 2000); //Change this to amount of eth we want in GWEI!\n        _;\n    }\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract.\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n   uint _tokenAmount,\n   string _name,\n   uint _countDown,\n   address  _smartContract\n   \n   )\n   public\n   minEth\n   payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount)\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        idCounter = airdrop.id+1;\n   }\n\n    ///@notice  Distirbutes a differen quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n\n    ///@notice  Distributes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index The airdrop token to withdraw based in the the array in which is saved\n    ///@param _amoutToEach  The amount to be withdrawn from the smart contract\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true && getTokensBalance(index)>= airdrop.tokenAmount) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Airdrop was NOT added\");\n    }\n    \n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _amount  The value to be distributed to each address in array form.\n    function withdrawTokens(\n        uint index,\n        uint _amount\n    )\n        public\n        onlyOwner\n    {\n        Airdrop memory airdrop = airdrops[index];\n        airdrop.tokenSC.transfer(owner,_amount);\n    }\n    \n    ///@notice  Determines whether an aidrop is due to be distributed or not.\n    ///@dev Distribution will only occur when a distribute function is called, and passed the correct parameters, it is not the smart contracts job to produce the addresses or determine the ammount\n   function timeGone(uint index) private view returns(bool){\n      Airdrop memory airdrop = airdrops[index];\n      uint timenow=now;\n      if ( airdrop.countDown <timenow){\n          return (true);\n      }else return (false);\n    }\n  \n    ///@notice  Get the balance of a specific token within the smart contracts\n   function getTokensBalance(uint index) private view returns(uint) {\n        Airdrop memory airdrop = airdrops[index];\n        Token t = Token(airdrop.tokenSC);\n        return (t.balanceOf(this));\n    }\n  \n  function withdrawLeftOverEth (\n      uint amount,\n      address receiver\n    )\n      public \n      onlyOwner\n   {\n      receiver.transfer(amount);\n   }\n}",
        "debug": "storage_0: 0x3164cdbbd7715000000000000000000000000000000000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_3319: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n",
        "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/34/0x128eb016a48ea9c451ffd802379d24b60b3da304.sol",
        "function": "addNewAirdrop(uint256,string,uint256,address)",
        "lineno": 10,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}