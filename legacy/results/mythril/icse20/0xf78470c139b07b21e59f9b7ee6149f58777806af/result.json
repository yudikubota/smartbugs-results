{
  "contract": "0xf78470c139b07b21e59f9b7ee6149f58777806af",
  "tool": "mythril",
  "start": 1563513370.119755,
  "end": 1563513515.6237998,
  "duration": 145.50404477119446,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1178,
        "code": ",) = getBestBidder(index);\n        if (bestBidder != who) {\n            minNeededBid = getMinAllowedBid(index) - currentBid;\n        }\n\n        uint256 bank = totalJackpot / 2;\n        bank += totalBank;\n\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, feePercent), 100));\n        bank -= fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, jackpotPercent), 100));\n        bank -= jackpotFill;\n\n        expectedProfit = bank;\n    }\n\n    function bid(string word) public payable notPaused {\n        uint index = idByWord[word];\n        require(index > 0);\n        addBid(msg.sender, index, msg.value);\n    }\n\n    /* FEED TRUMP TWEET */\n\n    function hasSubstring(string haystack, string needle) private pure returns (bool) {\n        uint needleSize = bytes(need",
        "debug": "calldata_TrumpBingo_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrumpBingo_0: 0x45b581a200000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getPotentialProfit(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "getPotentialProfit(address,string)",
        "lineno": 315,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1310,
        "code": "word: word, disabled: false})) - 1;\n        idByWord[word] = index;\n        bids.length = words.length;\n        WordSetChanged();\n    }\n\n    function delWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index > 0);\n        require(bids[index].bestBid",
        "debug": "calldata_TrumpBingo_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrumpBingo_0: 0x4974da8100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "addWord(string)",
        "lineno": 150,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1731,
        "code": "ddress(0));\n        idByWord[word] = 0;\n        words[index].disabled = true;\n        WordSetChanged();\n    }\n\n    /* WINNERS MANAGEMENT */\n    uint public prevTweetTime;\n    uint256 public prevRoundTweetId;\n    struct WinnerInfo {\n        address who;\n        uint256 ho",
        "debug": "calldata_TrumpBingo_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrumpBingo_0: 0x72ccd03a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `delWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "delWord(string)",
        "lineno": 159,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4241,
        "code": ";\n\nlibrary SafeMat",
        "debug": "storage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TrumpBingo_4 + calldata_TrumpBingo_4: 0x40\nstorage_4: 0x0\ncaller: 0x0\ncalldata_TrumpBingo_0: 0x4974da8100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\nstorage_KECCAC_mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4))): 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "addWord(string)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4293,
        "code": "  }\n\n    function delWord(string word) public o",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_TrumpBingo_4 + calldata_TrumpBingo_4: 0x1f\nstorage_4: 0x0\ncaller: 0x0\ncalldata_TrumpBingo_0: 0x4974da8100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\nstorage_KECCAC_mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4))): 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "addWord(string)",
        "lineno": 154,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4858,
        "code": "ordIndex].bestB",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TrumpBingo_4: 0x0\nstorage_17: 0x0\ncalldata_TrumpBingo_0: 0x6ac68f7f00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "getBestBidder(uint256)",
        "lineno": 227,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8007,
        "code": ";\n        for (",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_KECCAC_mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_32 + 4))): 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TrumpBingo_4 + calldata_TrumpBingo_32 + 4: 0x40\nstorage_17: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TrumpBingo_0: 0x45b581a200000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "getPotentialProfit(address,string)",
        "lineno": 243,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10541,
        "code": "GLOBAL CONSTANTS */\n    uint256 private minBid = 0.01 ether;\n    uint256 private feePercent = 5;  // only charged from profits\n    uint256 private jackpotPercent = 10;  // only charged from profits\n    uint256 private startingCoownerPrice = 10 ether;\n\n    /* ADMIN AREA */\n\n    bool public paused;\n\n    address public ceoAddress;\n    address public feeAddress;\n    address public feedAddress;\n\n    modifier notPaused() {\n        require(!paused);\n        _;\n    }\n\n    modifier onlyFeed() {\n        require(msg.sender == feedAddress);\n        _;\n    }\n\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n    function setCEO(address _newCEO) public onlyCEO {\n        require(_newCEO != address(0));\n\n        ceoAddress = _newCEO;\n    }\n\n    function setFeedAddress(address _newFeed) public onlyCEO {\n        feedAddress = _newFeed;\n    }\n\n    function setFeeAddress(address _newFee) public onlyCEO {\n        feeAddress = _newFee;\n    }\n\n    function pauseContract() public onlyCEO {\n        paused = true;\n    }\n\n    function unpauseContract() public onlyCEO {\n        paused = false;\n    }\n\n    /* PROFITS */\n\n    mapping (address => uint256) private profits;\n\n    function getProfits(address who) public view returns (uint256) {\n        return profits[who];\n    }\n\n    function withdraw(address who) public {\n        require(profits[who] > 0);\n        uint256 amount = profits[who];\n        profits[who] = 0;\n        who.transfer(amount);\n    }\n\n    /* COOWNER MANAGEMENT */\n\n    address public feeCoownerAddress;\n    uint256 public coownerPrice;\n\n    function becomeCoowner() public payable {\n        if (msg.value < coownerPrice) {\n            revert();\n        }\n\n        uint256 ourFee = coownerPrice / 10;\n        uint256 profit = coownerPrice - ourFee;\n        profits[feeCoownerAddress] += profit;\n        profits[feeAddress] += ourFee;\n        profits[msg.sender] += msg.value - coownerPrice;\n        coownerPrice = coownerPrice * 3 / 2;\n        feeCoownerAddress = msg.sender;\n    }\n\n\n    /* WORD MANAGEMENT */\n\n    struct Word {\n        string word;\n        bool disabled;\n    }\n\n\n    event WordSetChanged();\n\n    Word[] private words;\n    mapping (string => uint256) private idByWord;\n\n    function getWordCount() public view returns (uint) {\n        return words.length;\n     }\n\n    function getWord(uint index) public view returns (string word,\n                                                      bool disabled) {\n        require(index < words.length);\n        return (words[index].word, words[index].disabled);\n    }\n\n    function getWordIndex(string word) public view returns (uint) {\n        return idByWord[word];\n     }\n\n\n    function addWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index == 0);\n        index = words.push(Word({word: word, disabled: false})) - 1;\n        idByWord[word] = index;\n        bids.length = words.length;\n        WordSetChanged();\n    }\n\n    function delWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index > 0);\n        require(bids[index].bestBidder == address(0));\n        idByWord[word] = 0;\n        words[index].disabled = true;\n        WordSetChanged();\n    }\n\n    /* WINNERS MANAGEMENT */\n    uint public prevTweetTime;\n    uint256 public prevRoundTweetId;\n    struct WinnerInfo {\n        address who;\n        uint256 howMuch;\n        uint256 wordId;\n    }\n\n    WinnerInfo[] private prevRoundWinners;\n    uint private prevRoundWinnerCount;\n\n    function getPrevRoundWinnerCount() public view returns (uint256 winnerCount)  {\n        winnerCount = prevRoundWinnerCount;\n    }\n\n    function getPrevRoundWinner(uint i) public view returns (address who, uint256 howMuch, uint256 wordId) {\n        who = prevRoundWinners[i].who;\n        howMuch = prevRoundWinners[i].howMuch;\n        wordId = prevRoundWinners[i].wordId;\n    }\n\n    function addWinner(address who, uint howMuch, uint wordId) private {\n        ++prevRoundWinnerCount;\n        if (prevRoundWinners.length < prevRoundWinnerCount) {\n            prevRoundWinners.length = prevRoundWinnerCount;\n        }\n        prevRoundWinners[prevRoundWinnerCount - 1].who = who;\n        prevRoundWinners[prevRoundWinnerCount - 1].howMuch = howMuch;\n        prevRoundWinners[prevRoundWinnerCount - 1].wordId = wordId;\n    }\n\n    /* BIDS MANAGEMENT */\n    struct Bid {\n        uint256 cumValue;\n        uint256 validRoundNo;\n    }\n\n    struct WordBids {\n        mapping (address => Bid) totalBids;\n        address bestBidder;\n    }\n\n    uint256 private curRound;\n    WordBids[] private bids;\n\n    uint256 private totalBank;\n    uint256 private totalJackpot;\n\n    function getJackpot() public view returns (uint256) {\n        return totalJackpot;\n    }\n\n    function getBank() public view returns (uint256) {\n        return totalBank;\n    }\n\n    function getBestBidder(uint256 wordIndex) public view returns (address, uint256) {\n        return (bids[wordIndex].bestBidder, bids[wordIndex].totalBids[bids[wordIndex].bestBidder].cumValue);\n    }\n\n    function getBestBid(uint256 wordIndex) public view returns (uint256) {\n        return bids[wordIndex].totalBids[bids[wordIndex].bestBidder].cumValue;\n    }\n\n    function getMinAllowedBid(uint256 wordIndex) public view returns (uint256) {\n        return getBestBid(wordIndex) + minBid;\n    }\n\n    function getTotalBid(address who, uint256 wordIndex) public view returns (uint256) {\n        if (bids[wordIndex].totalBids[who].validRoundNo != curRound) {\n            return 0;\n        }\n        return bids[wordIndex].totalBids[who].cumValue;\n    }\n\n    function startNewRound() private {\n        totalBank = 0;\n        ++curRound;\n        for (uint i = 0; i < bids.length; ++i) {\n            bids[i].bestBidder = 0;\n        }\n    }\n\n    event BestBidUpdate();\n\n    function addBid(address who, uint wordIndex, uint256 value) private {\n        if (bids[wordIndex].totalBids[who].validRoundNo != curRound) {\n            bids[wordIndex].totalBids[who].cumValue = 0;\n            bids[wordIndex].totalBids[who].validRoundNo = curRound;\n        }\n\n        uint256 newBid = value + bids[wordIndex].totalBids[who].cumValue;\n        uint256 minAllowedBid = getMinAllowedBid(wordIndex);\n        if (minAllowedBid > newBid) {\n            revert();\n        }\n\n        bids[wordIndex].totalBids[who].cumValue = newBid;\n        bids[wordIndex].bestBidder = who;\n        totalBank += value;\n        BestBidUpdate();\n    }\n\n    function calcPayouts(bool[] hasWon) private {\n        uint256 totalWon;\n        uint i;\n        for (i = 0; i < words.length; ++i) {\n            if (hasWon[i]) {\n                totalWon += getBestBid(i);\n            }\n        }\n\n        if (totalWon == 0) {\n            totalJackpot += totalBank;\n            return;\n        }\n        uint256 bank = totalJackpot / 2;\n        totalJackpot -= bank;\n        bank += totalBank;\n\n        // charge only loosers\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - totalWon, feePercent), 100));\n        bank -= fee;\n        profits[feeAddress] += fee / 2;\n        fee -= fee / 2;\n        profits[feeCoownerAddress] += fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - totalWon, jackpotPercent), 100));\n        bank -= jackpotFill;\n        totalJackpot += jackpotFill;\n\n        for (i = 0; i < words.length; ++i) {\n            if (hasWon[i] && bids[i].bestBidder != address(0)) {\n                uint256 payout = uint256(SafeMath.div(SafeMath.mul(bank, getBestBid(i)), totalWon));\n                profits[bids[i].bestBidder] += payout;\n                addWinner(bids[i].bestBidder, payout, i);\n            }\n        }\n    }\n\n    function getPotentialProfit(address who, string word) public view returns\n        (uint256 minNeededBid,\n         uint256 expectedProfit) {\n\n        uint index = idByWord[word];\n        require(index > 0);\n\n        uint currentBid = getTotalBid(who, index);\n        address bestBidder;\n        (bestBidder,) = getBestBidder(index);\n        if (bestBidder != who) {\n            minNeededBid = getMinAllowedBid(index) - currentBid;\n        }\n\n        uint256 bank = totalJackpot / 2;\n        bank += totalBank;\n\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, feePercent), 100));\n        bank -= fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, jackpotPercent), 100));\n        bank -= jackpotFill;\n\n        expectedProfit = bank;\n    }\n\n    function bid(string word) public payable notPaused {\n        uint index = idByWord[word];\n        require(index > 0);\n        addBid(msg.sender, index, msg.value);\n    }\n\n    /* FEED TRUMP TWEET */\n\n    function hasSubstring(string haystack, string needle) private pure returns (bool) {\n        uint needleSize = bytes(needle).length;\n        bytes32 hash = keccak256(needle);\n        for(uint i = 0; i < bytes(haystack).length - needleSize; i++) {\n            bytes32 testHash;\n            assembly {\n                testHash := sha3(add(add(haystack, i), 32), needleSize)\n            }\n            if (hash == testHash)\n                return true;\n        }\n        return false;\n    }\n\n    event RoundFinished();\n    event NoBids();\n    event NoBingoWords();\n\n    function feedTweet(uint tweetTime, uint256 tweetId, string tweet) public onlyFeed notPaused {\n        prevTweetTime = tweetTime;\n        if (totalBank == 0) {\n            NoBids();\n            return;\n        }\n\n        bool[] memory hasWon = new bool[](words.length);\n        bool anyWordPresent = false;\n        for (uint i = 0; i < words.length; ++i) {\n            hasWon[i] = (!words[i].disabled) && hasSubstring(tweet, words[i].word);\n            if (hasWon[i]) {\n                anyWordPresent = true;\n            }\n        }\n\n        if (!anyWordPresent) {\n            NoBingoWords();\n            return;\n        }\n\n        prevRoundTweetId = tweetId;\n        prevRoundWinnerCount = 0;\n        calcPayouts(hasWon);\n        RoundFinished();\n        startNewRound();\n    }\n\n    /* CONSTRUCTOR */\n\n    function TrumpBingo() public {\n        ceoAddress = msg.sender;\n        feeAddress = msg.sender;\n        feedAddress = msg.sender;\n        feeCoownerAddress = msg.sender;\n        coownerPrice = startingCoownerPrice;\n\n        paused = false;\n        words.push(Word({word: \"\", disabled: true})); // fake '0' word\n        startNewRound();\n    }\n\n\n}",
        "debug": "keccac_0_+\n89717814153306320011181716697424560163256864414616650038987186496166826726056_+\n2*storage_10: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 +\n89717814153306320011181716697424560163256864414616650038987186496166826726056 +\n2*storage_10: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_TrumpBingo_4 + calldata_TrumpBingo_4: 0x1f\nstorage_4: 0x0\ncaller: 0x0\ncalldata_TrumpBingo_0: 0x4974da8100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\nstorage_KECCAC_mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4))): 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "addWord(string)",
        "lineno": 33,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10570,
        "code": "GLOBAL CONSTANTS */\n    uint256 private minBid = 0.01 ether;\n    uint256 private feePercent = 5;  // only charged from profits\n    uint256 private jackpotPercent = 10;  // only charged from profits\n    uint256 private startingCoownerPrice = 10 ether;\n\n    /* ADMIN AREA */\n\n    bool public paused;\n\n    address public ceoAddress;\n    address public feeAddress;\n    address public feedAddress;\n\n    modifier notPaused() {\n        require(!paused);\n        _;\n    }\n\n    modifier onlyFeed() {\n        require(msg.sender == feedAddress);\n        _;\n    }\n\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n    function setCEO(address _newCEO) public onlyCEO {\n        require(_newCEO != address(0));\n\n        ceoAddress = _newCEO;\n    }\n\n    function setFeedAddress(address _newFeed) public onlyCEO {\n        feedAddress = _newFeed;\n    }\n\n    function setFeeAddress(address _newFee) public onlyCEO {\n        feeAddress = _newFee;\n    }\n\n    function pauseContract() public onlyCEO {\n        paused = true;\n    }\n\n    function unpauseContract() public onlyCEO {\n        paused = false;\n    }\n\n    /* PROFITS */\n\n    mapping (address => uint256) private profits;\n\n    function getProfits(address who) public view returns (uint256) {\n        return profits[who];\n    }\n\n    function withdraw(address who) public {\n        require(profits[who] > 0);\n        uint256 amount = profits[who];\n        profits[who] = 0;\n        who.transfer(amount);\n    }\n\n    /* COOWNER MANAGEMENT */\n\n    address public feeCoownerAddress;\n    uint256 public coownerPrice;\n\n    function becomeCoowner() public payable {\n        if (msg.value < coownerPrice) {\n            revert();\n        }\n\n        uint256 ourFee = coownerPrice / 10;\n        uint256 profit = coownerPrice - ourFee;\n        profits[feeCoownerAddress] += profit;\n        profits[feeAddress] += ourFee;\n        profits[msg.sender] += msg.value - coownerPrice;\n        coownerPrice = coownerPrice * 3 / 2;\n        feeCoownerAddress = msg.sender;\n    }\n\n\n    /* WORD MANAGEMENT */\n\n    struct Word {\n        string word;\n        bool disabled;\n    }\n\n\n    event WordSetChanged();\n\n    Word[] private words;\n    mapping (string => uint256) private idByWord;\n\n    function getWordCount() public view returns (uint) {\n        return words.length;\n     }\n\n    function getWord(uint index) public view returns (string word,\n                                                      bool disabled) {\n        require(index < words.length);\n        return (words[index].word, words[index].disabled);\n    }\n\n    function getWordIndex(string word) public view returns (uint) {\n        return idByWord[word];\n     }\n\n\n    function addWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index == 0);\n        index = words.push(Word({word: word, disabled: false})) - 1;\n        idByWord[word] = index;\n        bids.length = words.length;\n        WordSetChanged();\n    }\n\n    function delWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index > 0);\n        require(bids[index].bestBidder == address(0));\n        idByWord[word] = 0;\n        words[index].disabled = true;\n        WordSetChanged();\n    }\n\n    /* WINNERS MANAGEMENT */\n    uint public prevTweetTime;\n    uint256 public prevRoundTweetId;\n    struct WinnerInfo {\n        address who;\n        uint256 howMuch;\n        uint256 wordId;\n    }\n\n    WinnerInfo[] private prevRoundWinners;\n    uint private prevRoundWinnerCount;\n\n    function getPrevRoundWinnerCount() public view returns (uint256 winnerCount)  {\n        winnerCount = prevRoundWinnerCount;\n    }\n\n    function getPrevRoundWinner(uint i) public view returns (address who, uint256 howMuch, uint256 wordId) {\n        who = prevRoundWinners[i].who;\n        howMuch = prevRoundWinners[i].howMuch;\n        wordId = prevRoundWinners[i].wordId;\n    }\n\n    function addWinner(address who, uint howMuch, uint wordId) private {\n        ++prevRoundWinnerCount;\n        if (prevRoundWinners.length < prevRoundWinnerCount) {\n            prevRoundWinners.length = prevRoundWinnerCount;\n        }\n        prevRoundWinners[prevRoundWinnerCount - 1].who = who;\n        prevRoundWinners[prevRoundWinnerCount - 1].howMuch = howMuch;\n        prevRoundWinners[prevRoundWinnerCount - 1].wordId = wordId;\n    }\n\n    /* BIDS MANAGEMENT */\n    struct Bid {\n        uint256 cumValue;\n        uint256 validRoundNo;\n    }\n\n    struct WordBids {\n        mapping (address => Bid) totalBids;\n        address bestBidder;\n    }\n\n    uint256 private curRound;\n    WordBids[] private bids;\n\n    uint256 private totalBank;\n    uint256 private totalJackpot;\n\n    function getJackpot() public view returns (uint256) {\n        return totalJackpot;\n    }\n\n    function getBank() public view returns (uint256) {\n        return totalBank;\n    }\n\n    function getBestBidder(uint256 wordIndex) public view returns (address, uint256) {\n        return (bids[wordIndex].bestBidder, bids[wordIndex].totalBids[bids[wordIndex].bestBidder].cumValue);\n    }\n\n    function getBestBid(uint256 wordIndex) public view returns (uint256) {\n        return bids[wordIndex].totalBids[bids[wordIndex].bestBidder].cumValue;\n    }\n\n    function getMinAllowedBid(uint256 wordIndex) public view returns (uint256) {\n        return getBestBid(wordIndex) + minBid;\n    }\n\n    function getTotalBid(address who, uint256 wordIndex) public view returns (uint256) {\n        if (bids[wordIndex].totalBids[who].validRoundNo != curRound) {\n            return 0;\n        }\n        return bids[wordIndex].totalBids[who].cumValue;\n    }\n\n    function startNewRound() private {\n        totalBank = 0;\n        ++curRound;\n        for (uint i = 0; i < bids.length; ++i) {\n            bids[i].bestBidder = 0;\n        }\n    }\n\n    event BestBidUpdate();\n\n    function addBid(address who, uint wordIndex, uint256 value) private {\n        if (bids[wordIndex].totalBids[who].validRoundNo != curRound) {\n            bids[wordIndex].totalBids[who].cumValue = 0;\n            bids[wordIndex].totalBids[who].validRoundNo = curRound;\n        }\n\n        uint256 newBid = value + bids[wordIndex].totalBids[who].cumValue;\n        uint256 minAllowedBid = getMinAllowedBid(wordIndex);\n        if (minAllowedBid > newBid) {\n            revert();\n        }\n\n        bids[wordIndex].totalBids[who].cumValue = newBid;\n        bids[wordIndex].bestBidder = who;\n        totalBank += value;\n        BestBidUpdate();\n    }\n\n    function calcPayouts(bool[] hasWon) private {\n        uint256 totalWon;\n        uint i;\n        for (i = 0; i < words.length; ++i) {\n            if (hasWon[i]) {\n                totalWon += getBestBid(i);\n            }\n        }\n\n        if (totalWon == 0) {\n            totalJackpot += totalBank;\n            return;\n        }\n        uint256 bank = totalJackpot / 2;\n        totalJackpot -= bank;\n        bank += totalBank;\n\n        // charge only loosers\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - totalWon, feePercent), 100));\n        bank -= fee;\n        profits[feeAddress] += fee / 2;\n        fee -= fee / 2;\n        profits[feeCoownerAddress] += fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - totalWon, jackpotPercent), 100));\n        bank -= jackpotFill;\n        totalJackpot += jackpotFill;\n\n        for (i = 0; i < words.length; ++i) {\n            if (hasWon[i] && bids[i].bestBidder != address(0)) {\n                uint256 payout = uint256(SafeMath.div(SafeMath.mul(bank, getBestBid(i)), totalWon));\n                profits[bids[i].bestBidder] += payout;\n                addWinner(bids[i].bestBidder, payout, i);\n            }\n        }\n    }\n\n    function getPotentialProfit(address who, string word) public view returns\n        (uint256 minNeededBid,\n         uint256 expectedProfit) {\n\n        uint index = idByWord[word];\n        require(index > 0);\n\n        uint currentBid = getTotalBid(who, index);\n        address bestBidder;\n        (bestBidder,) = getBestBidder(index);\n        if (bestBidder != who) {\n            minNeededBid = getMinAllowedBid(index) - currentBid;\n        }\n\n        uint256 bank = totalJackpot / 2;\n        bank += totalBank;\n\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, feePercent), 100));\n        bank -= fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, jackpotPercent), 100));\n        bank -= jackpotFill;\n\n        expectedProfit = bank;\n    }\n\n    function bid(string word) public payable notPaused {\n        uint index = idByWord[word];\n        require(index > 0);\n        addBid(msg.sender, index, msg.value);\n    }\n\n    /* FEED TRUMP TWEET */\n\n    function hasSubstring(string haystack, string needle) private pure returns (bool) {\n        uint needleSize = bytes(needle).length;\n        bytes32 hash = keccak256(needle);\n        for(uint i = 0; i < bytes(haystack).length - needleSize; i++) {\n            bytes32 testHash;\n            assembly {\n                testHash := sha3(add(add(haystack, i), 32), needleSize)\n            }\n            if (hash == testHash)\n                return true;\n        }\n        return false;\n    }\n\n    event RoundFinished();\n    event NoBids();\n    event NoBingoWords();\n\n    function feedTweet(uint tweetTime, uint256 tweetId, string tweet) public onlyFeed notPaused {\n        prevTweetTime = tweetTime;\n        if (totalBank == 0) {\n            NoBids();\n            return;\n        }\n\n        bool[] memory hasWon = new bool[](words.length);\n        bool anyWordPresent = false;\n        for (uint i = 0; i < words.length; ++i) {\n            hasWon[i] = (!words[i].disabled) && hasSubstring(tweet, words[i].word);\n            if (hasWon[i]) {\n                anyWordPresent = true;\n            }\n        }\n\n        if (!anyWordPresent) {\n            NoBingoWords();\n            return;\n        }\n\n        prevRoundTweetId = tweetId;\n        prevRoundWinnerCount = 0;\n        calcPayouts(hasWon);\n        RoundFinished();\n        startNewRound();\n    }\n\n    /* CONSTRUCTOR */\n\n    function TrumpBingo() public {\n        ceoAddress = msg.sender;\n        feeAddress = msg.sender;\n        feedAddress = msg.sender;\n        feeCoownerAddress = msg.sender;\n        coownerPrice = startingCoownerPrice;\n\n        paused = false;\n        words.push(Word({word: \"\", disabled: true})); // fake '0' word\n        startNewRound();\n    }\n\n\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TrumpBingo_4 + calldata_TrumpBingo_4: 0x20\nstorage_4: 0x0\ncaller: 0x0\ncalldata_TrumpBingo_0: 0x4974da8100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\nstorage_KECCAC_mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4))): 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "addWord(string)",
        "lineno": 33,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10584,
        "code": "GLOBAL CONSTANTS */\n    uint256 private minBid = 0.01 ether;\n    uint256 private feePercent = 5;  // only charged from profits\n    uint256 private jackpotPercent = 10;  // only charged from profits\n    uint256 private startingCoownerPrice = 10 ether;\n\n    /* ADMIN AREA */\n\n    bool public paused;\n\n    address public ceoAddress;\n    address public feeAddress;\n    address public feedAddress;\n\n    modifier notPaused() {\n        require(!paused);\n        _;\n    }\n\n    modifier onlyFeed() {\n        require(msg.sender == feedAddress);\n        _;\n    }\n\n    modifier onlyCEO() {\n        require(msg.sender == ceoAddress);\n        _;\n    }\n\n    function setCEO(address _newCEO) public onlyCEO {\n        require(_newCEO != address(0));\n\n        ceoAddress = _newCEO;\n    }\n\n    function setFeedAddress(address _newFeed) public onlyCEO {\n        feedAddress = _newFeed;\n    }\n\n    function setFeeAddress(address _newFee) public onlyCEO {\n        feeAddress = _newFee;\n    }\n\n    function pauseContract() public onlyCEO {\n        paused = true;\n    }\n\n    function unpauseContract() public onlyCEO {\n        paused = false;\n    }\n\n    /* PROFITS */\n\n    mapping (address => uint256) private profits;\n\n    function getProfits(address who) public view returns (uint256) {\n        return profits[who];\n    }\n\n    function withdraw(address who) public {\n        require(profits[who] > 0);\n        uint256 amount = profits[who];\n        profits[who] = 0;\n        who.transfer(amount);\n    }\n\n    /* COOWNER MANAGEMENT */\n\n    address public feeCoownerAddress;\n    uint256 public coownerPrice;\n\n    function becomeCoowner() public payable {\n        if (msg.value < coownerPrice) {\n            revert();\n        }\n\n        uint256 ourFee = coownerPrice / 10;\n        uint256 profit = coownerPrice - ourFee;\n        profits[feeCoownerAddress] += profit;\n        profits[feeAddress] += ourFee;\n        profits[msg.sender] += msg.value - coownerPrice;\n        coownerPrice = coownerPrice * 3 / 2;\n        feeCoownerAddress = msg.sender;\n    }\n\n\n    /* WORD MANAGEMENT */\n\n    struct Word {\n        string word;\n        bool disabled;\n    }\n\n\n    event WordSetChanged();\n\n    Word[] private words;\n    mapping (string => uint256) private idByWord;\n\n    function getWordCount() public view returns (uint) {\n        return words.length;\n     }\n\n    function getWord(uint index) public view returns (string word,\n                                                      bool disabled) {\n        require(index < words.length);\n        return (words[index].word, words[index].disabled);\n    }\n\n    function getWordIndex(string word) public view returns (uint) {\n        return idByWord[word];\n     }\n\n\n    function addWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index == 0);\n        index = words.push(Word({word: word, disabled: false})) - 1;\n        idByWord[word] = index;\n        bids.length = words.length;\n        WordSetChanged();\n    }\n\n    function delWord(string word) public onlyCEO {\n        uint index = idByWord[word];\n        require(index > 0);\n        require(bids[index].bestBidder == address(0));\n        idByWord[word] = 0;\n        words[index].disabled = true;\n        WordSetChanged();\n    }\n\n    /* WINNERS MANAGEMENT */\n    uint public prevTweetTime;\n    uint256 public prevRoundTweetId;\n    struct WinnerInfo {\n        address who;\n        uint256 howMuch;\n        uint256 wordId;\n    }\n\n    WinnerInfo[] private prevRoundWinners;\n    uint private prevRoundWinnerCount;\n\n    function getPrevRoundWinnerCount() public view returns (uint256 winnerCount)  {\n        winnerCount = prevRoundWinnerCount;\n    }\n\n    function getPrevRoundWinner(uint i) public view returns (address who, uint256 howMuch, uint256 wordId) {\n        who = prevRoundWinners[i].who;\n        howMuch = prevRoundWinners[i].howMuch;\n        wordId = prevRoundWinners[i].wordId;\n    }\n\n    function addWinner(address who, uint howMuch, uint wordId) private {\n        ++prevRoundWinnerCount;\n        if (prevRoundWinners.length < prevRoundWinnerCount) {\n            prevRoundWinners.length = prevRoundWinnerCount;\n        }\n        prevRoundWinners[prevRoundWinnerCount - 1].who = who;\n        prevRoundWinners[prevRoundWinnerCount - 1].howMuch = howMuch;\n        prevRoundWinners[prevRoundWinnerCount - 1].wordId = wordId;\n    }\n\n    /* BIDS MANAGEMENT */\n    struct Bid {\n        uint256 cumValue;\n        uint256 validRoundNo;\n    }\n\n    struct WordBids {\n        mapping (address => Bid) totalBids;\n        address bestBidder;\n    }\n\n    uint256 private curRound;\n    WordBids[] private bids;\n\n    uint256 private totalBank;\n    uint256 private totalJackpot;\n\n    function getJackpot() public view returns (uint256) {\n        return totalJackpot;\n    }\n\n    function getBank() public view returns (uint256) {\n        return totalBank;\n    }\n\n    function getBestBidder(uint256 wordIndex) public view returns (address, uint256) {\n        return (bids[wordIndex].bestBidder, bids[wordIndex].totalBids[bids[wordIndex].bestBidder].cumValue);\n    }\n\n    function getBestBid(uint256 wordIndex) public view returns (uint256) {\n        return bids[wordIndex].totalBids[bids[wordIndex].bestBidder].cumValue;\n    }\n\n    function getMinAllowedBid(uint256 wordIndex) public view returns (uint256) {\n        return getBestBid(wordIndex) + minBid;\n    }\n\n    function getTotalBid(address who, uint256 wordIndex) public view returns (uint256) {\n        if (bids[wordIndex].totalBids[who].validRoundNo != curRound) {\n            return 0;\n        }\n        return bids[wordIndex].totalBids[who].cumValue;\n    }\n\n    function startNewRound() private {\n        totalBank = 0;\n        ++curRound;\n        for (uint i = 0; i < bids.length; ++i) {\n            bids[i].bestBidder = 0;\n        }\n    }\n\n    event BestBidUpdate();\n\n    function addBid(address who, uint wordIndex, uint256 value) private {\n        if (bids[wordIndex].totalBids[who].validRoundNo != curRound) {\n            bids[wordIndex].totalBids[who].cumValue = 0;\n            bids[wordIndex].totalBids[who].validRoundNo = curRound;\n        }\n\n        uint256 newBid = value + bids[wordIndex].totalBids[who].cumValue;\n        uint256 minAllowedBid = getMinAllowedBid(wordIndex);\n        if (minAllowedBid > newBid) {\n            revert();\n        }\n\n        bids[wordIndex].totalBids[who].cumValue = newBid;\n        bids[wordIndex].bestBidder = who;\n        totalBank += value;\n        BestBidUpdate();\n    }\n\n    function calcPayouts(bool[] hasWon) private {\n        uint256 totalWon;\n        uint i;\n        for (i = 0; i < words.length; ++i) {\n            if (hasWon[i]) {\n                totalWon += getBestBid(i);\n            }\n        }\n\n        if (totalWon == 0) {\n            totalJackpot += totalBank;\n            return;\n        }\n        uint256 bank = totalJackpot / 2;\n        totalJackpot -= bank;\n        bank += totalBank;\n\n        // charge only loosers\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - totalWon, feePercent), 100));\n        bank -= fee;\n        profits[feeAddress] += fee / 2;\n        fee -= fee / 2;\n        profits[feeCoownerAddress] += fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - totalWon, jackpotPercent), 100));\n        bank -= jackpotFill;\n        totalJackpot += jackpotFill;\n\n        for (i = 0; i < words.length; ++i) {\n            if (hasWon[i] && bids[i].bestBidder != address(0)) {\n                uint256 payout = uint256(SafeMath.div(SafeMath.mul(bank, getBestBid(i)), totalWon));\n                profits[bids[i].bestBidder] += payout;\n                addWinner(bids[i].bestBidder, payout, i);\n            }\n        }\n    }\n\n    function getPotentialProfit(address who, string word) public view returns\n        (uint256 minNeededBid,\n         uint256 expectedProfit) {\n\n        uint index = idByWord[word];\n        require(index > 0);\n\n        uint currentBid = getTotalBid(who, index);\n        address bestBidder;\n        (bestBidder,) = getBestBidder(index);\n        if (bestBidder != who) {\n            minNeededBid = getMinAllowedBid(index) - currentBid;\n        }\n\n        uint256 bank = totalJackpot / 2;\n        bank += totalBank;\n\n        uint256 fee = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, feePercent), 100));\n        bank -= fee;\n\n        uint256 jackpotFill = uint256(SafeMath.div(SafeMath.mul(bank - currentBid, jackpotPercent), 100));\n        bank -= jackpotFill;\n\n        expectedProfit = bank;\n    }\n\n    function bid(string word) public payable notPaused {\n        uint index = idByWord[word];\n        require(index > 0);\n        addBid(msg.sender, index, msg.value);\n    }\n\n    /* FEED TRUMP TWEET */\n\n    function hasSubstring(string haystack, string needle) private pure returns (bool) {\n        uint needleSize = bytes(needle).length;\n        bytes32 hash = keccak256(needle);\n        for(uint i = 0; i < bytes(haystack).length - needleSize; i++) {\n            bytes32 testHash;\n            assembly {\n                testHash := sha3(add(add(haystack, i), 32), needleSize)\n            }\n            if (hash == testHash)\n                return true;\n        }\n        return false;\n    }\n\n    event RoundFinished();\n    event NoBids();\n    event NoBingoWords();\n\n    function feedTweet(uint tweetTime, uint256 tweetId, string tweet) public onlyFeed notPaused {\n        prevTweetTime = tweetTime;\n        if (totalBank == 0) {\n            NoBids();\n            return;\n        }\n\n        bool[] memory hasWon = new bool[](words.length);\n        bool anyWordPresent = false;\n        for (uint i = 0; i < words.length; ++i) {\n            hasWon[i] = (!words[i].disabled) && hasSubstring(tweet, words[i].word);\n            if (hasWon[i]) {\n                anyWordPresent = true;\n            }\n        }\n\n        if (!anyWordPresent) {\n            NoBingoWords();\n            return;\n        }\n\n        prevRoundTweetId = tweetId;\n        prevRoundWinnerCount = 0;\n        calcPayouts(hasWon);\n        RoundFinished();\n        startNewRound();\n    }\n\n    /* CONSTRUCTOR */\n\n    function TrumpBingo() public {\n        ceoAddress = msg.sender;\n        feeAddress = msg.sender;\n        feedAddress = msg.sender;\n        feeCoownerAddress = msg.sender;\n        coownerPrice = startingCoownerPrice;\n\n        paused = false;\n        words.push(Word({word: \"\", disabled: true})); // fake '0' word\n        startNewRound();\n    }\n\n\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\ncalldata_TrumpBingo_4 + calldata_TrumpBingo_4: 0x1f\nstorage_4: 0x0\ncaller: 0x0\ncalldata_TrumpBingo_0: 0x4974da8100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrumpBingo: 0x4\nstorage_KECCAC_mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrumpBingo_4 + calldata_TrumpBingo_4))): 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addWord(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/9/0xf78470c139b07b21e59f9b7ee6149f58777806af.sol",
        "function": "addWord(string)",
        "lineno": 33,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}