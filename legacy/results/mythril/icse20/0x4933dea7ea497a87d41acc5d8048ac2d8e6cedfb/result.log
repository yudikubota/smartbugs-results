{"error": null, "issues": [{"address": 261, "code": "ion distribute() public {\n    /", "debug": "callvalue: 0x9c5255c5e1c012af08021c2a8036246b0199a029e5873ec829e34a0c01e652d3\nstorage_5: 0xef565e0dbcde0bae1c2243ba9015c30e7490afa3f4a58114d839443c723060d2\ncalldata_OrganizeFunds_0: 0x3b00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "fallback", "lineno": 151, "title": "Integer Overflow ", "type": "Warning"}, {"address": 754, "code": "lockedOnly {\n    if (activityCount >= MAX_ACCOUNTS) {\n      MessageEvent(\"err: max accounts\");\n      return;\n    }\n    activityAccounts[activityCount].addr = _addr;\n    activityAccounts[activityCount].pctx10 = _pctx10;\n    activityAccounts[activityCount].credited = 0;\n    activityAccounts[activityCount].balance = 0;\n    activityAccounts[activityCount].name = _name;\n    ++activityCount;\n    MessageEvent(\"ok: acct added\");\n  }\n\n\n  // ----------------------------\n  // get acct info\n  // ----------------------------\n  function getA", "debug": "calldata_OrganizeFunds_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OrganizeFunds_0: 0x48ce382d00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addActivityAccount(address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "addActivityAccount(address,uint256,string)", "lineno": 94, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1318, "code": "name;\n  }\n\n  //\n  // reset\n  // reset all activity accounts\n  // in case ", "debug": "calldata_OrganizeFunds_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OrganizeFunds_0: 0xc47f002700000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "setName(string)", "lineno": 64, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2069, "code": "           totalFundsWithdraw", "debug": "storage_24465873643947496235832446106509767096567058095563226156125564318740882468608: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\nstorage_7: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\nstorage_2: 0x0\ncaller: 0x0\nstorage_24465873643947496235832446106509767096567058095563226156125564318740882468610: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OrganizeFunds_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `withdraw()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "withdraw()", "lineno": 192, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2119, "code": "       MessageEvent(\"err: error sending fu", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "withdraw()", "lineno": 193, "title": "Message call to external contract", "type": "Informational"}, {"address": 2119, "code": "       MessageEvent(\"err: error sending fu", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2119\nCall at address: 2119\nCall at address: 2119\nCall at address: 2119\nCall at address: 2119\nCall at address: 2119\n", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "withdraw()", "lineno": 193, "title": "Multiple Calls", "type": "Information"}, {"address": 2166, "code": " public ownerOnly unlockedOnl", "debug": "storage_24465873643947496235832446106509767096567058095563226156125564318740882468608: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x0\ncaller: 0x0\nstorage_24465873643947496235832446106509767096567058095563226156125564318740882468610: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OrganizeFunds_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\nretval_2119: 0x0\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `withdraw()`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "withdraw()", "lineno": 205, "title": "Integer Underflow", "type": "Warning"}, {"address": 4716, "code": "anizeFunds {\n\n  struct ActivityAccount {\n    uint credited;   // total funds credited to this account\n    uint balance;    // current balance = credited - amount withdrawn\n    uint pctx10;     // percent allocation times ten\n    address addr;    // payout addr of this acct\n    string name;\n  }\n\n  uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute\n  uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle\n\n  event MessageEvent(string message);\n  event MessageEventI(string message, uint val);\n\n\n  bool public isLocked;\n  string public name;\n  address public owner;                                // deployer executor\n  mapping (uint => ActivityAccount) activityAccounts;  // accounts by index\n  uint public activityCount;                           // how many activity accounts\n  uint public totalFundsReceived;                      // amount received since begin of time\n  uint public totalFundsDistributed;                   // amount distributed since begin of time\n  uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time\n  uint public withdrawGas = 100000;                    // gas for withdrawals\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier unlockedOnly {\n    require(!isLocked);\n    _;\n  }\n\n\n\n  //\n  // constructor\n  //\n  function OrganizeFunds() public {\n    owner = msg.sender;\n  }\n\n  function lock() public ownerOnly {\n    isLocked = true;\n  }\n\n  function setName(string _name) public ownerOnly {\n    name = _name;\n  }\n\n  //\n  // reset\n  // reset all activity accounts\n  // in case we have any funds that have not been withdrawn, they become  newly received and undistributed.\n  //\n  function reset() public ownerOnly unlockedOnly {\n    totalFundsReceived = this.balance;\n    totalFundsDistributed = 0;\n    totalFundsWithdrawn = 0;\n    activityCount = 0;\n    MessageEvent(\"ok: all accts reset\");\n  }\n\n\n  //\n  // set withdrawal gas\n  // nonstandard gas is necessary to support push-withdrawals to other contract\n  //\n  function setWitdrawGas(uint256 _withdrawGas) public ownerOnly {\n    withdrawGas = _withdrawGas;\n    MessageEventI(\"ok: withdraw gas set\", withdrawGas);\n  }\n\n\n  //\n  // add a new activity account\n  //\n  function addActivityAccount(address _addr, uint256 _pctx10, string _name) public ownerOnly unlockedOnly {\n    if (activityCount >= MAX_ACCOUNTS) {\n      MessageEvent(\"err: max accounts\");\n      return;\n    }\n    activityAccounts[activityCount].addr = _addr;\n    activityAccounts[activityCount].pctx10 = _pctx10;\n    activityAccounts[activityCount].credited = 0;\n    activityAccounts[activityCount].balance = 0;\n    activityAccounts[activityCount].name = _name;\n    ++activityCount;\n    MessageEvent(\"ok: acct added\");\n  }\n\n\n  // ----------------------------\n  // get acct info\n  // ----------------------------\n  function getActivityAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, string _name, uint _credited, uint _balance) {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == _addr) {\n        _idx = i;\n        _pctx10 = activityAccounts[i].pctx10;\n        _name = activityAccounts[i].name;\n        _credited = activityAccounts[i].credited;\n        _balance = activityAccounts[i].balance;\n        return;\n      }\n    }\n  }\n\n\n  //\n  // get total percentages x10\n  //\n  function getTotalPctx10() public constant returns(uint _totalPctx10) {\n    _totalPctx10 = 0;\n    for (uint i = 0; i < activityCount; i++ ) {\n      _totalPctx10 += activityAccounts[i].pctx10;\n    }\n  }\n\n\n  //\n  // default payable function.\n  // call us with plenty of gas, or catastrophe will ensue\n  //\n  function () public payable {\n    totalFundsReceived += msg.value;\n    MessageEventI(\"ok: received\", msg.value);\n  }\n\n\n  //\n  // distribute funds to all activities\n  //\n  function distribute() public {\n    //only payout if we have more than 1000 wei\n    if (this.balance < TENHUNDWEI) {\n      return;\n    }\n    //each account gets their prescribed percentage of this holdover.\n    uint i;\n    uint pctx10;\n    uint acctDist;\n    for (i = 0; i < activityCount; i++ ) {\n      pctx10 = activityAccounts[i].pctx10;\n      acctDist = totalFundsReceived * pctx10 / TENHUNDWEI;\n      //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct\n      if (activityAccounts[i].credited >= acctDist) {\n        acctDist = 0;\n      } else {\n        acctDist = acctDist - activityAccounts[i].credited;\n      }\n      activityAccounts[i].credited += acctDist;\n      activityAccounts[i].balance += acctDist;\n      totalFundsDistributed += acctDist;\n    }\n    MessageEvent(\"ok: distributed funds\");\n  }\n\n\n  //\n  // withdraw actvity balance\n  // can be called by owner to push funds to another contract\n  //\n  function withdraw() public {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == msg.sender || msg.sender == owner) {\n        uint amount = activityAccounts[i].balance;\n        if (amount > 0) {\n          activityAccounts[i].balance = 0;\n          totalFundsWithdrawn += amount;\n          if (!addr.call.gas(withdrawGas).value(amount)()) {\n            //put back funds in case of err\n            activityAccounts[i].balance = amount;\n            totalFundsWithdrawn -= amount;\n            MessageEvent(\"err: error sending funds\");\n            return;\n          }\n        }\n      }\n    }\n  }\n\n\n  //\n  // suicide\n  //\n  function hariKari() public ownerOnly unlockedOnly {\n    selfdestruct(owner);\n  }\n\n}", "debug": "storage_4 + keccac_storage_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_4_+_keccac_storage_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_4: 0x9\nstorage_0: 0x0\nstorage_2: 0x0\ncaller: 0x0\ncalldata_OrganizeFunds_0: 0x48ce382d00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addActivityAccount(address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "addActivityAccount(address,uint256,string)", "lineno": 13, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4745, "code": "anizeFunds {\n\n  struct ActivityAccount {\n    uint credited;   // total funds credited to this account\n    uint balance;    // current balance = credited - amount withdrawn\n    uint pctx10;     // percent allocation times ten\n    address addr;    // payout addr of this acct\n    string name;\n  }\n\n  uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute\n  uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle\n\n  event MessageEvent(string message);\n  event MessageEventI(string message, uint val);\n\n\n  bool public isLocked;\n  string public name;\n  address public owner;                                // deployer executor\n  mapping (uint => ActivityAccount) activityAccounts;  // accounts by index\n  uint public activityCount;                           // how many activity accounts\n  uint public totalFundsReceived;                      // amount received since begin of time\n  uint public totalFundsDistributed;                   // amount distributed since begin of time\n  uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time\n  uint public withdrawGas = 100000;                    // gas for withdrawals\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier unlockedOnly {\n    require(!isLocked);\n    _;\n  }\n\n\n\n  //\n  // constructor\n  //\n  function OrganizeFunds() public {\n    owner = msg.sender;\n  }\n\n  function lock() public ownerOnly {\n    isLocked = true;\n  }\n\n  function setName(string _name) public ownerOnly {\n    name = _name;\n  }\n\n  //\n  // reset\n  // reset all activity accounts\n  // in case we have any funds that have not been withdrawn, they become  newly received and undistributed.\n  //\n  function reset() public ownerOnly unlockedOnly {\n    totalFundsReceived = this.balance;\n    totalFundsDistributed = 0;\n    totalFundsWithdrawn = 0;\n    activityCount = 0;\n    MessageEvent(\"ok: all accts reset\");\n  }\n\n\n  //\n  // set withdrawal gas\n  // nonstandard gas is necessary to support push-withdrawals to other contract\n  //\n  function setWitdrawGas(uint256 _withdrawGas) public ownerOnly {\n    withdrawGas = _withdrawGas;\n    MessageEventI(\"ok: withdraw gas set\", withdrawGas);\n  }\n\n\n  //\n  // add a new activity account\n  //\n  function addActivityAccount(address _addr, uint256 _pctx10, string _name) public ownerOnly unlockedOnly {\n    if (activityCount >= MAX_ACCOUNTS) {\n      MessageEvent(\"err: max accounts\");\n      return;\n    }\n    activityAccounts[activityCount].addr = _addr;\n    activityAccounts[activityCount].pctx10 = _pctx10;\n    activityAccounts[activityCount].credited = 0;\n    activityAccounts[activityCount].balance = 0;\n    activityAccounts[activityCount].name = _name;\n    ++activityCount;\n    MessageEvent(\"ok: acct added\");\n  }\n\n\n  // ----------------------------\n  // get acct info\n  // ----------------------------\n  function getActivityAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, string _name, uint _credited, uint _balance) {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == _addr) {\n        _idx = i;\n        _pctx10 = activityAccounts[i].pctx10;\n        _name = activityAccounts[i].name;\n        _credited = activityAccounts[i].credited;\n        _balance = activityAccounts[i].balance;\n        return;\n      }\n    }\n  }\n\n\n  //\n  // get total percentages x10\n  //\n  function getTotalPctx10() public constant returns(uint _totalPctx10) {\n    _totalPctx10 = 0;\n    for (uint i = 0; i < activityCount; i++ ) {\n      _totalPctx10 += activityAccounts[i].pctx10;\n    }\n  }\n\n\n  //\n  // default payable function.\n  // call us with plenty of gas, or catastrophe will ensue\n  //\n  function () public payable {\n    totalFundsReceived += msg.value;\n    MessageEventI(\"ok: received\", msg.value);\n  }\n\n\n  //\n  // distribute funds to all activities\n  //\n  function distribute() public {\n    //only payout if we have more than 1000 wei\n    if (this.balance < TENHUNDWEI) {\n      return;\n    }\n    //each account gets their prescribed percentage of this holdover.\n    uint i;\n    uint pctx10;\n    uint acctDist;\n    for (i = 0; i < activityCount; i++ ) {\n      pctx10 = activityAccounts[i].pctx10;\n      acctDist = totalFundsReceived * pctx10 / TENHUNDWEI;\n      //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct\n      if (activityAccounts[i].credited >= acctDist) {\n        acctDist = 0;\n      } else {\n        acctDist = acctDist - activityAccounts[i].credited;\n      }\n      activityAccounts[i].credited += acctDist;\n      activityAccounts[i].balance += acctDist;\n      totalFundsDistributed += acctDist;\n    }\n    MessageEvent(\"ok: distributed funds\");\n  }\n\n\n  //\n  // withdraw actvity balance\n  // can be called by owner to push funds to another contract\n  //\n  function withdraw() public {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == msg.sender || msg.sender == owner) {\n        uint amount = activityAccounts[i].balance;\n        if (amount > 0) {\n          activityAccounts[i].balance = 0;\n          totalFundsWithdrawn += amount;\n          if (!addr.call.gas(withdrawGas).value(amount)()) {\n            //put back funds in case of err\n            activityAccounts[i].balance = amount;\n            totalFundsWithdrawn -= amount;\n            MessageEvent(\"err: error sending funds\");\n            return;\n          }\n        }\n      }\n    }\n  }\n\n\n  //\n  // suicide\n  //\n  function hariKari() public ownerOnly unlockedOnly {\n    selfdestruct(owner);\n  }\n\n}", "debug": "calldata_OrganizeFunds_4 + calldata_OrganizeFunds_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_2: 0x0\ncaller: 0x0\ncalldata_OrganizeFunds_0: 0xc47f002700000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "setName(string)", "lineno": 13, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4759, "code": "anizeFunds {\n\n  struct ActivityAccount {\n    uint credited;   // total funds credited to this account\n    uint balance;    // current balance = credited - amount withdrawn\n    uint pctx10;     // percent allocation times ten\n    address addr;    // payout addr of this acct\n    string name;\n  }\n\n  uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute\n  uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle\n\n  event MessageEvent(string message);\n  event MessageEventI(string message, uint val);\n\n\n  bool public isLocked;\n  string public name;\n  address public owner;                                // deployer executor\n  mapping (uint => ActivityAccount) activityAccounts;  // accounts by index\n  uint public activityCount;                           // how many activity accounts\n  uint public totalFundsReceived;                      // amount received since begin of time\n  uint public totalFundsDistributed;                   // amount distributed since begin of time\n  uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time\n  uint public withdrawGas = 100000;                    // gas for withdrawals\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier unlockedOnly {\n    require(!isLocked);\n    _;\n  }\n\n\n\n  //\n  // constructor\n  //\n  function OrganizeFunds() public {\n    owner = msg.sender;\n  }\n\n  function lock() public ownerOnly {\n    isLocked = true;\n  }\n\n  function setName(string _name) public ownerOnly {\n    name = _name;\n  }\n\n  //\n  // reset\n  // reset all activity accounts\n  // in case we have any funds that have not been withdrawn, they become  newly received and undistributed.\n  //\n  function reset() public ownerOnly unlockedOnly {\n    totalFundsReceived = this.balance;\n    totalFundsDistributed = 0;\n    totalFundsWithdrawn = 0;\n    activityCount = 0;\n    MessageEvent(\"ok: all accts reset\");\n  }\n\n\n  //\n  // set withdrawal gas\n  // nonstandard gas is necessary to support push-withdrawals to other contract\n  //\n  function setWitdrawGas(uint256 _withdrawGas) public ownerOnly {\n    withdrawGas = _withdrawGas;\n    MessageEventI(\"ok: withdraw gas set\", withdrawGas);\n  }\n\n\n  //\n  // add a new activity account\n  //\n  function addActivityAccount(address _addr, uint256 _pctx10, string _name) public ownerOnly unlockedOnly {\n    if (activityCount >= MAX_ACCOUNTS) {\n      MessageEvent(\"err: max accounts\");\n      return;\n    }\n    activityAccounts[activityCount].addr = _addr;\n    activityAccounts[activityCount].pctx10 = _pctx10;\n    activityAccounts[activityCount].credited = 0;\n    activityAccounts[activityCount].balance = 0;\n    activityAccounts[activityCount].name = _name;\n    ++activityCount;\n    MessageEvent(\"ok: acct added\");\n  }\n\n\n  // ----------------------------\n  // get acct info\n  // ----------------------------\n  function getActivityAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, string _name, uint _credited, uint _balance) {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == _addr) {\n        _idx = i;\n        _pctx10 = activityAccounts[i].pctx10;\n        _name = activityAccounts[i].name;\n        _credited = activityAccounts[i].credited;\n        _balance = activityAccounts[i].balance;\n        return;\n      }\n    }\n  }\n\n\n  //\n  // get total percentages x10\n  //\n  function getTotalPctx10() public constant returns(uint _totalPctx10) {\n    _totalPctx10 = 0;\n    for (uint i = 0; i < activityCount; i++ ) {\n      _totalPctx10 += activityAccounts[i].pctx10;\n    }\n  }\n\n\n  //\n  // default payable function.\n  // call us with plenty of gas, or catastrophe will ensue\n  //\n  function () public payable {\n    totalFundsReceived += msg.value;\n    MessageEventI(\"ok: received\", msg.value);\n  }\n\n\n  //\n  // distribute funds to all activities\n  //\n  function distribute() public {\n    //only payout if we have more than 1000 wei\n    if (this.balance < TENHUNDWEI) {\n      return;\n    }\n    //each account gets their prescribed percentage of this holdover.\n    uint i;\n    uint pctx10;\n    uint acctDist;\n    for (i = 0; i < activityCount; i++ ) {\n      pctx10 = activityAccounts[i].pctx10;\n      acctDist = totalFundsReceived * pctx10 / TENHUNDWEI;\n      //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct\n      if (activityAccounts[i].credited >= acctDist) {\n        acctDist = 0;\n      } else {\n        acctDist = acctDist - activityAccounts[i].credited;\n      }\n      activityAccounts[i].credited += acctDist;\n      activityAccounts[i].balance += acctDist;\n      totalFundsDistributed += acctDist;\n    }\n    MessageEvent(\"ok: distributed funds\");\n  }\n\n\n  //\n  // withdraw actvity balance\n  // can be called by owner to push funds to another contract\n  //\n  function withdraw() public {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == msg.sender || msg.sender == owner) {\n        uint amount = activityAccounts[i].balance;\n        if (amount > 0) {\n          activityAccounts[i].balance = 0;\n          totalFundsWithdrawn += amount;\n          if (!addr.call.gas(withdrawGas).value(amount)()) {\n            //put back funds in case of err\n            activityAccounts[i].balance = amount;\n            totalFundsWithdrawn -= amount;\n            MessageEvent(\"err: error sending funds\");\n            return;\n          }\n        }\n      }\n    }\n  }\n\n\n  //\n  // suicide\n  //\n  function hariKari() public ownerOnly unlockedOnly {\n    selfdestruct(owner);\n  }\n\n}", "debug": "calldata_OrganizeFunds_4 + calldata_OrganizeFunds_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_2: 0x0\ncaller: 0x0\ncalldata_OrganizeFunds_0: 0xc47f002700000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "setName(string)", "lineno": 13, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4781, "code": "anizeFunds {\n\n  struct ActivityAccount {\n    uint credited;   // total funds credited to this account\n    uint balance;    // current balance = credited - amount withdrawn\n    uint pctx10;     // percent allocation times ten\n    address addr;    // payout addr of this acct\n    string name;\n  }\n\n  uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute\n  uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle\n\n  event MessageEvent(string message);\n  event MessageEventI(string message, uint val);\n\n\n  bool public isLocked;\n  string public name;\n  address public owner;                                // deployer executor\n  mapping (uint => ActivityAccount) activityAccounts;  // accounts by index\n  uint public activityCount;                           // how many activity accounts\n  uint public totalFundsReceived;                      // amount received since begin of time\n  uint public totalFundsDistributed;                   // amount distributed since begin of time\n  uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time\n  uint public withdrawGas = 100000;                    // gas for withdrawals\n\n  modifier ownerOnly {\n    require(msg.sender == owner);\n    _;\n  }\n\n  modifier unlockedOnly {\n    require(!isLocked);\n    _;\n  }\n\n\n\n  //\n  // constructor\n  //\n  function OrganizeFunds() public {\n    owner = msg.sender;\n  }\n\n  function lock() public ownerOnly {\n    isLocked = true;\n  }\n\n  function setName(string _name) public ownerOnly {\n    name = _name;\n  }\n\n  //\n  // reset\n  // reset all activity accounts\n  // in case we have any funds that have not been withdrawn, they become  newly received and undistributed.\n  //\n  function reset() public ownerOnly unlockedOnly {\n    totalFundsReceived = this.balance;\n    totalFundsDistributed = 0;\n    totalFundsWithdrawn = 0;\n    activityCount = 0;\n    MessageEvent(\"ok: all accts reset\");\n  }\n\n\n  //\n  // set withdrawal gas\n  // nonstandard gas is necessary to support push-withdrawals to other contract\n  //\n  function setWitdrawGas(uint256 _withdrawGas) public ownerOnly {\n    withdrawGas = _withdrawGas;\n    MessageEventI(\"ok: withdraw gas set\", withdrawGas);\n  }\n\n\n  //\n  // add a new activity account\n  //\n  function addActivityAccount(address _addr, uint256 _pctx10, string _name) public ownerOnly unlockedOnly {\n    if (activityCount >= MAX_ACCOUNTS) {\n      MessageEvent(\"err: max accounts\");\n      return;\n    }\n    activityAccounts[activityCount].addr = _addr;\n    activityAccounts[activityCount].pctx10 = _pctx10;\n    activityAccounts[activityCount].credited = 0;\n    activityAccounts[activityCount].balance = 0;\n    activityAccounts[activityCount].name = _name;\n    ++activityCount;\n    MessageEvent(\"ok: acct added\");\n  }\n\n\n  // ----------------------------\n  // get acct info\n  // ----------------------------\n  function getActivityAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, string _name, uint _credited, uint _balance) {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == _addr) {\n        _idx = i;\n        _pctx10 = activityAccounts[i].pctx10;\n        _name = activityAccounts[i].name;\n        _credited = activityAccounts[i].credited;\n        _balance = activityAccounts[i].balance;\n        return;\n      }\n    }\n  }\n\n\n  //\n  // get total percentages x10\n  //\n  function getTotalPctx10() public constant returns(uint _totalPctx10) {\n    _totalPctx10 = 0;\n    for (uint i = 0; i < activityCount; i++ ) {\n      _totalPctx10 += activityAccounts[i].pctx10;\n    }\n  }\n\n\n  //\n  // default payable function.\n  // call us with plenty of gas, or catastrophe will ensue\n  //\n  function () public payable {\n    totalFundsReceived += msg.value;\n    MessageEventI(\"ok: received\", msg.value);\n  }\n\n\n  //\n  // distribute funds to all activities\n  //\n  function distribute() public {\n    //only payout if we have more than 1000 wei\n    if (this.balance < TENHUNDWEI) {\n      return;\n    }\n    //each account gets their prescribed percentage of this holdover.\n    uint i;\n    uint pctx10;\n    uint acctDist;\n    for (i = 0; i < activityCount; i++ ) {\n      pctx10 = activityAccounts[i].pctx10;\n      acctDist = totalFundsReceived * pctx10 / TENHUNDWEI;\n      //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct\n      if (activityAccounts[i].credited >= acctDist) {\n        acctDist = 0;\n      } else {\n        acctDist = acctDist - activityAccounts[i].credited;\n      }\n      activityAccounts[i].credited += acctDist;\n      activityAccounts[i].balance += acctDist;\n      totalFundsDistributed += acctDist;\n    }\n    MessageEvent(\"ok: distributed funds\");\n  }\n\n\n  //\n  // withdraw actvity balance\n  // can be called by owner to push funds to another contract\n  //\n  function withdraw() public {\n    for (uint i = 0; i < activityCount; i++ ) {\n      address addr = activityAccounts[i].addr;\n      if (addr == msg.sender || msg.sender == owner) {\n        uint amount = activityAccounts[i].balance;\n        if (amount > 0) {\n          activityAccounts[i].balance = 0;\n          totalFundsWithdrawn += amount;\n          if (!addr.call.gas(withdrawGas).value(amount)()) {\n            //put back funds in case of err\n            activityAccounts[i].balance = amount;\n            totalFundsWithdrawn -= amount;\n            MessageEvent(\"err: error sending funds\");\n            return;\n          }\n        }\n      }\n    }\n  }\n\n\n  //\n  // suicide\n  //\n  function hariKari() public ownerOnly unlockedOnly {\n    selfdestruct(owner);\n  }\n\n}", "debug": "keccac_4_+_keccac_storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OrganizeFunds_4 + calldata_OrganizeFunds_32 + 36: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nstorage_4: 0x9\nstorage_0: 0x0\nstorage_2: 0x0\ncaller: 0x0\ncalldata_OrganizeFunds_0: 0x48ce382d00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrganizeFunds: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addActivityAccount(address,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x4933dea7ea497a87d41acc5d8048ac2d8e6cedfb.sol", "function": "addActivityAccount(address,uint256,string)", "lineno": 13, "title": "Integer Overflow ", "type": "Warning"}], "success": true}