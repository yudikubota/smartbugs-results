{"error": null, "issues": [{"address": 2550, "code": ");\n        oldOwner.transfer(", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2810\nCall at address: 2703\n", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "buytoken(uint256)", "lineno": 120, "title": "Multiple Calls", "type": "Information"}, {"address": 2703, "code": "rice += price20; \n        t", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2810\n", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "buytoken(uint256)", "lineno": 122, "title": "Multiple Calls", "type": "Information"}, {"address": 2703, "code": "rice += price20; \n        t", "debug": "", "description": "A possible transaction order independence vulnerability exists in function buytoken(uint256). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "buytoken(uint256)", "lineno": 122, "title": "Transaction order dependence", "type": "Warning"}, {"address": 3022, "debug": "storage_keccac_calldata_TestERC721_4: 0xff00\ncallvalue: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_TestERC721_4,_256): 0x0\nretval_2810: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_2703: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_2550: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2 + keccac_calldata_TestERC721_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffff00\ncalldata_TestERC721_0: 0x19bece1b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\n", "description": "A possible integer underflow exists in the function `buytoken(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "buytoken(uint256)", "lineno": 128, "title": "Integer Underflow", "type": "Warning"}, {"address": 3100, "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_TestERC721_4: 0xff00\ncallvalue: 0x0\nretval_2810: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_2703: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_2550: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2 + keccac_calldata_TestERC721_4: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffff00\ncalldata_TestERC721_0: 0x19bece1b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\n", "description": "A possible integer overflow exists in the function `buytoken(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "buytoken(uint256)", "lineno": 128, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4318, "code": "nces[newOwner] += 1;\n      ", "debug": "storage_keccac_calldata_TestERC721_32_+_4: 0x100\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_TestERC721_4: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0x1\ncalldata_TestERC721_0: 0xa9059cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `transfer(address,uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "transfer(address,uint256)", "lineno": 86, "title": "Integer Underflow", "type": "Warning"}, {"address": 4478, "code": " }\n\n    function tokenM", "debug": "storage_keccac_calldata_TestERC721_32_+_4: 0x100\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TestERC721_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TestERC721_4: 0x20000000000\ncaller: 0x1\ncalldata_TestERC721_0: 0xa9059cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transfer(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "transfer(address,uint256)", "lineno": 88, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4750, "code": "okenExists[index] = true;\n        index += ", "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TestERC721_0: 0xabad346600000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createtoken(string,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "createtoken(string,string,uint256)", "lineno": 98, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5386, "code": "     balances[newOwner]", "debug": "storage_keccac_calldata_TestERC721_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_calldata_TestERC721_4,_256): 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffff00\ncalldata_TestERC721_0: 0xb2e6ceeb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncalldata_TestERC721_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `takeOwnership(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "takeOwnership(uint256)", "lineno": 73, "title": "Integer Underflow", "type": "Warning"}, {"address": 5546, "code": "nId);\n    }\n\n    functi", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_TestERC721_4: 0xff00\ncaller: 0xffffffffffffffffffffffffffffffffffffff00\ncalldata_TestERC721_0: 0xb2e6ceeb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncalldata_TestERC721_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `takeOwnership(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "takeOwnership(uint256)", "lineno": 74, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5768, "code": "_tokenId) payable public {\n        address new", "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 36)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_calldata_TestERC721_4: 0xff00\ncalldata_TestERC721_0: 0xe397dfd100000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updatetoken(uint256,string,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "updatetoken(uint256,string,string,uint256)", "lineno": 111, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5915, "code": "ntract TestERC721 {\n    \n    address private _admin;\n\n    uint256 private _totalSupply;\n    mapping(address => uint) private balances;\n    uint256 private index;\n\n    mapping(uint256 => address) private tokenOwners;\n    mapping(uint256 => bool) private tokenExists;\n    mapping(address => mapping (address => uint256)) allowed;\n    mapping(uint256 => token) tokens;\n\n    struct token {\n        string name;\n        string link;\n        uint256 price;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n    event Approval(address indexed _from, address indexed _to, uint256 _tokenId);\n\n    constructor() public {\n        _admin = 0xa06507041083cFfC7aB1E89f3c59d0AD49Bf384D;\n    }\n    \n    function admin() public constant returns (address) {\n        return _admin;\n    }\n    \n    function name() public pure returns (string) {\n        return \"Test Token\";\n    }\n\n    function symbol() public pure returns (string) {\n        return \"TTE\";\n    }\n\n    function totalSupply() public constant returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _address) public constant returns (uint) {\n        return balances[_address];\n    }\n\n    function changeAdmin(address _address) public {\n        require(msg.sender == _admin);\n        _admin = _address;\n    }\n    function ownerOf(uint256 _tokenId) public constant returns (address) {\n        require(tokenExists[_tokenId]);\n        return tokenOwners[_tokenId];\n    }\n\n    function approve(address _to, uint256 _tokenId) public {\n        require(msg.sender == ownerOf(_tokenId));\n        require(msg.sender != _to);\n        allowed[msg.sender][_to] = _tokenId;\n        emit Approval(msg.sender, _to, _tokenId);\n    }\n\n    function takeOwnership(uint256 _tokenId) public {\n        require(tokenExists[_tokenId]);\n        address oldOwner = ownerOf(_tokenId);\n        address newOwner = msg.sender;\n        require(newOwner != oldOwner);\n        require(allowed[oldOwner][newOwner] == _tokenId);\n        balances[oldOwner] -= 1;\n        tokenOwners[_tokenId] = newOwner;\n        balances[newOwner] += 1;\n        emit Transfer(oldOwner, newOwner, _tokenId);\n    }\n\n    function transfer(address _to, uint256 _tokenId) public {\n        address currentOwner = msg.sender;\n        address newOwner = _to;\n        require(tokenExists[_tokenId]);\n        require(currentOwner == ownerOf(_tokenId));\n        require(currentOwner != newOwner);\n        require(newOwner != address(0));\n        balances[currentOwner] -= 1;\n        tokenOwners[_tokenId] = newOwner;\n        balances[newOwner] += 1;\n        emit Transfer(currentOwner, newOwner, _tokenId);\n    }\n\n    function tokenMetadata(uint256 _tokenId) public constant returns (string, string, uint256) {\n        return (tokens[_tokenId].name, tokens[_tokenId].link, tokens[_tokenId].price);\n    }\n    \n    function createtoken(string _name, string _link, uint256 _price) public returns (bool success) {\n        require(msg.sender == _admin);\n        tokens[index] = token(_name, _link, _price);\n        tokenOwners[index] = msg.sender;\n        tokenExists[index] = true;\n        index += 1;\n        balances[msg.sender] += 1;\n        _totalSupply += 1;\n        return true;\n    }\n\n    function updatetoken(uint256 _tokenId, string _name, string _link, uint256 _price) public returns (bool success) {\n        require(tokenExists[_tokenId]);\n        tokens[_tokenId] = token(_name, _link, _price);\n        return true;\n    }\n\n    function buytoken(uint256 _tokenId) payable public {\n        address newOwner = msg.sender;\n        address oldOwner = tokenOwners[_tokenId];\n        require(tokenExists[_tokenId]);\n        require(newOwner != ownerOf(_tokenId));\n        require(msg.value >= tokens[_tokenId].price);\n        uint256 _remainder = msg.value - tokens[_tokenId].price;\n        newOwner.transfer(_remainder);\n        uint256 price20 = tokens[_tokenId].price/5;\n        _admin.transfer(price20/20);\n        oldOwner.transfer(tokens[_tokenId].price - price20/20);\n        tokens[_tokenId].price += price20; \n        tokenOwners[_tokenId] = newOwner;\n        balances[oldOwner] -= 1;\n        balances[newOwner] += 1;\n        emit Transfer(oldOwner, newOwner, _tokenId);\n    }\n}", "debug": "keccac_0_+_keccac_calldata_TestERC721_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 + keccac_calldata_TestERC721_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_keccac_calldata_TestERC721_4: 0xff00\ncalldata_TestERC721_0: 0xe397dfd100000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updatetoken(uint256,string,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "updatetoken(uint256,string,string,uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5944, "code": "ntract TestERC721 {\n    \n    address private _admin;\n\n    uint256 private _totalSupply;\n    mapping(address => uint) private balances;\n    uint256 private index;\n\n    mapping(uint256 => address) private tokenOwners;\n    mapping(uint256 => bool) private tokenExists;\n    mapping(address => mapping (address => uint256)) allowed;\n    mapping(uint256 => token) tokens;\n\n    struct token {\n        string name;\n        string link;\n        uint256 price;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n    event Approval(address indexed _from, address indexed _to, uint256 _tokenId);\n\n    constructor() public {\n        _admin = 0xa06507041083cFfC7aB1E89f3c59d0AD49Bf384D;\n    }\n    \n    function admin() public constant returns (address) {\n        return _admin;\n    }\n    \n    function name() public pure returns (string) {\n        return \"Test Token\";\n    }\n\n    function symbol() public pure returns (string) {\n        return \"TTE\";\n    }\n\n    function totalSupply() public constant returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _address) public constant returns (uint) {\n        return balances[_address];\n    }\n\n    function changeAdmin(address _address) public {\n        require(msg.sender == _admin);\n        _admin = _address;\n    }\n    function ownerOf(uint256 _tokenId) public constant returns (address) {\n        require(tokenExists[_tokenId]);\n        return tokenOwners[_tokenId];\n    }\n\n    function approve(address _to, uint256 _tokenId) public {\n        require(msg.sender == ownerOf(_tokenId));\n        require(msg.sender != _to);\n        allowed[msg.sender][_to] = _tokenId;\n        emit Approval(msg.sender, _to, _tokenId);\n    }\n\n    function takeOwnership(uint256 _tokenId) public {\n        require(tokenExists[_tokenId]);\n        address oldOwner = ownerOf(_tokenId);\n        address newOwner = msg.sender;\n        require(newOwner != oldOwner);\n        require(allowed[oldOwner][newOwner] == _tokenId);\n        balances[oldOwner] -= 1;\n        tokenOwners[_tokenId] = newOwner;\n        balances[newOwner] += 1;\n        emit Transfer(oldOwner, newOwner, _tokenId);\n    }\n\n    function transfer(address _to, uint256 _tokenId) public {\n        address currentOwner = msg.sender;\n        address newOwner = _to;\n        require(tokenExists[_tokenId]);\n        require(currentOwner == ownerOf(_tokenId));\n        require(currentOwner != newOwner);\n        require(newOwner != address(0));\n        balances[currentOwner] -= 1;\n        tokenOwners[_tokenId] = newOwner;\n        balances[newOwner] += 1;\n        emit Transfer(currentOwner, newOwner, _tokenId);\n    }\n\n    function tokenMetadata(uint256 _tokenId) public constant returns (string, string, uint256) {\n        return (tokens[_tokenId].name, tokens[_tokenId].link, tokens[_tokenId].price);\n    }\n    \n    function createtoken(string _name, string _link, uint256 _price) public returns (bool success) {\n        require(msg.sender == _admin);\n        tokens[index] = token(_name, _link, _price);\n        tokenOwners[index] = msg.sender;\n        tokenExists[index] = true;\n        index += 1;\n        balances[msg.sender] += 1;\n        _totalSupply += 1;\n        return true;\n    }\n\n    function updatetoken(uint256 _tokenId, string _name, string _link, uint256 _price) public returns (bool success) {\n        require(tokenExists[_tokenId]);\n        tokens[_tokenId] = token(_name, _link, _price);\n        return true;\n    }\n\n    function buytoken(uint256 _tokenId) payable public {\n        address newOwner = msg.sender;\n        address oldOwner = tokenOwners[_tokenId];\n        require(tokenExists[_tokenId]);\n        require(newOwner != ownerOf(_tokenId));\n        require(msg.value >= tokens[_tokenId].price);\n        uint256 _remainder = msg.value - tokens[_tokenId].price;\n        newOwner.transfer(_remainder);\n        uint256 price20 = tokens[_tokenId].price/5;\n        _admin.transfer(price20/20);\n        oldOwner.transfer(tokens[_tokenId].price - price20/20);\n        tokens[_tokenId].price += price20; \n        tokenOwners[_tokenId] = newOwner;\n        balances[oldOwner] -= 1;\n        balances[newOwner] += 1;\n        emit Transfer(oldOwner, newOwner, _tokenId);\n    }\n}", "debug": "mem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 36)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_calldata_TestERC721_4: 0xff00\ncalldata_TestERC721_0: 0xe397dfd100000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updatetoken(uint256,string,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "updatetoken(uint256,string,string,uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5958, "code": "ntract TestERC721 {\n    \n    address private _admin;\n\n    uint256 private _totalSupply;\n    mapping(address => uint) private balances;\n    uint256 private index;\n\n    mapping(uint256 => address) private tokenOwners;\n    mapping(uint256 => bool) private tokenExists;\n    mapping(address => mapping (address => uint256)) allowed;\n    mapping(uint256 => token) tokens;\n\n    struct token {\n        string name;\n        string link;\n        uint256 price;\n    }\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _tokenId);\n    event Approval(address indexed _from, address indexed _to, uint256 _tokenId);\n\n    constructor() public {\n        _admin = 0xa06507041083cFfC7aB1E89f3c59d0AD49Bf384D;\n    }\n    \n    function admin() public constant returns (address) {\n        return _admin;\n    }\n    \n    function name() public pure returns (string) {\n        return \"Test Token\";\n    }\n\n    function symbol() public pure returns (string) {\n        return \"TTE\";\n    }\n\n    function totalSupply() public constant returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address _address) public constant returns (uint) {\n        return balances[_address];\n    }\n\n    function changeAdmin(address _address) public {\n        require(msg.sender == _admin);\n        _admin = _address;\n    }\n    function ownerOf(uint256 _tokenId) public constant returns (address) {\n        require(tokenExists[_tokenId]);\n        return tokenOwners[_tokenId];\n    }\n\n    function approve(address _to, uint256 _tokenId) public {\n        require(msg.sender == ownerOf(_tokenId));\n        require(msg.sender != _to);\n        allowed[msg.sender][_to] = _tokenId;\n        emit Approval(msg.sender, _to, _tokenId);\n    }\n\n    function takeOwnership(uint256 _tokenId) public {\n        require(tokenExists[_tokenId]);\n        address oldOwner = ownerOf(_tokenId);\n        address newOwner = msg.sender;\n        require(newOwner != oldOwner);\n        require(allowed[oldOwner][newOwner] == _tokenId);\n        balances[oldOwner] -= 1;\n        tokenOwners[_tokenId] = newOwner;\n        balances[newOwner] += 1;\n        emit Transfer(oldOwner, newOwner, _tokenId);\n    }\n\n    function transfer(address _to, uint256 _tokenId) public {\n        address currentOwner = msg.sender;\n        address newOwner = _to;\n        require(tokenExists[_tokenId]);\n        require(currentOwner == ownerOf(_tokenId));\n        require(currentOwner != newOwner);\n        require(newOwner != address(0));\n        balances[currentOwner] -= 1;\n        tokenOwners[_tokenId] = newOwner;\n        balances[newOwner] += 1;\n        emit Transfer(currentOwner, newOwner, _tokenId);\n    }\n\n    function tokenMetadata(uint256 _tokenId) public constant returns (string, string, uint256) {\n        return (tokens[_tokenId].name, tokens[_tokenId].link, tokens[_tokenId].price);\n    }\n    \n    function createtoken(string _name, string _link, uint256 _price) public returns (bool success) {\n        require(msg.sender == _admin);\n        tokens[index] = token(_name, _link, _price);\n        tokenOwners[index] = msg.sender;\n        tokenExists[index] = true;\n        index += 1;\n        balances[msg.sender] += 1;\n        _totalSupply += 1;\n        return true;\n    }\n\n    function updatetoken(uint256 _tokenId, string _name, string _link, uint256 _price) public returns (bool success) {\n        require(tokenExists[_tokenId]);\n        tokens[_tokenId] = token(_name, _link, _price);\n        return true;\n    }\n\n    function buytoken(uint256 _tokenId) payable public {\n        address newOwner = msg.sender;\n        address oldOwner = tokenOwners[_tokenId];\n        require(tokenExists[_tokenId]);\n        require(newOwner != ownerOf(_tokenId));\n        require(msg.value >= tokens[_tokenId].price);\n        uint256 _remainder = msg.value - tokens[_tokenId].price;\n        newOwner.transfer(_remainder);\n        uint256 price20 = tokens[_tokenId].price/5;\n        _admin.transfer(price20/20);\n        oldOwner.transfer(tokens[_tokenId].price - price20/20);\n        tokens[_tokenId].price += price20; \n        tokenOwners[_tokenId] = newOwner;\n        balances[oldOwner] -= 1;\n        balances[newOwner] += 1;\n        emit Transfer(oldOwner, newOwner, _tokenId);\n    }\n}", "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 36)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TestERC721_4 + calldata_TestERC721_32 + 36)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_keccac_calldata_TestERC721_4: 0xff00\ncalldata_TestERC721_0: 0xe397dfd100000000000000000000000000000000000000000000000000000000\ncalldatasize_TestERC721: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `updatetoken(uint256,string,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/21/0x61c2d5cf5fb2096348e78f71315b9d42cf42082f.sol", "function": "updatetoken(uint256,string,string,uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}