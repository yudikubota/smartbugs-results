{
  "contract": "0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d",
  "tool": "mythril",
  "start": 1563482528.9452302,
  "end": 1563482714.9181905,
  "duration": 185.97296023368835,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 473,
        "code": "tingRecord storage lastVote = votes[guardian];\n\n        blockNumber = lastVote.blockNumber;\n        validators = lastVote.validators;\n    }\n\n    /// @dev check that the validators array is unique and non zero.\n    /// @param validators address[]\n    function sanitizeValidators(address[] validators",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_OrbsVoting_0: 0xa8b52c2500000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getCurrentVote(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "getCurrentVote(address)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 675,
        "code": "Bytes20, uint blockNumber)\n    {\n        address[] memory validatorAddresses;\n        (validatorAddresses, blockNumber) = getCurrentVote(guardian);\n\n        uint validatorAddressesLength = validatorAddresses.length;\n\n        validatorsBytes20 = new bytes20[](validatorAddressesLength);\n\n        for (uint i = 0; i < validatorAddressesLength; i++) {\n            validatorsBytes20[i] = bytes20(validatorAddresses[i]);\n        }\n    }\n\n    /// @dev returns the address to which the delegator has delegated the stake\n    /// @param delegator address the address of the de",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x1\nmem_128 +\n32 +\n32*\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_OrbsVoting_0: 0xe5d0161800000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getCurrentVoteBytes20(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "getCurrentVoteBytes20(address)",
        "lineno": 125,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 763,
        "code": "sender;\n        require(validators.length <= maxVoteOutCount, \"Validators list is over the allowed length\");\n        sanitizeValidators(validators);\n\n        voteCounter++;\n\n        votes[sender] = VotingRecord({\n            blockNumber: block.number,\n            validators: validators\n        });\n\n        emit VoteOut(sender, validators, voteCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n   ",
        "debug": "calldata_OrbsVoting_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 81,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1283,
        "code": "Counter);\n    }\n\n  ",
        "debug": "storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0x0\ncalldata_OrbsVoting_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_OrbsVoting_0: 0x5c19a95c00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `delegate(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "delegate(address)",
        "lineno": 106,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1539,
        "code": "ter);\n        emit ",
        "debug": "storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OrbsVoting_0: 0x92ab89bb00000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `undelegate()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "undelegate()",
        "lineno": 116,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1949,
        "code": " sanitizeValidators(address[] va",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_OrbsVoting_0: 0xe5d0161800000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getCurrentVoteBytes20(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "getCurrentVoteBytes20(address)",
        "lineno": 164,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1951,
        "code": " sanitizeValidators(address[] va",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_OrbsVoting_0: 0xe5d0161800000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getCurrentVoteBytes20(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "getCurrentVoteBytes20(address)",
        "lineno": 164,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2201,
        "code": "legated the stake\n  ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x1\ncalldata_OrbsVoting_0: 0xe5d0161800000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\nmem_128 +\n32 +\n32*\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_OrbsVoting_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "getCurrentVoteBytes20(address)",
        "lineno": 139,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2505,
        "code": "k.number,\n   ",
        "debug": "storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_OrbsVoting_4 + calldata_OrbsVoting_4: 0x1\ncalldata_OrbsVoting_cpy: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x1\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 88,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2667,
        "code": "dators: validators\n        });\n\n        emit VoteOut(sender, validators, voteCounter);\n    }\n\n    /// @dev Delegation ",
        "debug": "mem_160 + 32*calldata_OrbsVoting_4 + calldata_OrbsVoting_4 + 32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_OrbsVoting_4 + calldata_OrbsVoting_4: 0x1\ncalldata_OrbsVoting_cpy: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x1\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 89,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3333,
        "code": "vote is a pair of block number and list of validators. The vote's block\n    // number is used to determine the vote qualification for an election event.\n    struct VotingRecord {\n        uint blockNumber;\n        address[] validators;\n    }\n\n    // The version of the current Voting smart contract.\n    uint public constant VERSION = 1;\n\n    // Vars to see that voting and delegating is moving forward. Is used to emit\n    // events to test for completeness.\n    uint internal voteCounter;\n    uint internal delegationCounter;\n\n    // The amount of validators you can vote out in each election round. This will be set to 3 in the construction.\n    uint public maxVoteOutCount;\n\n    // Internal mappings to keep track of the votes and delegations.\n    mapping(address => VotingRecord) internal votes;\n    mapping(address => address) internal delegations;\n\n    /// @dev Constructor that initializes the Voting contract. maxVoteOutCount will be set to 3.\n    constructor(uint maxVoteOutCount_) public {\n        require(maxVoteOutCount_ > 0, \"maxVoteOutCount_ must be positive\");\n        maxVoteOutCount = maxVoteOutCount_;\n    }\n\n    /// @dev Voting method to select which validators you want to vote out in this election period.\n    /// @param validators address[] an array of validators addresses you want to vote out. In case you want to vote, but not vote out anyone, send an empty array.\n    function voteOut(address[] validators) external {\n        address sender = msg.sender;\n        require(validators.length <= maxVoteOutCount, \"Validators list is over the allowed length\");\n        sanitizeValidators(validators);\n\n        voteCounter++;\n\n        votes[sender] = VotingRecord({\n            blockNumber: block.number,\n            validators: validators\n        });\n\n        emit VoteOut(sender, validators, voteCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    /// @param to address the address, you want to delegate your stake to. If you want to cancel a delegation - delegate to yourself to yourself.\n    function delegate(address to) external {\n        address sender = msg.sender;\n        require(to != address(0), \"must delegate to non 0\");\n        require(sender != to , \"cant delegate to yourself\");\n\n        delegationCounter++;\n\n        delegations[sender] = to;\n\n        emit Delegate(sender, to, delegationCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    function undelegate() external {\n        address sender = msg.sender;\n        delegationCounter++;\n\n        delete delegations[sender];\n\n        emit Delegate(sender, sender, delegationCounter);\n        emit Undelegate(sender, delegationCounter);\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    ///      same as getCurrentVote but returns addresses represented as byte20.\n    function getCurrentVoteBytes20(address guardian)\n        public\n        view\n        returns (bytes20[] memory validatorsBytes20, uint blockNumber)\n    {\n        address[] memory validatorAddresses;\n        (validatorAddresses, blockNumber) = getCurrentVote(guardian);\n\n        uint validatorAddressesLength = validatorAddresses.length;\n\n        validatorsBytes20 = new bytes20[](validatorAddressesLength);\n\n        for (uint i = 0; i < validatorAddressesLength; i++) {\n            validatorsBytes20[i] = bytes20(validatorAddresses[i]);\n        }\n    }\n\n    /// @dev returns the address to which the delegator has delegated the stake\n    /// @param delegator address the address of the delegator\n    function getCurrentDelegation(address delegator)\n        public\n        view\n        returns (address)\n    {\n        return delegations[delegator];\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    /// @param guardian address the address of the guardian\n    function getCurrentVote(address guardian)\n        public\n        view\n        returns (address[] memory validators, uint blockNumber)\n    {\n        VotingRecord storage lastVote = votes[guardian];\n\n        blockNumber = lastVote.blockNumber;\n        validators = lastVote.validators;\n    }\n\n    /// @dev check that the validators array is unique and non zero.\n    /// @param validators address[]\n    function sanitizeValidators(address[] validators)\n        private\n        pure\n    {\n        uint validatorsLength = validators.length;\n        for (uint i = 0; i < validatorsLength; i++) {\n            require(validators[i] != address(0), \"All validator addresses must be non 0\");\n            for (uint j = i + 1; j < validatorsLength; j++) {\n                require(validators[j] != validators[i], \"Duplicate Validators\");\n            }\n        }\n    }\n}",
        "debug": "keccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncalldata_OrbsVoting_4 + calldata_OrbsVoting_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 50,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3344,
        "code": "vote is a pair of block number and list of validators. The vote's block\n    // number is used to determine the vote qualification for an election event.\n    struct VotingRecord {\n        uint blockNumber;\n        address[] validators;\n    }\n\n    // The version of the current Voting smart contract.\n    uint public constant VERSION = 1;\n\n    // Vars to see that voting and delegating is moving forward. Is used to emit\n    // events to test for completeness.\n    uint internal voteCounter;\n    uint internal delegationCounter;\n\n    // The amount of validators you can vote out in each election round. This will be set to 3 in the construction.\n    uint public maxVoteOutCount;\n\n    // Internal mappings to keep track of the votes and delegations.\n    mapping(address => VotingRecord) internal votes;\n    mapping(address => address) internal delegations;\n\n    /// @dev Constructor that initializes the Voting contract. maxVoteOutCount will be set to 3.\n    constructor(uint maxVoteOutCount_) public {\n        require(maxVoteOutCount_ > 0, \"maxVoteOutCount_ must be positive\");\n        maxVoteOutCount = maxVoteOutCount_;\n    }\n\n    /// @dev Voting method to select which validators you want to vote out in this election period.\n    /// @param validators address[] an array of validators addresses you want to vote out. In case you want to vote, but not vote out anyone, send an empty array.\n    function voteOut(address[] validators) external {\n        address sender = msg.sender;\n        require(validators.length <= maxVoteOutCount, \"Validators list is over the allowed length\");\n        sanitizeValidators(validators);\n\n        voteCounter++;\n\n        votes[sender] = VotingRecord({\n            blockNumber: block.number,\n            validators: validators\n        });\n\n        emit VoteOut(sender, validators, voteCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    /// @param to address the address, you want to delegate your stake to. If you want to cancel a delegation - delegate to yourself to yourself.\n    function delegate(address to) external {\n        address sender = msg.sender;\n        require(to != address(0), \"must delegate to non 0\");\n        require(sender != to , \"cant delegate to yourself\");\n\n        delegationCounter++;\n\n        delegations[sender] = to;\n\n        emit Delegate(sender, to, delegationCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    function undelegate() external {\n        address sender = msg.sender;\n        delegationCounter++;\n\n        delete delegations[sender];\n\n        emit Delegate(sender, sender, delegationCounter);\n        emit Undelegate(sender, delegationCounter);\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    ///      same as getCurrentVote but returns addresses represented as byte20.\n    function getCurrentVoteBytes20(address guardian)\n        public\n        view\n        returns (bytes20[] memory validatorsBytes20, uint blockNumber)\n    {\n        address[] memory validatorAddresses;\n        (validatorAddresses, blockNumber) = getCurrentVote(guardian);\n\n        uint validatorAddressesLength = validatorAddresses.length;\n\n        validatorsBytes20 = new bytes20[](validatorAddressesLength);\n\n        for (uint i = 0; i < validatorAddressesLength; i++) {\n            validatorsBytes20[i] = bytes20(validatorAddresses[i]);\n        }\n    }\n\n    /// @dev returns the address to which the delegator has delegated the stake\n    /// @param delegator address the address of the delegator\n    function getCurrentDelegation(address delegator)\n        public\n        view\n        returns (address)\n    {\n        return delegations[delegator];\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    /// @param guardian address the address of the guardian\n    function getCurrentVote(address guardian)\n        public\n        view\n        returns (address[] memory validators, uint blockNumber)\n    {\n        VotingRecord storage lastVote = votes[guardian];\n\n        blockNumber = lastVote.blockNumber;\n        validators = lastVote.validators;\n    }\n\n    /// @dev check that the validators array is unique and non zero.\n    /// @param validators address[]\n    function sanitizeValidators(address[] validators)\n        private\n        pure\n    {\n        uint validatorsLength = validators.length;\n        for (uint i = 0; i < validatorsLength; i++) {\n            require(validators[i] != address(0), \"All validator addresses must be non 0\");\n            for (uint j = i + 1; j < validatorsLength; j++) {\n                require(validators[j] != validators[i], \"Duplicate Validators\");\n            }\n        }\n    }\n}",
        "debug": "calldata_OrbsVoting_4 + calldata_OrbsVoting_4: 0x1\nmem_mem_160 + 32*calldata_OrbsVoting_4 + calldata_OrbsVoting_4 + 32: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_OrbsVoting_cpy: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x1\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 50,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3346,
        "code": "vote is a pair of block number and list of validators. The vote's block\n    // number is used to determine the vote qualification for an election event.\n    struct VotingRecord {\n        uint blockNumber;\n        address[] validators;\n    }\n\n    // The version of the current Voting smart contract.\n    uint public constant VERSION = 1;\n\n    // Vars to see that voting and delegating is moving forward. Is used to emit\n    // events to test for completeness.\n    uint internal voteCounter;\n    uint internal delegationCounter;\n\n    // The amount of validators you can vote out in each election round. This will be set to 3 in the construction.\n    uint public maxVoteOutCount;\n\n    // Internal mappings to keep track of the votes and delegations.\n    mapping(address => VotingRecord) internal votes;\n    mapping(address => address) internal delegations;\n\n    /// @dev Constructor that initializes the Voting contract. maxVoteOutCount will be set to 3.\n    constructor(uint maxVoteOutCount_) public {\n        require(maxVoteOutCount_ > 0, \"maxVoteOutCount_ must be positive\");\n        maxVoteOutCount = maxVoteOutCount_;\n    }\n\n    /// @dev Voting method to select which validators you want to vote out in this election period.\n    /// @param validators address[] an array of validators addresses you want to vote out. In case you want to vote, but not vote out anyone, send an empty array.\n    function voteOut(address[] validators) external {\n        address sender = msg.sender;\n        require(validators.length <= maxVoteOutCount, \"Validators list is over the allowed length\");\n        sanitizeValidators(validators);\n\n        voteCounter++;\n\n        votes[sender] = VotingRecord({\n            blockNumber: block.number,\n            validators: validators\n        });\n\n        emit VoteOut(sender, validators, voteCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    /// @param to address the address, you want to delegate your stake to. If you want to cancel a delegation - delegate to yourself to yourself.\n    function delegate(address to) external {\n        address sender = msg.sender;\n        require(to != address(0), \"must delegate to non 0\");\n        require(sender != to , \"cant delegate to yourself\");\n\n        delegationCounter++;\n\n        delegations[sender] = to;\n\n        emit Delegate(sender, to, delegationCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    function undelegate() external {\n        address sender = msg.sender;\n        delegationCounter++;\n\n        delete delegations[sender];\n\n        emit Delegate(sender, sender, delegationCounter);\n        emit Undelegate(sender, delegationCounter);\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    ///      same as getCurrentVote but returns addresses represented as byte20.\n    function getCurrentVoteBytes20(address guardian)\n        public\n        view\n        returns (bytes20[] memory validatorsBytes20, uint blockNumber)\n    {\n        address[] memory validatorAddresses;\n        (validatorAddresses, blockNumber) = getCurrentVote(guardian);\n\n        uint validatorAddressesLength = validatorAddresses.length;\n\n        validatorsBytes20 = new bytes20[](validatorAddressesLength);\n\n        for (uint i = 0; i < validatorAddressesLength; i++) {\n            validatorsBytes20[i] = bytes20(validatorAddresses[i]);\n        }\n    }\n\n    /// @dev returns the address to which the delegator has delegated the stake\n    /// @param delegator address the address of the delegator\n    function getCurrentDelegation(address delegator)\n        public\n        view\n        returns (address)\n    {\n        return delegations[delegator];\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    /// @param guardian address the address of the guardian\n    function getCurrentVote(address guardian)\n        public\n        view\n        returns (address[] memory validators, uint blockNumber)\n    {\n        VotingRecord storage lastVote = votes[guardian];\n\n        blockNumber = lastVote.blockNumber;\n        validators = lastVote.validators;\n    }\n\n    /// @dev check that the validators array is unique and non zero.\n    /// @param validators address[]\n    function sanitizeValidators(address[] validators)\n        private\n        pure\n    {\n        uint validatorsLength = validators.length;\n        for (uint i = 0; i < validatorsLength; i++) {\n            require(validators[i] != address(0), \"All validator addresses must be non 0\");\n            for (uint j = i + 1; j < validatorsLength; j++) {\n                require(validators[j] != validators[i], \"Duplicate Validators\");\n            }\n        }\n    }\n}",
        "debug": "mem_160 + 32*calldata_OrbsVoting_4 + calldata_OrbsVoting_4 + 32: 0x7fffffffffffffffffffffffffffffffffffffdaffffffffbfff7fffffffffe0\ncalldata_OrbsVoting_4 + calldata_OrbsVoting_4: 0x1\nmem_mem_160 + 32*calldata_OrbsVoting_4 + calldata_OrbsVoting_4 + 32: 0x7f6fc32c410701432cb30000000000000000000dfffffff3fc0000000000000\ncalldata_OrbsVoting_cpy: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x1\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 50,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3429,
        "code": "vote is a pair of block number and list of validators. The vote's block\n    // number is used to determine the vote qualification for an election event.\n    struct VotingRecord {\n        uint blockNumber;\n        address[] validators;\n    }\n\n    // The version of the current Voting smart contract.\n    uint public constant VERSION = 1;\n\n    // Vars to see that voting and delegating is moving forward. Is used to emit\n    // events to test for completeness.\n    uint internal voteCounter;\n    uint internal delegationCounter;\n\n    // The amount of validators you can vote out in each election round. This will be set to 3 in the construction.\n    uint public maxVoteOutCount;\n\n    // Internal mappings to keep track of the votes and delegations.\n    mapping(address => VotingRecord) internal votes;\n    mapping(address => address) internal delegations;\n\n    /// @dev Constructor that initializes the Voting contract. maxVoteOutCount will be set to 3.\n    constructor(uint maxVoteOutCount_) public {\n        require(maxVoteOutCount_ > 0, \"maxVoteOutCount_ must be positive\");\n        maxVoteOutCount = maxVoteOutCount_;\n    }\n\n    /// @dev Voting method to select which validators you want to vote out in this election period.\n    /// @param validators address[] an array of validators addresses you want to vote out. In case you want to vote, but not vote out anyone, send an empty array.\n    function voteOut(address[] validators) external {\n        address sender = msg.sender;\n        require(validators.length <= maxVoteOutCount, \"Validators list is over the allowed length\");\n        sanitizeValidators(validators);\n\n        voteCounter++;\n\n        votes[sender] = VotingRecord({\n            blockNumber: block.number,\n            validators: validators\n        });\n\n        emit VoteOut(sender, validators, voteCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    /// @param to address the address, you want to delegate your stake to. If you want to cancel a delegation - delegate to yourself to yourself.\n    function delegate(address to) external {\n        address sender = msg.sender;\n        require(to != address(0), \"must delegate to non 0\");\n        require(sender != to , \"cant delegate to yourself\");\n\n        delegationCounter++;\n\n        delegations[sender] = to;\n\n        emit Delegate(sender, to, delegationCounter);\n    }\n\n    /// @dev Delegation method to select who you would like to delegate your stake to.\n    function undelegate() external {\n        address sender = msg.sender;\n        delegationCounter++;\n\n        delete delegations[sender];\n\n        emit Delegate(sender, sender, delegationCounter);\n        emit Undelegate(sender, delegationCounter);\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    ///      same as getCurrentVote but returns addresses represented as byte20.\n    function getCurrentVoteBytes20(address guardian)\n        public\n        view\n        returns (bytes20[] memory validatorsBytes20, uint blockNumber)\n    {\n        address[] memory validatorAddresses;\n        (validatorAddresses, blockNumber) = getCurrentVote(guardian);\n\n        uint validatorAddressesLength = validatorAddresses.length;\n\n        validatorsBytes20 = new bytes20[](validatorAddressesLength);\n\n        for (uint i = 0; i < validatorAddressesLength; i++) {\n            validatorsBytes20[i] = bytes20(validatorAddresses[i]);\n        }\n    }\n\n    /// @dev returns the address to which the delegator has delegated the stake\n    /// @param delegator address the address of the delegator\n    function getCurrentDelegation(address delegator)\n        public\n        view\n        returns (address)\n    {\n        return delegations[delegator];\n    }\n\n    /// @dev returns vote pair - validators list and the block number the vote was set.\n    /// @param guardian address the address of the guardian\n    function getCurrentVote(address guardian)\n        public\n        view\n        returns (address[] memory validators, uint blockNumber)\n    {\n        VotingRecord storage lastVote = votes[guardian];\n\n        blockNumber = lastVote.blockNumber;\n        validators = lastVote.validators;\n    }\n\n    /// @dev check that the validators array is unique and non zero.\n    /// @param validators address[]\n    function sanitizeValidators(address[] validators)\n        private\n        pure\n    {\n        uint validatorsLength = validators.length;\n        for (uint i = 0; i < validatorsLength; i++) {\n            require(validators[i] != address(0), \"All validator addresses must be non 0\");\n            for (uint j = i + 1; j < validatorsLength; j++) {\n                require(validators[j] != validators[i], \"Duplicate Validators\");\n            }\n        }\n    }\n}",
        "debug": "mem_160 + 32*calldata_OrbsVoting_4 + calldata_OrbsVoting_4 + 32: 0x9c07de0effffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nkeccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_mem_160 + 32*calldata_OrbsVoting_4 + calldata_OrbsVoting_4 + 32: 0x180000000000000000000000000000000000000000000000000000000000\ncalldata_OrbsVoting_0: 0xf822202000000000000000000000000000000000000000000000000000000000\ncalldatasize_OrbsVoting: 0x4\ncalldata_OrbsVoting_4 + calldata_OrbsVoting_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `voteOut(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0x30f855afb78758aa4c2dc706fb0fa3a98c865d2d.sol",
        "function": "voteOut(address[])",
        "lineno": 50,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}