{"error": null, "issues": [{"address": 697, "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\ncalldatasize_TrivialToken: 0x3\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "fallback", "lineno": 608, "title": "Exception state", "type": "Informational"}, {"address": 1005, "code": "name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        icoDuration = _icoDuration;\n        auctionDuration = _auctionDuration;\n\n        artist = _artist;\n        trivial = _trivial;\n\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n        currentState = State.BeforeInitTwo;\n    }\n\n    function initTwo(\n        uint256 _totalSupply,\n        uint256 _tokensForArtist,\n        uint256 _tokensForTrivial,\n        uint256 _tokensForIco,\n        uint256 _minEthAmount,\n        uint256 _minBidPercentage,\n        uint256 _tokensPercentageForKeyHolder,\n        uint256 _cleanupDelay,\n        uint256 _fre", "debug": "calldata_TrivialToken_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `initOne(string,string,uint8,uint256,uint256,address,address,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 307, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1017, "code": "name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        icoDuration = _icoDuration;\n        auctionDuration = _auctionDuration;\n\n        artist = _artist;\n        trivial = _trivial;\n\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n        currentState = State.BeforeInitTwo;\n    }\n\n    function initTwo(\n        uint256 _totalSupply,\n        uint256 _tokensForArtist,\n        uint256 _tokensForTrivial,\n        uint256 _tokensForIco,\n        uint256 _minEthAmount,\n        uint256 _minBidPercentage,\n        uint256 _tokensPercentageForKeyHolder,\n        uint256 _cleanupDelay,\n        uint256 _fre", "debug": "calldata_TrivialToken_4 + calldata_TrivialToken_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `initOne(string,string,uint8,uint256,uint256,address,address,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 307, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1026, "code": "name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        icoDuration = _icoDuration;\n        auctionDuration = _auctionDuration;\n\n        artist = _artist;\n        trivial = _trivial;\n\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n        currentState = State.BeforeInitTwo;\n    }\n\n    function initTwo(\n        uint256 _totalSupply,\n        uint256 _tokensForArtist,\n        uint256 _tokensForTrivial,\n        uint256 _tokensForIco,\n        uint256 _minEthAmount,\n        uint256 _minBidPercentage,\n        uint256 _tokensPercentageForKeyHolder,\n        uint256 _cleanupDelay,\n        uint256 _fre", "debug": "calldata_TrivialToken_4 + calldata_TrivialToken_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `initOne(string,string,uint8,uint256,uint256,address,address,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 307, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1032, "code": "name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        icoDuration = _icoDuration;\n        auctionDuration = _auctionDuration;\n\n        artist = _artist;\n        trivial = _trivial;\n\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n        currentState = State.BeforeInitTwo;\n    }\n\n    function initTwo(\n        uint256 _totalSupply,\n        uint256 _tokensForArtist,\n        uint256 _tokensForTrivial,\n        uint256 _tokensForIco,\n        uint256 _minEthAmount,\n        uint256 _minBidPercentage,\n        uint256 _tokensPercentageForKeyHolder,\n        uint256 _cleanupDelay,\n        uint256 _fre", "debug": "calldata_TrivialToken_4 + calldata_TrivialToken_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `initOne(string,string,uint8,uint256,uint256,address,address,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 307, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1490, "code": "ributors and holders\n    ", "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\ncalldata_TrivialToken_0: 0xc3f6acf00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "_function_0x0c3f6acf", "lineno": 271, "title": "Exception state", "type": "Informational"}, {"address": 4578, "code": ";\n\n\n/*\n * Paste Tr", "debug": "storage_35: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_30: 0x100\nstorage_5: 0x0\ntimestamp: 0x0\ncallvalue: 0x1\nstorage_17: 0x1\ncalldatasize_TrivialToken: 0x3\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "fallback", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4983, "code": "ime); _; }\n    modifier onlyA", "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\ncalldata_TrivialToken_0: 0x9e2514100000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "bidInAuction()", "lineno": 281, "title": "Exception state", "type": "Informational"}, {"address": 5716, "code": "ime); _; }\n    modifier onlyA", "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 281, "title": "Exception state", "type": "Informational"}, {"address": 6528, "code": " uint256 _icoDuration,\n        uint25", "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\ncalldata_TrivialToken_0: 0xdfdcb7600000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "setAuctionWinnerMessageHash(bytes32)", "lineno": 299, "title": "Exception state", "type": "Informational"}, {"address": 6838, "code": ";\n\n\n/*\n * Paste Tr", "debug": "storage_33: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_14: 0x0\ncaller: 0x0\ncalldata_TrivialToken_0: 0x18804b0d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setDescriptionHash(bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "setDescriptionHash(bytes32)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7099, "code": "eturn (\n            icoEndTime, aucti", "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\nstorage_15: 0x0\ncaller: 0x0\ncalldata_TrivialToken_0: 0x1c02708d00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "killContract()", "lineno": 570, "title": "Exception state", "type": "Informational"}, {"address": 7284, "code": "l() { require(msg.sender == trivi", "debug": "The exception is triggered under the following conditions:\n\nstorage_30: 0xf800\ncalldata_TrivialToken_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "transferFrom(address,address,uint256)", "lineno": 283, "title": "Exception state", "type": "Informational"}, {"address": 12562, "code": "urn c", "debug": "storage_24: 0xa8723c77fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncallvalue: 0x57f03cc000000000000000000000000000000000000000000000000000000000\nstorage_30: 0x100\ntimestamp: 0x0\nstorage_5: 0x57f03cbfffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_17: 0x1\ncalldatasize_TrivialToken: 0x3\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "fallback", "lineno": 37, "title": "Integer Overflow ", "type": "Warning"}, {"address": 12575, "code": "\n\n\n/**\n * @tit", "debug": "The exception is triggered under the following conditions:\n\nstorage_24: 0xd6542a11e3c0945715c15f500c8000030b00901dfe51fa1f3d851f8759f1c169\ncallvalue: 0x463cfa29f0042f68e9015f09c47ffffccb7ef99cdcf3b9b8a32ca8e640bddd6d\nstorage_30: 0x100\ntimestamp: 0x0\nstorage_5: 0x463cfa29f0042f68e9015f09c47ffffccb7ef99cdcf3b9b8a32ca8e640bddd6c\nstorage_17: 0x1\ncalldatasize_TrivialToken: 0x3\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "fallback", "lineno": 39, "title": "Exception state", "type": "Informational"}, {"address": 14107, "code": "= 25;\n    uint256 public cleanupDelay = 180 days;\n    uint256 public freePeriodDuration = 60 days;\n\n    //Basic\n    string public name;\n    string public symbol;\n    uint8 public decimals = 0;\n    uint256 public totalSupply;\n\n    //Accounts\n    address public artist;\n    address public trivial;\n\n    //Time information\n    uint256 public icoDuration;\n    uint256 public icoEndTime;\n    uint256 public auctionDuration;\n    uint256 public auctionEndTime;\n    uint256 public freePeriodEndTime;\n\n    //Token information\n    uint256 public tokensForArtist;\n    uint256 public tokensForTrivial;\n    uint256 public tokensForIco;\n\n    //ICO and auction results\n    uint256 public amountRaised;\n    address public highestBidder;\n    uint256 public highestBid;\n    bytes32 public auctionWinnerMessageHash;\n    uint256 public nextContributorIndexToBeGivenTokens;\n    uint256 public tokensDistributedToContributors;\n\n    //Events\n    event IcoStarted(uint256 icoEndTime);\n    event IcoContributed(address contributor, uint256 amountContributed, uint256 amountRaised);\n    event IcoFinished(uint256 amountRaised);\n    event IcoCancelled();\n    event AuctionStarted(uint256 auctionEndTime);\n    event HighestBidChanged(address highestBidder, uint256 highestBid);\n    event AuctionFinished(address highestBidder, uint256 highestBid);\n    event WinnerProvidedHash();\n\n    //State\n    enum State {\n        Created, IcoStarted, IcoFinished, AuctionStarted, AuctionFinished, IcoCancelled,\n        BeforeInitOne, BeforeInitTwo\n    }\n    State public currentState;\n\n    //Item description\n    struct DescriptionHash {\n        bytes32 descriptionHash;\n        uint256 timestamp;\n    }\n    DescriptionHash public descriptionHash;\n    DescriptionHash[] public descriptionHashHistory;\n\n    //Token contributors and holders\n    mapping(address => uint) public contributions;\n    address[] public contributors;\n\n    //Modififers\n    modifier onlyInState(State expectedState) { require(expectedState == currentState); _; }\n    modifier onlyInTokensTrasferingPeriod() {\n        require(currentState == State.IcoFinished || (currentState == State.AuctionStarted && now < auctionEndTime));\n        _;\n    }\n    modifier onlyBefore(uint256 _time) { require(now < _time); _; }\n    modifier onlyAfter(uint256 _time) { require(now > _time); _; }\n    modifier onlyTrivial() { require(msg.sender == trivial); _; }\n    modifier onlyArtist() { require(msg.sender == artist); _; }\n    modifier onlyAuctionWinner() {\n        require(currentState == State.AuctionFinished);\n        require(msg.sender == highestBidder);\n        _;\n    }\n\n    function TrivialToken() {\n        currentState = State.BeforeInitOne;\n    }\n\n    function initOne(\n        string _name,\n        string _symbol,\n        uint8 _decimals,\n        uint256 _icoDuration,\n        uint256 _auctionDuration,\n        address _artist,\n        address _trivial,\n        bytes32 _descriptionHash\n    )\n    onlyInState(State.BeforeInitOne)\n    {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        icoDuration = _icoDuration;\n        auctionDuration = _auctionDuration;\n\n        artist = _artist;\n        trivial = _trivial;\n\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n        currentState = State.BeforeInitTwo;\n    }\n\n    function initTwo(\n        uint256 _totalSupply,\n        uint256 _tokensForArtist,\n        uint256 _tokensForTrivial,\n        uint256 _tokensForIco,\n        uint256 _minEthAmount,\n        uint256 _minBidPercentage,\n        uint256 _tokensPercentageForKeyHolder,\n        uint256 _cleanupDelay,\n        uint256 _freePeriodDuration\n    )\n    onlyInState(State.BeforeInitTwo) {\n        require(\n            _totalSupply == SafeMath.add(\n                _tokensForArtist,\n                SafeMath.add(_tokensForTrivial, _tokensForIco)\n            )\n        );\n        require(_minBidPercentage < 100);\n        require(_tokensPercentageForKeyHolder < 100);\n\n        totalSupply = _totalSupply;\n        minEthAmount = _minEthAmount;\n        minBidPercentage = _minBidPercentage;\n        tokensPercentageForKeyHolder = _tokensPercentageForKeyHolder;\n        cleanupDelay = _cleanupDelay;\n        freePeriodDuration = _freePeriodDuration;\n\n        tokensForArtist = _tokensForArtist;\n        tokensForTrivial = _tokensForTrivial;\n        tokensForIco = _tokensForIco;\n\n        currentState = State.Created;\n    }\n\n    /*\n        ICO methods\n    */\n    function startIco()\n    onlyInState(State.Created)\n    onlyTrivial() {\n        icoEndTime = SafeMath.add(now, icoDuration);\n        freePeriodEndTime = SafeMath.add(icoEndTime, freePeriodDuration);\n        currentState = State.IcoStarted;\n        IcoStarted(icoEndTime);\n    }\n\n    function contributeInIco() payable\n    onlyInState(State.IcoStarted)\n    onlyBefore(icoEndTime) {\n        require(msg.value > minEthAmount);\n\n        if (contributions[msg.sender] == 0) {\n            contributors.push(msg.sender);\n        }\n        contributions[msg.sender] = SafeMath.add(contributions[msg.sender], msg.value);\n        amountRaised = SafeMath.add(amountRaised, msg.value);\n\n        IcoContributed(msg.sender, msg.value, amountRaised);\n    }\n\n    function distributeTokens(uint256 contributorsNumber)\n    onlyInState(State.IcoStarted)\n    onlyAfter(icoEndTime) {\n        for (uint256 i = 0; i < contributorsNumber && nextContributorIndexToBeGivenTokens < contributors.length; ++i) {\n            address currentContributor = contributors[nextContributorIndexToBeGivenTokens++];\n            uint256 tokensForContributor = SafeMath.div(\n                SafeMath.mul(tokensForIco, contributions[currentContributor]),\n                amountRaised  // amountRaised can't be 0, ICO is cancelled then\n            );\n            balances[currentContributor] = tokensForContributor;\n            tokensDistributedToContributors = SafeMath.add(tokensDistributedToContributors, tokensForContributor);\n        }\n    }\n\n    function finishIco()\n    onlyInState(State.IcoStarted)\n    onlyAfter(icoEndTime) {\n        if (amountRaised == 0) {\n            currentState = State.IcoCancelled;\n            return;\n        }\n\n        // all contributors must have received their tokens to finish ICO\n        require(nextContributorIndexToBeGivenTokens >= contributors.length);\n\n        balances[artist] = SafeMath.add(balances[artist], tokensForArtist);\n        balances[trivial] = SafeMath.add(balances[trivial], tokensForTrivial);\n        uint256 leftovers = SafeMath.sub(tokensForIco, tokensDistributedToContributors);\n        balances[artist] = SafeMath.add(balances[artist], leftovers);\n\n        if (!artist.send(this.balance)) {\n            asyncSend(artist, this.balance);\n        }\n        currentState = State.IcoFinished;\n        IcoFinished(amountRaised);\n    }\n\n    function checkContribution(address contributor) constant returns (uint) {\n        return contributions[contributor];\n    }\n\n    /*\n        Auction methods\n    */\n    function canStartAuction() returns (bool) {\n        bool isArtist = msg.sender == artist;\n        bool isKeyHolder = balances[msg.sender] >= SafeMath.div(\n        SafeMath.mul(totalSupply, tokensPercentageForKeyHolder), 100);\n        return isArtist || isKeyHolder;\n    }\n\n    function startAuction()\n    onlyAfter(freePeriodEndTime)\n    onlyInState(State.IcoFinished) {\n        require(canStartAuction());\n\n        // 100% tokens owner is the only key holder\n        if (balances[msg.sender] == totalSupply) {\n            // no auction takes place,\n            highestBidder = msg.sender;\n            currentState = State.AuctionFinished;\n            AuctionFinished(highestBidder, highestBid);\n            return;\n        }\n\n        auctionEndTime = SafeMath.add(now, auctionDuration);\n        currentState = State.AuctionStarted;\n        AuctionStarted(auctionEndTime);\n    }\n\n    function bidInAuction() payable\n    onlyInState(State.AuctionStarted)\n    onlyBefore(auctionEndTime) {\n        //Must be greater or equal to minimal amount\n        require(msg.value >= minEthAmount);\n        uint256 bid = calculateUserBid();\n\n        //If there was a bid already\n        if (highestBid >= minEthAmount) {\n            //Must be greater or equal to 105% of previous bid\n            uint256 minimalOverBid = SafeMath.add(highestBid, SafeMath.div(\n                SafeMath.mul(highestBid, minBidPercentage), 100\n            ));\n            require(bid >= minimalOverBid);\n            //Return to previous bidder his balance\n            //Value to return: current balance - current bid - paymentsInAsyncSend\n            uint256 amountToReturn = SafeMath.sub(SafeMath.sub(\n                this.balance, msg.value\n            ), totalPayments);\n            if (!highestBidder.send(amountToReturn)) {\n                asyncSend(highestBidder, amountToReturn);\n            }\n        }\n\n        highestBidder = msg.sender;\n        highestBid = bid;\n        HighestBidChanged(highestBidder, highestBid);\n    }\n\n    function calculateUserBid() private returns (uint256) {\n        uint256 bid = msg.value;\n        uint256 contribution = balanceOf(msg.sender);\n        if (contribution > 0) {\n            //Formula: (sentETH * allTokens) / (allTokens - userTokens)\n            //User sends 16ETH, has 40 of 200 tokens\n            //(16 * 200) / (200 - 40) => 3200 / 160 => 20\n            bid = SafeMath.div(\n                SafeMath.mul(msg.value, totalSupply),\n                SafeMath.sub(totalSupply, contribution)\n            );\n        }\n        return bid;\n    }\n\n    function finishAuction()\n    onlyInState(State.AuctionStarted)\n    onlyAfter(auctionEndTime) {\n        require(highestBid > 0);  // auction cannot be finished until at least one person bids\n        currentState = State.AuctionFinished;\n        AuctionFinished(highestBidder, highestBid);\n    }\n\n    function withdrawShares(address holder) public\n    onlyInState(State.AuctionFinished) {\n        uint256 availableTokens = balances[holder];\n        require(availableTokens > 0);\n        balances[holder] = 0;\n\n        if (holder != highestBidder) {\n            holder.transfer(\n                SafeMath.div(SafeMath.mul(highestBid, availableTokens), totalSupply)\n            );\n        }\n    }\n\n    /*\n        General methods\n    */\n\n    function contributorsCount() constant returns (uint256) { return contributors.length; }\n\n    // Cancel ICO will be redesigned to prevent\n    // risk of user funds overtaken\n\n    /*function cancelIco()\n    onlyInState(State.IcoStarted)\n    onlyTrivial() {\n        currentState = State.IcoCancelled;\n        IcoCancelled();\n    }\n\n    function claimIcoContribution(address contributor) onlyInState(State.IcoCancelled) {\n        uint256 contribution = contributions[contributor];\n        require(contribution > 0);\n        contributions[contributor] = 0;\n        contributor.transfer(contribution);\n    }*/\n\n    function setDescriptionHash(bytes32 _descriptionHash)\n    onlyArtist() {\n        descriptionHashHistory.push(descriptionHash);\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n    }\n\n    function setAuctionWinnerMessageHash(bytes32 _auctionWinnerMessageHash)\n    onlyAuctionWinner() {\n        auctionWinnerMessageHash = _auctionWinnerMessageHash;\n        WinnerProvidedHash();\n    }\n\n    function killContract()\n    onlyTrivial() {\n        require(\n            (\n                currentState == State.AuctionFinished &&\n                now > SafeMath.add(auctionEndTime, cleanupDelay) // Delay in correct state\n            ) ||\n            currentState == State.IcoCancelled // No delay in cancelled state\n        );\n        selfdestruct(trivial);\n    }\n\n    // helper function to avoid too many contract calls on frontend side\n    function getContractState() constant returns (\n        uint256, uint256, uint256, uint256, uint256,\n        uint256, uint256, address, uint256, State,\n        uint256, uint256, uint256\n    ) {\n        return (\n            icoEndTime, auctionDuration, auctionEndTime,\n            tokensForArtist, tokensForTrivial, tokensForIco,\n            amountRaised, highestBidder, highestBid, currentState,\n            tokensPercentageForKeyHolder, minBidPercentage,\n            freePeriodEndTime\n        );\n    }\n\n    function transfer(address _to, uint _value)\n    onlyInTokensTrasferingPeriod() returns (bool) {\n        if (currentState == State.AuctionStarted) {\n            require(_to != highestBidder);\n            require(msg.sender != highestBidder);\n        }\n        return BasicToken.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value)\n    onlyInTokensTrasferingPeriod() returns (bool) {\n        if (currentState == State.AuctionStarted) {\n            require(_to != highestBidder);\n            require(_from != highestBidder);\n        }\n        return StandardToken.transferFrom(_from, _to, _value);\n    }\n\n    function () payable {\n        if (currentState == State.IcoStarted) {\n            contributeInIco();\n        }\n        else if (currentState == State.AuctionStarted) {\n            bidInAuction();\n        }\n        else {\n            revert();\n        }\n    }\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrivialToken_4 + calldata_TrivialToken_4)): 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_10: 0x140\nstorage_30: 0x600\ncalldata_TrivialToken_4 + calldata_TrivialToken_4: 0x0\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `initOne(string,string,uint8,uint256,uint256,address,address,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 212, "title": "Integer Overflow ", "type": "Warning"}, {"address": 14121, "code": "= 25;\n    uint256 public cleanupDelay = 180 days;\n    uint256 public freePeriodDuration = 60 days;\n\n    //Basic\n    string public name;\n    string public symbol;\n    uint8 public decimals = 0;\n    uint256 public totalSupply;\n\n    //Accounts\n    address public artist;\n    address public trivial;\n\n    //Time information\n    uint256 public icoDuration;\n    uint256 public icoEndTime;\n    uint256 public auctionDuration;\n    uint256 public auctionEndTime;\n    uint256 public freePeriodEndTime;\n\n    //Token information\n    uint256 public tokensForArtist;\n    uint256 public tokensForTrivial;\n    uint256 public tokensForIco;\n\n    //ICO and auction results\n    uint256 public amountRaised;\n    address public highestBidder;\n    uint256 public highestBid;\n    bytes32 public auctionWinnerMessageHash;\n    uint256 public nextContributorIndexToBeGivenTokens;\n    uint256 public tokensDistributedToContributors;\n\n    //Events\n    event IcoStarted(uint256 icoEndTime);\n    event IcoContributed(address contributor, uint256 amountContributed, uint256 amountRaised);\n    event IcoFinished(uint256 amountRaised);\n    event IcoCancelled();\n    event AuctionStarted(uint256 auctionEndTime);\n    event HighestBidChanged(address highestBidder, uint256 highestBid);\n    event AuctionFinished(address highestBidder, uint256 highestBid);\n    event WinnerProvidedHash();\n\n    //State\n    enum State {\n        Created, IcoStarted, IcoFinished, AuctionStarted, AuctionFinished, IcoCancelled,\n        BeforeInitOne, BeforeInitTwo\n    }\n    State public currentState;\n\n    //Item description\n    struct DescriptionHash {\n        bytes32 descriptionHash;\n        uint256 timestamp;\n    }\n    DescriptionHash public descriptionHash;\n    DescriptionHash[] public descriptionHashHistory;\n\n    //Token contributors and holders\n    mapping(address => uint) public contributions;\n    address[] public contributors;\n\n    //Modififers\n    modifier onlyInState(State expectedState) { require(expectedState == currentState); _; }\n    modifier onlyInTokensTrasferingPeriod() {\n        require(currentState == State.IcoFinished || (currentState == State.AuctionStarted && now < auctionEndTime));\n        _;\n    }\n    modifier onlyBefore(uint256 _time) { require(now < _time); _; }\n    modifier onlyAfter(uint256 _time) { require(now > _time); _; }\n    modifier onlyTrivial() { require(msg.sender == trivial); _; }\n    modifier onlyArtist() { require(msg.sender == artist); _; }\n    modifier onlyAuctionWinner() {\n        require(currentState == State.AuctionFinished);\n        require(msg.sender == highestBidder);\n        _;\n    }\n\n    function TrivialToken() {\n        currentState = State.BeforeInitOne;\n    }\n\n    function initOne(\n        string _name,\n        string _symbol,\n        uint8 _decimals,\n        uint256 _icoDuration,\n        uint256 _auctionDuration,\n        address _artist,\n        address _trivial,\n        bytes32 _descriptionHash\n    )\n    onlyInState(State.BeforeInitOne)\n    {\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n\n        icoDuration = _icoDuration;\n        auctionDuration = _auctionDuration;\n\n        artist = _artist;\n        trivial = _trivial;\n\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n        currentState = State.BeforeInitTwo;\n    }\n\n    function initTwo(\n        uint256 _totalSupply,\n        uint256 _tokensForArtist,\n        uint256 _tokensForTrivial,\n        uint256 _tokensForIco,\n        uint256 _minEthAmount,\n        uint256 _minBidPercentage,\n        uint256 _tokensPercentageForKeyHolder,\n        uint256 _cleanupDelay,\n        uint256 _freePeriodDuration\n    )\n    onlyInState(State.BeforeInitTwo) {\n        require(\n            _totalSupply == SafeMath.add(\n                _tokensForArtist,\n                SafeMath.add(_tokensForTrivial, _tokensForIco)\n            )\n        );\n        require(_minBidPercentage < 100);\n        require(_tokensPercentageForKeyHolder < 100);\n\n        totalSupply = _totalSupply;\n        minEthAmount = _minEthAmount;\n        minBidPercentage = _minBidPercentage;\n        tokensPercentageForKeyHolder = _tokensPercentageForKeyHolder;\n        cleanupDelay = _cleanupDelay;\n        freePeriodDuration = _freePeriodDuration;\n\n        tokensForArtist = _tokensForArtist;\n        tokensForTrivial = _tokensForTrivial;\n        tokensForIco = _tokensForIco;\n\n        currentState = State.Created;\n    }\n\n    /*\n        ICO methods\n    */\n    function startIco()\n    onlyInState(State.Created)\n    onlyTrivial() {\n        icoEndTime = SafeMath.add(now, icoDuration);\n        freePeriodEndTime = SafeMath.add(icoEndTime, freePeriodDuration);\n        currentState = State.IcoStarted;\n        IcoStarted(icoEndTime);\n    }\n\n    function contributeInIco() payable\n    onlyInState(State.IcoStarted)\n    onlyBefore(icoEndTime) {\n        require(msg.value > minEthAmount);\n\n        if (contributions[msg.sender] == 0) {\n            contributors.push(msg.sender);\n        }\n        contributions[msg.sender] = SafeMath.add(contributions[msg.sender], msg.value);\n        amountRaised = SafeMath.add(amountRaised, msg.value);\n\n        IcoContributed(msg.sender, msg.value, amountRaised);\n    }\n\n    function distributeTokens(uint256 contributorsNumber)\n    onlyInState(State.IcoStarted)\n    onlyAfter(icoEndTime) {\n        for (uint256 i = 0; i < contributorsNumber && nextContributorIndexToBeGivenTokens < contributors.length; ++i) {\n            address currentContributor = contributors[nextContributorIndexToBeGivenTokens++];\n            uint256 tokensForContributor = SafeMath.div(\n                SafeMath.mul(tokensForIco, contributions[currentContributor]),\n                amountRaised  // amountRaised can't be 0, ICO is cancelled then\n            );\n            balances[currentContributor] = tokensForContributor;\n            tokensDistributedToContributors = SafeMath.add(tokensDistributedToContributors, tokensForContributor);\n        }\n    }\n\n    function finishIco()\n    onlyInState(State.IcoStarted)\n    onlyAfter(icoEndTime) {\n        if (amountRaised == 0) {\n            currentState = State.IcoCancelled;\n            return;\n        }\n\n        // all contributors must have received their tokens to finish ICO\n        require(nextContributorIndexToBeGivenTokens >= contributors.length);\n\n        balances[artist] = SafeMath.add(balances[artist], tokensForArtist);\n        balances[trivial] = SafeMath.add(balances[trivial], tokensForTrivial);\n        uint256 leftovers = SafeMath.sub(tokensForIco, tokensDistributedToContributors);\n        balances[artist] = SafeMath.add(balances[artist], leftovers);\n\n        if (!artist.send(this.balance)) {\n            asyncSend(artist, this.balance);\n        }\n        currentState = State.IcoFinished;\n        IcoFinished(amountRaised);\n    }\n\n    function checkContribution(address contributor) constant returns (uint) {\n        return contributions[contributor];\n    }\n\n    /*\n        Auction methods\n    */\n    function canStartAuction() returns (bool) {\n        bool isArtist = msg.sender == artist;\n        bool isKeyHolder = balances[msg.sender] >= SafeMath.div(\n        SafeMath.mul(totalSupply, tokensPercentageForKeyHolder), 100);\n        return isArtist || isKeyHolder;\n    }\n\n    function startAuction()\n    onlyAfter(freePeriodEndTime)\n    onlyInState(State.IcoFinished) {\n        require(canStartAuction());\n\n        // 100% tokens owner is the only key holder\n        if (balances[msg.sender] == totalSupply) {\n            // no auction takes place,\n            highestBidder = msg.sender;\n            currentState = State.AuctionFinished;\n            AuctionFinished(highestBidder, highestBid);\n            return;\n        }\n\n        auctionEndTime = SafeMath.add(now, auctionDuration);\n        currentState = State.AuctionStarted;\n        AuctionStarted(auctionEndTime);\n    }\n\n    function bidInAuction() payable\n    onlyInState(State.AuctionStarted)\n    onlyBefore(auctionEndTime) {\n        //Must be greater or equal to minimal amount\n        require(msg.value >= minEthAmount);\n        uint256 bid = calculateUserBid();\n\n        //If there was a bid already\n        if (highestBid >= minEthAmount) {\n            //Must be greater or equal to 105% of previous bid\n            uint256 minimalOverBid = SafeMath.add(highestBid, SafeMath.div(\n                SafeMath.mul(highestBid, minBidPercentage), 100\n            ));\n            require(bid >= minimalOverBid);\n            //Return to previous bidder his balance\n            //Value to return: current balance - current bid - paymentsInAsyncSend\n            uint256 amountToReturn = SafeMath.sub(SafeMath.sub(\n                this.balance, msg.value\n            ), totalPayments);\n            if (!highestBidder.send(amountToReturn)) {\n                asyncSend(highestBidder, amountToReturn);\n            }\n        }\n\n        highestBidder = msg.sender;\n        highestBid = bid;\n        HighestBidChanged(highestBidder, highestBid);\n    }\n\n    function calculateUserBid() private returns (uint256) {\n        uint256 bid = msg.value;\n        uint256 contribution = balanceOf(msg.sender);\n        if (contribution > 0) {\n            //Formula: (sentETH * allTokens) / (allTokens - userTokens)\n            //User sends 16ETH, has 40 of 200 tokens\n            //(16 * 200) / (200 - 40) => 3200 / 160 => 20\n            bid = SafeMath.div(\n                SafeMath.mul(msg.value, totalSupply),\n                SafeMath.sub(totalSupply, contribution)\n            );\n        }\n        return bid;\n    }\n\n    function finishAuction()\n    onlyInState(State.AuctionStarted)\n    onlyAfter(auctionEndTime) {\n        require(highestBid > 0);  // auction cannot be finished until at least one person bids\n        currentState = State.AuctionFinished;\n        AuctionFinished(highestBidder, highestBid);\n    }\n\n    function withdrawShares(address holder) public\n    onlyInState(State.AuctionFinished) {\n        uint256 availableTokens = balances[holder];\n        require(availableTokens > 0);\n        balances[holder] = 0;\n\n        if (holder != highestBidder) {\n            holder.transfer(\n                SafeMath.div(SafeMath.mul(highestBid, availableTokens), totalSupply)\n            );\n        }\n    }\n\n    /*\n        General methods\n    */\n\n    function contributorsCount() constant returns (uint256) { return contributors.length; }\n\n    // Cancel ICO will be redesigned to prevent\n    // risk of user funds overtaken\n\n    /*function cancelIco()\n    onlyInState(State.IcoStarted)\n    onlyTrivial() {\n        currentState = State.IcoCancelled;\n        IcoCancelled();\n    }\n\n    function claimIcoContribution(address contributor) onlyInState(State.IcoCancelled) {\n        uint256 contribution = contributions[contributor];\n        require(contribution > 0);\n        contributions[contributor] = 0;\n        contributor.transfer(contribution);\n    }*/\n\n    function setDescriptionHash(bytes32 _descriptionHash)\n    onlyArtist() {\n        descriptionHashHistory.push(descriptionHash);\n        descriptionHash = DescriptionHash(_descriptionHash, now);\n    }\n\n    function setAuctionWinnerMessageHash(bytes32 _auctionWinnerMessageHash)\n    onlyAuctionWinner() {\n        auctionWinnerMessageHash = _auctionWinnerMessageHash;\n        WinnerProvidedHash();\n    }\n\n    function killContract()\n    onlyTrivial() {\n        require(\n            (\n                currentState == State.AuctionFinished &&\n                now > SafeMath.add(auctionEndTime, cleanupDelay) // Delay in correct state\n            ) ||\n            currentState == State.IcoCancelled // No delay in cancelled state\n        );\n        selfdestruct(trivial);\n    }\n\n    // helper function to avoid too many contract calls on frontend side\n    function getContractState() constant returns (\n        uint256, uint256, uint256, uint256, uint256,\n        uint256, uint256, address, uint256, State,\n        uint256, uint256, uint256\n    ) {\n        return (\n            icoEndTime, auctionDuration, auctionEndTime,\n            tokensForArtist, tokensForTrivial, tokensForIco,\n            amountRaised, highestBidder, highestBid, currentState,\n            tokensPercentageForKeyHolder, minBidPercentage,\n            freePeriodEndTime\n        );\n    }\n\n    function transfer(address _to, uint _value)\n    onlyInTokensTrasferingPeriod() returns (bool) {\n        if (currentState == State.AuctionStarted) {\n            require(_to != highestBidder);\n            require(msg.sender != highestBidder);\n        }\n        return BasicToken.transfer(_to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value)\n    onlyInTokensTrasferingPeriod() returns (bool) {\n        if (currentState == State.AuctionStarted) {\n            require(_to != highestBidder);\n            require(_from != highestBidder);\n        }\n        return StandardToken.transferFrom(_from, _to, _value);\n    }\n\n    function () payable {\n        if (currentState == State.IcoStarted) {\n            contributeInIco();\n        }\n        else if (currentState == State.AuctionStarted) {\n            bidInAuction();\n        }\n        else {\n            revert();\n        }\n    }\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TrivialToken_4 + calldata_TrivialToken_4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_10: 0x0\ncalldata_TrivialToken_4 + calldata_TrivialToken_4: 0x1\nstorage_30: 0x600\ncalldata_TrivialToken_0: 0x7db7fe000000000000000000000000000000000000000000000000000000000\ncalldatasize_TrivialToken: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `initOne(string,string,uint8,uint256,uint256,address,address,bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x92185519dc5a3ab41396d1da2bb4134ea3921172.sol", "function": "initOne(string,string,uint8,uint256,uint256,address,address,bytes32)", "lineno": 212, "title": "Integer Overflow ", "type": "Warning"}], "success": true}