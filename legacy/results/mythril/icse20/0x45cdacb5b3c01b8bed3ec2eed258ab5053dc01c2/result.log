{"error": null, "issues": [{"address": 1545, "code": "ublic transactionCount;", "debug": "The exception is triggered under the following conditions:\n\ncalldata_TEST_MultiSig_4: 0x0\nstorage_4: 0x0\ncalldata_TEST_MultiSig_0: 0x25e7c2700000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "_function_0x025e7c27", "lineno": 83, "title": "Exception state", "type": "Informational"}, {"address": 5983, "code": " Transaction id\n     */\n    function _confirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=true;\n        \n        transactions[_tx_id].receivedConfirmations=\n                transactions[_tx_id].receivedConfi", "debug": "timestamp: 0x1\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_TEST_MultiSig_32 + 68: 0x7ffffffffffffffffffffffff7ffffffffffffffe00000000000000000000000\nstorage_6: 0x7fffff\nstorage_7: 0x7ffffffffffffffffffffffff7ffffffffffffffe00000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 409, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7113, "code": ">=a", "debug": "timestamp: 0x2000000000000000000000000000000000000000000000000000000000000000\ncalldata_TEST_MultiSig_32 + 68: 0x8ffcffffdff1502fffeebe751bca5bfffdffffff63aed77ffdde759f35f5fbb7\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x6ffcffffdff1502fffeebe751bca5bfffdffffff63aed77ffdde759f35f5fbb8\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 26, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7455, "code": " Math for uint256;\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 expiration;\n        uint256 receivedConfirmations;\n\n    }\n\n    event LogMultiSigContractCreated(\n        uint256 numOwners,\n        uint256 numAllowedDestinations,\n        uint256 quorum,\n        uint256 maxTxValiditySeconds\n    );\n    event LogDestinationStatus(address destination,bool status);\n    event LogTransactionProposal(\n        uint256 indexed txId,\n        address destination,\n        uint256 value,\n        bytes data\n    );\n    event LogTransactionConfirmationRescission(\n        uint256 indexed txId,\n        address approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogTransactionExecutionSuccess(uint256 indexed txId);\n    event LogTransactionExecutionFailure(uint256 indexed txId);\n    event LogTransactionConfirmation(\n        uint256 indexed txId,\n        address indexed approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogDeposit(address depositer, uint256 depositedValue); \n   \n\n    mapping (uint256 => Transaction) public transactions;\n    mapping (uint256 => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    mapping (address => bool) public destinationAddressStatus;\n    address[] public owners;\n    uint256 public requiredConfirmations;\n    uint256 public transactionCount;\n    uint256 public maxValidTimeSecs;\n    uint256 constant MIN_OWNER_COUNT=3;\n    uint256 constant MIN_REQD_COUNT=2;\n\n    modifier onlyByThisAddress {\n        require(msg.sender == address(this),\"onlyByThisAddress\");\n        _;\n    }\n\n    modifier onlyByOwners {\n        require(isOwner[msg.sender],\"onlyByOwners\");\n        _;\n    }\n\n    modifier destinationStatusCheck(address _destination,bool _status) {\n        require(\n            destinationAddressStatus[_destination]==_status,\n            \"Failed destinationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingConfirmation(uint256 _tx_id) {\n        //need only up to required approvals\n        require(!isConfirmed(_tx_id),\"Already confirmed\");\n        _;\n    }\n\n    modifier completedConfirmation(uint256 _tx_id) {\n        //need exactly required approvals\n        require(isConfirmed(_tx_id),\"Not confirmed yet\");\n        _;\n    }\n\n    modifier confirmationStatusCheck(\n        uint256 _tx_id,\n        address _sender,\n        bool _status\n    ) \n    {\n        require(\n            confirmations[_tx_id][_sender]==_status,\n            \"Failed confirmationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingExecution(uint256 _tx_id) {\n        require( \n            !isExecuted(_tx_id), \n            \"Tx already executed\"\n        );\n        _;\n    }\n\n    modifier awaitingExpiry(uint256 _tx_id) {\n        require(\n            !isExpired(_tx_id),\n            \"Tx has expired\"\n        );\n        _;\n    }\n\n\n    modifier validRequirement(uint _ownercount,uint _required) {\n        require(\n            (_ownercount>=MIN_OWNER_COUNT) &&\n            (_required >= MIN_REQD_COUNT)  &&\n            (MIN_REQD_COUNT <= MIN_OWNER_COUNT),\n            \"Constructor requirements not met\"\n        );\n        _;\n    }\n\n    modifier validExpiration(uint256 _expiration) {\n        require(\n            _expiration>=now,\n            \"time must be >= now\"\n        );\n        require(\n            (_expiration-now)<maxValidTimeSecs,\n            \"Expiration time is too far in the future\" \n        );\n        _;\n    }\n\n\n    /**\n     * @dev constructor\n     * @param _owners owners array\n     * @param _required_confirmations number of required confirmations\n     */\n    constructor(\n        address[] _owners,\n        address[] _allowed_destinations, \n        uint256 _required_confirmations,\n        uint256 _max_valid_time_secs\n    ) \n        public\n        validRequirement(_owners.length,_required_confirmations)\n    {\n\n        //for(uint256 i=0;i<_owners.length;i++) {\n        for(uint256 i=0;i<_owners.length;i=i.Add(1)) {\n            \n            //requires an address\n            require(_owners[i] != address(0));\n\n            //cant be repeated address\n            require(!isOwner[_owners[i]]);\n            \n            isOwner[_owners[i]]=true;\n        }\n\n        requiredConfirmations = _required_confirmations;\n        maxValidTimeSecs = _max_valid_time_secs;\n        owners = _owners;\n        \n        //to allow this contract to call its own admin functions\n        destinationAddressStatus[address(this)] = true;\n\n        //for(uint256 j=0;j<_allowed_destinations.length;/*j++*/j=j.Add(1)) {\n        for(uint256 j=0;j<_allowed_destinations.length;j=j.Add(1)) {\n            destinationAddressStatus[_allowed_destinations[j]]=true;\n        }\n\n        emit LogMultiSigContractCreated(\n            _owners.length,\n            _allowed_destinations.length.Add(1),\n            _required_confirmations,\n            _max_valid_time_secs\n        );\n    }\n\n    function() public payable {\n        if(msg.value>0)\n            emit LogDeposit(msg.sender,msg.value);\n    }\n\n    /* =================================================================\n     *  admin functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Sets whether a destination address is allowed\n     * @param _destination Destination address\n     * @param _status true=allowed, false=not allowed\n     */\n    function setDestinationAddressStatus(\n        address _destination,\n        bool _status\n    )\n        public\n        onlyByThisAddress\n        destinationStatusCheck(_destination,!_status)\n    {\n        require(\n            _destination!=address(this),\n            \"contract can never disable calling itself\"\n        );\n\n        destinationAddressStatus[_destination] = _status;      \n        emit LogDestinationStatus(_destination,_status);\n    }\n\n    /* =================================================================\n     *  (propose,approve,revokeApproval,execute)Tx\n     * =================================================================\n     */\n\n    /**\n     * @notice Propose a transaction for multi-sig approval\n     * @dev Proposal also counts as one confirmation\n     * @param _destination Destination address\n     * @param _value Wei, if payable function\n     * @param _data Transaction data\n     * @return {\"tx_id\":\"Transaction id\"}\n     */\n    function proposeTx(\n        address _destination, \n        uint256 _value, \n        bytes _data,\n        uint256 _expiration\n    )\n        public\n        onlyByOwners\n        destinationStatusCheck(_destination,true)\n        validExpiration(_expiration)\n        returns (uint256 tx_id)\n    {\n        tx_id = _createTx(_destination,_value,_data,_expiration);\n        _confirmTx(tx_id);\n    }\n\n    /**\n     * @notice Approver calls this to approve a transaction\n     * @dev Transaction will be executed if <br/>\n     * @dev ...1) quorum is reached <br/> \n     * @dev ...2) not expired, <br/> \n     * @dev ...3) valid transaction <br/>\n     * @param _tx_id Transaction id\n     */\n    function approveTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,false)\n        awaitingConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _confirmTx(_tx_id);\n    }\n     \n    /**\n     * @notice Approver calls this to revoke an earlier approval\n     * @param _tx_id the transaction id\n     */\n    function revokeApprovalTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,true)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _unconfirmTx(_tx_id);\n    }\n\n    /**\n     * @notice Executes a multi-sig transaction\n     * @param _tx_id the transaction id\n     */\n    function executeTx(uint256 _tx_id)\n        public\n        //onlyByOwners\n        completedConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _executeTx(_tx_id);\n    }\n\n    /* =================================================================\n     *  view functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Returns the number of owners of this contract\n     * @return {\"\":\"the number of owners\"}\n     */\n    function getNumberOfOwners() \n        external \n        view \n        returns (uint256) \n    {\n        return owners.length;\n    }\n\n    /**\n     * @notice Checks to see if transacton was executed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Executed, false on Not Executed\"}\n     */\n    function isExecuted(uint256 _tx_id) internal view returns(bool) {\n        return transactions[_tx_id].executed;\n    }\n\n    /**\n     * @notice Checks to see if transacton has expired\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Expired, false on Not Expired\"}\n     */\n    function isExpired(uint256 _tx_id) internal view returns(bool) {\n        return (now>transactions[_tx_id].expiration);\n    }\n\n    /**\n     * @notice Checks to see if transacton has been confirmed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Confirmed, false on Not Confirmed\"}\n     */\n    function isConfirmed(uint256 _tx_id) internal view returns(bool) {\n        return \n            transactions[_tx_id].receivedConfirmations==requiredConfirmations;\n    }\n\n\n\n    /* =================================================================\n     *  internal functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Creates a multi-sig transaction\n     * @param _destination Destination address \n     * @param _value Amount of wei to pay if calling a payable fn\n     * @param _data Transaction data\n     */\n    function _createTx(\n        address _destination,\n        uint256 _value,\n        bytes _data,\n        uint256 _expiration\n    )\n        internal\n        returns (uint256 tx_id)\n    {\n        tx_id = transactionCount;\n        transactionCount=transactionCount.Add(1);\n        \n        transactions[tx_id] = Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            executed: false,\n            expiration: _expiration,\n            receivedConfirmations: 0\n        });\n        emit LogTransactionProposal(tx_id,_destination,_value,_data);\n    }\n\n    /**\n     * @notice Confirms a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _confirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=true;\n        \n        transactions[_tx_id].receivedConfirmations=\n                transactions[_tx_id].receivedConfirmations.Add(1);\n\n        //try to execute\n        _executeTx(_tx_id);\n\n        emit LogTransactionConfirmation(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Removes confirmation of a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _unconfirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=false;\n\n        assert(transactions[_tx_id].receivedConfirmations!=0);\n        \n        transactions[_tx_id].receivedConfirmations = \n            transactions[_tx_id].receivedConfirmations.Sub(1);\n\n        emit LogTransactionConfirmationRescission(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Internal execute function invoking \"call\"\n     * @dev this function cannot throw<br/>\n     * @dev cannot use modifiers, check explicitly here<br/>\n     * @dev ignoring the gas limits here<br/>\n     * @param _tx_id Transaction id\n     */\n    function _executeTx(uint256 _tx_id)\n        internal\n    {\n        if( \n            (!isExecuted(_tx_id)) && \n            (!isExpired(_tx_id)) && \n            (isConfirmed(_tx_id)) \n        )\n        {\n\n            transactions[_tx_id].executed = true;\n            bool result = \n                (transactions[_tx_id].destination)\n                .call\n                .value(transactions[_tx_id].value)\n                (transactions[_tx_id].data);\n\n            transactions[_tx_id].executed = result;\n\n            if(result) \n            {\n                emit LogTransactionExecutionSuccess(_tx_id);\n            }\n            else \n            {\n                emit LogTransactionExecutionFailure(_tx_id);\n            }\n        }\n    }\n}", "debug": "storage_2 + keccac_storage_6: 0xe29002b800000000000000000000007fffffffffffffffffffffffffffffffc5\nkeccac_2_+_keccac_storage_6: 0xfcf5b6f511e7bd596bf46318f667e50000408cba7ff34ffe33be9fb4efffffcc\ntimestamp: 0x80000000000000000000000000000000000000000000000000000000001\ncalldata_TEST_MultiSig_32 + 68: 0x2000000000000000000000000000000000000000000000000000000000001\nstorage_6: 0x10000ffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x1f80000000000000000000000000000000000000000000000000000000001\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 38, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7484, "code": " Math for uint256;\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 expiration;\n        uint256 receivedConfirmations;\n\n    }\n\n    event LogMultiSigContractCreated(\n        uint256 numOwners,\n        uint256 numAllowedDestinations,\n        uint256 quorum,\n        uint256 maxTxValiditySeconds\n    );\n    event LogDestinationStatus(address destination,bool status);\n    event LogTransactionProposal(\n        uint256 indexed txId,\n        address destination,\n        uint256 value,\n        bytes data\n    );\n    event LogTransactionConfirmationRescission(\n        uint256 indexed txId,\n        address approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogTransactionExecutionSuccess(uint256 indexed txId);\n    event LogTransactionExecutionFailure(uint256 indexed txId);\n    event LogTransactionConfirmation(\n        uint256 indexed txId,\n        address indexed approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogDeposit(address depositer, uint256 depositedValue); \n   \n\n    mapping (uint256 => Transaction) public transactions;\n    mapping (uint256 => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    mapping (address => bool) public destinationAddressStatus;\n    address[] public owners;\n    uint256 public requiredConfirmations;\n    uint256 public transactionCount;\n    uint256 public maxValidTimeSecs;\n    uint256 constant MIN_OWNER_COUNT=3;\n    uint256 constant MIN_REQD_COUNT=2;\n\n    modifier onlyByThisAddress {\n        require(msg.sender == address(this),\"onlyByThisAddress\");\n        _;\n    }\n\n    modifier onlyByOwners {\n        require(isOwner[msg.sender],\"onlyByOwners\");\n        _;\n    }\n\n    modifier destinationStatusCheck(address _destination,bool _status) {\n        require(\n            destinationAddressStatus[_destination]==_status,\n            \"Failed destinationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingConfirmation(uint256 _tx_id) {\n        //need only up to required approvals\n        require(!isConfirmed(_tx_id),\"Already confirmed\");\n        _;\n    }\n\n    modifier completedConfirmation(uint256 _tx_id) {\n        //need exactly required approvals\n        require(isConfirmed(_tx_id),\"Not confirmed yet\");\n        _;\n    }\n\n    modifier confirmationStatusCheck(\n        uint256 _tx_id,\n        address _sender,\n        bool _status\n    ) \n    {\n        require(\n            confirmations[_tx_id][_sender]==_status,\n            \"Failed confirmationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingExecution(uint256 _tx_id) {\n        require( \n            !isExecuted(_tx_id), \n            \"Tx already executed\"\n        );\n        _;\n    }\n\n    modifier awaitingExpiry(uint256 _tx_id) {\n        require(\n            !isExpired(_tx_id),\n            \"Tx has expired\"\n        );\n        _;\n    }\n\n\n    modifier validRequirement(uint _ownercount,uint _required) {\n        require(\n            (_ownercount>=MIN_OWNER_COUNT) &&\n            (_required >= MIN_REQD_COUNT)  &&\n            (MIN_REQD_COUNT <= MIN_OWNER_COUNT),\n            \"Constructor requirements not met\"\n        );\n        _;\n    }\n\n    modifier validExpiration(uint256 _expiration) {\n        require(\n            _expiration>=now,\n            \"time must be >= now\"\n        );\n        require(\n            (_expiration-now)<maxValidTimeSecs,\n            \"Expiration time is too far in the future\" \n        );\n        _;\n    }\n\n\n    /**\n     * @dev constructor\n     * @param _owners owners array\n     * @param _required_confirmations number of required confirmations\n     */\n    constructor(\n        address[] _owners,\n        address[] _allowed_destinations, \n        uint256 _required_confirmations,\n        uint256 _max_valid_time_secs\n    ) \n        public\n        validRequirement(_owners.length,_required_confirmations)\n    {\n\n        //for(uint256 i=0;i<_owners.length;i++) {\n        for(uint256 i=0;i<_owners.length;i=i.Add(1)) {\n            \n            //requires an address\n            require(_owners[i] != address(0));\n\n            //cant be repeated address\n            require(!isOwner[_owners[i]]);\n            \n            isOwner[_owners[i]]=true;\n        }\n\n        requiredConfirmations = _required_confirmations;\n        maxValidTimeSecs = _max_valid_time_secs;\n        owners = _owners;\n        \n        //to allow this contract to call its own admin functions\n        destinationAddressStatus[address(this)] = true;\n\n        //for(uint256 j=0;j<_allowed_destinations.length;/*j++*/j=j.Add(1)) {\n        for(uint256 j=0;j<_allowed_destinations.length;j=j.Add(1)) {\n            destinationAddressStatus[_allowed_destinations[j]]=true;\n        }\n\n        emit LogMultiSigContractCreated(\n            _owners.length,\n            _allowed_destinations.length.Add(1),\n            _required_confirmations,\n            _max_valid_time_secs\n        );\n    }\n\n    function() public payable {\n        if(msg.value>0)\n            emit LogDeposit(msg.sender,msg.value);\n    }\n\n    /* =================================================================\n     *  admin functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Sets whether a destination address is allowed\n     * @param _destination Destination address\n     * @param _status true=allowed, false=not allowed\n     */\n    function setDestinationAddressStatus(\n        address _destination,\n        bool _status\n    )\n        public\n        onlyByThisAddress\n        destinationStatusCheck(_destination,!_status)\n    {\n        require(\n            _destination!=address(this),\n            \"contract can never disable calling itself\"\n        );\n\n        destinationAddressStatus[_destination] = _status;      \n        emit LogDestinationStatus(_destination,_status);\n    }\n\n    /* =================================================================\n     *  (propose,approve,revokeApproval,execute)Tx\n     * =================================================================\n     */\n\n    /**\n     * @notice Propose a transaction for multi-sig approval\n     * @dev Proposal also counts as one confirmation\n     * @param _destination Destination address\n     * @param _value Wei, if payable function\n     * @param _data Transaction data\n     * @return {\"tx_id\":\"Transaction id\"}\n     */\n    function proposeTx(\n        address _destination, \n        uint256 _value, \n        bytes _data,\n        uint256 _expiration\n    )\n        public\n        onlyByOwners\n        destinationStatusCheck(_destination,true)\n        validExpiration(_expiration)\n        returns (uint256 tx_id)\n    {\n        tx_id = _createTx(_destination,_value,_data,_expiration);\n        _confirmTx(tx_id);\n    }\n\n    /**\n     * @notice Approver calls this to approve a transaction\n     * @dev Transaction will be executed if <br/>\n     * @dev ...1) quorum is reached <br/> \n     * @dev ...2) not expired, <br/> \n     * @dev ...3) valid transaction <br/>\n     * @param _tx_id Transaction id\n     */\n    function approveTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,false)\n        awaitingConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _confirmTx(_tx_id);\n    }\n     \n    /**\n     * @notice Approver calls this to revoke an earlier approval\n     * @param _tx_id the transaction id\n     */\n    function revokeApprovalTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,true)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _unconfirmTx(_tx_id);\n    }\n\n    /**\n     * @notice Executes a multi-sig transaction\n     * @param _tx_id the transaction id\n     */\n    function executeTx(uint256 _tx_id)\n        public\n        //onlyByOwners\n        completedConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _executeTx(_tx_id);\n    }\n\n    /* =================================================================\n     *  view functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Returns the number of owners of this contract\n     * @return {\"\":\"the number of owners\"}\n     */\n    function getNumberOfOwners() \n        external \n        view \n        returns (uint256) \n    {\n        return owners.length;\n    }\n\n    /**\n     * @notice Checks to see if transacton was executed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Executed, false on Not Executed\"}\n     */\n    function isExecuted(uint256 _tx_id) internal view returns(bool) {\n        return transactions[_tx_id].executed;\n    }\n\n    /**\n     * @notice Checks to see if transacton has expired\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Expired, false on Not Expired\"}\n     */\n    function isExpired(uint256 _tx_id) internal view returns(bool) {\n        return (now>transactions[_tx_id].expiration);\n    }\n\n    /**\n     * @notice Checks to see if transacton has been confirmed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Confirmed, false on Not Confirmed\"}\n     */\n    function isConfirmed(uint256 _tx_id) internal view returns(bool) {\n        return \n            transactions[_tx_id].receivedConfirmations==requiredConfirmations;\n    }\n\n\n\n    /* =================================================================\n     *  internal functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Creates a multi-sig transaction\n     * @param _destination Destination address \n     * @param _value Amount of wei to pay if calling a payable fn\n     * @param _data Transaction data\n     */\n    function _createTx(\n        address _destination,\n        uint256 _value,\n        bytes _data,\n        uint256 _expiration\n    )\n        internal\n        returns (uint256 tx_id)\n    {\n        tx_id = transactionCount;\n        transactionCount=transactionCount.Add(1);\n        \n        transactions[tx_id] = Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            executed: false,\n            expiration: _expiration,\n            receivedConfirmations: 0\n        });\n        emit LogTransactionProposal(tx_id,_destination,_value,_data);\n    }\n\n    /**\n     * @notice Confirms a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _confirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=true;\n        \n        transactions[_tx_id].receivedConfirmations=\n                transactions[_tx_id].receivedConfirmations.Add(1);\n\n        //try to execute\n        _executeTx(_tx_id);\n\n        emit LogTransactionConfirmation(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Removes confirmation of a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _unconfirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=false;\n\n        assert(transactions[_tx_id].receivedConfirmations!=0);\n        \n        transactions[_tx_id].receivedConfirmations = \n            transactions[_tx_id].receivedConfirmations.Sub(1);\n\n        emit LogTransactionConfirmationRescission(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Internal execute function invoking \"call\"\n     * @dev this function cannot throw<br/>\n     * @dev cannot use modifiers, check explicitly here<br/>\n     * @dev ignoring the gas limits here<br/>\n     * @param _tx_id Transaction id\n     */\n    function _executeTx(uint256 _tx_id)\n        internal\n    {\n        if( \n            (!isExecuted(_tx_id)) && \n            (!isExpired(_tx_id)) && \n            (isConfirmed(_tx_id)) \n        )\n        {\n\n            transactions[_tx_id].executed = true;\n            bool result = \n                (transactions[_tx_id].destination)\n                .call\n                .value(transactions[_tx_id].value)\n                (transactions[_tx_id].data);\n\n            transactions[_tx_id].executed = result;\n\n            if(result) \n            {\n                emit LogTransactionExecutionSuccess(_tx_id);\n            }\n            else \n            {\n                emit LogTransactionExecutionFailure(_tx_id);\n            }\n        }\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0x8000000000000000000000000000000000000000000000000000000000000000\ntimestamp: 0x0\ncalldata_TEST_MultiSig_32 + 68: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6: 0x40000000000003ffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 38, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7498, "code": " Math for uint256;\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 expiration;\n        uint256 receivedConfirmations;\n\n    }\n\n    event LogMultiSigContractCreated(\n        uint256 numOwners,\n        uint256 numAllowedDestinations,\n        uint256 quorum,\n        uint256 maxTxValiditySeconds\n    );\n    event LogDestinationStatus(address destination,bool status);\n    event LogTransactionProposal(\n        uint256 indexed txId,\n        address destination,\n        uint256 value,\n        bytes data\n    );\n    event LogTransactionConfirmationRescission(\n        uint256 indexed txId,\n        address approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogTransactionExecutionSuccess(uint256 indexed txId);\n    event LogTransactionExecutionFailure(uint256 indexed txId);\n    event LogTransactionConfirmation(\n        uint256 indexed txId,\n        address indexed approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogDeposit(address depositer, uint256 depositedValue); \n   \n\n    mapping (uint256 => Transaction) public transactions;\n    mapping (uint256 => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    mapping (address => bool) public destinationAddressStatus;\n    address[] public owners;\n    uint256 public requiredConfirmations;\n    uint256 public transactionCount;\n    uint256 public maxValidTimeSecs;\n    uint256 constant MIN_OWNER_COUNT=3;\n    uint256 constant MIN_REQD_COUNT=2;\n\n    modifier onlyByThisAddress {\n        require(msg.sender == address(this),\"onlyByThisAddress\");\n        _;\n    }\n\n    modifier onlyByOwners {\n        require(isOwner[msg.sender],\"onlyByOwners\");\n        _;\n    }\n\n    modifier destinationStatusCheck(address _destination,bool _status) {\n        require(\n            destinationAddressStatus[_destination]==_status,\n            \"Failed destinationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingConfirmation(uint256 _tx_id) {\n        //need only up to required approvals\n        require(!isConfirmed(_tx_id),\"Already confirmed\");\n        _;\n    }\n\n    modifier completedConfirmation(uint256 _tx_id) {\n        //need exactly required approvals\n        require(isConfirmed(_tx_id),\"Not confirmed yet\");\n        _;\n    }\n\n    modifier confirmationStatusCheck(\n        uint256 _tx_id,\n        address _sender,\n        bool _status\n    ) \n    {\n        require(\n            confirmations[_tx_id][_sender]==_status,\n            \"Failed confirmationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingExecution(uint256 _tx_id) {\n        require( \n            !isExecuted(_tx_id), \n            \"Tx already executed\"\n        );\n        _;\n    }\n\n    modifier awaitingExpiry(uint256 _tx_id) {\n        require(\n            !isExpired(_tx_id),\n            \"Tx has expired\"\n        );\n        _;\n    }\n\n\n    modifier validRequirement(uint _ownercount,uint _required) {\n        require(\n            (_ownercount>=MIN_OWNER_COUNT) &&\n            (_required >= MIN_REQD_COUNT)  &&\n            (MIN_REQD_COUNT <= MIN_OWNER_COUNT),\n            \"Constructor requirements not met\"\n        );\n        _;\n    }\n\n    modifier validExpiration(uint256 _expiration) {\n        require(\n            _expiration>=now,\n            \"time must be >= now\"\n        );\n        require(\n            (_expiration-now)<maxValidTimeSecs,\n            \"Expiration time is too far in the future\" \n        );\n        _;\n    }\n\n\n    /**\n     * @dev constructor\n     * @param _owners owners array\n     * @param _required_confirmations number of required confirmations\n     */\n    constructor(\n        address[] _owners,\n        address[] _allowed_destinations, \n        uint256 _required_confirmations,\n        uint256 _max_valid_time_secs\n    ) \n        public\n        validRequirement(_owners.length,_required_confirmations)\n    {\n\n        //for(uint256 i=0;i<_owners.length;i++) {\n        for(uint256 i=0;i<_owners.length;i=i.Add(1)) {\n            \n            //requires an address\n            require(_owners[i] != address(0));\n\n            //cant be repeated address\n            require(!isOwner[_owners[i]]);\n            \n            isOwner[_owners[i]]=true;\n        }\n\n        requiredConfirmations = _required_confirmations;\n        maxValidTimeSecs = _max_valid_time_secs;\n        owners = _owners;\n        \n        //to allow this contract to call its own admin functions\n        destinationAddressStatus[address(this)] = true;\n\n        //for(uint256 j=0;j<_allowed_destinations.length;/*j++*/j=j.Add(1)) {\n        for(uint256 j=0;j<_allowed_destinations.length;j=j.Add(1)) {\n            destinationAddressStatus[_allowed_destinations[j]]=true;\n        }\n\n        emit LogMultiSigContractCreated(\n            _owners.length,\n            _allowed_destinations.length.Add(1),\n            _required_confirmations,\n            _max_valid_time_secs\n        );\n    }\n\n    function() public payable {\n        if(msg.value>0)\n            emit LogDeposit(msg.sender,msg.value);\n    }\n\n    /* =================================================================\n     *  admin functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Sets whether a destination address is allowed\n     * @param _destination Destination address\n     * @param _status true=allowed, false=not allowed\n     */\n    function setDestinationAddressStatus(\n        address _destination,\n        bool _status\n    )\n        public\n        onlyByThisAddress\n        destinationStatusCheck(_destination,!_status)\n    {\n        require(\n            _destination!=address(this),\n            \"contract can never disable calling itself\"\n        );\n\n        destinationAddressStatus[_destination] = _status;      \n        emit LogDestinationStatus(_destination,_status);\n    }\n\n    /* =================================================================\n     *  (propose,approve,revokeApproval,execute)Tx\n     * =================================================================\n     */\n\n    /**\n     * @notice Propose a transaction for multi-sig approval\n     * @dev Proposal also counts as one confirmation\n     * @param _destination Destination address\n     * @param _value Wei, if payable function\n     * @param _data Transaction data\n     * @return {\"tx_id\":\"Transaction id\"}\n     */\n    function proposeTx(\n        address _destination, \n        uint256 _value, \n        bytes _data,\n        uint256 _expiration\n    )\n        public\n        onlyByOwners\n        destinationStatusCheck(_destination,true)\n        validExpiration(_expiration)\n        returns (uint256 tx_id)\n    {\n        tx_id = _createTx(_destination,_value,_data,_expiration);\n        _confirmTx(tx_id);\n    }\n\n    /**\n     * @notice Approver calls this to approve a transaction\n     * @dev Transaction will be executed if <br/>\n     * @dev ...1) quorum is reached <br/> \n     * @dev ...2) not expired, <br/> \n     * @dev ...3) valid transaction <br/>\n     * @param _tx_id Transaction id\n     */\n    function approveTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,false)\n        awaitingConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _confirmTx(_tx_id);\n    }\n     \n    /**\n     * @notice Approver calls this to revoke an earlier approval\n     * @param _tx_id the transaction id\n     */\n    function revokeApprovalTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,true)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _unconfirmTx(_tx_id);\n    }\n\n    /**\n     * @notice Executes a multi-sig transaction\n     * @param _tx_id the transaction id\n     */\n    function executeTx(uint256 _tx_id)\n        public\n        //onlyByOwners\n        completedConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _executeTx(_tx_id);\n    }\n\n    /* =================================================================\n     *  view functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Returns the number of owners of this contract\n     * @return {\"\":\"the number of owners\"}\n     */\n    function getNumberOfOwners() \n        external \n        view \n        returns (uint256) \n    {\n        return owners.length;\n    }\n\n    /**\n     * @notice Checks to see if transacton was executed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Executed, false on Not Executed\"}\n     */\n    function isExecuted(uint256 _tx_id) internal view returns(bool) {\n        return transactions[_tx_id].executed;\n    }\n\n    /**\n     * @notice Checks to see if transacton has expired\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Expired, false on Not Expired\"}\n     */\n    function isExpired(uint256 _tx_id) internal view returns(bool) {\n        return (now>transactions[_tx_id].expiration);\n    }\n\n    /**\n     * @notice Checks to see if transacton has been confirmed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Confirmed, false on Not Confirmed\"}\n     */\n    function isConfirmed(uint256 _tx_id) internal view returns(bool) {\n        return \n            transactions[_tx_id].receivedConfirmations==requiredConfirmations;\n    }\n\n\n\n    /* =================================================================\n     *  internal functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Creates a multi-sig transaction\n     * @param _destination Destination address \n     * @param _value Amount of wei to pay if calling a payable fn\n     * @param _data Transaction data\n     */\n    function _createTx(\n        address _destination,\n        uint256 _value,\n        bytes _data,\n        uint256 _expiration\n    )\n        internal\n        returns (uint256 tx_id)\n    {\n        tx_id = transactionCount;\n        transactionCount=transactionCount.Add(1);\n        \n        transactions[tx_id] = Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            executed: false,\n            expiration: _expiration,\n            receivedConfirmations: 0\n        });\n        emit LogTransactionProposal(tx_id,_destination,_value,_data);\n    }\n\n    /**\n     * @notice Confirms a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _confirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=true;\n        \n        transactions[_tx_id].receivedConfirmations=\n                transactions[_tx_id].receivedConfirmations.Add(1);\n\n        //try to execute\n        _executeTx(_tx_id);\n\n        emit LogTransactionConfirmation(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Removes confirmation of a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _unconfirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=false;\n\n        assert(transactions[_tx_id].receivedConfirmations!=0);\n        \n        transactions[_tx_id].receivedConfirmations = \n            transactions[_tx_id].receivedConfirmations.Sub(1);\n\n        emit LogTransactionConfirmationRescission(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Internal execute function invoking \"call\"\n     * @dev this function cannot throw<br/>\n     * @dev cannot use modifiers, check explicitly here<br/>\n     * @dev ignoring the gas limits here<br/>\n     * @param _tx_id Transaction id\n     */\n    function _executeTx(uint256 _tx_id)\n        internal\n    {\n        if( \n            (!isExecuted(_tx_id)) && \n            (!isExpired(_tx_id)) && \n            (isConfirmed(_tx_id)) \n        )\n        {\n\n            transactions[_tx_id].executed = true;\n            bool result = \n                (transactions[_tx_id].destination)\n                .call\n                .value(transactions[_tx_id].value)\n                (transactions[_tx_id].data);\n\n            transactions[_tx_id].executed = result;\n\n            if(result) \n            {\n                emit LogTransactionExecutionSuccess(_tx_id);\n            }\n            else \n            {\n                emit LogTransactionExecutionFailure(_tx_id);\n            }\n        }\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0xb73be8984f2adc80000000000000000000000000000000000000000000000001\ntimestamp: 0x80000000000000000000000000000000000000000000000000000000000000\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0xa52d20d9658fbafffffffffffffffffffffffffffffffffffffffffffffffff9\ncalldata_TEST_MultiSig_32 + 68: 0x20541d000820ec802f0b49fc44100827008603a1020f3536d68ed6071300008\nstorage_6: 0x9100000100000002000000000000000000000000000000000000000000000000\nstorage_7: 0x18541d000820ec802f0b49fc44100827008603a1020f3536d68ed6071300009\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 38, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7515, "code": " Math for uint256;\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 expiration;\n        uint256 receivedConfirmations;\n\n    }\n\n    event LogMultiSigContractCreated(\n        uint256 numOwners,\n        uint256 numAllowedDestinations,\n        uint256 quorum,\n        uint256 maxTxValiditySeconds\n    );\n    event LogDestinationStatus(address destination,bool status);\n    event LogTransactionProposal(\n        uint256 indexed txId,\n        address destination,\n        uint256 value,\n        bytes data\n    );\n    event LogTransactionConfirmationRescission(\n        uint256 indexed txId,\n        address approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogTransactionExecutionSuccess(uint256 indexed txId);\n    event LogTransactionExecutionFailure(uint256 indexed txId);\n    event LogTransactionConfirmation(\n        uint256 indexed txId,\n        address indexed approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogDeposit(address depositer, uint256 depositedValue); \n   \n\n    mapping (uint256 => Transaction) public transactions;\n    mapping (uint256 => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    mapping (address => bool) public destinationAddressStatus;\n    address[] public owners;\n    uint256 public requiredConfirmations;\n    uint256 public transactionCount;\n    uint256 public maxValidTimeSecs;\n    uint256 constant MIN_OWNER_COUNT=3;\n    uint256 constant MIN_REQD_COUNT=2;\n\n    modifier onlyByThisAddress {\n        require(msg.sender == address(this),\"onlyByThisAddress\");\n        _;\n    }\n\n    modifier onlyByOwners {\n        require(isOwner[msg.sender],\"onlyByOwners\");\n        _;\n    }\n\n    modifier destinationStatusCheck(address _destination,bool _status) {\n        require(\n            destinationAddressStatus[_destination]==_status,\n            \"Failed destinationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingConfirmation(uint256 _tx_id) {\n        //need only up to required approvals\n        require(!isConfirmed(_tx_id),\"Already confirmed\");\n        _;\n    }\n\n    modifier completedConfirmation(uint256 _tx_id) {\n        //need exactly required approvals\n        require(isConfirmed(_tx_id),\"Not confirmed yet\");\n        _;\n    }\n\n    modifier confirmationStatusCheck(\n        uint256 _tx_id,\n        address _sender,\n        bool _status\n    ) \n    {\n        require(\n            confirmations[_tx_id][_sender]==_status,\n            \"Failed confirmationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingExecution(uint256 _tx_id) {\n        require( \n            !isExecuted(_tx_id), \n            \"Tx already executed\"\n        );\n        _;\n    }\n\n    modifier awaitingExpiry(uint256 _tx_id) {\n        require(\n            !isExpired(_tx_id),\n            \"Tx has expired\"\n        );\n        _;\n    }\n\n\n    modifier validRequirement(uint _ownercount,uint _required) {\n        require(\n            (_ownercount>=MIN_OWNER_COUNT) &&\n            (_required >= MIN_REQD_COUNT)  &&\n            (MIN_REQD_COUNT <= MIN_OWNER_COUNT),\n            \"Constructor requirements not met\"\n        );\n        _;\n    }\n\n    modifier validExpiration(uint256 _expiration) {\n        require(\n            _expiration>=now,\n            \"time must be >= now\"\n        );\n        require(\n            (_expiration-now)<maxValidTimeSecs,\n            \"Expiration time is too far in the future\" \n        );\n        _;\n    }\n\n\n    /**\n     * @dev constructor\n     * @param _owners owners array\n     * @param _required_confirmations number of required confirmations\n     */\n    constructor(\n        address[] _owners,\n        address[] _allowed_destinations, \n        uint256 _required_confirmations,\n        uint256 _max_valid_time_secs\n    ) \n        public\n        validRequirement(_owners.length,_required_confirmations)\n    {\n\n        //for(uint256 i=0;i<_owners.length;i++) {\n        for(uint256 i=0;i<_owners.length;i=i.Add(1)) {\n            \n            //requires an address\n            require(_owners[i] != address(0));\n\n            //cant be repeated address\n            require(!isOwner[_owners[i]]);\n            \n            isOwner[_owners[i]]=true;\n        }\n\n        requiredConfirmations = _required_confirmations;\n        maxValidTimeSecs = _max_valid_time_secs;\n        owners = _owners;\n        \n        //to allow this contract to call its own admin functions\n        destinationAddressStatus[address(this)] = true;\n\n        //for(uint256 j=0;j<_allowed_destinations.length;/*j++*/j=j.Add(1)) {\n        for(uint256 j=0;j<_allowed_destinations.length;j=j.Add(1)) {\n            destinationAddressStatus[_allowed_destinations[j]]=true;\n        }\n\n        emit LogMultiSigContractCreated(\n            _owners.length,\n            _allowed_destinations.length.Add(1),\n            _required_confirmations,\n            _max_valid_time_secs\n        );\n    }\n\n    function() public payable {\n        if(msg.value>0)\n            emit LogDeposit(msg.sender,msg.value);\n    }\n\n    /* =================================================================\n     *  admin functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Sets whether a destination address is allowed\n     * @param _destination Destination address\n     * @param _status true=allowed, false=not allowed\n     */\n    function setDestinationAddressStatus(\n        address _destination,\n        bool _status\n    )\n        public\n        onlyByThisAddress\n        destinationStatusCheck(_destination,!_status)\n    {\n        require(\n            _destination!=address(this),\n            \"contract can never disable calling itself\"\n        );\n\n        destinationAddressStatus[_destination] = _status;      \n        emit LogDestinationStatus(_destination,_status);\n    }\n\n    /* =================================================================\n     *  (propose,approve,revokeApproval,execute)Tx\n     * =================================================================\n     */\n\n    /**\n     * @notice Propose a transaction for multi-sig approval\n     * @dev Proposal also counts as one confirmation\n     * @param _destination Destination address\n     * @param _value Wei, if payable function\n     * @param _data Transaction data\n     * @return {\"tx_id\":\"Transaction id\"}\n     */\n    function proposeTx(\n        address _destination, \n        uint256 _value, \n        bytes _data,\n        uint256 _expiration\n    )\n        public\n        onlyByOwners\n        destinationStatusCheck(_destination,true)\n        validExpiration(_expiration)\n        returns (uint256 tx_id)\n    {\n        tx_id = _createTx(_destination,_value,_data,_expiration);\n        _confirmTx(tx_id);\n    }\n\n    /**\n     * @notice Approver calls this to approve a transaction\n     * @dev Transaction will be executed if <br/>\n     * @dev ...1) quorum is reached <br/> \n     * @dev ...2) not expired, <br/> \n     * @dev ...3) valid transaction <br/>\n     * @param _tx_id Transaction id\n     */\n    function approveTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,false)\n        awaitingConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _confirmTx(_tx_id);\n    }\n     \n    /**\n     * @notice Approver calls this to revoke an earlier approval\n     * @param _tx_id the transaction id\n     */\n    function revokeApprovalTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,true)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _unconfirmTx(_tx_id);\n    }\n\n    /**\n     * @notice Executes a multi-sig transaction\n     * @param _tx_id the transaction id\n     */\n    function executeTx(uint256 _tx_id)\n        public\n        //onlyByOwners\n        completedConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _executeTx(_tx_id);\n    }\n\n    /* =================================================================\n     *  view functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Returns the number of owners of this contract\n     * @return {\"\":\"the number of owners\"}\n     */\n    function getNumberOfOwners() \n        external \n        view \n        returns (uint256) \n    {\n        return owners.length;\n    }\n\n    /**\n     * @notice Checks to see if transacton was executed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Executed, false on Not Executed\"}\n     */\n    function isExecuted(uint256 _tx_id) internal view returns(bool) {\n        return transactions[_tx_id].executed;\n    }\n\n    /**\n     * @notice Checks to see if transacton has expired\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Expired, false on Not Expired\"}\n     */\n    function isExpired(uint256 _tx_id) internal view returns(bool) {\n        return (now>transactions[_tx_id].expiration);\n    }\n\n    /**\n     * @notice Checks to see if transacton has been confirmed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Confirmed, false on Not Confirmed\"}\n     */\n    function isConfirmed(uint256 _tx_id) internal view returns(bool) {\n        return \n            transactions[_tx_id].receivedConfirmations==requiredConfirmations;\n    }\n\n\n\n    /* =================================================================\n     *  internal functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Creates a multi-sig transaction\n     * @param _destination Destination address \n     * @param _value Amount of wei to pay if calling a payable fn\n     * @param _data Transaction data\n     */\n    function _createTx(\n        address _destination,\n        uint256 _value,\n        bytes _data,\n        uint256 _expiration\n    )\n        internal\n        returns (uint256 tx_id)\n    {\n        tx_id = transactionCount;\n        transactionCount=transactionCount.Add(1);\n        \n        transactions[tx_id] = Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            executed: false,\n            expiration: _expiration,\n            receivedConfirmations: 0\n        });\n        emit LogTransactionProposal(tx_id,_destination,_value,_data);\n    }\n\n    /**\n     * @notice Confirms a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _confirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=true;\n        \n        transactions[_tx_id].receivedConfirmations=\n                transactions[_tx_id].receivedConfirmations.Add(1);\n\n        //try to execute\n        _executeTx(_tx_id);\n\n        emit LogTransactionConfirmation(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Removes confirmation of a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _unconfirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=false;\n\n        assert(transactions[_tx_id].receivedConfirmations!=0);\n        \n        transactions[_tx_id].receivedConfirmations = \n            transactions[_tx_id].receivedConfirmations.Sub(1);\n\n        emit LogTransactionConfirmationRescission(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Internal execute function invoking \"call\"\n     * @dev this function cannot throw<br/>\n     * @dev cannot use modifiers, check explicitly here<br/>\n     * @dev ignoring the gas limits here<br/>\n     * @param _tx_id Transaction id\n     */\n    function _executeTx(uint256 _tx_id)\n        internal\n    {\n        if( \n            (!isExecuted(_tx_id)) && \n            (!isExpired(_tx_id)) && \n            (isConfirmed(_tx_id)) \n        )\n        {\n\n            transactions[_tx_id].executed = true;\n            bool result = \n                (transactions[_tx_id].destination)\n                .call\n                .value(transactions[_tx_id].value)\n                (transactions[_tx_id].data);\n\n            transactions[_tx_id].executed = result;\n\n            if(result) \n            {\n                emit LogTransactionExecutionSuccess(_tx_id);\n            }\n            else \n            {\n                emit LogTransactionExecutionFailure(_tx_id);\n            }\n        }\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0x21\ntimestamp: 0x804000000000020000000000000000000000000000000000000000000000000\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\ncalldata_TEST_MultiSig_32 + 68: 0x8024b4819844001ffffffffffffffffffffffffbffffffffffffffffffffffff\nstorage_6: 0x5990400040000000000000000000000000ffffffffffffffffffffffffffffff\nstorage_7: 0x7820b4819843fffffffffffffffffffffffffffc000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 38, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7520, "code": " Math for uint256;\n    struct Transaction {\n        address destination;\n        uint256 value;\n        bytes data;\n        bool executed;\n        uint256 expiration;\n        uint256 receivedConfirmations;\n\n    }\n\n    event LogMultiSigContractCreated(\n        uint256 numOwners,\n        uint256 numAllowedDestinations,\n        uint256 quorum,\n        uint256 maxTxValiditySeconds\n    );\n    event LogDestinationStatus(address destination,bool status);\n    event LogTransactionProposal(\n        uint256 indexed txId,\n        address destination,\n        uint256 value,\n        bytes data\n    );\n    event LogTransactionConfirmationRescission(\n        uint256 indexed txId,\n        address approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogTransactionExecutionSuccess(uint256 indexed txId);\n    event LogTransactionExecutionFailure(uint256 indexed txId);\n    event LogTransactionConfirmation(\n        uint256 indexed txId,\n        address indexed approver,\n        uint256 currentlyReceivedConfirmations\n    );\n    event LogDeposit(address depositer, uint256 depositedValue); \n   \n\n    mapping (uint256 => Transaction) public transactions;\n    mapping (uint256 => mapping (address => bool)) public confirmations;\n    mapping (address => bool) public isOwner;\n    mapping (address => bool) public destinationAddressStatus;\n    address[] public owners;\n    uint256 public requiredConfirmations;\n    uint256 public transactionCount;\n    uint256 public maxValidTimeSecs;\n    uint256 constant MIN_OWNER_COUNT=3;\n    uint256 constant MIN_REQD_COUNT=2;\n\n    modifier onlyByThisAddress {\n        require(msg.sender == address(this),\"onlyByThisAddress\");\n        _;\n    }\n\n    modifier onlyByOwners {\n        require(isOwner[msg.sender],\"onlyByOwners\");\n        _;\n    }\n\n    modifier destinationStatusCheck(address _destination,bool _status) {\n        require(\n            destinationAddressStatus[_destination]==_status,\n            \"Failed destinationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingConfirmation(uint256 _tx_id) {\n        //need only up to required approvals\n        require(!isConfirmed(_tx_id),\"Already confirmed\");\n        _;\n    }\n\n    modifier completedConfirmation(uint256 _tx_id) {\n        //need exactly required approvals\n        require(isConfirmed(_tx_id),\"Not confirmed yet\");\n        _;\n    }\n\n    modifier confirmationStatusCheck(\n        uint256 _tx_id,\n        address _sender,\n        bool _status\n    ) \n    {\n        require(\n            confirmations[_tx_id][_sender]==_status,\n            \"Failed confirmationStatusCheck\"\n        );\n        _;\n    }\n\n    modifier awaitingExecution(uint256 _tx_id) {\n        require( \n            !isExecuted(_tx_id), \n            \"Tx already executed\"\n        );\n        _;\n    }\n\n    modifier awaitingExpiry(uint256 _tx_id) {\n        require(\n            !isExpired(_tx_id),\n            \"Tx has expired\"\n        );\n        _;\n    }\n\n\n    modifier validRequirement(uint _ownercount,uint _required) {\n        require(\n            (_ownercount>=MIN_OWNER_COUNT) &&\n            (_required >= MIN_REQD_COUNT)  &&\n            (MIN_REQD_COUNT <= MIN_OWNER_COUNT),\n            \"Constructor requirements not met\"\n        );\n        _;\n    }\n\n    modifier validExpiration(uint256 _expiration) {\n        require(\n            _expiration>=now,\n            \"time must be >= now\"\n        );\n        require(\n            (_expiration-now)<maxValidTimeSecs,\n            \"Expiration time is too far in the future\" \n        );\n        _;\n    }\n\n\n    /**\n     * @dev constructor\n     * @param _owners owners array\n     * @param _required_confirmations number of required confirmations\n     */\n    constructor(\n        address[] _owners,\n        address[] _allowed_destinations, \n        uint256 _required_confirmations,\n        uint256 _max_valid_time_secs\n    ) \n        public\n        validRequirement(_owners.length,_required_confirmations)\n    {\n\n        //for(uint256 i=0;i<_owners.length;i++) {\n        for(uint256 i=0;i<_owners.length;i=i.Add(1)) {\n            \n            //requires an address\n            require(_owners[i] != address(0));\n\n            //cant be repeated address\n            require(!isOwner[_owners[i]]);\n            \n            isOwner[_owners[i]]=true;\n        }\n\n        requiredConfirmations = _required_confirmations;\n        maxValidTimeSecs = _max_valid_time_secs;\n        owners = _owners;\n        \n        //to allow this contract to call its own admin functions\n        destinationAddressStatus[address(this)] = true;\n\n        //for(uint256 j=0;j<_allowed_destinations.length;/*j++*/j=j.Add(1)) {\n        for(uint256 j=0;j<_allowed_destinations.length;j=j.Add(1)) {\n            destinationAddressStatus[_allowed_destinations[j]]=true;\n        }\n\n        emit LogMultiSigContractCreated(\n            _owners.length,\n            _allowed_destinations.length.Add(1),\n            _required_confirmations,\n            _max_valid_time_secs\n        );\n    }\n\n    function() public payable {\n        if(msg.value>0)\n            emit LogDeposit(msg.sender,msg.value);\n    }\n\n    /* =================================================================\n     *  admin functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Sets whether a destination address is allowed\n     * @param _destination Destination address\n     * @param _status true=allowed, false=not allowed\n     */\n    function setDestinationAddressStatus(\n        address _destination,\n        bool _status\n    )\n        public\n        onlyByThisAddress\n        destinationStatusCheck(_destination,!_status)\n    {\n        require(\n            _destination!=address(this),\n            \"contract can never disable calling itself\"\n        );\n\n        destinationAddressStatus[_destination] = _status;      \n        emit LogDestinationStatus(_destination,_status);\n    }\n\n    /* =================================================================\n     *  (propose,approve,revokeApproval,execute)Tx\n     * =================================================================\n     */\n\n    /**\n     * @notice Propose a transaction for multi-sig approval\n     * @dev Proposal also counts as one confirmation\n     * @param _destination Destination address\n     * @param _value Wei, if payable function\n     * @param _data Transaction data\n     * @return {\"tx_id\":\"Transaction id\"}\n     */\n    function proposeTx(\n        address _destination, \n        uint256 _value, \n        bytes _data,\n        uint256 _expiration\n    )\n        public\n        onlyByOwners\n        destinationStatusCheck(_destination,true)\n        validExpiration(_expiration)\n        returns (uint256 tx_id)\n    {\n        tx_id = _createTx(_destination,_value,_data,_expiration);\n        _confirmTx(tx_id);\n    }\n\n    /**\n     * @notice Approver calls this to approve a transaction\n     * @dev Transaction will be executed if <br/>\n     * @dev ...1) quorum is reached <br/> \n     * @dev ...2) not expired, <br/> \n     * @dev ...3) valid transaction <br/>\n     * @param _tx_id Transaction id\n     */\n    function approveTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,false)\n        awaitingConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _confirmTx(_tx_id);\n    }\n     \n    /**\n     * @notice Approver calls this to revoke an earlier approval\n     * @param _tx_id the transaction id\n     */\n    function revokeApprovalTx(uint256 _tx_id)\n        public\n        onlyByOwners\n        confirmationStatusCheck(_tx_id,msg.sender,true)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _unconfirmTx(_tx_id);\n    }\n\n    /**\n     * @notice Executes a multi-sig transaction\n     * @param _tx_id the transaction id\n     */\n    function executeTx(uint256 _tx_id)\n        public\n        //onlyByOwners\n        completedConfirmation(_tx_id)\n        awaitingExecution(_tx_id)\n        awaitingExpiry(_tx_id)\n    {\n        _executeTx(_tx_id);\n    }\n\n    /* =================================================================\n     *  view functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Returns the number of owners of this contract\n     * @return {\"\":\"the number of owners\"}\n     */\n    function getNumberOfOwners() \n        external \n        view \n        returns (uint256) \n    {\n        return owners.length;\n    }\n\n    /**\n     * @notice Checks to see if transacton was executed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Executed, false on Not Executed\"}\n     */\n    function isExecuted(uint256 _tx_id) internal view returns(bool) {\n        return transactions[_tx_id].executed;\n    }\n\n    /**\n     * @notice Checks to see if transacton has expired\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Expired, false on Not Expired\"}\n     */\n    function isExpired(uint256 _tx_id) internal view returns(bool) {\n        return (now>transactions[_tx_id].expiration);\n    }\n\n    /**\n     * @notice Checks to see if transacton has been confirmed\n     * @param _tx_id Transaction id\n     * @return {\"\":\"true on Confirmed, false on Not Confirmed\"}\n     */\n    function isConfirmed(uint256 _tx_id) internal view returns(bool) {\n        return \n            transactions[_tx_id].receivedConfirmations==requiredConfirmations;\n    }\n\n\n\n    /* =================================================================\n     *  internal functions\n     * =================================================================\n     */\n\n    /**\n     * @notice Creates a multi-sig transaction\n     * @param _destination Destination address \n     * @param _value Amount of wei to pay if calling a payable fn\n     * @param _data Transaction data\n     */\n    function _createTx(\n        address _destination,\n        uint256 _value,\n        bytes _data,\n        uint256 _expiration\n    )\n        internal\n        returns (uint256 tx_id)\n    {\n        tx_id = transactionCount;\n        transactionCount=transactionCount.Add(1);\n        \n        transactions[tx_id] = Transaction({\n            destination: _destination,\n            value: _value,\n            data: _data,\n            executed: false,\n            expiration: _expiration,\n            receivedConfirmations: 0\n        });\n        emit LogTransactionProposal(tx_id,_destination,_value,_data);\n    }\n\n    /**\n     * @notice Confirms a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _confirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=true;\n        \n        transactions[_tx_id].receivedConfirmations=\n                transactions[_tx_id].receivedConfirmations.Add(1);\n\n        //try to execute\n        _executeTx(_tx_id);\n\n        emit LogTransactionConfirmation(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Removes confirmation of a multi-sig transaction\n     * @param _tx_id Transaction id\n     */\n    function _unconfirmTx(uint256 _tx_id) \n        internal\n    {\n        confirmations[_tx_id][msg.sender]=false;\n\n        assert(transactions[_tx_id].receivedConfirmations!=0);\n        \n        transactions[_tx_id].receivedConfirmations = \n            transactions[_tx_id].receivedConfirmations.Sub(1);\n\n        emit LogTransactionConfirmationRescission(\n            _tx_id,\n            msg.sender,\n            transactions[_tx_id].receivedConfirmations\n        );\n    }\n\n    /**\n     * @notice Internal execute function invoking \"call\"\n     * @dev this function cannot throw<br/>\n     * @dev cannot use modifiers, check explicitly here<br/>\n     * @dev ignoring the gas limits here<br/>\n     * @param _tx_id Transaction id\n     */\n    function _executeTx(uint256 _tx_id)\n        internal\n    {\n        if( \n            (!isExecuted(_tx_id)) && \n            (!isExpired(_tx_id)) && \n            (isConfirmed(_tx_id)) \n        )\n        {\n\n            transactions[_tx_id].executed = true;\n            bool result = \n                (transactions[_tx_id].destination)\n                .call\n                .value(transactions[_tx_id].value)\n                (transactions[_tx_id].data);\n\n            transactions[_tx_id].executed = result;\n\n            if(result) \n            {\n                emit LogTransactionExecutionSuccess(_tx_id);\n            }\n            else \n            {\n                emit LogTransactionExecutionFailure(_tx_id);\n            }\n        }\n    }\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0x388000000000000000000000000007ffffffffffffffffffffffffffffffffe0\nkeccac_2_+_keccac_storage_6: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x80059c200000000000000000000000000000000000000000000000000000000\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_TEST_MultiSig_4 + calldata_TEST_MultiSig_32 + 36)) +\n64: 0x4d7ffffffffffffffffffffffffff7fffffffffffffffffffffffffffffffffc\ncalldata_TEST_MultiSig_32 + 68: 0x7dffff99ffffffff7f6ffffffffffffffffffffffffffffffffffffffffffffe\nstorage_6: 0x400000000000000000000000000000001fffffffffffffffffffffffffffffff\nstorage_7: 0x75ffa5d7ffffffff7f6fffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TEST_MultiSig_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TEST_MultiSig_0: 0x1542146a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TEST_MultiSig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `proposeTx(address,uint256,bytes,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x45cdacb5b3c01b8bed3ec2eed258ab5053dc01c2.sol", "function": "proposeTx(address,uint256,bytes,uint256)", "lineno": 38, "title": "Integer Overflow ", "type": "Warning"}], "success": true}