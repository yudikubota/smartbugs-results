{
  "contract": "0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44",
  "tool": "mythril",
  "start": 1563642612.9236767,
  "end": 1563642900.6880822,
  "duration": 287.7644054889679,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1092,
        "code": "     Pool sto",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\ncalldata_SanityPools_0: 0xf76f48900000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "getPoolName(uint256)",
        "lineno": 114,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1301,
        "code": " eth_to_withd",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\ncalldata_SanityPools_0: 0x278ecde100000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "refund(uint256)",
        "lineno": 117,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1518,
        "code": "56 _index) validIndex(_index) {\n      ",
        "debug": "calldata_SanityPools_4: 0x0\nstorage_5 + 2 + 8*calldata_SanityPools_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_6 + 2 + 8*calldata_SanityPools_4: 0x0\nstorage_802: 0x0\ncalldata_SanityPools_0: 0x278ecde100000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `refund(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "refund(uint256)",
        "lineno": 125,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 1641,
        "code": "int256 contra",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\ncalldata_SanityPools_0: 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 129,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1871,
        "code": "ontract_token_balance != 0);\n      ",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 131,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 1871,
        "code": "ontract_token_balance != 0);\n      ",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2750\nCall at address: 2448\n",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 131,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 2041,
        "code": "by the contract.\n        pool.pool_eth_value -= balances[_index][msg.sender];",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x0\nreturndatasize: 0x20\nretval_1871: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6 + 2 + 8*calldata_SanityPools_4: 0xff00\nstorage_802: 0x0\ncalldata_SanityPools_0: 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\nstorage_5 + 2 + 8*calldata_SanityPools_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 134,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2136,
        "code": "        balances[_index][msg.sender] = 0;\n        /",
        "debug": "calldata_SanityPools_4: 0x0\nstorage_5 + 2 + 8*calldata_SanityPools_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8000000000000000000000000000000000000000000000000000000000000001\nreturndatasize: 0x20\nretval_1871: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6 + 2 + 8*calldata_SanityPools_4: 0xff00\nstorage_802: 0x0\ncalldata_SanityPools_0: 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `withdraw(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 137,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 2142,
        "code": "        balances[_index][msg.sender] = 0;\n        /",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 137,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 2228,
        "code": "s on failure to prevent loss of ",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 140,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 2448,
        "code": "veloper, fee));\n    }\n\n    function contribute(uint256 _i",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 143,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 2448,
        "code": "veloper, fee));\n    }\n\n    function contribute(uint256 _i",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2750\n",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 143,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 2750,
        "code": "pools[_index];\n        require(!poo",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "withdraw(uint256)",
        "lineno": 147,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 2951,
        "code": "    require(p",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x3610724e00000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "buyTokens(uint256)",
        "lineno": 79,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3636,
        "code": "0), 0, false, 0);\n        //updates the active index\n        index_active +",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_802: 0x63\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x9b6c528300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPool(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "createPool(string,uint256,uint256)",
        "lineno": 60,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4015,
        "code": "buyTokens(uin",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0xaf906cf300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "setToken(uint256,address)",
        "lineno": 76,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4224,
        "code": "20 token = ER",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0xb78be80200000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "emergency_withdraw(uint256,address)",
        "lineno": 96,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4416,
        "code": "he funds.  Throws on failure t",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "emergency_withdraw(uint256,address)",
        "lineno": 99,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 4416,
        "code": "he funds.  Throws on failure t",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4656\n",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "emergency_withdraw(uint256,address)",
        "lineno": 99,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4656,
        "code": "y) onlyOwner {\n        week_in_blocs = _delay;\n   ",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "emergency_withdraw(uint256,address)",
        "lineno": 103,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 4766,
        "code": " require(pool",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\ncalldata_SanityPools_0: 0xc1cbbca700000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "contribute(uint256)",
        "lineno": 150,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4815,
        "code": "sg.value;\n        //Updates t",
        "debug": "calldata_SanityPools_4: 0x0\nstorage_5 + 2 + 8*calldata_SanityPools_4: 0xe58bdacc7a82074fc167e440f5bf8df5ddcdeeefa26f5c4bbd76d039276eee0b\ncallvalue: 0xe56b92aa20fb776de0601bb4833a51871fa810ca1a1080c431781fa9828afed1\nstorage_6 + 2 + 8*calldata_SanityPools_4: 0x0\nstorage_802: 0x0\ncalldata_SanityPools_0: 0xc1cbbca700000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\n",
        "description": "A possible integer overflow exists in the function `contribute(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "contribute(uint256)",
        "lineno": 152,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4854,
        "debug": "calldata_SanityPools_4: 0x0\nstorage_5 + 2 + 8*calldata_SanityPools_4: 0xbcd5565b74616c03bdead0c2e1ef9fdbeed7a55fbf792c86f2965eb3888a3cec\ncallvalue: 0xf805665d6a308fe83c0122faf7ffde1bcd0647db8d61e34ea840000000000000\nstorage_6 + 2 + 8*calldata_SanityPools_4: 0x0\nstorage_802: 0x0\ncalldata_SanityPools_0: 0xc1cbbca700000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\nstorage_2 + 2 + 8*calldata_SanityPools_4: 0x0\n",
        "description": "A possible integer overflow exists in the function `contribute(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "contribute(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4948,
        "debug": "calldata_SanityPools_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe58bdacc7a82074fc167e440f5bf8df5ddcdeeefa26f5c4bbd76d039276eee0b\ncallvalue: 0xe56b92aa20fb776de0601bb4833a51871fa810ca1a1080c431781fa9828afed1\nstorage_5 + 2 + 8*calldata_SanityPools_4: 0xe56b92aa20fb776de0601bb4833a51871fa810ca1a1080c431781fa9828afed0\nstorage_6 + 2 + 8*calldata_SanityPools_4: 0x0\nstorage_802: 0x0\ncalldata_SanityPools_0: 0xc1cbbca700000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\nstorage_2 + 2 + 8*calldata_SanityPools_4: 0x0\n",
        "description": "A possible integer overflow exists in the function `contribute(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "contribute(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5130,
        "code": "le = _sale;\n ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SanityPools_4: 0x70\nstorage_802: 0x70\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0xff02615800000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "setSale(uint256,address)",
        "lineno": 68,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5322,
        "code": "Controller {\n\n    //mapping of the pool's index with the corresponding balances\n    mapping (uint256 => mapping (address => uint256)) balances;\n    //Array of 100 pools max\n    Pool[100] pools;\n    //Index of the active pool\n    uint256 index_active = 0;\n    //Allows an emergency withdraw after 1 week after the buy : 7*24*60*60 / 15.3 (mean time for mining a block)\n    uint256 public week_in_blocs = 39529;\n\n    modifier validIndex(uint256 _index){\n        require(_index <= index_active);\n        _;\n    }\n\n    struct Pool {\n        string name;\n        //0 means there is no min/max amount\n        uint256 min_amount;\n        uint256 max_amount;\n        //\n        address sale;\n        ERC20 token;\n        // Record ETH value of tokens currently held by contract for the pool.\n        uint256 pool_eth_value;\n        // Track whether the pool has bought the tokens yet.\n        bool bought_tokens;\n        uint256 buy_block;\n    }\n\n    //Functions reserved for the owner\n    function createPool(string _name, uint256 _min, uint256 _max) onlyOwner {\n        require(index_active < 100);\n        //Creates a new struct and saves in storage\n        pools[index_active] = Pool(_name, _min, _max, 0x0, ERC20(0x0), 0, false, 0);\n        //updates the active index\n        index_active += 1;\n    }\n\n    function setSale(uint256 _index, address _sale) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.sale == 0x0);\n        pool.sale = _sale;\n    }\n\n    function setToken(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        pool.token = ERC20(_token);\n    }\n\n    function buyTokens(uint256 _index) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.pool_eth_value >= pool.min_amount);\n        require(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);\n        require(!pool.bought_tokens);\n        //Prevent burning of ETH by mistake\n        require(pool.sale != 0x0);\n        //Registers the buy block number\n        pool.buy_block = block.number;\n        // Record that the contract has bought the tokens.\n        pool.bought_tokens = true;\n        // Transfer all the funds to the crowdsale address.\n        pool.sale.transfer(pool.pool_eth_value);\n    }\n\n    function emergency_withdraw(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        //Allows to withdraw all the tokens after a certain amount of time, in the case\n        //of an unplanned situation\n        Pool storage pool = pools[_index];\n        require(block.number >= (pool.buy_block + week_in_blocs));\n        ERC20 token = ERC20(_token);\n        uint256 contract_token_balance = token.balanceOf(address(this));\n        require (contract_token_balance != 0);\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(token.transfer(msg.sender, contract_token_balance));\n    }\n\n    function change_delay(uint256 _delay) onlyOwner {\n        week_in_blocs = _delay;\n    }\n\n    //Functions accessible to everyone\n    function getPoolName(uint256 _index) validIndex(_index) constant returns (string) {\n        Pool storage pool = pools[_index];\n        return pool.name;\n    }\n\n    function refund(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        //Can't refund if tokens were bought\n        require(!pool.bought_tokens);\n        uint256 eth_to_withdraw = balances[_index][msg.sender];\n        //Updates the user's balance prior to sending ETH to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //Updates the pool ETH value\n        pool.pool_eth_value -= eth_to_withdraw;\n        msg.sender.transfer(eth_to_withdraw);\n    }\n\n    function withdraw(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        // Disallow withdraw if tokens haven't been bought yet.\n        require(pool.bought_tokens);\n        uint256 contract_token_balance = pool.token.balanceOf(address(this));\n        // Disallow token withdrawals if there are no tokens to withdraw.\n        require(contract_token_balance != 0);\n        // Store the user's token balance in a temporary variable.\n        uint256 tokens_to_withdraw = (balances[_index][msg.sender] * contract_token_balance) / pool.pool_eth_value;\n        // Update the value of tokens currently held by the contract.\n        pool.pool_eth_value -= balances[_index][msg.sender];\n        // Update the user's balance prior to sending to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //The 1% fee\n        uint256 fee = tokens_to_withdraw / 100;\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(pool.token.transfer(msg.sender, tokens_to_withdraw - fee));\n        // Send the fee to the developer.\n        require(pool.token.transfer(developer, fee));\n    }\n\n    function contribute(uint256 _index) validIndex(_index) payable {\n        Pool storage pool = pools[_index];\n        require(!pool.bought_tokens);\n        //Check if the contribution is within the limits or if there is no max amount\n        require(pool.pool_eth_value+msg.value <= pool.max_amount || pool.max_amount == 0);\n        //Update the eth held by the pool\n        pool.pool_eth_value += msg.value;\n        //Updates the user's balance\n        balances[_index][msg.sender] += msg.value;\n    }\n}",
        "debug": "keccac_0_+_2_+_8*storage_802: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 + 2 + 8*storage_802: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_802: 0x63\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x9b6c528300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPool(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "createPool(string,uint256,uint256)",
        "lineno": 25,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5351,
        "code": "Controller {\n\n    //mapping of the pool's index with the corresponding balances\n    mapping (uint256 => mapping (address => uint256)) balances;\n    //Array of 100 pools max\n    Pool[100] pools;\n    //Index of the active pool\n    uint256 index_active = 0;\n    //Allows an emergency withdraw after 1 week after the buy : 7*24*60*60 / 15.3 (mean time for mining a block)\n    uint256 public week_in_blocs = 39529;\n\n    modifier validIndex(uint256 _index){\n        require(_index <= index_active);\n        _;\n    }\n\n    struct Pool {\n        string name;\n        //0 means there is no min/max amount\n        uint256 min_amount;\n        uint256 max_amount;\n        //\n        address sale;\n        ERC20 token;\n        // Record ETH value of tokens currently held by contract for the pool.\n        uint256 pool_eth_value;\n        // Track whether the pool has bought the tokens yet.\n        bool bought_tokens;\n        uint256 buy_block;\n    }\n\n    //Functions reserved for the owner\n    function createPool(string _name, uint256 _min, uint256 _max) onlyOwner {\n        require(index_active < 100);\n        //Creates a new struct and saves in storage\n        pools[index_active] = Pool(_name, _min, _max, 0x0, ERC20(0x0), 0, false, 0);\n        //updates the active index\n        index_active += 1;\n    }\n\n    function setSale(uint256 _index, address _sale) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.sale == 0x0);\n        pool.sale = _sale;\n    }\n\n    function setToken(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        pool.token = ERC20(_token);\n    }\n\n    function buyTokens(uint256 _index) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.pool_eth_value >= pool.min_amount);\n        require(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);\n        require(!pool.bought_tokens);\n        //Prevent burning of ETH by mistake\n        require(pool.sale != 0x0);\n        //Registers the buy block number\n        pool.buy_block = block.number;\n        // Record that the contract has bought the tokens.\n        pool.bought_tokens = true;\n        // Transfer all the funds to the crowdsale address.\n        pool.sale.transfer(pool.pool_eth_value);\n    }\n\n    function emergency_withdraw(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        //Allows to withdraw all the tokens after a certain amount of time, in the case\n        //of an unplanned situation\n        Pool storage pool = pools[_index];\n        require(block.number >= (pool.buy_block + week_in_blocs));\n        ERC20 token = ERC20(_token);\n        uint256 contract_token_balance = token.balanceOf(address(this));\n        require (contract_token_balance != 0);\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(token.transfer(msg.sender, contract_token_balance));\n    }\n\n    function change_delay(uint256 _delay) onlyOwner {\n        week_in_blocs = _delay;\n    }\n\n    //Functions accessible to everyone\n    function getPoolName(uint256 _index) validIndex(_index) constant returns (string) {\n        Pool storage pool = pools[_index];\n        return pool.name;\n    }\n\n    function refund(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        //Can't refund if tokens were bought\n        require(!pool.bought_tokens);\n        uint256 eth_to_withdraw = balances[_index][msg.sender];\n        //Updates the user's balance prior to sending ETH to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //Updates the pool ETH value\n        pool.pool_eth_value -= eth_to_withdraw;\n        msg.sender.transfer(eth_to_withdraw);\n    }\n\n    function withdraw(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        // Disallow withdraw if tokens haven't been bought yet.\n        require(pool.bought_tokens);\n        uint256 contract_token_balance = pool.token.balanceOf(address(this));\n        // Disallow token withdrawals if there are no tokens to withdraw.\n        require(contract_token_balance != 0);\n        // Store the user's token balance in a temporary variable.\n        uint256 tokens_to_withdraw = (balances[_index][msg.sender] * contract_token_balance) / pool.pool_eth_value;\n        // Update the value of tokens currently held by the contract.\n        pool.pool_eth_value -= balances[_index][msg.sender];\n        // Update the user's balance prior to sending to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //The 1% fee\n        uint256 fee = tokens_to_withdraw / 100;\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(pool.token.transfer(msg.sender, tokens_to_withdraw - fee));\n        // Send the fee to the developer.\n        require(pool.token.transfer(developer, fee));\n    }\n\n    function contribute(uint256 _index) validIndex(_index) payable {\n        Pool storage pool = pools[_index];\n        require(!pool.bought_tokens);\n        //Check if the contribution is within the limits or if there is no max amount\n        require(pool.pool_eth_value+msg.value <= pool.max_amount || pool.max_amount == 0);\n        //Update the eth held by the pool\n        pool.pool_eth_value += msg.value;\n        //Updates the user's balance\n        balances[_index][msg.sender] += msg.value;\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_802: 0x63\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x9b6c528300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPool(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "createPool(string,uint256,uint256)",
        "lineno": 25,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5365,
        "code": "Controller {\n\n    //mapping of the pool's index with the corresponding balances\n    mapping (uint256 => mapping (address => uint256)) balances;\n    //Array of 100 pools max\n    Pool[100] pools;\n    //Index of the active pool\n    uint256 index_active = 0;\n    //Allows an emergency withdraw after 1 week after the buy : 7*24*60*60 / 15.3 (mean time for mining a block)\n    uint256 public week_in_blocs = 39529;\n\n    modifier validIndex(uint256 _index){\n        require(_index <= index_active);\n        _;\n    }\n\n    struct Pool {\n        string name;\n        //0 means there is no min/max amount\n        uint256 min_amount;\n        uint256 max_amount;\n        //\n        address sale;\n        ERC20 token;\n        // Record ETH value of tokens currently held by contract for the pool.\n        uint256 pool_eth_value;\n        // Track whether the pool has bought the tokens yet.\n        bool bought_tokens;\n        uint256 buy_block;\n    }\n\n    //Functions reserved for the owner\n    function createPool(string _name, uint256 _min, uint256 _max) onlyOwner {\n        require(index_active < 100);\n        //Creates a new struct and saves in storage\n        pools[index_active] = Pool(_name, _min, _max, 0x0, ERC20(0x0), 0, false, 0);\n        //updates the active index\n        index_active += 1;\n    }\n\n    function setSale(uint256 _index, address _sale) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.sale == 0x0);\n        pool.sale = _sale;\n    }\n\n    function setToken(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        pool.token = ERC20(_token);\n    }\n\n    function buyTokens(uint256 _index) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.pool_eth_value >= pool.min_amount);\n        require(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);\n        require(!pool.bought_tokens);\n        //Prevent burning of ETH by mistake\n        require(pool.sale != 0x0);\n        //Registers the buy block number\n        pool.buy_block = block.number;\n        // Record that the contract has bought the tokens.\n        pool.bought_tokens = true;\n        // Transfer all the funds to the crowdsale address.\n        pool.sale.transfer(pool.pool_eth_value);\n    }\n\n    function emergency_withdraw(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        //Allows to withdraw all the tokens after a certain amount of time, in the case\n        //of an unplanned situation\n        Pool storage pool = pools[_index];\n        require(block.number >= (pool.buy_block + week_in_blocs));\n        ERC20 token = ERC20(_token);\n        uint256 contract_token_balance = token.balanceOf(address(this));\n        require (contract_token_balance != 0);\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(token.transfer(msg.sender, contract_token_balance));\n    }\n\n    function change_delay(uint256 _delay) onlyOwner {\n        week_in_blocs = _delay;\n    }\n\n    //Functions accessible to everyone\n    function getPoolName(uint256 _index) validIndex(_index) constant returns (string) {\n        Pool storage pool = pools[_index];\n        return pool.name;\n    }\n\n    function refund(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        //Can't refund if tokens were bought\n        require(!pool.bought_tokens);\n        uint256 eth_to_withdraw = balances[_index][msg.sender];\n        //Updates the user's balance prior to sending ETH to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //Updates the pool ETH value\n        pool.pool_eth_value -= eth_to_withdraw;\n        msg.sender.transfer(eth_to_withdraw);\n    }\n\n    function withdraw(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        // Disallow withdraw if tokens haven't been bought yet.\n        require(pool.bought_tokens);\n        uint256 contract_token_balance = pool.token.balanceOf(address(this));\n        // Disallow token withdrawals if there are no tokens to withdraw.\n        require(contract_token_balance != 0);\n        // Store the user's token balance in a temporary variable.\n        uint256 tokens_to_withdraw = (balances[_index][msg.sender] * contract_token_balance) / pool.pool_eth_value;\n        // Update the value of tokens currently held by the contract.\n        pool.pool_eth_value -= balances[_index][msg.sender];\n        // Update the user's balance prior to sending to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //The 1% fee\n        uint256 fee = tokens_to_withdraw / 100;\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(pool.token.transfer(msg.sender, tokens_to_withdraw - fee));\n        // Send the fee to the developer.\n        require(pool.token.transfer(developer, fee));\n    }\n\n    function contribute(uint256 _index) validIndex(_index) payable {\n        Pool storage pool = pools[_index];\n        require(!pool.bought_tokens);\n        //Check if the contribution is within the limits or if there is no max amount\n        require(pool.pool_eth_value+msg.value <= pool.max_amount || pool.max_amount == 0);\n        //Update the eth held by the pool\n        pool.pool_eth_value += msg.value;\n        //Updates the user's balance\n        balances[_index][msg.sender] += msg.value;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_802: 0x63\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x9b6c528300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPool(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "createPool(string,uint256,uint256)",
        "lineno": 25,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5382,
        "code": "Controller {\n\n    //mapping of the pool's index with the corresponding balances\n    mapping (uint256 => mapping (address => uint256)) balances;\n    //Array of 100 pools max\n    Pool[100] pools;\n    //Index of the active pool\n    uint256 index_active = 0;\n    //Allows an emergency withdraw after 1 week after the buy : 7*24*60*60 / 15.3 (mean time for mining a block)\n    uint256 public week_in_blocs = 39529;\n\n    modifier validIndex(uint256 _index){\n        require(_index <= index_active);\n        _;\n    }\n\n    struct Pool {\n        string name;\n        //0 means there is no min/max amount\n        uint256 min_amount;\n        uint256 max_amount;\n        //\n        address sale;\n        ERC20 token;\n        // Record ETH value of tokens currently held by contract for the pool.\n        uint256 pool_eth_value;\n        // Track whether the pool has bought the tokens yet.\n        bool bought_tokens;\n        uint256 buy_block;\n    }\n\n    //Functions reserved for the owner\n    function createPool(string _name, uint256 _min, uint256 _max) onlyOwner {\n        require(index_active < 100);\n        //Creates a new struct and saves in storage\n        pools[index_active] = Pool(_name, _min, _max, 0x0, ERC20(0x0), 0, false, 0);\n        //updates the active index\n        index_active += 1;\n    }\n\n    function setSale(uint256 _index, address _sale) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.sale == 0x0);\n        pool.sale = _sale;\n    }\n\n    function setToken(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        pool.token = ERC20(_token);\n    }\n\n    function buyTokens(uint256 _index) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.pool_eth_value >= pool.min_amount);\n        require(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);\n        require(!pool.bought_tokens);\n        //Prevent burning of ETH by mistake\n        require(pool.sale != 0x0);\n        //Registers the buy block number\n        pool.buy_block = block.number;\n        // Record that the contract has bought the tokens.\n        pool.bought_tokens = true;\n        // Transfer all the funds to the crowdsale address.\n        pool.sale.transfer(pool.pool_eth_value);\n    }\n\n    function emergency_withdraw(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        //Allows to withdraw all the tokens after a certain amount of time, in the case\n        //of an unplanned situation\n        Pool storage pool = pools[_index];\n        require(block.number >= (pool.buy_block + week_in_blocs));\n        ERC20 token = ERC20(_token);\n        uint256 contract_token_balance = token.balanceOf(address(this));\n        require (contract_token_balance != 0);\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(token.transfer(msg.sender, contract_token_balance));\n    }\n\n    function change_delay(uint256 _delay) onlyOwner {\n        week_in_blocs = _delay;\n    }\n\n    //Functions accessible to everyone\n    function getPoolName(uint256 _index) validIndex(_index) constant returns (string) {\n        Pool storage pool = pools[_index];\n        return pool.name;\n    }\n\n    function refund(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        //Can't refund if tokens were bought\n        require(!pool.bought_tokens);\n        uint256 eth_to_withdraw = balances[_index][msg.sender];\n        //Updates the user's balance prior to sending ETH to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //Updates the pool ETH value\n        pool.pool_eth_value -= eth_to_withdraw;\n        msg.sender.transfer(eth_to_withdraw);\n    }\n\n    function withdraw(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        // Disallow withdraw if tokens haven't been bought yet.\n        require(pool.bought_tokens);\n        uint256 contract_token_balance = pool.token.balanceOf(address(this));\n        // Disallow token withdrawals if there are no tokens to withdraw.\n        require(contract_token_balance != 0);\n        // Store the user's token balance in a temporary variable.\n        uint256 tokens_to_withdraw = (balances[_index][msg.sender] * contract_token_balance) / pool.pool_eth_value;\n        // Update the value of tokens currently held by the contract.\n        pool.pool_eth_value -= balances[_index][msg.sender];\n        // Update the user's balance prior to sending to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //The 1% fee\n        uint256 fee = tokens_to_withdraw / 100;\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(pool.token.transfer(msg.sender, tokens_to_withdraw - fee));\n        // Send the fee to the developer.\n        require(pool.token.transfer(developer, fee));\n    }\n\n    function contribute(uint256 _index) validIndex(_index) payable {\n        Pool storage pool = pools[_index];\n        require(!pool.bought_tokens);\n        //Check if the contribution is within the limits or if there is no max amount\n        require(pool.pool_eth_value+msg.value <= pool.max_amount || pool.max_amount == 0);\n        //Update the eth held by the pool\n        pool.pool_eth_value += msg.value;\n        //Updates the user's balance\n        balances[_index][msg.sender] += msg.value;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0x25\nstorage_802: 0x63\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x9b6c528300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPool(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "createPool(string,uint256,uint256)",
        "lineno": 25,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5387,
        "code": "Controller {\n\n    //mapping of the pool's index with the corresponding balances\n    mapping (uint256 => mapping (address => uint256)) balances;\n    //Array of 100 pools max\n    Pool[100] pools;\n    //Index of the active pool\n    uint256 index_active = 0;\n    //Allows an emergency withdraw after 1 week after the buy : 7*24*60*60 / 15.3 (mean time for mining a block)\n    uint256 public week_in_blocs = 39529;\n\n    modifier validIndex(uint256 _index){\n        require(_index <= index_active);\n        _;\n    }\n\n    struct Pool {\n        string name;\n        //0 means there is no min/max amount\n        uint256 min_amount;\n        uint256 max_amount;\n        //\n        address sale;\n        ERC20 token;\n        // Record ETH value of tokens currently held by contract for the pool.\n        uint256 pool_eth_value;\n        // Track whether the pool has bought the tokens yet.\n        bool bought_tokens;\n        uint256 buy_block;\n    }\n\n    //Functions reserved for the owner\n    function createPool(string _name, uint256 _min, uint256 _max) onlyOwner {\n        require(index_active < 100);\n        //Creates a new struct and saves in storage\n        pools[index_active] = Pool(_name, _min, _max, 0x0, ERC20(0x0), 0, false, 0);\n        //updates the active index\n        index_active += 1;\n    }\n\n    function setSale(uint256 _index, address _sale) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.sale == 0x0);\n        pool.sale = _sale;\n    }\n\n    function setToken(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        pool.token = ERC20(_token);\n    }\n\n    function buyTokens(uint256 _index) onlyOwner validIndex(_index) {\n        Pool storage pool = pools[_index];\n        require(pool.pool_eth_value >= pool.min_amount);\n        require(pool.pool_eth_value <= pool.max_amount || pool.max_amount == 0);\n        require(!pool.bought_tokens);\n        //Prevent burning of ETH by mistake\n        require(pool.sale != 0x0);\n        //Registers the buy block number\n        pool.buy_block = block.number;\n        // Record that the contract has bought the tokens.\n        pool.bought_tokens = true;\n        // Transfer all the funds to the crowdsale address.\n        pool.sale.transfer(pool.pool_eth_value);\n    }\n\n    function emergency_withdraw(uint256 _index, address _token) onlyOwner validIndex(_index) {\n        //Allows to withdraw all the tokens after a certain amount of time, in the case\n        //of an unplanned situation\n        Pool storage pool = pools[_index];\n        require(block.number >= (pool.buy_block + week_in_blocs));\n        ERC20 token = ERC20(_token);\n        uint256 contract_token_balance = token.balanceOf(address(this));\n        require (contract_token_balance != 0);\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(token.transfer(msg.sender, contract_token_balance));\n    }\n\n    function change_delay(uint256 _delay) onlyOwner {\n        week_in_blocs = _delay;\n    }\n\n    //Functions accessible to everyone\n    function getPoolName(uint256 _index) validIndex(_index) constant returns (string) {\n        Pool storage pool = pools[_index];\n        return pool.name;\n    }\n\n    function refund(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        //Can't refund if tokens were bought\n        require(!pool.bought_tokens);\n        uint256 eth_to_withdraw = balances[_index][msg.sender];\n        //Updates the user's balance prior to sending ETH to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //Updates the pool ETH value\n        pool.pool_eth_value -= eth_to_withdraw;\n        msg.sender.transfer(eth_to_withdraw);\n    }\n\n    function withdraw(uint256 _index) validIndex(_index) {\n        Pool storage pool = pools[_index];\n        // Disallow withdraw if tokens haven't been bought yet.\n        require(pool.bought_tokens);\n        uint256 contract_token_balance = pool.token.balanceOf(address(this));\n        // Disallow token withdrawals if there are no tokens to withdraw.\n        require(contract_token_balance != 0);\n        // Store the user's token balance in a temporary variable.\n        uint256 tokens_to_withdraw = (balances[_index][msg.sender] * contract_token_balance) / pool.pool_eth_value;\n        // Update the value of tokens currently held by the contract.\n        pool.pool_eth_value -= balances[_index][msg.sender];\n        // Update the user's balance prior to sending to prevent recursive call.\n        balances[_index][msg.sender] = 0;\n        //The 1% fee\n        uint256 fee = tokens_to_withdraw / 100;\n        // Send the funds.  Throws on failure to prevent loss of funds.\n        require(pool.token.transfer(msg.sender, tokens_to_withdraw - fee));\n        // Send the fee to the developer.\n        require(pool.token.transfer(developer, fee));\n    }\n\n    function contribute(uint256 _index) validIndex(_index) payable {\n        Pool storage pool = pools[_index];\n        require(!pool.bought_tokens);\n        //Check if the contribution is within the limits or if there is no max amount\n        require(pool.pool_eth_value+msg.value <= pool.max_amount || pool.max_amount == 0);\n        //Update the eth held by the pool\n        pool.pool_eth_value += msg.value;\n        //Updates the user's balance\n        balances[_index][msg.sender] += msg.value;\n    }\n}",
        "debug": "keccac_0_+_2_+_8*storage_802: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_SanityPools_4 + calldata_SanityPools_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nstorage_802: 0x63\nstorage_0: 0x0\ncaller: 0x0\ncalldata_SanityPools_0: 0x9b6c528300000000000000000000000000000000000000000000000000000000\ncalldatasize_SanityPools: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createPool(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/25/0x51e4e00e3e019e58fc0b8cc8c6490a2d28efbf44.sol",
        "function": "createPool(string,uint256,uint256)",
        "lineno": 25,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}