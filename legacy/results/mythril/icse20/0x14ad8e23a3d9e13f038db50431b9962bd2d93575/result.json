{
  "contract": "0x14ad8e23a3d9e13f038db50431b9962bd2d93575",
  "tool": "mythril",
  "start": 1563356107.3704348,
  "end": 1563356337.3045332,
  "duration": 229.93409848213196,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 499,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 511,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4 + calldata_TokenSwap_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 514,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4 + calldata_TokenSwap_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 520,
        "code": "defines array of addresses of new owners\n    * @param newHowManyOwnersDecide defines how many owners can decide\n    */\n    function",
        "debug": "calldata_TokenSwap_4 + calldata_TokenSwap_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 214,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 648,
        "code": " Status newStatus);\n    event AddParty(a",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\ncalldata_TokenSwap_0: 0x200d2ed200000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "_function_0x200d2ed2",
        "lineno": 488,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2065,
        "code": "public owners;\n    byte",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenSwap_4: 0x0\nstorage_3: 0x0\ncalldata_TokenSwap_0: 0x25e7c2700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "_function_0x025e7c27",
        "lineno": 11,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2260,
        "code": " );\n        _;\n    }\n\n    m",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x1c99d34100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "removeParty(uint256)",
        "lineno": 531,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3744,
        "code": "rent status\"\n        );\n      ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TokenSwap_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "withdraw()",
        "lineno": 559,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5010,
        "code": "ublic allOperations;\n    addre",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenSwap_4: 0x0\nstorage_4: 0x0\ncalldata_TokenSwap_0: 0x431ab23300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "_function_0x431ab233",
        "lineno": 12,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5189,
        "code": "         _haveEveryoneDepos",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x6b5c8fba00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "confirmParties()",
        "lineno": 538,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5479,
        "code": "CancelSwap onlyManyOwne",
        "debug": "storage_11: 0x0\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x6b5c8fba00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `confirmParties()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "confirmParties()",
        "lineno": 665,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6416,
        "code": "    * @param _tokensFee How mu",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TokenSwap_0: 0x80e9071b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "reclaim()",
        "lineno": 576,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6976,
        "code": "ta.\n     */\n    function tokenFallba",
        "debug": "",
        "description": "This contract executes a message call to the address of the transaction sender. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "reclaim()",
        "lineno": 737,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 8504,
        "code": "us\");\n        require(startLocku",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0xfc00\ncalldata_TokenSwap_0: 0x9e0fdb2600000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "cancelSwap()",
        "lineno": 545,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 15862,
        "code": "operation = keccak256(msg.dat",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x893372ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `cancelPending(bytes32)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "cancelPending(bytes32)",
        "lineno": 145,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 16044,
        "code": "lready voted for the operation\");\n   ",
        "debug": "calldatasize_TokenSwap: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff80\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x893372ca00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `cancelPending(bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "cancelPending(bytes32)",
        "lineno": 147,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16053,
        "code": "lready voted for the operation\");\n   ",
        "debug": "calldatasize_TokenSwap: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x893372ca00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `cancelPending(bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "cancelPending(bytes32)",
        "lineno": 147,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16333,
        "code": "      allOperationsIndicies[operatio",
        "debug": "2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x4000000000000000000000000000001000000000000000000000000000000000\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128): 0xbfffffffffffffffffffffffffffffefffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x893372ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `cancelPending(bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "cancelPending(bytes32)",
        "lineno": 152,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16423,
        "code": ";\n\n// File: Multio",
        "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128): 0x0\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x893372ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `cancelPending(bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "cancelPending(bytes32)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16987,
        "code": " index;\n        }\n      ",
        "debug": "storage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferOwnership(address[])`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 176,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 17016,
        "code": "yOperation[operation];\n        delete v",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_4: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x2edcbb76edd9b366d9b325e517366cd99f1e7fffffef2fff7fefdbff77ed73d6\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1123448912264c99264cda1ae8c9932660e180000010d0008010240088128c28\nstorage_2: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 180,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 17130,
        "code": "\n    // PUBLIC METHODS",
        "debug": "storage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferOwnership(address[])`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 184,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 18987,
        "code": "okensTotal;\n        uint256 withdrawnTokensTotal;\n    }\n\n    struct LockupStage {\n        uint256 secondsSinceLockupStart;\n        uint8 unlockedTokensPercentage;\n    }\n\n    // VARIABLES\n    Status public status = Status.AddParties;\n\n    uint256 internal startLockupAt;\n    LockupStage[] internal lockupStages;\n\n    address[] internal participants;\n    mapping(address => bool) internal isParticipant;\n    mapping(address => address) internal tokenByParticipant;\n    mapping(address => SwapOffer) internal offerByToken;\n\n    // EVENTS\n    event AddLockupStage(uint256 secondsSinceLockupStart, uint8 unlockedTokensPercentage);\n    event StatusUpdate(Status oldStatus, Status newStatus);\n    event AddParty(address participant, ERC20 token, uint256 amount);\n    event RemoveParty(address participant);\n    event ConfirmParties();\n    event CancelSwap();\n    event ConfirmSwap();\n    event StartLockup(uint256 startLockupAt);\n    event Withdraw(address participant, ERC20 token, uint256 amount);\n    event WithdrawFee(ERC20 token, uint256 amount);\n    event Reclaim(address participant, ERC20 token, uint256 amount);\n\n    // MODIFIERS\n    modifier onlyParticipant {\n        require(\n            isParticipant[msg.sender] == true,\n            \"Only swap participants allowed to call the method\"\n        );\n        _;\n    }\n\n    modifier canAddParty {\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\n        _;\n    }\n\n    modifier canRemoveParty {\n        require(status == Status.AddParties, \"Unable to remove parties in the current status\");\n        _;\n    }\n\n    modifier canConfirmParties {\n        require(\n            status == Status.AddParties,\n            \"Unable to confirm parties in the current status\"\n        );\n        require(participants.length > 1, \"Need at least two participants\");\n        _;\n    }\n\n    modifier canCancelSwap {\n        require(\n            status == Status.WaitingDeposits,\n            \"Unable to cancel swap in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmSwap {\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\n        require(\n            _haveEveryoneDeposited(),\n            \"Unable to confirm swap before all parties have deposited tokens\"\n        );\n        _;\n    }\n\n    modifier canWithdraw {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canWithdrawFee {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw fee in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canReclaim {\n        require(\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n            \"Unable to reclaim in the current status\"\n        );\n        _;\n    }\n\n    // CONSTRUCTOR\n    constructor() public {\n        _initializeLockupStages();\n        _validateLockupStages();\n    }\n\n    // EXTERNAL METHODS\n    /**\n     * @dev Add new party to the swap.\n     * @param _participant Address of the participant.\n     * @param _token An ERC20-compliant token which participant is offering to swap.\n     * @param _tokensForSwap How much tokens the participant wants to swap.\n     * @param _tokensFee How much tokens will be payed as a fee.\n     * @param _tokensTotal How much tokens the participant is offering (i.e. _tokensForSwap + _tokensFee).\n     */\n    function addParty(\n        address _participant,\n        ERC20 _token,\n        uint256 _tokensForSwap,\n        uint256 _tokensFee,\n        uint256 _tokensTotal\n    )\n        external\n        onlyOwner\n        canAddParty\n    {\n        require(_participant != address(0), \"_participant is invalid address\");\n        require(_token != address(0), \"_token is invalid address\");\n        require(_tokensForSwap > 0, \"_tokensForSwap must be positive\");\n        require(_tokensFee > 0, \"_tokensFee must be positive\");\n        require(_tokensTotal == _tokensForSwap.add(_tokensFee), \"token amounts inconsistency\");\n        require(\n            isParticipant[_participant] == false,\n            \"Unable to add the same party multiple times\"\n        );\n\n        isParticipant[_participant] = true;\n        SwapOffer memory offer = SwapOffer({\n            participant: _participant,\n            token: _token,\n            tokensForSwap: _tokensForSwap,\n            withdrawnTokensForSwap: 0,\n            tokensFee: _tokensFee,\n            withdrawnFee: 0,\n            tokensTotal: _tokensTotal,\n            withdrawnTokensTotal: 0\n        });\n        participants.push(offer.participant);\n        offerByToken[offer.token] = offer;\n        tokenByParticipant[offer.participant] = offer.token;\n\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n    }\n\n    /**\n     * @dev Remove party.\n     * @param _participantIndex Index of the participant in the participants array.\n     */\n    function removeParty(uint256 _participantIndex) external onlyOwner canRemoveParty {\n        require(_participantIndex < participants.length, \"Participant does not exist\");\n\n        address participant = participants[_participantIndex];\n        address token = tokenByParticipant[participant];\n\n        delete isParticipant[participant];\n        participants[_participantIndex] = participants[participants.length - 1];\n        participants.length--;\n        delete offerByToken[token];\n        delete tokenByParticipant[participant];\n\n        emit RemoveParty(participant);\n    }\n\n    /**\n     * @dev Confirm swap parties\n     */\n    function confirmParties() external onlyOwner canConfirmParties {\n        address[] memory newOwners = new address[](participants.length + 1);\n\n        for (uint256 i = 0; i < participants.length; i++) {\n            newOwners[i] = participants[i];\n        }\n\n        newOwners[newOwners.length - 1] = owner;\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n        _changeStatus(Status.WaitingDeposits);\n        emit ConfirmParties();\n    }\n\n    /**\n     * @dev Confirm swap.\n     */\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\n        emit ConfirmSwap();\n        _changeStatus(Status.SwapConfirmed);\n        _startLockup();\n    }\n\n    /**\n     * @dev Cancel swap.\n     */\n    function cancelSwap() external canCancelSwap onlyManyOwners {\n        emit CancelSwap();\n        _changeStatus(Status.SwapCanceled);\n    }\n\n    /**\n     * @dev Withdraw tokens\n     */\n    function withdraw() external onlyParticipant canWithdraw {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            if (offer.participant == msg.sender) {\n                continue;\n            }\n\n            uint256 tokenReceivers = participants.length - 1;\n            uint256 tokensAmount = _withdrawableAmount(offer).div(tokenReceivers);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit Withdraw(msg.sender, offer.token, tokensAmount);\n            offer.withdrawnTokensForSwap = offer.withdrawnTokensForSwap.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Withdraw swap fee\n     */\n    function withdrawFee() external onlyOwner canWithdrawFee {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            uint256 tokensAmount = _withdrawableFee(offer);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit WithdrawFee(offer.token, tokensAmount);\n            offer.withdrawnFee = offer.withdrawnFee.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n     */\n    function reclaim() external onlyParticipant canReclaim {\n        address token = tokenByParticipant[msg.sender];\n\n        SwapOffer storage offer = offerByToken[token];\n        uint256 currentBalance = offer.token.balanceOf(address(this));\n        uint256 availableForReclaim = currentBalance\n            .sub(offer.tokensTotal.sub(offer.withdrawnTokensTotal));\n\n        if (status == Status.SwapCanceled) {\n            availableForReclaim = currentBalance;\n        }\n\n        if (availableForReclaim > 0) {\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\n        }\n\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n    }\n\n    // PUBLIC METHODS\n    /**\n     * @dev Standard ERC223 function that will handle incoming token transfers.\n     *\n     * @param _from  Token sender address.\n     * @param _value Amount of tokens.\n     * @param _data  Transaction metadata.\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n\n    }\n\n    // INTERNAL METHODS\n    /**\n     * @dev Initialize lockup period stages.\n     */\n    function _initializeLockupStages() internal {\n        _addLockupStage(LockupStage(0, 10));\n        _addLockupStage(LockupStage(60 days, 25));\n        _addLockupStage(LockupStage(120 days, 40));\n        _addLockupStage(LockupStage(180 days, 55));\n        _addLockupStage(LockupStage(240 days, 70));\n        _addLockupStage(LockupStage(300 days, 85));\n        _addLockupStage(LockupStage(360 days, 100));\n    }\n\n    /**\n     * @dev Add lockup period stage\n     */\n    function _addLockupStage(LockupStage _stage) internal {\n        emit AddLockupStage(_stage.secondsSinceLockupStart, _stage.unlockedTokensPercentage);\n        lockupStages.push(_stage);\n    }\n\n    /**\n     * @dev Validate lock-up period configuration.\n     */\n    function _validateLockupStages() internal view {\n        for (uint i = 0; i < lockupStages.length; i++) {\n            LockupStage memory stage = lockupStages[i];\n\n            require(\n                stage.unlockedTokensPercentage >= 0,\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\n            );\n            require(\n                stage.unlockedTokensPercentage <= 100,\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\n            );\n\n            if (i == 0) {\n                continue;\n            }\n\n            LockupStage memory previousStage = lockupStages[i - 1];\n            require(\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\n            );\n            require(\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\n            );\n        }\n\n        require(\n            lockupStages[0].secondsSinceLockupStart == 0,\n            \"The first lockup stage must start immediately\"\n        );\n        require(\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n            \"The last lockup stage must unlock 100% of tokens\"\n        );\n    }\n\n    /**\n     * @dev Change swap status.\n     */\n    function _changeStatus(Status _newStatus) internal {\n        emit StatusUpdate(status, _newStatus);\n        status = _newStatus;\n    }\n\n    /**\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n     */\n    function _haveEveryoneDeposited() internal view returns(bool) {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer memory offer = offerByToken[token];\n\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Start lockup period\n     */\n    function _startLockup() internal {\n        startLockupAt = now;\n        emit StartLockup(startLockupAt);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn by a swap party.\n     */\n    function _withdrawableAmount(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensForSwap).sub(_offer.withdrawnTokensForSwap);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn as the swap fee.\n     */\n    function _withdrawableFee(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensFee).sub(_offer.withdrawnFee);\n    }\n\n    /**\n     * @dev Find amount of unlocked tokens, including withdrawn tokens.\n     */\n    function _unlockedAmount(uint256 totalAmount) internal view returns(uint256) {\n        return totalAmount.mul(_getUnlockedTokensPercentage()).div(100);\n    }\n\n    /**\n     * @dev Get percent of unlocked tokens\n     */\n    function _getUnlockedTokensPercentage() internal view returns(uint256) {\n        for (uint256 i = lockupStages.length; i > 0; i--) {\n            LockupStage storage stage = lockupStages[i - 1];\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n\n            if (now < stageBecomesActiveAt) {\n                continue;\n            }\n\n            return stage.unlockedTokensPercentage;\n        }\n    }\n}",
        "debug": "storage_11: 0x0\nstorage_14: 0x8043c03aae3e40c57bdde0f83ccc42006203c9900003c11cf9038011c0cf1c03\ncalldata_TokenSwap_4: 0x8043c03aae3e40c57bdde0f83ccc42006203c9900003c11cf9038011c0cf1c02\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x1c99d34100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeParty(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "removeParty(uint256)",
        "lineno": 466,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 18989,
        "code": "okensTotal;\n        uint256 withdrawnTokensTotal;\n    }\n\n    struct LockupStage {\n        uint256 secondsSinceLockupStart;\n        uint8 unlockedTokensPercentage;\n    }\n\n    // VARIABLES\n    Status public status = Status.AddParties;\n\n    uint256 internal startLockupAt;\n    LockupStage[] internal lockupStages;\n\n    address[] internal participants;\n    mapping(address => bool) internal isParticipant;\n    mapping(address => address) internal tokenByParticipant;\n    mapping(address => SwapOffer) internal offerByToken;\n\n    // EVENTS\n    event AddLockupStage(uint256 secondsSinceLockupStart, uint8 unlockedTokensPercentage);\n    event StatusUpdate(Status oldStatus, Status newStatus);\n    event AddParty(address participant, ERC20 token, uint256 amount);\n    event RemoveParty(address participant);\n    event ConfirmParties();\n    event CancelSwap();\n    event ConfirmSwap();\n    event StartLockup(uint256 startLockupAt);\n    event Withdraw(address participant, ERC20 token, uint256 amount);\n    event WithdrawFee(ERC20 token, uint256 amount);\n    event Reclaim(address participant, ERC20 token, uint256 amount);\n\n    // MODIFIERS\n    modifier onlyParticipant {\n        require(\n            isParticipant[msg.sender] == true,\n            \"Only swap participants allowed to call the method\"\n        );\n        _;\n    }\n\n    modifier canAddParty {\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\n        _;\n    }\n\n    modifier canRemoveParty {\n        require(status == Status.AddParties, \"Unable to remove parties in the current status\");\n        _;\n    }\n\n    modifier canConfirmParties {\n        require(\n            status == Status.AddParties,\n            \"Unable to confirm parties in the current status\"\n        );\n        require(participants.length > 1, \"Need at least two participants\");\n        _;\n    }\n\n    modifier canCancelSwap {\n        require(\n            status == Status.WaitingDeposits,\n            \"Unable to cancel swap in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmSwap {\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\n        require(\n            _haveEveryoneDeposited(),\n            \"Unable to confirm swap before all parties have deposited tokens\"\n        );\n        _;\n    }\n\n    modifier canWithdraw {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canWithdrawFee {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw fee in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canReclaim {\n        require(\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n            \"Unable to reclaim in the current status\"\n        );\n        _;\n    }\n\n    // CONSTRUCTOR\n    constructor() public {\n        _initializeLockupStages();\n        _validateLockupStages();\n    }\n\n    // EXTERNAL METHODS\n    /**\n     * @dev Add new party to the swap.\n     * @param _participant Address of the participant.\n     * @param _token An ERC20-compliant token which participant is offering to swap.\n     * @param _tokensForSwap How much tokens the participant wants to swap.\n     * @param _tokensFee How much tokens will be payed as a fee.\n     * @param _tokensTotal How much tokens the participant is offering (i.e. _tokensForSwap + _tokensFee).\n     */\n    function addParty(\n        address _participant,\n        ERC20 _token,\n        uint256 _tokensForSwap,\n        uint256 _tokensFee,\n        uint256 _tokensTotal\n    )\n        external\n        onlyOwner\n        canAddParty\n    {\n        require(_participant != address(0), \"_participant is invalid address\");\n        require(_token != address(0), \"_token is invalid address\");\n        require(_tokensForSwap > 0, \"_tokensForSwap must be positive\");\n        require(_tokensFee > 0, \"_tokensFee must be positive\");\n        require(_tokensTotal == _tokensForSwap.add(_tokensFee), \"token amounts inconsistency\");\n        require(\n            isParticipant[_participant] == false,\n            \"Unable to add the same party multiple times\"\n        );\n\n        isParticipant[_participant] = true;\n        SwapOffer memory offer = SwapOffer({\n            participant: _participant,\n            token: _token,\n            tokensForSwap: _tokensForSwap,\n            withdrawnTokensForSwap: 0,\n            tokensFee: _tokensFee,\n            withdrawnFee: 0,\n            tokensTotal: _tokensTotal,\n            withdrawnTokensTotal: 0\n        });\n        participants.push(offer.participant);\n        offerByToken[offer.token] = offer;\n        tokenByParticipant[offer.participant] = offer.token;\n\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n    }\n\n    /**\n     * @dev Remove party.\n     * @param _participantIndex Index of the participant in the participants array.\n     */\n    function removeParty(uint256 _participantIndex) external onlyOwner canRemoveParty {\n        require(_participantIndex < participants.length, \"Participant does not exist\");\n\n        address participant = participants[_participantIndex];\n        address token = tokenByParticipant[participant];\n\n        delete isParticipant[participant];\n        participants[_participantIndex] = participants[participants.length - 1];\n        participants.length--;\n        delete offerByToken[token];\n        delete tokenByParticipant[participant];\n\n        emit RemoveParty(participant);\n    }\n\n    /**\n     * @dev Confirm swap parties\n     */\n    function confirmParties() external onlyOwner canConfirmParties {\n        address[] memory newOwners = new address[](participants.length + 1);\n\n        for (uint256 i = 0; i < participants.length; i++) {\n            newOwners[i] = participants[i];\n        }\n\n        newOwners[newOwners.length - 1] = owner;\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n        _changeStatus(Status.WaitingDeposits);\n        emit ConfirmParties();\n    }\n\n    /**\n     * @dev Confirm swap.\n     */\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\n        emit ConfirmSwap();\n        _changeStatus(Status.SwapConfirmed);\n        _startLockup();\n    }\n\n    /**\n     * @dev Cancel swap.\n     */\n    function cancelSwap() external canCancelSwap onlyManyOwners {\n        emit CancelSwap();\n        _changeStatus(Status.SwapCanceled);\n    }\n\n    /**\n     * @dev Withdraw tokens\n     */\n    function withdraw() external onlyParticipant canWithdraw {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            if (offer.participant == msg.sender) {\n                continue;\n            }\n\n            uint256 tokenReceivers = participants.length - 1;\n            uint256 tokensAmount = _withdrawableAmount(offer).div(tokenReceivers);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit Withdraw(msg.sender, offer.token, tokensAmount);\n            offer.withdrawnTokensForSwap = offer.withdrawnTokensForSwap.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Withdraw swap fee\n     */\n    function withdrawFee() external onlyOwner canWithdrawFee {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            uint256 tokensAmount = _withdrawableFee(offer);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit WithdrawFee(offer.token, tokensAmount);\n            offer.withdrawnFee = offer.withdrawnFee.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n     */\n    function reclaim() external onlyParticipant canReclaim {\n        address token = tokenByParticipant[msg.sender];\n\n        SwapOffer storage offer = offerByToken[token];\n        uint256 currentBalance = offer.token.balanceOf(address(this));\n        uint256 availableForReclaim = currentBalance\n            .sub(offer.tokensTotal.sub(offer.withdrawnTokensTotal));\n\n        if (status == Status.SwapCanceled) {\n            availableForReclaim = currentBalance;\n        }\n\n        if (availableForReclaim > 0) {\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\n        }\n\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n    }\n\n    // PUBLIC METHODS\n    /**\n     * @dev Standard ERC223 function that will handle incoming token transfers.\n     *\n     * @param _from  Token sender address.\n     * @param _value Amount of tokens.\n     * @param _data  Transaction metadata.\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n\n    }\n\n    // INTERNAL METHODS\n    /**\n     * @dev Initialize lockup period stages.\n     */\n    function _initializeLockupStages() internal {\n        _addLockupStage(LockupStage(0, 10));\n        _addLockupStage(LockupStage(60 days, 25));\n        _addLockupStage(LockupStage(120 days, 40));\n        _addLockupStage(LockupStage(180 days, 55));\n        _addLockupStage(LockupStage(240 days, 70));\n        _addLockupStage(LockupStage(300 days, 85));\n        _addLockupStage(LockupStage(360 days, 100));\n    }\n\n    /**\n     * @dev Add lockup period stage\n     */\n    function _addLockupStage(LockupStage _stage) internal {\n        emit AddLockupStage(_stage.secondsSinceLockupStart, _stage.unlockedTokensPercentage);\n        lockupStages.push(_stage);\n    }\n\n    /**\n     * @dev Validate lock-up period configuration.\n     */\n    function _validateLockupStages() internal view {\n        for (uint i = 0; i < lockupStages.length; i++) {\n            LockupStage memory stage = lockupStages[i];\n\n            require(\n                stage.unlockedTokensPercentage >= 0,\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\n            );\n            require(\n                stage.unlockedTokensPercentage <= 100,\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\n            );\n\n            if (i == 0) {\n                continue;\n            }\n\n            LockupStage memory previousStage = lockupStages[i - 1];\n            require(\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\n            );\n            require(\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\n            );\n        }\n\n        require(\n            lockupStages[0].secondsSinceLockupStart == 0,\n            \"The first lockup stage must start immediately\"\n        );\n        require(\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n            \"The last lockup stage must unlock 100% of tokens\"\n        );\n    }\n\n    /**\n     * @dev Change swap status.\n     */\n    function _changeStatus(Status _newStatus) internal {\n        emit StatusUpdate(status, _newStatus);\n        status = _newStatus;\n    }\n\n    /**\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n     */\n    function _haveEveryoneDeposited() internal view returns(bool) {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer memory offer = offerByToken[token];\n\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Start lockup period\n     */\n    function _startLockup() internal {\n        startLockupAt = now;\n        emit StartLockup(startLockupAt);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn by a swap party.\n     */\n    function _withdrawableAmount(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensForSwap).sub(_offer.withdrawnTokensForSwap);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn as the swap fee.\n     */\n    function _withdrawableFee(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensFee).sub(_offer.withdrawnFee);\n    }\n\n    /**\n     * @dev Find amount of unlocked tokens, including withdrawn tokens.\n     */\n    function _unlockedAmount(uint256 totalAmount) internal view returns(uint256) {\n        return totalAmount.mul(_getUnlockedTokensPercentage()).div(100);\n    }\n\n    /**\n     * @dev Get percent of unlocked tokens\n     */\n    function _getUnlockedTokensPercentage() internal view returns(uint256) {\n        for (uint256 i = lockupStages.length; i > 0; i--) {\n            LockupStage storage stage = lockupStages[i - 1];\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n\n            if (now < stageBecomesActiveAt) {\n                continue;\n            }\n\n            return stage.unlockedTokensPercentage;\n        }\n    }\n}",
        "debug": "storage_11: 0x0\nstorage_14: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TokenSwap_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenSwap_0: 0x1c99d34100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeParty(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "removeParty(uint256)",
        "lineno": 466,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 19283,
        "code": "okensTotal;\n        uint256 withdrawnTokensTotal;\n    }\n\n    struct LockupStage {\n        uint256 secondsSinceLockupStart;\n        uint8 unlockedTokensPercentage;\n    }\n\n    // VARIABLES\n    Status public status = Status.AddParties;\n\n    uint256 internal startLockupAt;\n    LockupStage[] internal lockupStages;\n\n    address[] internal participants;\n    mapping(address => bool) internal isParticipant;\n    mapping(address => address) internal tokenByParticipant;\n    mapping(address => SwapOffer) internal offerByToken;\n\n    // EVENTS\n    event AddLockupStage(uint256 secondsSinceLockupStart, uint8 unlockedTokensPercentage);\n    event StatusUpdate(Status oldStatus, Status newStatus);\n    event AddParty(address participant, ERC20 token, uint256 amount);\n    event RemoveParty(address participant);\n    event ConfirmParties();\n    event CancelSwap();\n    event ConfirmSwap();\n    event StartLockup(uint256 startLockupAt);\n    event Withdraw(address participant, ERC20 token, uint256 amount);\n    event WithdrawFee(ERC20 token, uint256 amount);\n    event Reclaim(address participant, ERC20 token, uint256 amount);\n\n    // MODIFIERS\n    modifier onlyParticipant {\n        require(\n            isParticipant[msg.sender] == true,\n            \"Only swap participants allowed to call the method\"\n        );\n        _;\n    }\n\n    modifier canAddParty {\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\n        _;\n    }\n\n    modifier canRemoveParty {\n        require(status == Status.AddParties, \"Unable to remove parties in the current status\");\n        _;\n    }\n\n    modifier canConfirmParties {\n        require(\n            status == Status.AddParties,\n            \"Unable to confirm parties in the current status\"\n        );\n        require(participants.length > 1, \"Need at least two participants\");\n        _;\n    }\n\n    modifier canCancelSwap {\n        require(\n            status == Status.WaitingDeposits,\n            \"Unable to cancel swap in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmSwap {\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\n        require(\n            _haveEveryoneDeposited(),\n            \"Unable to confirm swap before all parties have deposited tokens\"\n        );\n        _;\n    }\n\n    modifier canWithdraw {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canWithdrawFee {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw fee in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canReclaim {\n        require(\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n            \"Unable to reclaim in the current status\"\n        );\n        _;\n    }\n\n    // CONSTRUCTOR\n    constructor() public {\n        _initializeLockupStages();\n        _validateLockupStages();\n    }\n\n    // EXTERNAL METHODS\n    /**\n     * @dev Add new party to the swap.\n     * @param _participant Address of the participant.\n     * @param _token An ERC20-compliant token which participant is offering to swap.\n     * @param _tokensForSwap How much tokens the participant wants to swap.\n     * @param _tokensFee How much tokens will be payed as a fee.\n     * @param _tokensTotal How much tokens the participant is offering (i.e. _tokensForSwap + _tokensFee).\n     */\n    function addParty(\n        address _participant,\n        ERC20 _token,\n        uint256 _tokensForSwap,\n        uint256 _tokensFee,\n        uint256 _tokensTotal\n    )\n        external\n        onlyOwner\n        canAddParty\n    {\n        require(_participant != address(0), \"_participant is invalid address\");\n        require(_token != address(0), \"_token is invalid address\");\n        require(_tokensForSwap > 0, \"_tokensForSwap must be positive\");\n        require(_tokensFee > 0, \"_tokensFee must be positive\");\n        require(_tokensTotal == _tokensForSwap.add(_tokensFee), \"token amounts inconsistency\");\n        require(\n            isParticipant[_participant] == false,\n            \"Unable to add the same party multiple times\"\n        );\n\n        isParticipant[_participant] = true;\n        SwapOffer memory offer = SwapOffer({\n            participant: _participant,\n            token: _token,\n            tokensForSwap: _tokensForSwap,\n            withdrawnTokensForSwap: 0,\n            tokensFee: _tokensFee,\n            withdrawnFee: 0,\n            tokensTotal: _tokensTotal,\n            withdrawnTokensTotal: 0\n        });\n        participants.push(offer.participant);\n        offerByToken[offer.token] = offer;\n        tokenByParticipant[offer.participant] = offer.token;\n\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n    }\n\n    /**\n     * @dev Remove party.\n     * @param _participantIndex Index of the participant in the participants array.\n     */\n    function removeParty(uint256 _participantIndex) external onlyOwner canRemoveParty {\n        require(_participantIndex < participants.length, \"Participant does not exist\");\n\n        address participant = participants[_participantIndex];\n        address token = tokenByParticipant[participant];\n\n        delete isParticipant[participant];\n        participants[_participantIndex] = participants[participants.length - 1];\n        participants.length--;\n        delete offerByToken[token];\n        delete tokenByParticipant[participant];\n\n        emit RemoveParty(participant);\n    }\n\n    /**\n     * @dev Confirm swap parties\n     */\n    function confirmParties() external onlyOwner canConfirmParties {\n        address[] memory newOwners = new address[](participants.length + 1);\n\n        for (uint256 i = 0; i < participants.length; i++) {\n            newOwners[i] = participants[i];\n        }\n\n        newOwners[newOwners.length - 1] = owner;\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n        _changeStatus(Status.WaitingDeposits);\n        emit ConfirmParties();\n    }\n\n    /**\n     * @dev Confirm swap.\n     */\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\n        emit ConfirmSwap();\n        _changeStatus(Status.SwapConfirmed);\n        _startLockup();\n    }\n\n    /**\n     * @dev Cancel swap.\n     */\n    function cancelSwap() external canCancelSwap onlyManyOwners {\n        emit CancelSwap();\n        _changeStatus(Status.SwapCanceled);\n    }\n\n    /**\n     * @dev Withdraw tokens\n     */\n    function withdraw() external onlyParticipant canWithdraw {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            if (offer.participant == msg.sender) {\n                continue;\n            }\n\n            uint256 tokenReceivers = participants.length - 1;\n            uint256 tokensAmount = _withdrawableAmount(offer).div(tokenReceivers);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit Withdraw(msg.sender, offer.token, tokensAmount);\n            offer.withdrawnTokensForSwap = offer.withdrawnTokensForSwap.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Withdraw swap fee\n     */\n    function withdrawFee() external onlyOwner canWithdrawFee {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            uint256 tokensAmount = _withdrawableFee(offer);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit WithdrawFee(offer.token, tokensAmount);\n            offer.withdrawnFee = offer.withdrawnFee.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n     */\n    function reclaim() external onlyParticipant canReclaim {\n        address token = tokenByParticipant[msg.sender];\n\n        SwapOffer storage offer = offerByToken[token];\n        uint256 currentBalance = offer.token.balanceOf(address(this));\n        uint256 availableForReclaim = currentBalance\n            .sub(offer.tokensTotal.sub(offer.withdrawnTokensTotal));\n\n        if (status == Status.SwapCanceled) {\n            availableForReclaim = currentBalance;\n        }\n\n        if (availableForReclaim > 0) {\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\n        }\n\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n    }\n\n    // PUBLIC METHODS\n    /**\n     * @dev Standard ERC223 function that will handle incoming token transfers.\n     *\n     * @param _from  Token sender address.\n     * @param _value Amount of tokens.\n     * @param _data  Transaction metadata.\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n\n    }\n\n    // INTERNAL METHODS\n    /**\n     * @dev Initialize lockup period stages.\n     */\n    function _initializeLockupStages() internal {\n        _addLockupStage(LockupStage(0, 10));\n        _addLockupStage(LockupStage(60 days, 25));\n        _addLockupStage(LockupStage(120 days, 40));\n        _addLockupStage(LockupStage(180 days, 55));\n        _addLockupStage(LockupStage(240 days, 70));\n        _addLockupStage(LockupStage(300 days, 85));\n        _addLockupStage(LockupStage(360 days, 100));\n    }\n\n    /**\n     * @dev Add lockup period stage\n     */\n    function _addLockupStage(LockupStage _stage) internal {\n        emit AddLockupStage(_stage.secondsSinceLockupStart, _stage.unlockedTokensPercentage);\n        lockupStages.push(_stage);\n    }\n\n    /**\n     * @dev Validate lock-up period configuration.\n     */\n    function _validateLockupStages() internal view {\n        for (uint i = 0; i < lockupStages.length; i++) {\n            LockupStage memory stage = lockupStages[i];\n\n            require(\n                stage.unlockedTokensPercentage >= 0,\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\n            );\n            require(\n                stage.unlockedTokensPercentage <= 100,\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\n            );\n\n            if (i == 0) {\n                continue;\n            }\n\n            LockupStage memory previousStage = lockupStages[i - 1];\n            require(\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\n            );\n            require(\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\n            );\n        }\n\n        require(\n            lockupStages[0].secondsSinceLockupStart == 0,\n            \"The first lockup stage must start immediately\"\n        );\n        require(\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n            \"The last lockup stage must unlock 100% of tokens\"\n        );\n    }\n\n    /**\n     * @dev Change swap status.\n     */\n    function _changeStatus(Status _newStatus) internal {\n        emit StatusUpdate(status, _newStatus);\n        status = _newStatus;\n    }\n\n    /**\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n     */\n    function _haveEveryoneDeposited() internal view returns(bool) {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer memory offer = offerByToken[token];\n\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Start lockup period\n     */\n    function _startLockup() internal {\n        startLockupAt = now;\n        emit StartLockup(startLockupAt);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn by a swap party.\n     */\n    function _withdrawableAmount(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensForSwap).sub(_offer.withdrawnTokensForSwap);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn as the swap fee.\n     */\n    function _withdrawableFee(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensFee).sub(_offer.withdrawnFee);\n    }\n\n    /**\n     * @dev Find amount of unlocked tokens, including withdrawn tokens.\n     */\n    function _unlockedAmount(uint256 totalAmount) internal view returns(uint256) {\n        return totalAmount.mul(_getUnlockedTokensPercentage()).div(100);\n    }\n\n    /**\n     * @dev Get percent of unlocked tokens\n     */\n    function _getUnlockedTokensPercentage() internal view returns(uint256) {\n        for (uint256 i = lockupStages.length; i > 0; i--) {\n            LockupStage storage stage = lockupStages[i - 1];\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n\n            if (now < stageBecomesActiveAt) {\n                continue;\n            }\n\n            return stage.unlockedTokensPercentage;\n        }\n    }\n}",
        "debug": "storage_4: 0x75ca53043ea007e5c65182cbb1ffffffffffffffffffffffffffffffffffffff\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_2: 0x75ca53043ea007e5c65182cbb1ffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 466,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 19285,
        "code": "okensTotal;\n        uint256 withdrawnTokensTotal;\n    }\n\n    struct LockupStage {\n        uint256 secondsSinceLockupStart;\n        uint8 unlockedTokensPercentage;\n    }\n\n    // VARIABLES\n    Status public status = Status.AddParties;\n\n    uint256 internal startLockupAt;\n    LockupStage[] internal lockupStages;\n\n    address[] internal participants;\n    mapping(address => bool) internal isParticipant;\n    mapping(address => address) internal tokenByParticipant;\n    mapping(address => SwapOffer) internal offerByToken;\n\n    // EVENTS\n    event AddLockupStage(uint256 secondsSinceLockupStart, uint8 unlockedTokensPercentage);\n    event StatusUpdate(Status oldStatus, Status newStatus);\n    event AddParty(address participant, ERC20 token, uint256 amount);\n    event RemoveParty(address participant);\n    event ConfirmParties();\n    event CancelSwap();\n    event ConfirmSwap();\n    event StartLockup(uint256 startLockupAt);\n    event Withdraw(address participant, ERC20 token, uint256 amount);\n    event WithdrawFee(ERC20 token, uint256 amount);\n    event Reclaim(address participant, ERC20 token, uint256 amount);\n\n    // MODIFIERS\n    modifier onlyParticipant {\n        require(\n            isParticipant[msg.sender] == true,\n            \"Only swap participants allowed to call the method\"\n        );\n        _;\n    }\n\n    modifier canAddParty {\n        require(status == Status.AddParties, \"Unable to add new parties in the current status\");\n        _;\n    }\n\n    modifier canRemoveParty {\n        require(status == Status.AddParties, \"Unable to remove parties in the current status\");\n        _;\n    }\n\n    modifier canConfirmParties {\n        require(\n            status == Status.AddParties,\n            \"Unable to confirm parties in the current status\"\n        );\n        require(participants.length > 1, \"Need at least two participants\");\n        _;\n    }\n\n    modifier canCancelSwap {\n        require(\n            status == Status.WaitingDeposits,\n            \"Unable to cancel swap in the current status\"\n        );\n        _;\n    }\n\n    modifier canConfirmSwap {\n        require(status == Status.WaitingDeposits, \"Unable to confirm in the current status\");\n        require(\n            _haveEveryoneDeposited(),\n            \"Unable to confirm swap before all parties have deposited tokens\"\n        );\n        _;\n    }\n\n    modifier canWithdraw {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw tokens in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canWithdrawFee {\n        require(status == Status.SwapConfirmed, \"Unable to withdraw fee in the current status\");\n        require(startLockupAt != 0, \"Lockup has not been started\");\n        _;\n    }\n\n    modifier canReclaim {\n        require(\n            status == Status.SwapConfirmed || status == Status.SwapCanceled,\n            \"Unable to reclaim in the current status\"\n        );\n        _;\n    }\n\n    // CONSTRUCTOR\n    constructor() public {\n        _initializeLockupStages();\n        _validateLockupStages();\n    }\n\n    // EXTERNAL METHODS\n    /**\n     * @dev Add new party to the swap.\n     * @param _participant Address of the participant.\n     * @param _token An ERC20-compliant token which participant is offering to swap.\n     * @param _tokensForSwap How much tokens the participant wants to swap.\n     * @param _tokensFee How much tokens will be payed as a fee.\n     * @param _tokensTotal How much tokens the participant is offering (i.e. _tokensForSwap + _tokensFee).\n     */\n    function addParty(\n        address _participant,\n        ERC20 _token,\n        uint256 _tokensForSwap,\n        uint256 _tokensFee,\n        uint256 _tokensTotal\n    )\n        external\n        onlyOwner\n        canAddParty\n    {\n        require(_participant != address(0), \"_participant is invalid address\");\n        require(_token != address(0), \"_token is invalid address\");\n        require(_tokensForSwap > 0, \"_tokensForSwap must be positive\");\n        require(_tokensFee > 0, \"_tokensFee must be positive\");\n        require(_tokensTotal == _tokensForSwap.add(_tokensFee), \"token amounts inconsistency\");\n        require(\n            isParticipant[_participant] == false,\n            \"Unable to add the same party multiple times\"\n        );\n\n        isParticipant[_participant] = true;\n        SwapOffer memory offer = SwapOffer({\n            participant: _participant,\n            token: _token,\n            tokensForSwap: _tokensForSwap,\n            withdrawnTokensForSwap: 0,\n            tokensFee: _tokensFee,\n            withdrawnFee: 0,\n            tokensTotal: _tokensTotal,\n            withdrawnTokensTotal: 0\n        });\n        participants.push(offer.participant);\n        offerByToken[offer.token] = offer;\n        tokenByParticipant[offer.participant] = offer.token;\n\n        emit AddParty(offer.participant, offer.token, offer.tokensTotal);\n    }\n\n    /**\n     * @dev Remove party.\n     * @param _participantIndex Index of the participant in the participants array.\n     */\n    function removeParty(uint256 _participantIndex) external onlyOwner canRemoveParty {\n        require(_participantIndex < participants.length, \"Participant does not exist\");\n\n        address participant = participants[_participantIndex];\n        address token = tokenByParticipant[participant];\n\n        delete isParticipant[participant];\n        participants[_participantIndex] = participants[participants.length - 1];\n        participants.length--;\n        delete offerByToken[token];\n        delete tokenByParticipant[participant];\n\n        emit RemoveParty(participant);\n    }\n\n    /**\n     * @dev Confirm swap parties\n     */\n    function confirmParties() external onlyOwner canConfirmParties {\n        address[] memory newOwners = new address[](participants.length + 1);\n\n        for (uint256 i = 0; i < participants.length; i++) {\n            newOwners[i] = participants[i];\n        }\n\n        newOwners[newOwners.length - 1] = owner;\n        transferOwnershipWithHowMany(newOwners, newOwners.length - 1);\n        _changeStatus(Status.WaitingDeposits);\n        emit ConfirmParties();\n    }\n\n    /**\n     * @dev Confirm swap.\n     */\n    function confirmSwap() external canConfirmSwap onlyManyOwners {\n        emit ConfirmSwap();\n        _changeStatus(Status.SwapConfirmed);\n        _startLockup();\n    }\n\n    /**\n     * @dev Cancel swap.\n     */\n    function cancelSwap() external canCancelSwap onlyManyOwners {\n        emit CancelSwap();\n        _changeStatus(Status.SwapCanceled);\n    }\n\n    /**\n     * @dev Withdraw tokens\n     */\n    function withdraw() external onlyParticipant canWithdraw {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            if (offer.participant == msg.sender) {\n                continue;\n            }\n\n            uint256 tokenReceivers = participants.length - 1;\n            uint256 tokensAmount = _withdrawableAmount(offer).div(tokenReceivers);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit Withdraw(msg.sender, offer.token, tokensAmount);\n            offer.withdrawnTokensForSwap = offer.withdrawnTokensForSwap.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Withdraw swap fee\n     */\n    function withdrawFee() external onlyOwner canWithdrawFee {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer storage offer = offerByToken[token];\n\n            uint256 tokensAmount = _withdrawableFee(offer);\n\n            offer.token.safeTransfer(msg.sender, tokensAmount);\n            emit WithdrawFee(offer.token, tokensAmount);\n            offer.withdrawnFee = offer.withdrawnFee.add(tokensAmount);\n            offer.withdrawnTokensTotal = offer.withdrawnTokensTotal.add(tokensAmount);\n        }\n    }\n\n    /**\n     * @dev Reclaim tokens if a participant has deposited too much or if the swap has been canceled.\n     */\n    function reclaim() external onlyParticipant canReclaim {\n        address token = tokenByParticipant[msg.sender];\n\n        SwapOffer storage offer = offerByToken[token];\n        uint256 currentBalance = offer.token.balanceOf(address(this));\n        uint256 availableForReclaim = currentBalance\n            .sub(offer.tokensTotal.sub(offer.withdrawnTokensTotal));\n\n        if (status == Status.SwapCanceled) {\n            availableForReclaim = currentBalance;\n        }\n\n        if (availableForReclaim > 0) {\n            offer.token.safeTransfer(offer.participant, availableForReclaim);\n        }\n\n        emit Reclaim(offer.participant, offer.token, availableForReclaim);\n    }\n\n    // PUBLIC METHODS\n    /**\n     * @dev Standard ERC223 function that will handle incoming token transfers.\n     *\n     * @param _from  Token sender address.\n     * @param _value Amount of tokens.\n     * @param _data  Transaction metadata.\n     */\n    function tokenFallback(address _from, uint256 _value, bytes _data) public {\n\n    }\n\n    // INTERNAL METHODS\n    /**\n     * @dev Initialize lockup period stages.\n     */\n    function _initializeLockupStages() internal {\n        _addLockupStage(LockupStage(0, 10));\n        _addLockupStage(LockupStage(60 days, 25));\n        _addLockupStage(LockupStage(120 days, 40));\n        _addLockupStage(LockupStage(180 days, 55));\n        _addLockupStage(LockupStage(240 days, 70));\n        _addLockupStage(LockupStage(300 days, 85));\n        _addLockupStage(LockupStage(360 days, 100));\n    }\n\n    /**\n     * @dev Add lockup period stage\n     */\n    function _addLockupStage(LockupStage _stage) internal {\n        emit AddLockupStage(_stage.secondsSinceLockupStart, _stage.unlockedTokensPercentage);\n        lockupStages.push(_stage);\n    }\n\n    /**\n     * @dev Validate lock-up period configuration.\n     */\n    function _validateLockupStages() internal view {\n        for (uint i = 0; i < lockupStages.length; i++) {\n            LockupStage memory stage = lockupStages[i];\n\n            require(\n                stage.unlockedTokensPercentage >= 0,\n                \"LockupStage.unlockedTokensPercentage must not be negative\"\n            );\n            require(\n                stage.unlockedTokensPercentage <= 100,\n                \"LockupStage.unlockedTokensPercentage must not be greater than 100\"\n            );\n\n            if (i == 0) {\n                continue;\n            }\n\n            LockupStage memory previousStage = lockupStages[i - 1];\n            require(\n                stage.secondsSinceLockupStart > previousStage.secondsSinceLockupStart,\n                \"LockupStage.secondsSinceLockupStart must increase monotonically\"\n            );\n            require(\n                stage.unlockedTokensPercentage > previousStage.unlockedTokensPercentage,\n                \"LockupStage.unlockedTokensPercentage must increase monotonically\"\n            );\n        }\n\n        require(\n            lockupStages[0].secondsSinceLockupStart == 0,\n            \"The first lockup stage must start immediately\"\n        );\n        require(\n            lockupStages[lockupStages.length - 1].unlockedTokensPercentage == 100,\n            \"The last lockup stage must unlock 100% of tokens\"\n        );\n    }\n\n    /**\n     * @dev Change swap status.\n     */\n    function _changeStatus(Status _newStatus) internal {\n        emit StatusUpdate(status, _newStatus);\n        status = _newStatus;\n    }\n\n    /**\n     * @dev Check whether every participant has deposited enough tokens for the swap to be confirmed.\n     */\n    function _haveEveryoneDeposited() internal view returns(bool) {\n        for (uint i = 0; i < participants.length; i++) {\n            address token = tokenByParticipant[participants[i]];\n            SwapOffer memory offer = offerByToken[token];\n\n            if (offer.token.balanceOf(address(this)) < offer.tokensTotal) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Start lockup period\n     */\n    function _startLockup() internal {\n        startLockupAt = now;\n        emit StartLockup(startLockupAt);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn by a swap party.\n     */\n    function _withdrawableAmount(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensForSwap).sub(_offer.withdrawnTokensForSwap);\n    }\n\n    /**\n     * @dev Find amount of tokens ready to be withdrawn as the swap fee.\n     */\n    function _withdrawableFee(SwapOffer _offer) internal view returns(uint256) {\n        return _unlockedAmount(_offer.tokensFee).sub(_offer.withdrawnFee);\n    }\n\n    /**\n     * @dev Find amount of unlocked tokens, including withdrawn tokens.\n     */\n    function _unlockedAmount(uint256 totalAmount) internal view returns(uint256) {\n        return totalAmount.mul(_getUnlockedTokensPercentage()).div(100);\n    }\n\n    /**\n     * @dev Get percent of unlocked tokens\n     */\n    function _getUnlockedTokensPercentage() internal view returns(uint256) {\n        for (uint256 i = lockupStages.length; i > 0; i--) {\n            LockupStage storage stage = lockupStages[i - 1];\n            uint256 stageBecomesActiveAt = startLockupAt.add(stage.secondsSinceLockupStart);\n\n            if (now < stageBecomesActiveAt) {\n                continue;\n            }\n\n            return stage.unlockedTokensPercentage;\n        }\n    }\n}",
        "debug": "storage_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+_32_+_32*calldata_TokenSwap_4_+_calldata_TokenSwap_4): 0x0\n2_EXP_115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_3: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncaller: 0x0\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenSwap_0: 0x18bcd3d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenSwap: 0x4\nstorage_2: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferOwnership(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x14ad8e23a3d9e13f038db50431b9962bd2d93575.sol",
        "function": "transferOwnership(address[])",
        "lineno": 466,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}