{
  "contract": "0x4342cc6763de448927cbae70eb56ec783d2ce00d",
  "tool": "mythril",
  "start": 1563232588.997142,
  "end": 1563233508.2043016,
  "duration": 919.2071595191956,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1350,
        "code": "th > 0) {\n            matches[_id].teamDetail = _teamDetail;\n        }\n        if (_startTime != 0) {\n            matches[_id].startTime = _startTime;\n        }\n        if (_endTime != 0) {\n            matches[_id].endTime = _endTime;\n        }\n\n        // Set event\n        emit MatchInfo(_id, _teamDetail);\n    }\n\n    function announceMatchResult(uint _id, Result _result)\n    onlyManager\n    validId(_id)\n    validResult(_result)\n    public {\n\n        // Check current result\n        require(matches[_id].result == Result.Unknown",
        "debug": "calldata_WorldCup_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_WorldCup_0: 0x7fef2d3800000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateMatchInfo(uint256,string,uint64,uint64)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "updateMatchInfo(uint256,string,uint64,uint64)",
        "lineno": 207,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1594,
        "code": " string team, string detail, int32 spread, uint64 start, uint64 en",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\ncalldata_WorldCup_32_+_4: 0xfc00\ncalldata_WorldCup_0: 0x92b108d000000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "_function_0x92b108d0",
        "lineno": 149,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 1688,
        "code": "tion setManager(address _manager) onlyManager public {\n        manager = _manager;\n      ",
        "debug": "storage_1: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_WorldCup_0: 0xa0e67e2b00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getOwners()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "getOwners()",
        "lineno": 102,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2060,
        "code": "ublic ownerByAddress;\n\n",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WorldCup_4: 0x0\nstorage_1: 0x0\ncalldata_WorldCup_0: 0x25e7c2700000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "_function_0x025e7c27",
        "lineno": 57,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2285,
        "code": " }\n\n    // For Owner & Ma",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WorldCup_32 + 4: 0xfc\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WorldCup_0: 0x238c8a8200000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "_function_0x238c8a82",
        "lineno": 168,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2422,
        "code": "];\n\n        if (_result == Result.Hom",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WorldCup_32 + 4: 0x3\nstorage_7 + keccac_calldata_WorldCup_4: 0xfc00\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WorldCup_0: 0x238c8a8200000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "_function_0x238c8a82",
        "lineno": 236,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3146,
        "code": "t\n        require(_prediction.r",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7 + keccac_calldata_WorldCup_4: 0xfc00\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\ncalldata_WorldCup_0: 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "withdraw(uint256)",
        "lineno": 353,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3283,
        "code": "s, _prediction.stake);\n\n        addr",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7 + keccac_calldata_WorldCup_4: 0x300\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfc00\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\ncalldata_WorldCup_0: 0x2e1a7d4d00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "withdraw(uint256)",
        "lineno": 358,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3801,
        "code": "esult) {\n            return 0;\n",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7 + keccac_calldata_WorldCup_4: 0xfc00\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\ncalldata_WorldCup_0: 0x446dba8f00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "getBonus(uint256,address)",
        "lineno": 328,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3940,
        "code": "eturn bonus;\n    }\n\n    function wit",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7 + keccac_calldata_WorldCup_4: 0x300\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WorldCup_32_+_4: 0xfc00\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\ncalldata_WorldCup_0: 0x446dba8f00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "getBonus(uint256,address)",
        "lineno": 336,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6229,
        "code": "er = _manager",
        "debug": "storage_1: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_WorldCup_0: 0xa0e67e2b00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getOwners()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "getOwners()",
        "lineno": 103,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6231,
        "code": "er = _manager",
        "debug": "storage_1: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_WorldCup_0: 0xa0e67e2b00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getOwners()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "getOwners()",
        "lineno": 103,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6410,
        "code": " }\n\n    // For Owner & Ma",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WorldCup_32 + 4: 0xfc\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\ncalldata_WorldCup_0: 0xc437a0cd00000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "_function_0xc437a0cd",
        "lineno": 168,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 7659,
        "code": "/**\n * @title ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7 + keccac_calldata_WorldCup_4: 0x0\ncalldata_WorldCup_32 + 4: 0x1\nstorage_5 + keccac_calldata_WorldCup_4: 0x1\nstorage_6 + keccac_calldata_WorldCup_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WorldCup_0: 0x238c8a8200000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "_function_0x238c8a82",
        "lineno": 49,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9032,
        "code": "/ Data Struct\n\n    struct Match {\n        bool created;\n\n        // Match Info\n        string team;\n        string teamDetail;\n        int32  pointSpread;\n        uint64 startTime;\n        uint64 endTime;\n\n        // Current Stakes\n        uint256 stakesOfWin;\n        uint256 stakesOfDraw;\n        uint256 stakesOfLoss;\n\n        // Result\n        Result result;\n    }\n\n    struct Prediction {\n        Result result;\n        uint256 stake;\n        bool withdraw;\n    }\n\n    // Storage\n\n    uint public numMatches;\n    mapping(uint => Match) public matches;\n    mapping(uint => mapping(address => Prediction)) public predictions;\n    uint256 public rate;\n\n    // Event\n\n    event NewMatch(uint indexed id, string team, string detail, int32 spread, uint64 start, uint64 end);\n    event MatchInfo(uint indexed id, string detail);\n    event MatchResult(uint indexed id, Result result, uint256 fee);\n    event Bet(address indexed user, uint indexed id, Result result, uint256 stake,\n        uint256 stakesOfWin, uint256 stakesOfDraw, uint256 stakesOfLoss);\n    event Withdraw(address indexed user, uint indexed id, uint256 bonus);\n\n    modifier validId(uint _id) {\n        require(matches[_id].created == true);\n        _;\n    }\n\n    modifier validResult(Result _result) {\n        require(_result == Result.HomeWin || _result == Result.HomeDraw || _result == Result.HomeLoss);\n        _;\n    }\n\n    constructor() public {\n        rate = 20; // 5%\n    }\n\n    // For Owner & Manager\n\n    function createMatch(uint _id, string _team, string _teamDetail, int32 _pointSpread, uint64 _startTime, uint64 _endTime)\n    onlyOwner\n    public {\n\n        require(_startTime < _endTime);\n        require(matches[_id].created == false);\n\n        // Create new match\n        Match memory _match = Match({\n            created:true,\n            team: _team,\n            teamDetail: _teamDetail,\n            pointSpread: _pointSpread,\n            startTime: _startTime,\n            endTime: _endTime,\n            stakesOfWin: 0,\n            stakesOfDraw: 0,\n            stakesOfLoss: 0,\n            result: Result.Unknown\n            });\n\n        // Insert into matches\n        matches[_id] = _match;\n        numMatches++;\n\n        // Set event\n        emit NewMatch(_id, _team, _teamDetail, _pointSpread, _startTime, _endTime);\n    }\n\n    function updateMatchInfo(uint _id, string _teamDetail, uint64 _startTime, uint64 _endTime)\n    onlyOwner\n    validId(_id)\n    public {\n\n        // Update match info\n        if (bytes(_teamDetail).length > 0) {\n            matches[_id].teamDetail = _teamDetail;\n        }\n        if (_startTime != 0) {\n            matches[_id].startTime = _startTime;\n        }\n        if (_endTime != 0) {\n            matches[_id].endTime = _endTime;\n        }\n\n        // Set event\n        emit MatchInfo(_id, _teamDetail);\n    }\n\n    function announceMatchResult(uint _id, Result _result)\n    onlyManager\n    validId(_id)\n    validResult(_result)\n    public {\n\n        // Check current result\n        require(matches[_id].result == Result.Unknown);\n\n        // Update result\n        matches[_id].result = _result;\n\n        // Calculate bonus and fee\n        uint256 bonus;\n        uint256 fee;\n        Match storage _match = matches[_id];\n\n        if (_result == Result.HomeWin) {\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\n            if (_match.stakesOfWin > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        } else if (_result == Result.HomeDraw) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\n            if (_match.stakesOfDraw > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        } else if (_result == Result.HomeLoss) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\n            if (_match.stakesOfLoss > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        }\n\n        address thiz = address(this);\n        require(thiz.balance >= fee);\n        manager.transfer(fee);\n\n        // Set event\n        emit MatchResult(_id, _result, fee);\n    }\n\n    // For Player\n\n    function bet(uint _id, Result _result)\n    validId(_id)\n    validResult(_result)\n    public\n    payable {\n\n        // Check value\n        require(msg.value > 0);\n\n        // Check match state\n        Match storage _match = matches[_id];\n        require(_match.result == Result.Unknown);\n        require(_match.startTime <= now);\n        require(_match.endTime >= now);\n\n        // Update matches\n        if (_result == Result.HomeWin) {\n            _match.stakesOfWin = add(_match.stakesOfWin, msg.value);\n        } else if (_result == Result.HomeDraw) {\n            _match.stakesOfDraw = add(_match.stakesOfDraw, msg.value);\n        } else if (_result == Result.HomeLoss) {\n            _match.stakesOfLoss = add(_match.stakesOfLoss, msg.value);\n        }\n\n        // Update predictions\n        Prediction storage _prediction = predictions[_id][msg.sender];\n        if (_prediction.result == Result.Unknown) {\n            _prediction.stake = msg.value;\n            _prediction.result = _result;\n        } else {\n            require(_prediction.result == _result);\n            _prediction.stake = add(_prediction.stake, msg.value);\n        }\n\n        // Set event\n        emit Bet(msg.sender, _id, _result, msg.value, _match.stakesOfWin, _match.stakesOfDraw, _match.stakesOfLoss);\n    }\n\n    function getBonus(uint _id, address addr)\n    validId(_id)\n    public\n    view\n    returns (uint256) {\n\n        // Get match state\n        Match storage _match = matches[_id];\n        if (_match.result == Result.Unknown) {\n            return 0;\n        }\n\n        // Get prediction state\n        Prediction storage _prediction = predictions[_id][addr];\n        if (_prediction.result == Result.Unknown) {\n            return 0;\n        }\n\n        // Check result\n        if (_match.result != _prediction.result) {\n            return 0;\n        }\n\n        // Calculate bonus\n        uint256 bonus = _calcBouns(_match, _prediction);\n        bonus = add(bonus, _prediction.stake);\n\n        return bonus;\n    }\n\n    function withdraw(uint _id)\n    validId(_id)\n    public {\n        // Check match state\n        Match storage _match = matches[_id];\n        require(_match.result != Result.Unknown);\n\n        // Check prediction state\n        Prediction storage _prediction = predictions[_id][msg.sender];\n        require(_prediction.result != Result.Unknown);\n        require(_prediction.stake > 0);\n        require(_prediction.withdraw == false);\n        _prediction.withdraw = true;\n\n        // Check result\n        require(_prediction.result == _match.result);\n\n        // Calc bonus\n        uint256 bonus = _calcBouns(_match, _prediction);\n        bonus = add(bonus, _prediction.stake);\n\n        address thiz = address(this);\n        require(thiz.balance >= bonus);\n        msg.sender.transfer(bonus);\n\n        // Set event\n        emit Withdraw(msg.sender, _id, bonus);\n    }\n\n    function _calcBouns(Match storage _match, Prediction storage _prediction)\n    internal\n    view\n    returns (uint256) {\n\n        uint256 bonus;\n\n        if (_match.result != _prediction.result) {\n            return 0;\n        }\n\n        if (_match.result == Result.HomeWin && _match.stakesOfWin > 0) {\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfWin);\n        } else if (_match.result == Result.HomeDraw && _match.stakesOfDraw > 0 ) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfDraw);\n        } else if (_match.result == Result.HomeLoss && _match.stakesOfLoss > 0) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfLoss);\n        }\n\n        return bonus;\n    }\n}",
        "debug": "keccac_2_+_keccac_calldata_WorldCup_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_2 + keccac_calldata_WorldCup_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_WorldCup_4 + calldata_WorldCup_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_WorldCup_0: 0x7fef2d3800000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateMatchInfo(uint256,string,uint64,uint64)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "updateMatchInfo(uint256,string,uint64,uint64)",
        "lineno": 113,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9061,
        "code": "/ Data Struct\n\n    struct Match {\n        bool created;\n\n        // Match Info\n        string team;\n        string teamDetail;\n        int32  pointSpread;\n        uint64 startTime;\n        uint64 endTime;\n\n        // Current Stakes\n        uint256 stakesOfWin;\n        uint256 stakesOfDraw;\n        uint256 stakesOfLoss;\n\n        // Result\n        Result result;\n    }\n\n    struct Prediction {\n        Result result;\n        uint256 stake;\n        bool withdraw;\n    }\n\n    // Storage\n\n    uint public numMatches;\n    mapping(uint => Match) public matches;\n    mapping(uint => mapping(address => Prediction)) public predictions;\n    uint256 public rate;\n\n    // Event\n\n    event NewMatch(uint indexed id, string team, string detail, int32 spread, uint64 start, uint64 end);\n    event MatchInfo(uint indexed id, string detail);\n    event MatchResult(uint indexed id, Result result, uint256 fee);\n    event Bet(address indexed user, uint indexed id, Result result, uint256 stake,\n        uint256 stakesOfWin, uint256 stakesOfDraw, uint256 stakesOfLoss);\n    event Withdraw(address indexed user, uint indexed id, uint256 bonus);\n\n    modifier validId(uint _id) {\n        require(matches[_id].created == true);\n        _;\n    }\n\n    modifier validResult(Result _result) {\n        require(_result == Result.HomeWin || _result == Result.HomeDraw || _result == Result.HomeLoss);\n        _;\n    }\n\n    constructor() public {\n        rate = 20; // 5%\n    }\n\n    // For Owner & Manager\n\n    function createMatch(uint _id, string _team, string _teamDetail, int32 _pointSpread, uint64 _startTime, uint64 _endTime)\n    onlyOwner\n    public {\n\n        require(_startTime < _endTime);\n        require(matches[_id].created == false);\n\n        // Create new match\n        Match memory _match = Match({\n            created:true,\n            team: _team,\n            teamDetail: _teamDetail,\n            pointSpread: _pointSpread,\n            startTime: _startTime,\n            endTime: _endTime,\n            stakesOfWin: 0,\n            stakesOfDraw: 0,\n            stakesOfLoss: 0,\n            result: Result.Unknown\n            });\n\n        // Insert into matches\n        matches[_id] = _match;\n        numMatches++;\n\n        // Set event\n        emit NewMatch(_id, _team, _teamDetail, _pointSpread, _startTime, _endTime);\n    }\n\n    function updateMatchInfo(uint _id, string _teamDetail, uint64 _startTime, uint64 _endTime)\n    onlyOwner\n    validId(_id)\n    public {\n\n        // Update match info\n        if (bytes(_teamDetail).length > 0) {\n            matches[_id].teamDetail = _teamDetail;\n        }\n        if (_startTime != 0) {\n            matches[_id].startTime = _startTime;\n        }\n        if (_endTime != 0) {\n            matches[_id].endTime = _endTime;\n        }\n\n        // Set event\n        emit MatchInfo(_id, _teamDetail);\n    }\n\n    function announceMatchResult(uint _id, Result _result)\n    onlyManager\n    validId(_id)\n    validResult(_result)\n    public {\n\n        // Check current result\n        require(matches[_id].result == Result.Unknown);\n\n        // Update result\n        matches[_id].result = _result;\n\n        // Calculate bonus and fee\n        uint256 bonus;\n        uint256 fee;\n        Match storage _match = matches[_id];\n\n        if (_result == Result.HomeWin) {\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\n            if (_match.stakesOfWin > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        } else if (_result == Result.HomeDraw) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\n            if (_match.stakesOfDraw > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        } else if (_result == Result.HomeLoss) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\n            if (_match.stakesOfLoss > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        }\n\n        address thiz = address(this);\n        require(thiz.balance >= fee);\n        manager.transfer(fee);\n\n        // Set event\n        emit MatchResult(_id, _result, fee);\n    }\n\n    // For Player\n\n    function bet(uint _id, Result _result)\n    validId(_id)\n    validResult(_result)\n    public\n    payable {\n\n        // Check value\n        require(msg.value > 0);\n\n        // Check match state\n        Match storage _match = matches[_id];\n        require(_match.result == Result.Unknown);\n        require(_match.startTime <= now);\n        require(_match.endTime >= now);\n\n        // Update matches\n        if (_result == Result.HomeWin) {\n            _match.stakesOfWin = add(_match.stakesOfWin, msg.value);\n        } else if (_result == Result.HomeDraw) {\n            _match.stakesOfDraw = add(_match.stakesOfDraw, msg.value);\n        } else if (_result == Result.HomeLoss) {\n            _match.stakesOfLoss = add(_match.stakesOfLoss, msg.value);\n        }\n\n        // Update predictions\n        Prediction storage _prediction = predictions[_id][msg.sender];\n        if (_prediction.result == Result.Unknown) {\n            _prediction.stake = msg.value;\n            _prediction.result = _result;\n        } else {\n            require(_prediction.result == _result);\n            _prediction.stake = add(_prediction.stake, msg.value);\n        }\n\n        // Set event\n        emit Bet(msg.sender, _id, _result, msg.value, _match.stakesOfWin, _match.stakesOfDraw, _match.stakesOfLoss);\n    }\n\n    function getBonus(uint _id, address addr)\n    validId(_id)\n    public\n    view\n    returns (uint256) {\n\n        // Get match state\n        Match storage _match = matches[_id];\n        if (_match.result == Result.Unknown) {\n            return 0;\n        }\n\n        // Get prediction state\n        Prediction storage _prediction = predictions[_id][addr];\n        if (_prediction.result == Result.Unknown) {\n            return 0;\n        }\n\n        // Check result\n        if (_match.result != _prediction.result) {\n            return 0;\n        }\n\n        // Calculate bonus\n        uint256 bonus = _calcBouns(_match, _prediction);\n        bonus = add(bonus, _prediction.stake);\n\n        return bonus;\n    }\n\n    function withdraw(uint _id)\n    validId(_id)\n    public {\n        // Check match state\n        Match storage _match = matches[_id];\n        require(_match.result != Result.Unknown);\n\n        // Check prediction state\n        Prediction storage _prediction = predictions[_id][msg.sender];\n        require(_prediction.result != Result.Unknown);\n        require(_prediction.stake > 0);\n        require(_prediction.withdraw == false);\n        _prediction.withdraw = true;\n\n        // Check result\n        require(_prediction.result == _match.result);\n\n        // Calc bonus\n        uint256 bonus = _calcBouns(_match, _prediction);\n        bonus = add(bonus, _prediction.stake);\n\n        address thiz = address(this);\n        require(thiz.balance >= bonus);\n        msg.sender.transfer(bonus);\n\n        // Set event\n        emit Withdraw(msg.sender, _id, bonus);\n    }\n\n    function _calcBouns(Match storage _match, Prediction storage _prediction)\n    internal\n    view\n    returns (uint256) {\n\n        uint256 bonus;\n\n        if (_match.result != _prediction.result) {\n            return 0;\n        }\n\n        if (_match.result == Result.HomeWin && _match.stakesOfWin > 0) {\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfWin);\n        } else if (_match.result == Result.HomeDraw && _match.stakesOfDraw > 0 ) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfDraw);\n        } else if (_match.result == Result.HomeLoss && _match.stakesOfLoss > 0) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfLoss);\n        }\n\n        return bonus;\n    }\n}",
        "debug": "calldata_WorldCup_4 + calldata_WorldCup_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_WorldCup_0: 0x7fef2d3800000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateMatchInfo(uint256,string,uint64,uint64)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "updateMatchInfo(uint256,string,uint64,uint64)",
        "lineno": 113,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9075,
        "code": "/ Data Struct\n\n    struct Match {\n        bool created;\n\n        // Match Info\n        string team;\n        string teamDetail;\n        int32  pointSpread;\n        uint64 startTime;\n        uint64 endTime;\n\n        // Current Stakes\n        uint256 stakesOfWin;\n        uint256 stakesOfDraw;\n        uint256 stakesOfLoss;\n\n        // Result\n        Result result;\n    }\n\n    struct Prediction {\n        Result result;\n        uint256 stake;\n        bool withdraw;\n    }\n\n    // Storage\n\n    uint public numMatches;\n    mapping(uint => Match) public matches;\n    mapping(uint => mapping(address => Prediction)) public predictions;\n    uint256 public rate;\n\n    // Event\n\n    event NewMatch(uint indexed id, string team, string detail, int32 spread, uint64 start, uint64 end);\n    event MatchInfo(uint indexed id, string detail);\n    event MatchResult(uint indexed id, Result result, uint256 fee);\n    event Bet(address indexed user, uint indexed id, Result result, uint256 stake,\n        uint256 stakesOfWin, uint256 stakesOfDraw, uint256 stakesOfLoss);\n    event Withdraw(address indexed user, uint indexed id, uint256 bonus);\n\n    modifier validId(uint _id) {\n        require(matches[_id].created == true);\n        _;\n    }\n\n    modifier validResult(Result _result) {\n        require(_result == Result.HomeWin || _result == Result.HomeDraw || _result == Result.HomeLoss);\n        _;\n    }\n\n    constructor() public {\n        rate = 20; // 5%\n    }\n\n    // For Owner & Manager\n\n    function createMatch(uint _id, string _team, string _teamDetail, int32 _pointSpread, uint64 _startTime, uint64 _endTime)\n    onlyOwner\n    public {\n\n        require(_startTime < _endTime);\n        require(matches[_id].created == false);\n\n        // Create new match\n        Match memory _match = Match({\n            created:true,\n            team: _team,\n            teamDetail: _teamDetail,\n            pointSpread: _pointSpread,\n            startTime: _startTime,\n            endTime: _endTime,\n            stakesOfWin: 0,\n            stakesOfDraw: 0,\n            stakesOfLoss: 0,\n            result: Result.Unknown\n            });\n\n        // Insert into matches\n        matches[_id] = _match;\n        numMatches++;\n\n        // Set event\n        emit NewMatch(_id, _team, _teamDetail, _pointSpread, _startTime, _endTime);\n    }\n\n    function updateMatchInfo(uint _id, string _teamDetail, uint64 _startTime, uint64 _endTime)\n    onlyOwner\n    validId(_id)\n    public {\n\n        // Update match info\n        if (bytes(_teamDetail).length > 0) {\n            matches[_id].teamDetail = _teamDetail;\n        }\n        if (_startTime != 0) {\n            matches[_id].startTime = _startTime;\n        }\n        if (_endTime != 0) {\n            matches[_id].endTime = _endTime;\n        }\n\n        // Set event\n        emit MatchInfo(_id, _teamDetail);\n    }\n\n    function announceMatchResult(uint _id, Result _result)\n    onlyManager\n    validId(_id)\n    validResult(_result)\n    public {\n\n        // Check current result\n        require(matches[_id].result == Result.Unknown);\n\n        // Update result\n        matches[_id].result = _result;\n\n        // Calculate bonus and fee\n        uint256 bonus;\n        uint256 fee;\n        Match storage _match = matches[_id];\n\n        if (_result == Result.HomeWin) {\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\n            if (_match.stakesOfWin > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        } else if (_result == Result.HomeDraw) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\n            if (_match.stakesOfDraw > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        } else if (_result == Result.HomeLoss) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\n            if (_match.stakesOfLoss > 0) {\n                fee = div(bonus, rate);\n            } else {\n                fee = bonus;\n            }\n        }\n\n        address thiz = address(this);\n        require(thiz.balance >= fee);\n        manager.transfer(fee);\n\n        // Set event\n        emit MatchResult(_id, _result, fee);\n    }\n\n    // For Player\n\n    function bet(uint _id, Result _result)\n    validId(_id)\n    validResult(_result)\n    public\n    payable {\n\n        // Check value\n        require(msg.value > 0);\n\n        // Check match state\n        Match storage _match = matches[_id];\n        require(_match.result == Result.Unknown);\n        require(_match.startTime <= now);\n        require(_match.endTime >= now);\n\n        // Update matches\n        if (_result == Result.HomeWin) {\n            _match.stakesOfWin = add(_match.stakesOfWin, msg.value);\n        } else if (_result == Result.HomeDraw) {\n            _match.stakesOfDraw = add(_match.stakesOfDraw, msg.value);\n        } else if (_result == Result.HomeLoss) {\n            _match.stakesOfLoss = add(_match.stakesOfLoss, msg.value);\n        }\n\n        // Update predictions\n        Prediction storage _prediction = predictions[_id][msg.sender];\n        if (_prediction.result == Result.Unknown) {\n            _prediction.stake = msg.value;\n            _prediction.result = _result;\n        } else {\n            require(_prediction.result == _result);\n            _prediction.stake = add(_prediction.stake, msg.value);\n        }\n\n        // Set event\n        emit Bet(msg.sender, _id, _result, msg.value, _match.stakesOfWin, _match.stakesOfDraw, _match.stakesOfLoss);\n    }\n\n    function getBonus(uint _id, address addr)\n    validId(_id)\n    public\n    view\n    returns (uint256) {\n\n        // Get match state\n        Match storage _match = matches[_id];\n        if (_match.result == Result.Unknown) {\n            return 0;\n        }\n\n        // Get prediction state\n        Prediction storage _prediction = predictions[_id][addr];\n        if (_prediction.result == Result.Unknown) {\n            return 0;\n        }\n\n        // Check result\n        if (_match.result != _prediction.result) {\n            return 0;\n        }\n\n        // Calculate bonus\n        uint256 bonus = _calcBouns(_match, _prediction);\n        bonus = add(bonus, _prediction.stake);\n\n        return bonus;\n    }\n\n    function withdraw(uint _id)\n    validId(_id)\n    public {\n        // Check match state\n        Match storage _match = matches[_id];\n        require(_match.result != Result.Unknown);\n\n        // Check prediction state\n        Prediction storage _prediction = predictions[_id][msg.sender];\n        require(_prediction.result != Result.Unknown);\n        require(_prediction.stake > 0);\n        require(_prediction.withdraw == false);\n        _prediction.withdraw = true;\n\n        // Check result\n        require(_prediction.result == _match.result);\n\n        // Calc bonus\n        uint256 bonus = _calcBouns(_match, _prediction);\n        bonus = add(bonus, _prediction.stake);\n\n        address thiz = address(this);\n        require(thiz.balance >= bonus);\n        msg.sender.transfer(bonus);\n\n        // Set event\n        emit Withdraw(msg.sender, _id, bonus);\n    }\n\n    function _calcBouns(Match storage _match, Prediction storage _prediction)\n    internal\n    view\n    returns (uint256) {\n\n        uint256 bonus;\n\n        if (_match.result != _prediction.result) {\n            return 0;\n        }\n\n        if (_match.result == Result.HomeWin && _match.stakesOfWin > 0) {\n            bonus = add(_match.stakesOfDraw, _match.stakesOfLoss);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfWin);\n        } else if (_match.result == Result.HomeDraw && _match.stakesOfDraw > 0 ) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfLoss);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfDraw);\n        } else if (_match.result == Result.HomeLoss && _match.stakesOfLoss > 0) {\n            bonus = add(_match.stakesOfWin, _match.stakesOfDraw);\n            bonus = sub(bonus, div(bonus, rate));\n            bonus = div(mul(_prediction.stake, bonus), _match.stakesOfLoss);\n        }\n\n        return bonus;\n    }\n}",
        "debug": "calldata_WorldCup_4 + calldata_WorldCup_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60\nstorage_0 + keccac_calldata_WorldCup_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_WorldCup_0: 0x7fef2d3800000000000000000000000000000000000000000000000000000000\ncalldatasize_WorldCup: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateMatchInfo(uint256,string,uint64,uint64)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0x4342cc6763de448927cbae70eb56ec783d2ce00d.sol",
        "function": "updateMatchInfo(uint256,string,uint64,uint64)",
        "lineno": 113,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}