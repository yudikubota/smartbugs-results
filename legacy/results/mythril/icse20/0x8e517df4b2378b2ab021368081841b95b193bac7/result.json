{
  "contract": "0x8e517df4b2378b2ab021368081841b95b193bac7",
  "tool": "mythril",
  "start": 1563640626.896645,
  "end": 1563641292.563079,
  "duration": 665.6664340496063,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 623,
        "code": "Supply += _amount;",
        "debug": "storage_6: 0xf77124b52a24e057d8a070024000e4e0e29fe1280e6ec1bac4ce6c09cd081036\nretval_594: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_Token: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "fallback",
        "lineno": 55,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 634,
        "code": "lances[msg.sender] += _amount;\n       ",
        "debug": "storage_6: 0xd6272c21e28ee2a9aa37d12c12aa92d6ef8a62d929fb586fbd8dc825613\nstorage_5: 0xf6d14ebf7e33fcecfe2fefad81f75d89c06c6b40002039460fff8eb5eff80000\nretval_594: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_Token: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "fallback",
        "lineno": 56,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 711,
        "code": "ly += _amount;\n            Tran",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbd10b7c7400062cfbeb7d5fbcbfabfe87fdd87bfa8f79fa9e60ab0c3bf940000\nstorage_6: 0x2bcf132164ead8b4032659fd905c1d5161b04c23dfde04577db0a18a3b5b\nretval_594: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\ncalldatasize_Token: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "fallback",
        "lineno": 57,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 727,
        "code": "sender, _amount);\n     ",
        "debug": "storage_2: 0x8cfcf72bfffccb8c3d575aa5a921c137fc900387f1e53ffe1fa7e65d9d9c0000\nstorage_6: 0x30c0a13b47a897a2e806bb57dd6cfbc147e285f48aa90122eec66ddf542f\nretval_594: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldatasize_Token: 0x3\nstorage_3: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "fallback",
        "lineno": 58,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2172,
        "code": "ed, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWe",
        "debug": "calldata_Token_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 89,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2184,
        "code": "ed, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWe",
        "debug": "calldata_Token_4 + calldata_Token_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 89,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2193,
        "code": "ed, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWe",
        "debug": "calldata_Token_4 + calldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 89,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2199,
        "code": "ed, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWe",
        "debug": "calldata_Token_4 + calldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 89,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4428,
        "code": "okensReceiverAddress] += _remainingAmount;\n          ",
        "debug": "storage_3: 0x1\nstorage_15: 0xff00\nstorage_5: 0x2\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Token_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `StopDistrib()`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "StopDistrib()",
        "lineno": 142,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4543,
        "code": "sfer(this, _remainingTokensReceiverAddress, _remainingAmount)",
        "debug": "storage_3: 0x940e7efffffee1ffc453c844ecaf3d009306789a479485f37b0944eae86247c4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_14,_256): 0xca0b416000014175629c58be85d948d81ba0869287028324cd21131dbdaec8b4\nstorage_5: 0x10268100000120017ede3713feedee02fffeffffe3bff40dd8d3adbff621419f\nstorage_15: 0xff00\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Token_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `StopDistrib()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "StopDistrib()",
        "lineno": 144,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4559,
        "code": "         }\n            DistribSt",
        "debug": "storage_3: 0x940e7efffffee1ffc453c844ecaf3d009306789a479485f37b0944eae86247c4\nstorage_2: 0xca0b416000014175629c58be85d948d81ba0869287028324cd21131dbdaec8b4\nstorage_5: 0x10268100000120017ede3713feedee02fffeffffe3bff40dd8d3adbff621419f\nstorage_15: 0xff00\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Token_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `StopDistrib()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "StopDistrib()",
        "lineno": 146,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5347,
        "code": "lse;\n        }\n    }\n\n ",
        "debug": "calldata_Token_32 + 36: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_32_+_4: 0x800000000000000000008eb2e34648ee0801030820000000000000000000a000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\ncalldata_Token_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 286,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5782,
        "code": "fer(msg.sender, 0,",
        "debug": "calldata_Token_4: 0xf77124b52a24e057d8a070024000e4e0e29fe1280e6ec1bac4ce6c09cd081036\ncalldata_Token_0: 0x2cd3fd7000000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `BurnTokens(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "BurnTokens(uint256)",
        "lineno": 207,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5942,
        "code": "pply() public constant",
        "debug": "calldata_Token_4: 0xf2c71b6ec72a2bc2cbdb1100a6c0a6800901d865bacf0a0402981f33eb\nstorage_2: 0x8311d86797e4b35c6094b1d0993b66af86537eac20e1bf6e2b9a265f94cbffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8311d86797e4b35c6094b1d0993b66af86537eac20e1bf6e2b9a265f94cc0000\ncalldata_Token_0: 0x2cd3fd7000000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `BurnTokens(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "BurnTokens(uint256)",
        "lineno": 214,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 6349,
        "code": "            _BonusTo",
        "debug": "storage_15: 0x0\ncalldata_Token_4 + calldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff21\ncaller: 0x0\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 94,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9365,
        "code": "ntract Token {\n    string public symbol = \"\";\n    string public name = \"\";\n    uint8 public constant decimals = 18;\n    uint256 _totalSupply = 0;\n    uint256 _MaxDistribPublicSupply = 0;\n    uint256 _OwnerDistribSupply = 0;\n    uint256 _CurrentDistribPublicSupply = 0;\n    uint256 _FreeTokens = 0;\n    uint256 _Multiplier1 = 2;\n    uint256 _Multiplier2 = 3;\n    uint256 _LimitMultiplier1 = 4e15;\n    uint256 _LimitMultiplier2 = 8e15;\n    uint256 _HighDonateLimit = 5e16;\n    uint256 _BonusTokensPerETHdonated = 0;\n    address _DistribFundsReceiverAddress = 0;\n    address _remainingTokensReceiverAddress = 0;\n    address owner = 0;\n    bool setupDone = false;\n    bool IsDistribRunning = false;\n    bool DistribStarted = false;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _owner, uint256 _value);\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\tmapping(address => bool) public claimedAlready;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\t\n\tmodifier notClaimed() {\n        require(claimedAlready[msg.sender] == false);\n        _;\n    }\n\n\n    function Token() public {\n        owner = msg.sender;\n    }\n\n    function() public notClaimed payable {\n        if (IsDistribRunning) {\n            uint256 _amount;\n            if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert();\n            if (!_DistribFundsReceiverAddress.send(msg.value)) revert();\n            _amount = _FreeTokens * 1e18;\n            _CurrentDistribPublicSupply += _amount;\n            balances[msg.sender] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, msg.sender, _amount);\n            require(msg.value <= _HighDonateLimit);\n\n            if (msg.value >= 1e15) {\n                if (msg.value >= _LimitMultiplier2) {\n                    _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier2;\n                } else {\n                    if (msg.value >= _LimitMultiplier1) {\n                        _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier1;\n                    } else {\n\n                        _amount = msg.value * _BonusTokensPerETHdonated;\n\n                    }\n\n                }\n\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n\t\t\t\tclaimedAlready[msg.sender]=true;\n            }\n\n\n\n        } else {\n            revert();\n        }\n    }\n\n    function SetupToken(string tokenName, string tokenSymbol, uint256 BonusTokensPerETHdonated, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwner public {\n        _Multiplier1 = Multiplier1inX;\n        _Multiplier2 = Multiplier2inX;\n        _LimitMultiplier1 = LimitMultiplier1inWei;\n        _LimitMultiplier2 = LimitMultiplier2inWei;\n        _HighDonateLimit = HighDonateLimitInWei;\n    }\n\n    function SetBonus(uint256 BonusTokensPerETHdonated) onlyOwner public {\n        _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n    }\n\n    function SetFreeTokens(uint256 FreeTokens) onlyOwner public {\n        _FreeTokens = FreeTokens;\n    }\n\n    function StartDistrib() public returns(bool success) {\n        if (msg.sender == owner && !DistribStarted && setupDone) {\n            DistribStarted = true;\n            IsDistribRunning = true;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function StopDistrib() public returns(bool success) {\n        if (msg.sender == owner && IsDistribRunning) {\n            if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) {\n                uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n                if (_remainingAmount > 0) {\n                    balances[_remainingTokensReceiverAddress] += _remainingAmount;\n                    _totalSupply += _remainingAmount;\n                    Transfer(this, _remainingTokensReceiverAddress, _remainingAmount);\n                }\n            }\n            DistribStarted = false;\n            IsDistribRunning = false;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function distribution(address[] addresses, uint256 _amount) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        require(addresses.length <= 255);\n        require(_amount <= _remainingAmount);\n        _amount = _amount * 1e18;\n\n        for (uint i = 0; i < addresses.length; i++) {\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[msg.sender] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n        }\n\n        if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n            DistribStarted = false;\n            IsDistribRunning = false;\n        }\n    }\n\n    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        uint256 _amount;\n\n        require(addresses.length <= 255);\n        require(addresses.length == amounts.length);\n\n        for (uint8 i = 0; i < addresses.length; i++) {\n            _amount = amounts[i] * 1e18;\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[msg.sender] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n\n            if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n                DistribStarted = false;\n                IsDistribRunning = false;\n            }\n        }\n    }\n\n    function BurnTokens(uint256 amountInWei) public returns(bool success) {\n        uint256 amount = amountInWei * 1e18;\n        if (balances[msg.sender] >= amount) {\n            balances[msg.sender] -= amount;\n            _totalSupply -= amount;\n            Burn(msg.sender, amount);\n            Transfer(msg.sender, 0, amount);\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function totalSupply() public constant returns(uint256 totalSupplyValue) {\n        return _totalSupply;\n    }\n\n    function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) {\n        return _MaxDistribPublicSupply;\n    }\n\n    function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) {\n        return _OwnerDistribSupply;\n    }\n\n    function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) {\n        return _CurrentDistribPublicSupply;\n    }\n\n    function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) {\n        return _remainingTokensReceiverAddress;\n    }\n\n    function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) {\n        return _DistribFundsReceiverAddress;\n    }\n\n    function Owner() public constant returns(address ownerAddress) {\n        return owner;\n    }\n\n    function SetupDone() public constant returns(bool setupDoneFlag) {\n        return setupDone;\n    }\n\n    function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) {\n        return IsDistribRunning;\n    }\n\n    function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) {\n        return DistribStarted;\n    }\n\n    function balanceOf(address _owner) public constant returns(uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) public returns(bool success) {\n        if (balances[msg.sender] >= _amount &&\n            _amount > 0 &&\n            balances[_to] + _amount > balances[_to]) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public returns(bool success) {\n        if (balances[_from] >= _amount &&\n            allowed[_from][msg.sender] >= _amount &&\n            _amount > 0 &&\n            balances[_to] + _amount > balances[_to]) {\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) public returns(bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}",
        "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_4)): 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_15: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9379,
        "code": "ntract Token {\n    string public symbol = \"\";\n    string public name = \"\";\n    uint8 public constant decimals = 18;\n    uint256 _totalSupply = 0;\n    uint256 _MaxDistribPublicSupply = 0;\n    uint256 _OwnerDistribSupply = 0;\n    uint256 _CurrentDistribPublicSupply = 0;\n    uint256 _FreeTokens = 0;\n    uint256 _Multiplier1 = 2;\n    uint256 _Multiplier2 = 3;\n    uint256 _LimitMultiplier1 = 4e15;\n    uint256 _LimitMultiplier2 = 8e15;\n    uint256 _HighDonateLimit = 5e16;\n    uint256 _BonusTokensPerETHdonated = 0;\n    address _DistribFundsReceiverAddress = 0;\n    address _remainingTokensReceiverAddress = 0;\n    address owner = 0;\n    bool setupDone = false;\n    bool IsDistribRunning = false;\n    bool DistribStarted = false;\n\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _owner, uint256 _value);\n\n    mapping(address => uint256) balances;\n    mapping(address => mapping(address => uint256)) allowed;\n\tmapping(address => bool) public claimedAlready;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\t\n\tmodifier notClaimed() {\n        require(claimedAlready[msg.sender] == false);\n        _;\n    }\n\n\n    function Token() public {\n        owner = msg.sender;\n    }\n\n    function() public notClaimed payable {\n        if (IsDistribRunning) {\n            uint256 _amount;\n            if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert();\n            if (!_DistribFundsReceiverAddress.send(msg.value)) revert();\n            _amount = _FreeTokens * 1e18;\n            _CurrentDistribPublicSupply += _amount;\n            balances[msg.sender] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, msg.sender, _amount);\n            require(msg.value <= _HighDonateLimit);\n\n            if (msg.value >= 1e15) {\n                if (msg.value >= _LimitMultiplier2) {\n                    _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier2;\n                } else {\n                    if (msg.value >= _LimitMultiplier1) {\n                        _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier1;\n                    } else {\n\n                        _amount = msg.value * _BonusTokensPerETHdonated;\n\n                    }\n\n                }\n\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n\t\t\t\tclaimedAlready[msg.sender]=true;\n            }\n\n\n\n        } else {\n            revert();\n        }\n    }\n\n    function SetupToken(string tokenName, string tokenSymbol, uint256 BonusTokensPerETHdonated, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwner public {\n        _Multiplier1 = Multiplier1inX;\n        _Multiplier2 = Multiplier2inX;\n        _LimitMultiplier1 = LimitMultiplier1inWei;\n        _LimitMultiplier2 = LimitMultiplier2inWei;\n        _HighDonateLimit = HighDonateLimitInWei;\n    }\n\n    function SetBonus(uint256 BonusTokensPerETHdonated) onlyOwner public {\n        _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n    }\n\n    function SetFreeTokens(uint256 FreeTokens) onlyOwner public {\n        _FreeTokens = FreeTokens;\n    }\n\n    function StartDistrib() public returns(bool success) {\n        if (msg.sender == owner && !DistribStarted && setupDone) {\n            DistribStarted = true;\n            IsDistribRunning = true;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function StopDistrib() public returns(bool success) {\n        if (msg.sender == owner && IsDistribRunning) {\n            if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) {\n                uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n                if (_remainingAmount > 0) {\n                    balances[_remainingTokensReceiverAddress] += _remainingAmount;\n                    _totalSupply += _remainingAmount;\n                    Transfer(this, _remainingTokensReceiverAddress, _remainingAmount);\n                }\n            }\n            DistribStarted = false;\n            IsDistribRunning = false;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function distribution(address[] addresses, uint256 _amount) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        require(addresses.length <= 255);\n        require(_amount <= _remainingAmount);\n        _amount = _amount * 1e18;\n\n        for (uint i = 0; i < addresses.length; i++) {\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[msg.sender] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n        }\n\n        if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n            DistribStarted = false;\n            IsDistribRunning = false;\n        }\n    }\n\n    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        uint256 _amount;\n\n        require(addresses.length <= 255);\n        require(addresses.length == amounts.length);\n\n        for (uint8 i = 0; i < addresses.length; i++) {\n            _amount = amounts[i] * 1e18;\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[msg.sender] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n\n            if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n                DistribStarted = false;\n                IsDistribRunning = false;\n            }\n        }\n    }\n\n    function BurnTokens(uint256 amountInWei) public returns(bool success) {\n        uint256 amount = amountInWei * 1e18;\n        if (balances[msg.sender] >= amount) {\n            balances[msg.sender] -= amount;\n            _totalSupply -= amount;\n            Burn(msg.sender, amount);\n            Transfer(msg.sender, 0, amount);\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function totalSupply() public constant returns(uint256 totalSupplyValue) {\n        return _totalSupply;\n    }\n\n    function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) {\n        return _MaxDistribPublicSupply;\n    }\n\n    function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) {\n        return _OwnerDistribSupply;\n    }\n\n    function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) {\n        return _CurrentDistribPublicSupply;\n    }\n\n    function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) {\n        return _remainingTokensReceiverAddress;\n    }\n\n    function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) {\n        return _DistribFundsReceiverAddress;\n    }\n\n    function Owner() public constant returns(address ownerAddress) {\n        return owner;\n    }\n\n    function SetupDone() public constant returns(bool setupDoneFlag) {\n        return setupDone;\n    }\n\n    function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) {\n        return IsDistribRunning;\n    }\n\n    function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) {\n        return DistribStarted;\n    }\n\n    function balanceOf(address _owner) public constant returns(uint256 balance) {\n        return balances[_owner];\n    }\n\n    function transfer(address _to, uint256 _amount) public returns(bool success) {\n        if (balances[msg.sender] >= _amount &&\n            _amount > 0 &&\n            balances[_to] + _amount > balances[_to]) {\n            balances[msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(msg.sender, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function transferFrom(\n        address _from,\n        address _to,\n        uint256 _amount\n    ) public returns(bool success) {\n        if (balances[_from] >= _amount &&\n            allowed[_from][msg.sender] >= _amount &&\n            _amount > 0 &&\n            balances[_to] + _amount > balances[_to]) {\n            balances[_from] -= _amount;\n            allowed[_from][msg.sender] -= _amount;\n            balances[_to] += _amount;\n            Transfer(_from, _to, _amount);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function approve(address _spender, uint256 _amount) public returns(bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n}",
        "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_4)): 0xa7d18fd5703fddff6f5377fa44900dfb4a10ffffe39800000000000000000060\nstorage_15: 0x0\ncalldata_Token_4 + calldata_Token_4: 0x7fffffffffffffffffffffffffffffffffffffff3fffffffffffffffffffff41\ncaller: 0x0\ncalldata_Token_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0x8e517df4b2378b2ab021368081841b95b193bac7.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}