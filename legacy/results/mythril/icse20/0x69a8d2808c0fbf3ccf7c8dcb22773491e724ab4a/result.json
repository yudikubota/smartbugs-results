{
  "contract": "0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a",
  "tool": "mythril",
  "start": 1563640395.9811757,
  "end": 1563640656.0417693,
  "duration": 260.0605936050415,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 3031,
        "code": "nceOf[_from] + balanceOf[msg.sender] == ",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xa870d5e7fffffffffffffffffffffffffffffffffffffffffffffffffffffefe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x57f2c1f800000000000000000000000000000000000000000000000000000100\ncalldata_VVToken_0: 0x95e596f00000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AccountVoid(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "AccountVoid(address)",
        "lineno": 231,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3180,
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0x95e493df09774eb49bd48003c0850b30f8d10a2a1341043d4c008560e08500c4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa923bc2c35ea58231bc6409900885b40fedbadcbd5004fbf0bfef9fcf6f50329\ncalldata_VVToken_0: 0x95e596f00000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AccountVoid(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "AccountVoid(address)",
        "lineno": 233,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4354,
        "code": "           count ",
        "debug": "storage_3: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `kill()`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "kill()",
        "lineno": 75,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4379,
        "code": "uired)\n  ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\nstorage_3: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "kill()",
        "lineno": 76,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5780,
        "code": ";\n\ncontract MultiO",
        "debug": "storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x7065cb4800000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "addOwner(address)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9687,
        "code": "nt Confirmation(address sender, bytes32 transactionHash);\n\tevent Execution(bytes32 transactionHash);\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent VoidAccount(address indexed from, address indexed to, uint256 value);\n\t\n\tstring public name = \"VV Coin\";\n\tstring public symbol = \"VVC\";\n\tuint8 public decimals = 8;\n\tuint256 public totalSupply = 3000000000 * 10 ** uint256(decimals);\n\tuint256 public EthPerToken = 300;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction VVToken(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tbalanceOf[msg.sender] = totalSupply;                    \n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n    \n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable {\n\t\trevert();\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = sha3(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction AccountVoid(address _from) onlyOwner public{\n\t\trequire (balanceOf[_from] > 0); \n\t\tuint256 CurrentBalances = balanceOf[_from];\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\n        balanceOf[_from] -= CurrentBalances;                         \n        balanceOf[msg.sender] += CurrentBalances;\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\n\t}\n}",
        "debug": "storage_3: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VVToken_4: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037083: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "removeOwner(address)",
        "lineno": 90,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9689,
        "code": "nt Confirmation(address sender, bytes32 transactionHash);\n\tevent Execution(bytes32 transactionHash);\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\tevent VoidAccount(address indexed from, address indexed to, uint256 value);\n\t\n\tstring public name = \"VV Coin\";\n\tstring public symbol = \"VVC\";\n\tuint8 public decimals = 8;\n\tuint256 public totalSupply = 3000000000 * 10 ** uint256(decimals);\n\tuint256 public EthPerToken = 300;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction VVToken(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tbalanceOf[msg.sender] = totalSupply;                    \n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n    \n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable {\n\t\trevert();\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = sha3(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction AccountVoid(address _from) onlyOwner public{\n\t\trequire (balanceOf[_from] > 0); \n\t\tuint256 CurrentBalances = balanceOf[_from];\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\n        balanceOf[_from] -= CurrentBalances;                         \n        balanceOf[msg.sender] += CurrentBalances;\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\n\t}\n}",
        "debug": "storage_3: 0x7fffffffffffffffffffffefffffffffffffffffffffffffffffc00000000000\ncalldata_VVToken_4: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037083: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x69a8d2808c0fbf3ccf7c8dcb22773491e724ab4a.sol",
        "function": "removeOwner(address)",
        "lineno": 90,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}