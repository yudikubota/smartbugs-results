{
  "contract": "0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca",
  "tool": "mythril",
  "start": 1563640128.8984907,
  "end": 1563641302.1617982,
  "duration": 1173.2633075714111,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 200,
        "code": "_url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregi",
        "debug": "calldata_ServerRegistry_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 32,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 212,
        "code": "_url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregi",
        "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 32,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 221,
        "code": "_url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregi",
        "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 32,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 227,
        "code": "_url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregi",
        "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 32,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1382,
        "code": "stered(_url, _p",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xa0\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\nstorage_0: 0x0\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 45,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1815,
        "code": "ers;\n\n    function totalSer",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0x5cf0f35700000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "_function_0x5cf0f357",
        "lineno": 25,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2107,
        "code": "quested it before\n   ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0x6ba3751e00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "cancelUnregisteringServer(uint256)",
        "lineno": 93,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2945,
        "code": "        uint payout =",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_32 + 4: 0x0\nblockhash_block_calldata_ServerRegistry_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ServerRegistry_0: 0x6ec61caf00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "convict(uint256,bytes32,uint256,uint8,bytes32,bytes32)",
        "lineno": 117,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3157,
        "code": "he deposit\n        if (servers[_serverIndex].deposit>0) {\n",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "convict(uint256,bytes32,uint256,uint8,bytes32,bytes32)",
        "lineno": 115,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 3850,
        "code": "uested it before\n    ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0xdc95f70b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "confirmUnregisteringServer(uint256)",
        "lineno": 75,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4226,
        "code": "ner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payB",
        "debug": "",
        "description": "In the function `confirmUnregisteringServer(uint256)` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "confirmUnregisteringServer(uint256)",
        "lineno": 81,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 4226,
        "code": "ner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payB",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4343\n",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "confirmUnregisteringServer(uint256)",
        "lineno": 81,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4343,
        "code": "   function cancelUnregisteringServer",
        "debug": "",
        "description": "In the function `confirmUnregisteringServer(uint256)` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "confirmUnregisteringServer(uint256)",
        "lineno": 90,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 4396,
        "code": " if nobody requested ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0xff40ae6900000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "requestUnregisteringServer(uint256)",
        "lineno": 59,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4637,
        "code": "e = now + 28 ",
        "debug": "timestamp: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8f0\ncalldata_ServerRegistry_4: 0x0\nstorage_1 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_5 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_0: 0x1\ncalldata_ServerRegistry_0: 0xff40ae6900000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `requestUnregisteringServer(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "requestUnregisteringServer(uint256)",
        "lineno": 65,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4656,
        "code": "e requester n",
        "debug": "timestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef8400\ncalldata_ServerRegistry_4: 0x0\nstorage_1 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_0: 0x1\ncalldata_ServerRegistry_0: 0xff40ae6900000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `requestUnregisteringServer(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "requestUnregisteringServer(uint256)",
        "lineno": 66,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6110,
        "code": "tract ServerRegistry {\n\n    uint internal constant unregisterDeposit = 100000;\n\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n    event LogServerUnregisterCanceled(string url, address owner);\n    event LogServerConvicted(string url, address owner);\n    event LogServerRemoved(string url, address owner);\n\n    struct Web3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint unregisterTime; // earliest timestamp in to to call unregister\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n    \n    Web3Server[] public servers;\n\n    function totalServers() public constant returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering this.\n    ///    in this case he has to wait for one hour before actually removing the server.\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller==address(0x0));\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = now + 1 hours;\n        else {\n            server.unregisterTime = now + 28 days; // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value==unregisterDeposit);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender );\n    }\n    \n    function confirmUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller!=address(0x0) && server.unregisterTime < now);\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit/5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer( unregisterDeposit + server.deposit - payBackOwner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payBackOwner );\n\n        removeServer(_serverIndex);\n    }\n\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller!=address(0) &&  server.owner == msg.sender);\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer( unregisterDeposit );\n\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        \n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        // if the blockhash is correct you cannot convict the server\n        require(blockhash(_blocknumber) != _blockhash);\n\n        // make sure the hash was signed by the owner of the server\n        require(ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner);\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit>0) {\n            uint payout = servers[_serverIndex].deposit/2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        removeServer(_serverIndex);\n\n    }\n    \n    // internal helpers\n    \n    function removeServer(uint _serverIndex) internal {\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner );\n        uint length = servers.length;\n        Web3Server memory m = servers[length - 1];\n        servers[_serverIndex] = m;\n        servers.length--;\n    }\n}",
        "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec1\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6240,
        "code": "tract ServerRegistry {\n\n    uint internal constant unregisterDeposit = 100000;\n\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n    event LogServerUnregisterCanceled(string url, address owner);\n    event LogServerConvicted(string url, address owner);\n    event LogServerRemoved(string url, address owner);\n\n    struct Web3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint unregisterTime; // earliest timestamp in to to call unregister\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n    \n    Web3Server[] public servers;\n\n    function totalServers() public constant returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering this.\n    ///    in this case he has to wait for one hour before actually removing the server.\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller==address(0x0));\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = now + 1 hours;\n        else {\n            server.unregisterTime = now + 28 days; // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value==unregisterDeposit);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender );\n    }\n    \n    function confirmUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller!=address(0x0) && server.unregisterTime < now);\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit/5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer( unregisterDeposit + server.deposit - payBackOwner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payBackOwner );\n\n        removeServer(_serverIndex);\n    }\n\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller!=address(0) &&  server.owner == msg.sender);\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer( unregisterDeposit );\n\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        \n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        // if the blockhash is correct you cannot convict the server\n        require(blockhash(_blocknumber) != _blockhash);\n\n        // make sure the hash was signed by the owner of the server\n        require(ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner);\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit>0) {\n            uint payout = servers[_serverIndex].deposit/2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        removeServer(_serverIndex);\n\n    }\n    \n    // internal helpers\n    \n    function removeServer(uint _serverIndex) internal {\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner );\n        uint length = servers.length;\n        Web3Server memory m = servers[length - 1];\n        servers[_serverIndex] = m;\n        servers.length--;\n    }\n}",
        "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x80\nkeccac_0_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n6*storage_0: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*storage_0: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\nstorage_0: 0x0\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6269,
        "code": "tract ServerRegistry {\n\n    uint internal constant unregisterDeposit = 100000;\n\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n    event LogServerUnregisterCanceled(string url, address owner);\n    event LogServerConvicted(string url, address owner);\n    event LogServerRemoved(string url, address owner);\n\n    struct Web3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint unregisterTime; // earliest timestamp in to to call unregister\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n    \n    Web3Server[] public servers;\n\n    function totalServers() public constant returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering this.\n    ///    in this case he has to wait for one hour before actually removing the server.\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller==address(0x0));\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = now + 1 hours;\n        else {\n            server.unregisterTime = now + 28 days; // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value==unregisterDeposit);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender );\n    }\n    \n    function confirmUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller!=address(0x0) && server.unregisterTime < now);\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit/5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer( unregisterDeposit + server.deposit - payBackOwner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payBackOwner );\n\n        removeServer(_serverIndex);\n    }\n\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller!=address(0) &&  server.owner == msg.sender);\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer( unregisterDeposit );\n\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        \n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        // if the blockhash is correct you cannot convict the server\n        require(blockhash(_blocknumber) != _blockhash);\n\n        // make sure the hash was signed by the owner of the server\n        require(ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner);\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit>0) {\n            uint payout = servers[_serverIndex].deposit/2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        removeServer(_serverIndex);\n\n    }\n    \n    // internal helpers\n    \n    function removeServer(uint _serverIndex) internal {\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner );\n        uint length = servers.length;\n        Web3Server memory m = servers[length - 1];\n        servers[_serverIndex] = m;\n        servers.length--;\n    }\n}",
        "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xc0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\nstorage_0: 0x0\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6283,
        "code": "tract ServerRegistry {\n\n    uint internal constant unregisterDeposit = 100000;\n\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n    event LogServerUnregisterCanceled(string url, address owner);\n    event LogServerConvicted(string url, address owner);\n    event LogServerRemoved(string url, address owner);\n\n    struct Web3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint unregisterTime; // earliest timestamp in to to call unregister\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n    \n    Web3Server[] public servers;\n\n    function totalServers() public constant returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering this.\n    ///    in this case he has to wait for one hour before actually removing the server.\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller==address(0x0));\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = now + 1 hours;\n        else {\n            server.unregisterTime = now + 28 days; // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value==unregisterDeposit);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender );\n    }\n    \n    function confirmUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller!=address(0x0) && server.unregisterTime < now);\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit/5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer( unregisterDeposit + server.deposit - payBackOwner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payBackOwner );\n\n        removeServer(_serverIndex);\n    }\n\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller!=address(0) &&  server.owner == msg.sender);\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer( unregisterDeposit );\n\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        \n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        // if the blockhash is correct you cannot convict the server\n        require(blockhash(_blocknumber) != _blockhash);\n\n        // make sure the hash was signed by the owner of the server\n        require(ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner);\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit>0) {\n            uint payout = servers[_serverIndex].deposit/2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        removeServer(_serverIndex);\n\n    }\n    \n    // internal helpers\n    \n    function removeServer(uint _serverIndex) internal {\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner );\n        uint length = servers.length;\n        Web3Server memory m = servers[length - 1];\n        servers[_serverIndex] = m;\n        servers.length--;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0xa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\nstorage_0: 0x0\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6300,
        "code": "tract ServerRegistry {\n\n    uint internal constant unregisterDeposit = 100000;\n\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n    event LogServerUnregisterCanceled(string url, address owner);\n    event LogServerConvicted(string url, address owner);\n    event LogServerRemoved(string url, address owner);\n\n    struct Web3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint unregisterTime; // earliest timestamp in to to call unregister\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n    \n    Web3Server[] public servers;\n\n    function totalServers() public constant returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering this.\n    ///    in this case he has to wait for one hour before actually removing the server.\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller==address(0x0));\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = now + 1 hours;\n        else {\n            server.unregisterTime = now + 28 days; // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value==unregisterDeposit);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender );\n    }\n    \n    function confirmUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller!=address(0x0) && server.unregisterTime < now);\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit/5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer( unregisterDeposit + server.deposit - payBackOwner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payBackOwner );\n\n        removeServer(_serverIndex);\n    }\n\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller!=address(0) &&  server.owner == msg.sender);\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer( unregisterDeposit );\n\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        \n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        // if the blockhash is correct you cannot convict the server\n        require(blockhash(_blocknumber) != _blockhash);\n\n        // make sure the hash was signed by the owner of the server\n        require(ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner);\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit>0) {\n            uint payout = servers[_serverIndex].deposit/2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        removeServer(_serverIndex);\n\n    }\n    \n    // internal helpers\n    \n    function removeServer(uint _serverIndex) internal {\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner );\n        uint length = servers.length;\n        Web3Server memory m = servers[length - 1];\n        servers[_serverIndex] = m;\n        servers.length--;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x60\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x25\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\nstorage_0: 0x0\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6305,
        "code": "tract ServerRegistry {\n\n    uint internal constant unregisterDeposit = 100000;\n\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n    event LogServerUnregisterCanceled(string url, address owner);\n    event LogServerConvicted(string url, address owner);\n    event LogServerRemoved(string url, address owner);\n\n    struct Web3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint unregisterTime; // earliest timestamp in to to call unregister\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n    \n    Web3Server[] public servers;\n\n    function totalServers() public constant returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        // make sure this url and also this owner was not registered before.\n        bytes32 hash = keccak256(_url);\n        for (uint i=0;i<servers.length;i++) \n            require(keccak256(servers[i].url)!=hash && servers[i].owner!=msg.sender);\n\n        // create new Webserver\n        Web3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering this.\n    ///    in this case he has to wait for one hour before actually removing the server.\n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller==address(0x0));\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = now + 1 hours;\n        else {\n            server.unregisterTime = now + 28 days; // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value==unregisterDeposit);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender );\n    }\n    \n    function confirmUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller!=address(0x0) && server.unregisterTime < now);\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit/5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer( unregisterDeposit + server.deposit - payBackOwner );\n        }\n\n        if (payBackOwner>0)\n            server.owner.transfer( payBackOwner );\n\n        removeServer(_serverIndex);\n    }\n\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        Web3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller!=address(0) &&  server.owner == msg.sender);\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer( unregisterDeposit );\n\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        \n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        // if the blockhash is correct you cannot convict the server\n        require(blockhash(_blocknumber) != _blockhash);\n\n        // make sure the hash was signed by the owner of the server\n        require(ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner);\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit>0) {\n            uint payout = servers[_serverIndex].deposit/2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        removeServer(_serverIndex);\n\n    }\n    \n    // internal helpers\n    \n    function removeServer(uint _serverIndex) internal {\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner );\n        uint length = servers.length;\n        Web3Server memory m = servers[length - 1];\n        servers[_serverIndex] = m;\n        servers.length--;\n    }\n}",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x60\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nkeccac_0_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n6*storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\nstorage_0: 0x0\n",
        "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0xfdb0ea8ab08212a1fffdb35afacf37c3857083ca.sol",
        "function": "registerServer(string,uint256)",
        "lineno": 4,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}