{
  "contract": "0x75aa66b8405dcef0e935de1c1627196b704a0e91",
  "tool": "mythril",
  "start": 1563769925.1269019,
  "end": 1563771512.3992028,
  "duration": 1587.2723009586334,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 257,
        "code": "value);\n    } \n\n    modifier onlyO",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "fallback",
        "lineno": 29,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 3314,
        "code": "tamp, block.number, msg.value, _message);\n        running_id++;\n        donationWallet.transfer(msg",
        "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_4: 0x0\ncallvalue: 0x1\ncalldata_DonationGuestbook_0: 0xc190836000000000000000000000000000000000000000000000000000000000\ncalldatasize_DonationGuestbook: 0x4\n",
        "description": "A possible integer overflow exists in the function `createEntry(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "createEntry(string,string)",
        "lineno": 60,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3593,
        "code": "ntract DonationGuestbook {\n    struct Entry{\n        // structure for an guestbook entry\n        address owner;\n        string alias;\n        uint timestamp;\n        uint blocknumber;\n        uint donation;\n        string message;\n    }\n\n    address public owner; // Guestbook creator\n    address public donationWallet; // wallet to store donations\n    \n    uint public running_id = 0; // number of guestbook entries\n    mapping(uint=>Entry) public entries; // guestbook entries\n    uint public minimum_donation = 0; // to prevent spam in the guestbook\n\n    function DonationGuestbook() public { \n    // called at creation of contract\n        owner = msg.sender;\n        donationWallet = msg.sender;\n    }\n    \n    function() payable public {\n    // fallback function. In case somebody sends ether directly to the contract.\n        donationWallet.transfer(msg.value);\n    } \n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeDonationWallet(address _new_storage) public onlyOwner {\n    // in case the donation wallet address ever changes\n        donationWallet = _new_storage; \n    }\n\n    function changeOwner(address _new_owner) public onlyOwner {\n    // in case the owner ever changes\n        owner = _new_owner;\n    }\n\n    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n    // in case people spam into the guestbook\n        minimum_donation = _minDonation;\n    }\n\n    function destroy() onlyOwner public {\n    // kills the contract and sends all funds (which should be impossible to have) to the owner\n        selfdestruct(owner);\n    }\n\n    function createEntry(string _alias, string _message) payable public {\n    // called by a donator to make a donation + guestbook entry\n        require(msg.value > minimum_donation); // entries only for those that donate something\n        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n        running_id++;\n        donationWallet.transfer(msg.value);\n    }\n\n    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n    // for reading the entries of the guestbook\n        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n                entries[entry_id].donation, entries[entry_id].message);\n    }\n}",
        "debug": "storage_1 + keccac_storage_2: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_1_+_keccac_storage_2: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_4: 0x0\ncallvalue: 0x1\ncalldata_DonationGuestbook_0: 0xc190836000000000000000000000000000000000000000000000000000000000\ncalldatasize_DonationGuestbook: 0x4\n",
        "description": "A possible integer overflow exists in the function `createEntry(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "createEntry(string,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3622,
        "code": "ntract DonationGuestbook {\n    struct Entry{\n        // structure for an guestbook entry\n        address owner;\n        string alias;\n        uint timestamp;\n        uint blocknumber;\n        uint donation;\n        string message;\n    }\n\n    address public owner; // Guestbook creator\n    address public donationWallet; // wallet to store donations\n    \n    uint public running_id = 0; // number of guestbook entries\n    mapping(uint=>Entry) public entries; // guestbook entries\n    uint public minimum_donation = 0; // to prevent spam in the guestbook\n\n    function DonationGuestbook() public { \n    // called at creation of contract\n        owner = msg.sender;\n        donationWallet = msg.sender;\n    }\n    \n    function() payable public {\n    // fallback function. In case somebody sends ether directly to the contract.\n        donationWallet.transfer(msg.value);\n    } \n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeDonationWallet(address _new_storage) public onlyOwner {\n    // in case the donation wallet address ever changes\n        donationWallet = _new_storage; \n    }\n\n    function changeOwner(address _new_owner) public onlyOwner {\n    // in case the owner ever changes\n        owner = _new_owner;\n    }\n\n    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n    // in case people spam into the guestbook\n        minimum_donation = _minDonation;\n    }\n\n    function destroy() onlyOwner public {\n    // kills the contract and sends all funds (which should be impossible to have) to the owner\n        selfdestruct(owner);\n    }\n\n    function createEntry(string _alias, string _message) payable public {\n    // called by a donator to make a donation + guestbook entry\n        require(msg.value > minimum_donation); // entries only for those that donate something\n        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n        running_id++;\n        donationWallet.transfer(msg.value);\n    }\n\n    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n    // for reading the entries of the guestbook\n        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n                entries[entry_id].donation, entries[entry_id].message);\n    }\n}",
        "debug": "mem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_4: 0x0\ncallvalue: 0x1\ncalldata_DonationGuestbook_0: 0xc190836000000000000000000000000000000000000000000000000000000000\ncalldatasize_DonationGuestbook: 0x4\n",
        "description": "A possible integer overflow exists in the function `createEntry(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "createEntry(string,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3636,
        "code": "ntract DonationGuestbook {\n    struct Entry{\n        // structure for an guestbook entry\n        address owner;\n        string alias;\n        uint timestamp;\n        uint blocknumber;\n        uint donation;\n        string message;\n    }\n\n    address public owner; // Guestbook creator\n    address public donationWallet; // wallet to store donations\n    \n    uint public running_id = 0; // number of guestbook entries\n    mapping(uint=>Entry) public entries; // guestbook entries\n    uint public minimum_donation = 0; // to prevent spam in the guestbook\n\n    function DonationGuestbook() public { \n    // called at creation of contract\n        owner = msg.sender;\n        donationWallet = msg.sender;\n    }\n    \n    function() payable public {\n    // fallback function. In case somebody sends ether directly to the contract.\n        donationWallet.transfer(msg.value);\n    } \n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeDonationWallet(address _new_storage) public onlyOwner {\n    // in case the donation wallet address ever changes\n        donationWallet = _new_storage; \n    }\n\n    function changeOwner(address _new_owner) public onlyOwner {\n    // in case the owner ever changes\n        owner = _new_owner;\n    }\n\n    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n    // in case people spam into the guestbook\n        minimum_donation = _minDonation;\n    }\n\n    function destroy() onlyOwner public {\n    // kills the contract and sends all funds (which should be impossible to have) to the owner\n        selfdestruct(owner);\n    }\n\n    function createEntry(string _alias, string _message) payable public {\n    // called by a donator to make a donation + guestbook entry\n        require(msg.value > minimum_donation); // entries only for those that donate something\n        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n        running_id++;\n        donationWallet.transfer(msg.value);\n    }\n\n    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n    // for reading the entries of the guestbook\n        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n                entries[entry_id].donation, entries[entry_id].message);\n    }\n}",
        "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_4: 0x0\ncallvalue: 0x1\ncalldata_DonationGuestbook_0: 0xc190836000000000000000000000000000000000000000000000000000000000\ncalldatasize_DonationGuestbook: 0x4\n",
        "description": "A possible integer overflow exists in the function `createEntry(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "createEntry(string,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3653,
        "code": "ntract DonationGuestbook {\n    struct Entry{\n        // structure for an guestbook entry\n        address owner;\n        string alias;\n        uint timestamp;\n        uint blocknumber;\n        uint donation;\n        string message;\n    }\n\n    address public owner; // Guestbook creator\n    address public donationWallet; // wallet to store donations\n    \n    uint public running_id = 0; // number of guestbook entries\n    mapping(uint=>Entry) public entries; // guestbook entries\n    uint public minimum_donation = 0; // to prevent spam in the guestbook\n\n    function DonationGuestbook() public { \n    // called at creation of contract\n        owner = msg.sender;\n        donationWallet = msg.sender;\n    }\n    \n    function() payable public {\n    // fallback function. In case somebody sends ether directly to the contract.\n        donationWallet.transfer(msg.value);\n    } \n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeDonationWallet(address _new_storage) public onlyOwner {\n    // in case the donation wallet address ever changes\n        donationWallet = _new_storage; \n    }\n\n    function changeOwner(address _new_owner) public onlyOwner {\n    // in case the owner ever changes\n        owner = _new_owner;\n    }\n\n    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n    // in case people spam into the guestbook\n        minimum_donation = _minDonation;\n    }\n\n    function destroy() onlyOwner public {\n    // kills the contract and sends all funds (which should be impossible to have) to the owner\n        selfdestruct(owner);\n    }\n\n    function createEntry(string _alias, string _message) payable public {\n    // called by a donator to make a donation + guestbook entry\n        require(msg.value > minimum_donation); // entries only for those that donate something\n        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n        running_id++;\n        donationWallet.transfer(msg.value);\n    }\n\n    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n    // for reading the entries of the guestbook\n        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n                entries[entry_id].donation, entries[entry_id].message);\n    }\n}",
        "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0x25\nstorage_4: 0x0\ncallvalue: 0x1\ncalldata_DonationGuestbook_0: 0xc190836000000000000000000000000000000000000000000000000000000000\ncalldatasize_DonationGuestbook: 0x4\n",
        "description": "A possible integer overflow exists in the function `createEntry(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "createEntry(string,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3658,
        "code": "ntract DonationGuestbook {\n    struct Entry{\n        // structure for an guestbook entry\n        address owner;\n        string alias;\n        uint timestamp;\n        uint blocknumber;\n        uint donation;\n        string message;\n    }\n\n    address public owner; // Guestbook creator\n    address public donationWallet; // wallet to store donations\n    \n    uint public running_id = 0; // number of guestbook entries\n    mapping(uint=>Entry) public entries; // guestbook entries\n    uint public minimum_donation = 0; // to prevent spam in the guestbook\n\n    function DonationGuestbook() public { \n    // called at creation of contract\n        owner = msg.sender;\n        donationWallet = msg.sender;\n    }\n    \n    function() payable public {\n    // fallback function. In case somebody sends ether directly to the contract.\n        donationWallet.transfer(msg.value);\n    } \n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function changeDonationWallet(address _new_storage) public onlyOwner {\n    // in case the donation wallet address ever changes\n        donationWallet = _new_storage; \n    }\n\n    function changeOwner(address _new_owner) public onlyOwner {\n    // in case the owner ever changes\n        owner = _new_owner;\n    }\n\n    function changeMinimumDonation(uint _minDonation) public onlyOwner {\n    // in case people spam into the guestbook\n        minimum_donation = _minDonation;\n    }\n\n    function destroy() onlyOwner public {\n    // kills the contract and sends all funds (which should be impossible to have) to the owner\n        selfdestruct(owner);\n    }\n\n    function createEntry(string _alias, string _message) payable public {\n    // called by a donator to make a donation + guestbook entry\n        require(msg.value > minimum_donation); // entries only for those that donate something\n        entries[running_id] = Entry(msg.sender, _alias, block.timestamp, block.number, msg.value, _message);\n        running_id++;\n        donationWallet.transfer(msg.value);\n    }\n\n    function getEntry(uint entry_id) public constant returns (address, string, uint, uint, uint, string) {\n    // for reading the entries of the guestbook\n        return (entries[entry_id].owner, entries[entry_id].alias, entries[entry_id].blocknumber,  entries[entry_id].timestamp,\n                entries[entry_id].donation, entries[entry_id].message);\n    }\n}",
        "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DonationGuestbook_4 + calldata_DonationGuestbook_32 + 4)) +\n32: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nkeccac_1_+_keccac_storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0x0\ncallvalue: 0x1\ncalldata_DonationGuestbook_0: 0xc190836000000000000000000000000000000000000000000000000000000000\ncalldatasize_DonationGuestbook: 0x4\n",
        "description": "A possible integer overflow exists in the function `createEntry(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/44/0x75aa66b8405dcef0e935de1c1627196b704a0e91.sol",
        "function": "createEntry(string,string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}