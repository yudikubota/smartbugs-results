{
  "contract": "0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce",
  "tool": "mythril",
  "start": 1563322989.1597285,
  "end": 1563326646.5755494,
  "duration": 3657.415820837021,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 266,
        "code": "   require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareI",
        "debug": "calldata_WallCryptoStreet_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 91,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 278,
        "code": "   require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareI",
        "debug": "calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 91,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 287,
        "code": "   require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareI",
        "debug": "calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 91,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 293,
        "code": "   require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareI",
        "debug": "calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 91,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 592,
        "code": "nerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Lo",
        "debug": "storage_3: 0x2\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x84210421084001f00037c1056456000800070a1e0f00037c00008264da0803e\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037087: 0x0\ncaller: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037084: 0x0\ncalldata_WallCryptoStreet_0: 0x3e83fe3600000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getMyShares()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "getMyShares()",
        "lineno": 236,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1826,
        "code": "nies[_companyId].curA",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x0\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 94,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2631,
        "code": " return the deta",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_3: 0x0\ncalldata_WallCryptoStreet_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WallCryptoStreet_0: 0x1b1da1af00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "updateSharePrice(uint256,uint256)",
        "lineno": 191,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3415,
        "code": "t) {\n        ui",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037087: 0x0\ncaller: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037084: 0x0\ncalldata_WallCryptoStreet_0: 0x3e83fe3600000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "getMyShares()",
        "lineno": 245,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3597,
        "code": "is is the first ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_3: 0x0\ncalldata_WallCryptoStreet_0: 0x4cf3301000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 127,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3840,
        "code": "cfoAddress.transfer(commission1percen",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_0 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x0\nstorage_1: 0x0\nstorage_1 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\nstorage_3: 0x1\ncalldata_WallCryptoStreet_0: 0x4cf3301000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_2 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 133,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3941,
        "code": "cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } el",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4049\n",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 133,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4192,
        "code": "s[_shareId].companyId].ownerAddress.transfer(commission1percent",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4470\nCall at address: 4362\n",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 137,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4261,
        "code": "dress.transfer(commission1percent * 5",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_0 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x0\nretval_4192: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_1 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_3: 0x1\ncalldata_WallCryptoStreet_0: 0x4cf3301000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_2 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 138,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4362,
        "code": "dress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        /",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4470\n",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 138,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4633,
        "code": " = msg.sender;\n        addressSharesCount[msg.sende",
        "debug": "storage_0 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\ncalldata_WallCryptoStreet_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_1_+\n87903029871075914254377627908054574944891091886930582284385770809450030037083_+\n3*calldata_WallCryptoStreet_4,\n_____256): 0x0\nretval_4049: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_3941: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x1\nstorage_1: 0x0\nstorage_1 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\nstorage_3: 0x1\ncalldata_WallCryptoStreet_0: 0x4cf3301000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_2 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `purchaseShare(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 144,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 4807,
        "code": " + (shares[_shareId].curPrice / ",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\ncalldata_WallCryptoStreet_4: 0x0\nretval_4049: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nretval_3941: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0x1\nstorage_1: 0x0\nstorage_1 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\nstorage_3: 0x1\ncalldata_WallCryptoStreet_0: 0x4cf3301000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_2 +\n87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n3*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `purchaseShare(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseShare(uint256)",
        "lineno": 148,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5393,
        "code": ";\n\n/*\nGame Name: W",
        "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x5ea050ec00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `InitiateCompanies()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "InitiateCompanies()",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5445,
        "code": "\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(compa",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x4e35aacf00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createCompany(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "createCompany(string,uint256)",
        "lineno": 297,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6788,
        "code": "ompany.curAdText;\n   ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x0\ncalldata_WallCryptoStreet_0: 0x57d1391700000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "getCompany(uint256)",
        "lineno": 209,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8200,
        "code": " \n    /*\n    The owne",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x0\ncalldata_WallCryptoStreet_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WallCryptoStreet_0: 0x664eb12e00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "updateCompanyPrice(uint256,uint256)",
        "lineno": 178,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8730,
        "code": "*/\n    function ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_3: 0x0\ncalldata_WallCryptoStreet_0: 0xcfb5a5f800000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "getShare(uint256)",
        "lineno": 231,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8825,
        "code": "se);\n\n        // Calc",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x0\ncalldata_WallCryptoStreet_0: 0xea6c118000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseCompany(uint256)",
        "lineno": 66,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9607,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "keccac_4_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*calldata_WallCryptoStreet_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_4 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x1\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_3 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9636,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "keccac_4_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*calldata_WallCryptoStreet_4: 0xd9ca011060000000000000000000000000000000000000000000000000000000\nstorage_4 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0x8000000000001ffffc00000001c1000001000000000000000000000000780\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4)): 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_WallCryptoStreet_4: 0x0\ncalldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4: 0x0\nstorage_2: 0x1\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_3 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9650,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4: 0x0\nkeccac_4_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*calldata_WallCryptoStreet_4: 0x0\nstorage_4 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0x41\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x1\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_3 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9672,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_32 + 4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_4_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*calldata_WallCryptoStreet_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WallCryptoStreet_4: 0x0\nstorage_2: 0x1\ncalldata_WallCryptoStreet_0: 0xdb8158000000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\nstorage_3 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*calldata_WallCryptoStreet_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `purchaseAd(uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "purchaseAd(uint256,string,string)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9735,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "keccac_0_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*storage_2: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*storage_2: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_5: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x5ea050ec00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `InitiateCompanies()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "InitiateCompanies()",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9764,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "keccac_0_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*storage_2: 0xfe6c3882c8c219105b1269338c14a907b57fe56d7e7402ce023400000973b6fb\nstorage_0 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n7*storage_2: 0xfde7dbef9fbcee952ba2fefcee7f3f46f6fffcffffffffffffffffffffffffc5\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n128: 0x8000000000000000000000000000000000000000000000000000000000000000\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x4e35aacf00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createCompany(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "createCompany(string,uint256)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9778,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x4e35aacf00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createCompany(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "createCompany(string,uint256)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9795,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0x25\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x4e35aacf00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createCompany(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "createCompany(string,uint256)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9800,
        "code": "CryptoStreet {\n\n    address ceoAddress = 0x9aFbaA3003D9e75C35FdE2D1fd283b13d3335f00;\n    address cfoAddress = 0x23a49A9930f5b562c6B1096C3e6b5BEc133E8B2E;\n    \n    modifier onlyCeo() {\n        require (msg.sender == ceoAddress);\n        _;\n    }\n    \n    struct Company {\n        string name;\n        address ownerAddress;\n        uint256 curPrice;\n        uint256 curAdPrice;\n        string curAdText;\n        string curAdLink;\n        uint256 volume;\n    }\n    Company[] companies;\n\n    struct Share {\n        uint companyId;\n        address ownerAddress;\n        uint256 curPrice;\n    }\n    Share[] shares;\n\n    // How many shares an addres own\n    mapping (address => uint) public addressSharesCount;\n    bool companiesAreInitiated;\n    bool isPaused;\n    \n    /*\n    We use the following functions to pause and unpause the game.\n    */\n    function pauseGame() public onlyCeo {\n        isPaused = true;\n    }\n    function unPauseGame() public onlyCeo {\n        isPaused = false;\n    }\n    function GetIsPauded() public view returns(bool) {\n       return(isPaused);\n    }\n\n    /*\n    This function allows players to purchase companies from other players. \n    The price is automatically multiplied by 1.5 after each purchase.\n    */\n    function purchaseCompany(uint _companyId) public payable {\n        require(msg.value == companies[_companyId].curPrice);\n        require(isPaused == false);\n\n        // Calculate the 5% value\n        uint256 commission5percent = ((msg.value / 10)/2);\n\n        // Calculate the owner commission on this sale & transfer the commission to the owner.      \n        uint256 commissionOwner = msg.value - commission5percent; // => 95%\n        companies[_companyId].ownerAddress.transfer(commissionOwner);\n\n        // Transfer the 5% commission to the developer\n        cfoAddress.transfer(commission5percent); // => 5%                   \n\n        // Update the company owner and set the new price\n        companies[_companyId].ownerAddress = msg.sender;\n        companies[_companyId].curPrice = companies[_companyId].curPrice + (companies[_companyId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n    \n    /*\n    We use this function to allow users to purchase advertisment from a listing. \n    Ad is visible until someone pays more than the previous user\n    */\n    function purchaseAd(uint _companyId, string adText, string adLink) public payable {\n        require(msg.value == companies[_companyId].curAdPrice);\n\n        // Save text and link for the ad\n        companies[_companyId].curAdText = adText;\n        companies[_companyId].curAdLink = adLink;\n\n        // Distribute the money paid among investors, company owner and dev\n        uint256 commission1percent = (msg.value / 100);\n        companies[_companyId].ownerAddress.transfer(commission1percent * 40);   // Company owner gets 40% of the amount paid\n        cfoAddress.transfer(commission1percent * 10);   // Dev gets a commission of 10% of the amount paid\n\n        uint256 commissionShareholders = commission1percent * 50;   // 50% of the amount paid is distributed to shareholders\n        uint256 commissionOneShareholder = commissionShareholders / 5;\n\n        // Get the list of shareholders for this company\n        address[] memory shareholdersAddresses = getCompanyShareholders(_companyId);\n        // We loop thrugh all of the shareholders and transfer their commission\n        for (uint8 i = 0; i < 5; i++) {\n            shareholdersAddresses[i].transfer(commissionOneShareholder);\n        }\n\n        // Raise the price of the advertising\n        companies[_companyId].curAdPrice = companies[_companyId].curAdPrice + (companies[_companyId].curAdPrice / 2);\n\n        // Increment volume generated by company\n        companies[_companyId].volume = companies[_companyId].volume + msg.value;\n    }\n\n    /*\n    This function is used to handle the purchase of a share.\n    */\n    function purchaseShare(uint _shareId) public payable {\n        require(msg.value == shares[_shareId].curPrice);\n    \n        uint256 commission1percent = (msg.value / 100);\n        /*\n        We check if this is the first purchase of a share or a \"repurchase\".\n        If it's the first purchase we transfer a larger commission to the company owner\n        */\n        if(shares[_shareId].ownerAddress == cfoAddress) {\n            // This is the initial sale\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 80); // 80% goes to the company owner\n            cfoAddress.transfer(commission1percent * 20);    // 20% goes to the dev\n        } else {\n            // This is a consecutive sale\n            shares[_shareId].ownerAddress.transfer(commission1percent * 85);    // 85% goes to the previous shareholder\n            companies[shares[_shareId].companyId].ownerAddress.transfer(commission1percent * 10); // 10% goes to the company owner\n            cfoAddress.transfer(commission1percent * 5);    // 5% goes to the dev\n        }\n        // Decrement count shares previous user\n        addressSharesCount[shares[_shareId].ownerAddress]--;\n        \n        // Update the owner of the share\n        shares[_shareId].ownerAddress = msg.sender;\n        addressSharesCount[msg.sender]++;\n        \n        // Raise the price of the share\n        shares[_shareId].curPrice = shares[_shareId].curPrice + (shares[_shareId].curPrice / 2);\n        \n        // Increment volume generated by company\n        companies[shares[_shareId].companyId].volume = companies[shares[_shareId].companyId].volume + msg.value;\n    }\n\n    // This function will return an array of addresses of the company shareholders (very useful to transfer their ad commission)\n    function getCompanyShareholders(uint _companyId) public view returns(address[]) {\n        address[] memory result = new address[](5);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].companyId == _companyId) {\n            result[counter] = shares[i].ownerAddress;\n            counter++;\n          }\n        }\n        return result;\n    }\n\n    /*\n    The owner of a company can reduce the price of the company using this function.\n    The price can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateCompanyPrice(uint _companyId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(companies[_companyId].ownerAddress == msg.sender);\n        require(_newPrice < companies[_companyId].curPrice);\n        companies[_companyId].curPrice = _newPrice;\n    }\n    \n    /*\n    The owner of a share can reduce the price of the selected share using this function.\n    The price of the share can be reduced but cannot be bigger.\n    The price is set in WEI.\n    */\n    function updateSharePrice(uint _shareId, uint256 _newPrice) public {\n        require(_newPrice > 0);\n        require(shares[_shareId].ownerAddress == msg.sender);\n        require(_newPrice < shares[_shareId].curPrice);\n        shares[_shareId].curPrice = _newPrice;\n    }\n    \n    // This function will return the details of a company\n    function getCompany(uint _companyId) public view returns (\n        string name,\n        address ownerAddress,\n        uint256 curPrice,\n        uint256 curAdPrice,\n        string curAdText,\n        string curAdLink,\n        uint shareId,   // The id of the least expensive share of this company\n        uint256 sharePrice,  // The price of the least expensive share of this company\n        uint256 volume\n    ) {\n        Company storage _company = companies[_companyId];\n\n        name = _company.name;\n        ownerAddress = _company.ownerAddress;\n        curPrice = _company.curPrice;\n        curAdPrice = _company.curAdPrice;\n        curAdText = _company.curAdText;\n        curAdLink = _company.curAdLink;\n        shareId = getLeastExpensiveShare(_companyId,0);\n        sharePrice = getLeastExpensiveShare(_companyId,1);\n        volume = _company.volume;\n    }\n\n    // This function will return the details of a share\n    function getShare(uint _shareId) public view returns (\n        uint companyId,\n        address ownerAddress,\n        uint256 curPrice\n    ) {\n        Share storage _share = shares[_shareId];\n\n        companyId = _share.companyId;\n        ownerAddress = _share.ownerAddress;\n        curPrice = _share.curPrice;\n    }\n    \n    /*\n    This function will return the shares owned by the sender.\n    */\n    function getMyShares() public view returns(uint[]) {\n        uint[] memory result = new uint[](addressSharesCount[msg.sender]);\n        uint counter = 0;\n        for (uint i = 0; i < shares.length; i++) {\n          if (shares[i].ownerAddress == msg.sender) {\n            result[counter] = i;\n            counter++;\n          }\n        }\n        return result;\n    }\n    \n    // Get least expensive share of one company\n    function getLeastExpensiveShare(uint _companyId, uint _type) public view returns(uint) {\n        uint _shareId = 0;\n        uint256 _sharePrice = 999000000000000000000;\n\n        // Loop through all the shares of this company\n        for (uint8 i = 0; i < shares.length; i++) {\n            // Get only the shares of this company\n            if(shares[i].companyId == _companyId) {\n                // Check if this share is less expensive than the previous and if it's not already owned by the connected user\n                if(shares[i].curPrice < _sharePrice && shares[i].ownerAddress != msg.sender) {\n                    _sharePrice = shares[i].curPrice;\n                    _shareId = i;\n                }\n            }\n        }\n\n        // Return the price or the id of the company's least expensive share\n        if(_type == 0) {\n            return(_shareId);\n        } else {\n            return(_sharePrice);\n        }\n    }\n    \n    /**\n    @dev Multiplies two numbers, throws on overflow. => From the SafeMath library\n    */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n          return 0;\n        }\n        uint256 c = a * b;\n        assert(c / a == b);\n        return c;\n    }\n\n    /**\n    @dev Integer division of two numbers, truncating the quotient. => From the SafeMath library\n    */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        // assert(b > 0); // Solidity automatically throws when dividing by 0\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n        return c;\n    }\n    \n    // The dev can use this function to create new companies.\n    function createCompany(string _companyName, uint256 _companyPrice) public onlyCeo {\n        uint companyId = companies.push(Company(_companyName, cfoAddress, _companyPrice, 10000000000000000, \"0\", \"#\",0)) - 1;\n        // The initial price of a share is always the initial price of a company / 10.\n        uint256 sharePrice = _companyPrice / 10;\n        \n        // We create 5 shares for this company\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n        shares.push(Share(companyId, cfoAddress, sharePrice));\n    }\n    \n    // Initiate functions that will create the companies\n    function InitiateCompanies() public onlyCeo {\n        require(companiesAreInitiated == false);\n        createCompany(\"Apple\", 350000000000000000); \n        createCompany(\"Snapchat\", 200000000000000000); \n        createCompany(\"Facebook\", 250000000000000000); \n        createCompany(\"Google\", 250000000000000000); \n        createCompany(\"Microsoft\", 350000000000000000); \n        createCompany(\"Nintendo\", 150000000000000000); \n        createCompany(\"Mc Donald\", 250000000000000000); \n        createCompany(\"Kodak\", 100000000000000000);\n        createCompany(\"Twitter\", 100000000000000000);\n\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nkeccac_0_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n7*storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WallCryptoStreet_4 + calldata_WallCryptoStreet_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WallCryptoStreet_0: 0x4e35aacf00000000000000000000000000000000000000000000000000000000\ncalldatasize_WallCryptoStreet: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createCompany(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xcf3a6ec03b0e8e8525933d4e2439d4d5ee2763ce.sol",
        "function": "createCompany(string,uint256)",
        "lineno": 14,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}