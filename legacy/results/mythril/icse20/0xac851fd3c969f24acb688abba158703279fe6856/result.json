{
  "contract": "0xac851fd3c969f24acb688abba158703279fe6856",
  "tool": "mythril",
  "start": 1563560646.454657,
  "end": 1563561557.8925812,
  "duration": 911.4379241466522,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 465,
        "code": "ive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    fun",
        "debug": "calldata_TVLottery_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TVLottery_0: 0xb1202bb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0b1202bb`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0b1202bb",
        "lineno": 271,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3805,
        "code": "lectionByIndex(uint id, uint index) public view returns(uint) {\n        return lot",
        "debug": "mem_160 +\n32*calldata_TVLottery_4 + calldata_TVLottery_32 + 36 +\n64: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xcf8e8c300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0cf8e8c3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0cf8e8c3",
        "lineno": 257,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4220,
        "code": "lottery.bankPercentage;\n        return chest.percen",
        "debug": "storage_keccac_storage_keccac_calldata_TVLottery_4_+_1 + 2: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_TVLottery_0: 0x10cd3f0a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getChestReward(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getChestReward(uint256)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4222,
        "code": "lottery.bankPercentage;\n        return chest.percen",
        "debug": "storage_keccac_storage_keccac_calldata_TVLottery_4_+_1 + 2: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_TVLottery_0: 0x10cd3f0a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getChestReward(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getChestReward(uint256)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4525,
        "code": "   function getKey(uint lotteryId, uint collecti",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getChestReward(uint256)",
        "lineno": 180,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4525,
        "code": "   function getKey(uint lotteryId, uint collecti",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function getChestReward(uint256). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getChestReward(uint256)",
        "lineno": 180,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 4597,
        "code": "returns (uint) {\n        Lottery mem",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_storage_keccac_calldata_TVLottery_4_+_1 + 2: 0x8000000000000000000000000000000000000000000000000000000000000000\nreturndatasize: 0x20\nretval_4525: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TVLottery_0: 0x10cd3f0a00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\nstorage_keccac_storage_keccac_calldata_TVLottery_4_+_1 + 3: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getChestReward(uint256)",
        "lineno": 180,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5272,
        "code": "nt,\n        bool created\n    )",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TVLottery_32 + 4: 0x0\nstorage_1 + keccac_calldata_TVLottery_4: 0x0\ncalldata_TVLottery_0: 0x7f4d1ee300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getCollectionElementByIndex(uint256,uint256)",
        "lineno": 236,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5318,
        "code": "ublic onlyOwnerOrManager {\n  ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TVLottery_32 + 4: 0x0\nstorage_2 + keccac_calldata_TVLottery_4: 0x0\nstorage_1 + keccac_calldata_TVLottery_4: 0x1\ncalldata_TVLottery_0: 0x7f4d1ee300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getCollectionElementByIndex(uint256,uint256)",
        "lineno": 238,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5409,
        "code": "  }\n\n    function updateCollecti",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TVLottery_32 + 4: 0x0\nstorage_2 + keccac_calldata_TVLottery_4: 0x0\ncalldata_TVLottery_0: 0x8078267100000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "getLotteryCollectionByIndex(uint256,uint256)",
        "lineno": 264,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 11253,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "storage_2 + keccac_calldata_TVLottery_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nkeccac_2_+_keccac_calldata_TVLottery_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xb1202bb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0b1202bb`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0b1202bb",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11264,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "calldata_TVLottery_4 + calldata_TVLottery_32 + 4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xb1202bb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0b1202bb`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0b1202bb",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11266,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "calldata_TVLottery_4 + calldata_TVLottery_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xb1202bb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0b1202bb`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0b1202bb",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11288,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "calldata_TVLottery_4 + calldata_TVLottery_32 + 4: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nkeccac_2_+_keccac_calldata_TVLottery_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xb1202bb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0b1202bb`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0b1202bb",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11330,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "storage_2 + keccac_calldata_TVLottery_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nkeccac_2_+_keccac_calldata_TVLottery_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xcf8e8c300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0cf8e8c3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0cf8e8c3",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11341,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "mem_mem_160 +\n32*calldata_TVLottery_4 + calldata_TVLottery_32 + 36 +\n64: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xcf8e8c300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0cf8e8c3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0cf8e8c3",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11343,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "mem_160 +\n32*calldata_TVLottery_4 + calldata_TVLottery_32 + 36 +\n64: 0x7fffffffffffffffffffffffffffffffffffffdaffffffffbfff7fffffffffe0\nmem_mem_160 +\n32*calldata_TVLottery_4 + calldata_TVLottery_32 + 36 +\n64: 0x7f6fc32c410701432cb30000000000000000000dfffffff3fc0000000000000\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xcf8e8c300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0cf8e8c3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0cf8e8c3",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11365,
        "code": "TVTokenAddress;\n    address public TVKeyAddress;\n\n    struct Collection {\n        uint id;\n        uint[] typeIds;\n        address[] tokens;\n        uint chestId;\n        uint lotteryId;\n        bool created;\n    }\n\n    struct Lottery {\n        uint id;\n        address bank;\n        uint[] collections;\n        uint bankPercentage;\n        bool isActive;\n        bool created;\n    }\n\n    struct Chest {\n        uint id;\n        uint lotteryId;\n        uint percentage;\n        uint count;\n        uint keysCount;\n        uint openedCount;\n        bool created;\n    }\n\n    mapping(uint => Lottery) public lotteries;\n    mapping(uint => Chest) public chests;\n    mapping(uint => Collection) public collections;\n    mapping(uint => mapping(address => bool)) public usedElements;\n\n    event KeyReceived(uint keyId, uint lotteryId, uint collectionId, uint chestId, address receiver);\n    event ChestOpened(uint keyId, uint lotteryId, uint chestId, uint reward, address receiver);\n    event ArtefactUsed(uint id, address token, address sender);\n\n    modifier onlyOwnerOrManager() {\n        require(msg.sender == owner || manager == msg.sender);\n        _;\n    }\n\n    constructor(\n        address _TVTokenAddress,\n        address _TVKeyAddress,\n        address _manager\n    ) public {\n        manager = _manager;\n        TVTokenAddress = _TVTokenAddress;\n        TVKeyAddress = _TVKeyAddress;\n    }\n\n    function onERC721Received(\n        address _from,\n        uint256 _tokenId,\n        bytes\n    ) public returns (bytes4) {\n        require(msg.sender == TVKeyAddress);\n        (, uint chestId) = ITVKey(TVKeyAddress).keys(_tokenId);\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n\n        ITVKey(TVKeyAddress).transferFrom(this, lottery.bank, _tokenId);\n        lotteries[chest.lotteryId].bankPercentage -= chest.percentage;\n        chests[chestId].openedCount = chest.openedCount + 1;\n        uint reward = getChestReward(chestId);\n        ITVToken(TVTokenAddress).transferFrom(lottery.bank, _from, reward);\n        emit ChestOpened(_tokenId, lottery.id, chest.id, reward, _from);\n        return ERC721_RECEIVED;\n    }\n\n    function getChestReward(uint chestId) public view returns (uint) {\n        Chest memory chest = chests[chestId];\n        Lottery memory lottery = lotteries[chest.lotteryId];\n        uint bankBalance = ITVToken(TVTokenAddress).balanceOf(lottery.bank);\n        uint onePercentage = bankBalance / lottery.bankPercentage;\n        return chest.percentage * onePercentage;\n    }\n\n    function getKey(uint lotteryId, uint collectionId, uint[] elementIds) public returns (uint) {\n        Lottery memory lottery = lotteries[lotteryId];\n        Collection memory collection = collections[collectionId];\n        Chest memory chest = chests[collection.chestId];\n\n        require(collection.lotteryId == lotteryId);\n        require(lottery.created && lottery.isActive && collection.created);\n        require(chest.keysCount > 0);\n\n        checkCollection(collection, elementIds);\n\n        chests[collection.chestId].keysCount = chest.keysCount - 1;\n        uint keyId = ITVKey(TVKeyAddress).mint(msg.sender, chest.id);\n        emit KeyReceived(keyId, lotteryId, collectionId, chest.id, msg.sender);\n\n        return keyId;\n    }\n\n    function checkCollection(Collection collection, uint[] elementsIds) internal {\n        require(elementsIds.length == collection.typeIds.length);\n        for (uint i = 0; i < elementsIds.length; i++) {\n            (uint id, uint typeId) = IArtefact(collection.tokens[i]).artefacts(elementsIds[i]);\n            require(typeId == collection.typeIds[i]);\n            require(!usedElements[id][collection.tokens[i]]);\n            require(IArtefact(collection.tokens[i]).ownerOf(id) == msg.sender);\n            usedElements[id][collection.tokens[i]] = true;\n            emit ArtefactUsed(id, collection.tokens[i], msg.sender);\n        }\n    }\n\n    function setCollection(\n        uint id,\n        uint[] typeIds,\n        address[] tokens,\n        uint chestId,\n        uint lotteryId,\n        bool created\n    ) public onlyOwnerOrManager {\n        require(typeIds.length == tokens.length);\n        collections[id] = Collection(id, typeIds, tokens, chestId, lotteryId, created);\n    }\n\n    function getCollectionElementsCount(uint id) public view returns(uint) {\n        return collections[id].typeIds.length;\n    }\n\n    function getCollectionElementByIndex(uint id, uint index) public view returns(uint, address) {\n        return (collections[id].typeIds[index], collections[id].tokens[index]);\n    }\n\n    function setChest(\n        uint lotteryId,\n        uint id,\n        uint percentage,\n        uint count,\n        uint keysCount,\n        uint openedCount,\n        bool created\n    ) public onlyOwnerOrManager {\n        chests[id] = Chest(id, lotteryId, percentage, count, keysCount, openedCount, created);\n    }\n\n    function setLottery(\n        uint id,\n        address bank,\n        uint[] _collections,\n        uint bankPercentage,\n        bool isActive,\n        bool created\n    ) public onlyOwnerOrManager {\n        lotteries[id] = Lottery(id, bank, _collections, bankPercentage, isActive, created);\n    }\n\n    function getLotteryCollectionCount(uint id) public view returns(uint) {\n        return lotteries[id].collections.length;\n    }\n\n    function getLotteryCollectionByIndex(uint id, uint index) public view returns(uint) {\n        return lotteries[id].collections[index];\n    }\n\n    function changeLotteryBank(uint lotteryId, address bank, uint bankPercentage) public onlyOwnerOrManager {\n        lotteries[lotteryId].bank = bank;\n        lotteries[lotteryId].bankPercentage = bankPercentage;\n    }\n\n    function updateCollections(uint lotteryId, uint[] _collections) public onlyOwnerOrManager {\n        lotteries[lotteryId].collections = _collections;\n    }\n\n    function setLotteryActive(uint id, bool isActive) public onlyOwnerOrManager {\n        lotteries[id].isActive = isActive;\n    }\n\n    function changeTVTokenAddress(address newAddress) public onlyOwnerOrManager {\n        TVTokenAddress = newAddress;\n    }\n\n    function changeTVKeyAddress(address newAddress) public onlyOwnerOrManager {\n        TVKeyAddress = newAddress;\n    }\n\n    function setManager(address _manager) public onlyOwner {\n        manager = _manager;\n    }\n}",
        "debug": "mem_160 +\n32*calldata_TVLottery_4 + calldata_TVLottery_32 + 36 +\n64: 0x9c07de0effffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nkeccac_2_+_keccac_calldata_TVLottery_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_mem_160 +\n32*calldata_TVLottery_4 + calldata_TVLottery_32 + 36 +\n64: 0x180000000000000000000000000000000000000000000000000000000000\nstorage_1: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_TVLottery_0: 0xcf8e8c300000000000000000000000000000000000000000000000000000000\ncalldatasize_TVLottery: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x0cf8e8c3`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xac851fd3c969f24acb688abba158703279fe6856.sol",
        "function": "_function_0x0cf8e8c3",
        "lineno": 98,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}