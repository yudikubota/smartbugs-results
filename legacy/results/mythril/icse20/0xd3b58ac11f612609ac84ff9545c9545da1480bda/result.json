{
  "contract": "0xd3b58ac11f612609ac84ff9545c9545da1480bda",
  "tool": "mythril",
  "start": 1563503433.5454013,
  "end": 1563503845.1438625,
  "duration": 411.59846115112305,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1218,
        "code": "dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = ",
        "debug": "calldata_TokenDistributor_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenDistributor_0: 0xa543a7e500000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\n",
        "description": "A possible integer overflow exists in the function `_function_0xa543a7e5`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "_function_0xa543a7e5",
        "lineno": 253,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2268,
        "code": "easedToken, uint _releasableToken) {",
        "debug": "mem_0 +\n192 +\n32*calldata_TokenDistributor_4 + calldata_TokenDistributor_4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_6: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nmem_128 +\n32 +\n32*calldata_TokenDistributor_4 + calldata_TokenDistributor_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x1a38fa0600000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\ncalldata_TokenDistributor_4 + calldata_TokenDistributor_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\n",
        "description": "A possible integer overflow exists in the function `_function_0x1a38fa06`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "_function_0x1a38fa06",
        "lineno": 343,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2635,
        "code": "[_tokenReceiver];\n        uint releasableToken;\n\n     ",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "_function_0x1a38fa06",
        "lineno": 345,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 2635,
        "code": "[_tokenReceiver];\n        uint releasableToken;\n\n     ",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2635\n",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "_function_0x1a38fa06",
        "lineno": 345,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 3134,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "viewContractHoldingToken()",
        "lineno": 381,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4223,
        "code": "    _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffe\nstorage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffd\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x6552d8b400000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `removeReceiver(address)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "removeReceiver(address)",
        "lineno": 292,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 5264,
        "code": " }\n    \n    function ",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "_function_0xa543a7e5",
        "lineno": 269,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5843,
        "code": " checked approved amo",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "transfer(address,uint256)",
        "lineno": 330,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 7577,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "viewNextRelease(address)",
        "lineno": 381,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 8480,
        "code": "ceiver, releasableToken);\n        emit Rel",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1000000000000000000000000000000\nstorage_0 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xc69e8cb480d249800d8b18113efb0a0406fb6d6af3be30227394d149b0140a07\nstorage_0 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xb6a8628978db7dbf7e57881b1fcbf3f7f6020e2614923dcb8bb6d601a7b7e275\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_TokenDistributor: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "fallback",
        "lineno": 316,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8547,
        "code": "t _amount) public onlyOwner {\n        ",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x2\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbd6ab435093efde61c2b93756939813074d47c5862d860753fcb0455ff40337a\nstorage_0 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe13093b3ecab5a297cb0746594433636d011810202d5387edd40000940000000\nstorage_0 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe51221ec3687bb056211507353006d7449853a004a073e7fdf497755cfad1c42\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_TokenDistributor: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "fallback",
        "lineno": 320,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8563,
        "code": "dedAmountTotal.add(_amount) <= token.b",
        "debug": "storage_4: 0xbd6ab435093efde61c2b93756939813074d47c5862d860753fcb0455ff40337a\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x2\nstorage_0 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe13093b3ecab5a297cb0746594433636d011810202d5387edd40000940000000\nstorage_0 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe51221ec3687bb056211507353006d7449853a004a073e7fdf497755cfad1c42\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_TokenDistributor: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "fallback",
        "lineno": 321,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8579,
        "code": "is) && token.balanceOf(this) > 0);\n   ",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x2\nstorage_0 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x4000000000000000000000000000000000000000000000000000000000000000\nstorage_0 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x4000000000000000000000000000000000000000000000000000000000000000\ntimestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\n2 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1 +\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_TokenDistributor: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `fallback`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "fallback",
        "lineno": 321,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 8786,
        "code": "to, _amount);\n    }\n    \n    //should be set fo",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "fallback",
        "lineno": 322,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 8971,
        "code": "@title ERC20Ba",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0x1\ncalldata_TokenDistributor_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_5843: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0xa9059cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "transfer(address,uint256)",
        "lineno": 51,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 9001,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TokenDistributor_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x4c69ec9300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeReceiver(address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "changeReceiver(address,address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9003,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x4522846f8a480087ded1df3dd4eba28607966bc300b077b978d5d6ec3644e4af\nkeccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0xab35dd14103840033983a97295e767efe80e1872fe7e8ffcfdee28e74a899e9e\ncalldata_TokenDistributor_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x4c69ec9300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeReceiver(address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "changeReceiver(address,address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9022,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4 +\n2: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TokenDistributor_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x4c69ec9300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeReceiver(address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "changeReceiver(address,address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9024,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4_+\n2: 0x521df086832ac8e2687fcff786313c7f9dc4a66107ec36d807e5aaa48b97d73c\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4 +\n2: 0x5dc43f1a483401c0aa3ff7f2d3df3030088017691be5f07dbafd117c960f2c4b\ncalldata_TokenDistributor_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x4c69ec9300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeReceiver(address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "changeReceiver(address,address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9066,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "keccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4_+\n2: 0x303f780f82f31a0225e593d72fda98ae4b00fab38675b06ec059c3d1cc9b8ffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4 +\n2: 0x813062b6d38a88715d67699554c0c572c6784e860acdef4a43b81ac2e676f0f\ncalldata_TokenDistributor_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x4c69ec9300000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_32_+_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `changeReceiver(address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "changeReceiver(address,address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9100,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4 +\n2: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4: 0x0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x6552d8b400000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeReceiver(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "removeReceiver(address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9112,
        "code": "neededAmountTotal;\n    uint public releasedTokenTotal;\n\n    address public approver;\n    uint public distributedBountyTotal;\n\n    struct DistributeList {\n        uint totalAmount;\n        uint releasedToken;\n        LockUpData[] lockUpData;\n    }    \n\n    struct LockUpData {\n        uint amount;\n        uint releaseDate;\n    }\n\n    /*\n    //\n    // address for DateTime should be changed before contract deploying.\n    //\n    */\n    //address public dateTimeAddr = 0xF0847087aAf608b4732be58b63151bDf4d548612;\n    //DateTime public dateTime = DateTime(dateTimeAddr);    \n    DateTime public dateTime;\n    \n    mapping (address => DistributeList) public distributeList;    \n\n    /*\n    //  events\n    */\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n    event OwnershipTransferRequsted(address indexed previousOwner, address indexed newOwner);\n    \n    event ReceiverChanged(address indexed previousReceiver, address indexed newReceiver);\n    event ReceiverRemoved(address indexed tokenReceiver);\n    \n    event ReleaseToken(address indexed tokenReceiver, uint amount);\n\n    event BountyDistributed(uint listCount, uint amount);\n   \n   /*\n   //   modifiers\n   */\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n    \n    /* constructor */\n    function TokenDistributor(ERC20 _tokenAddr, address _dateTimeAddr) public {\n        owner = msg.sender;\n        token = _tokenAddr;\n        dateTime = DateTime(_dateTimeAddr); \n    }\n\n    /* fallback */\n    function () external  {\n        releaseToken();\n    }\n\n    function requestTransferOwnership(address newOwner) public onlyOwner {\n        require(newOwner != address(0));\n        emit OwnershipTransferRequsted(owner, newOwner);\n        newOwnerCandidate = newOwner;\n    }\n\n    function receiveTransferOwnership() public {\n        require(newOwnerCandidate == msg.sender);\n        emit OwnershipTransferred(owner, newOwnerCandidate);\n        owner = newOwnerCandidate;\n    }\n\n    function addLockUpData(address _receiver, uint[] _amount, uint[] _releaseDate) public payable onlyOwner {\n        require(_amount.length == _releaseDate.length && _receiver != address(0));\n\n        uint tokenReserve;\n        DistributeList storage dl = distributeList[_receiver];\n\n        // check amount of lock token\n        for (uint i = 0; i < _amount.length; i++) {\n            tokenReserve += _amount[i];\n        }\n        \n        require(neededAmountTotal.add(tokenReserve) <= token.balanceOf(this));\n\n        for (i = 0; i < _amount.length; i++) {\n            dl.lockUpData.push(LockUpData(_amount[i], _releaseDate[i]));\n        }\n        \n        dl.totalAmount += tokenReserve;\n        neededAmountTotal += tokenReserve;\n        \n    }\n    \n    function changeReceiver(address _from, address _to) public onlyOwner {\n        //change only when _to address has 0 amount (means new address)\n        require(_to != address(0) && distributeList[_to].totalAmount == 0);\n        \n        distributeList[_to] = distributeList[_from];\n        delete distributeList[_from];\n        emit ReceiverChanged(_from, _to);\n    }\n    \n    function removeReceiver(address _receiver) public onlyOwner {\n        require(distributeList[_receiver].totalAmount >= distributeList[_receiver].releasedToken);\n        \n        //adjust neededAmountTotal when lockupdata removing.\n        neededAmountTotal -= (distributeList[_receiver].totalAmount).sub(distributeList[_receiver].releasedToken);\n\n        delete distributeList[_receiver];\n\n        emit ReceiverRemoved(_receiver);\n    }\n    \n    function releaseTokenByOwner(address _tokenReceiver) public onlyOwner {\n        _releaseToken(_tokenReceiver);\n    }\n    \n    function releaseToken() public {\n        _releaseToken(msg.sender);\n    }\n    \n    function _releaseToken(address _tokenReceiver) internal {\n\n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0){\n                releasableToken += dl.lockUpData[i].amount;\n                dl.lockUpData[i].amount = 0;\n            }\n        }\n        \n        dl.releasedToken    += releasableToken;\n        releasedTokenTotal  += releasableToken;\n        neededAmountTotal   -= releasableToken;\n        \n        token.transfer(_tokenReceiver, releasableToken);\n        emit ReleaseToken(_tokenReceiver, releasableToken);\n    }\n    \n    function transfer(address _to, uint _amount) public onlyOwner {\n        require(neededAmountTotal.add(_amount) <= token.balanceOf(this) && token.balanceOf(this) > 0);\n        token.transfer(_to, _amount);\n    }\n    \n    //should be set for distributeBounty function. and set appropriate approve amount for bounty. \n    function setApprover(address _approver) public onlyOwner {\n        approver = _approver;\n    }\n    \n    //should be checked approved amount and the sum of _amount\n    function distributeBounty(address[] _receiver, uint[] _amount) public payable onlyOwner {\n        require(_receiver.length == _amount.length);\n        uint bountyAmount;\n        \n        for (uint i = 0; i < _amount.length; i++) {\n            distributedBountyTotal += _amount[i];\n            bountyAmount += _amount[i];\n            token.transferFrom(approver, _receiver[i], _amount[i]);\n        }\n        emit BountyDistributed(_receiver.length, bountyAmount);\n    }\n\n    function viewLockUpStatus(address _tokenReceiver) public view returns (uint _totalLockedToken, uint _releasedToken, uint _releasableToken) {\n    \n        DistributeList storage dl = distributeList[_tokenReceiver];\n        uint releasableToken;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++) {\n            if(dl.lockUpData[i].releaseDate <= now && dl.lockUpData[i].amount > 0) {\n                releasableToken += dl.lockUpData[i].amount;\n            }\n        }\n        \n        return (dl.totalAmount, dl.releasedToken, releasableToken);\n        \n    }\n\n    function viewNextRelease(address _tokenRecv) public view returns (uint _amount, uint _year, uint _month, uint _day) {\n    \n        DistributeList storage dl = distributeList[_tokenRecv];\n        uint _releasableToken;\n        uint _releaseDate;\n\n        for (uint i=0; i < dl.lockUpData.length ; i++){\n            if(dl.lockUpData[i].releaseDate > now && dl.lockUpData[i].amount > 0){\n                if(_releaseDate < dl.lockUpData[i].releaseDate || _releaseDate == 0 ){\n                    _releasableToken = dl.lockUpData[i].amount;\n                    _releaseDate = dl.lockUpData[i].releaseDate;\n                }\n            }\n        }\n        \n        return (_releasableToken, dateTime.getYear(_releaseDate), dateTime.getMonth(_releaseDate), dateTime.getDay(_releaseDate) );\n\n    }\n\n    function viewContractHoldingToken() public view returns (uint _amount) {\n        return (token.balanceOf(this));\n    }\n\n}",
        "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4_+\n2: 0xab35dd14103840033983a97295e767efe80e1872fe7e8ffcfdee28e74a899e9e\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4 +\n2: 0x4522846f8a480087ded1df3dd4eba28607966bc300b077b978d5d6ec3644e4af\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4: 0x0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenDistributor_4: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenDistributor_0: 0x6552d8b400000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenDistributor: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeReceiver(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/8/0xd3b58ac11f612609ac84ff9545c9545da1480bda.sol",
        "function": "removeReceiver(address)",
        "lineno": 176,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}