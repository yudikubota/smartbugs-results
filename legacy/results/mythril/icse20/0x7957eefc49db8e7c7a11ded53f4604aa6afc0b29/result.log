{"error": null, "issues": [{"address": 1924, "code": "\n\ncontract Ethraff", "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_72984518589826227531578991903372844090998219903258077796093728159832249402700: 0x0\ncaller: 0x0\ncalldata_Ethraffle_0: 0xb2d5ae4400000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle: 0x4\nstorage_72984518589826227531578991903372844090998219903258077796093728159832249402701: 0x0\nstorage_1: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getRefund()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "getRefund()", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2218, "code": "nction Ethraffle()", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Ethraffle_4: 0x0\nstorage_4: 0x0\ncalldata_Ethraffle_0: 0xb4894b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "_function_0xb4894b1d", "lineno": 53, "title": "Exception state", "type": "Informational"}, {"address": 2843, "code": "ween 1 and totalTickets\n    fu", "debug": "", "description": "In the function `fallback` the following predictable state variables are used to determine Ether recipient:\n- block.coinbase\n- block.gaslimit\n- block.timestamp\n- block.number\n", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "fallback", "lineno": 110, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 2843, "code": "ween 1 and totalTickets\n    fu", "debug": "SOLVER OUTPUT:\nstorage_2: 0x6\ncallvalue: 0x40000000000000000000000000000000000000000f0d695f200000\ncalldatasize_Ethraffle: 0x3\nstorage_4: 0x0\n", "description": "In the function `fallback` a non-zero amount of Ether is sent to msg.sender.\n\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 4. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "fallback", "lineno": 110, "title": "Ether send", "type": "Warning"}, {"address": 2843, "code": "ween 1 and totalTickets\n    fu", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1411\nCall at address: 2941\n", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "fallback", "lineno": 110, "title": "Multiple Calls", "type": "Information"}, {"address": 2941, "code": "andom() private returns (u", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1411\n", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "fallback", "lineno": 111, "title": "Multiple Calls", "type": "Information"}, {"address": 3102, "code": "Tickets() ", "debug": "storage_2: 0x6\ncallvalue: 0x80000000000000000000000000000000000000000000000000030e6581000000\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_Ethraffle: 0x3\nstorage_4: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "fallback", "lineno": 63, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3143, "code": "ntract Ethraffle {\n    // Structs\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    // Events\n    event RaffleResult(\n        uint indexed raffleId,\n        uint winningNumber,\n        address winningAddress,\n        uint blockTimestamp,\n        uint blockNumber,\n        uint gasLimit,\n        uint difficulty,\n        uint gas,\n        uint value,\n        address msgSender,\n        address blockCoinbase,\n        bytes32 sha\n    );\n\n    event TicketPurchase(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    address public creatorAddress;\n    address constant public rakeAddress = 0x15887100f3b3cA0b645F007c6AA11348665c69e5;\n    uint constant public prize = 0.1 ether;\n    uint constant public rake = 0.02 ether;\n    uint constant public totalTickets = 6;\n    uint constant public pricePerTicket = (prize + rake) / totalTickets;\n\n    // Variables\n    uint public raffleId = 0;\n    uint public nextTicket = 0;\n    mapping (uint => Contestant) public contestants;\n    uint[] public gaps;\n\n    // Initialization\n    function Ethraffle() public {\n        creatorAddress = msg.sender;\n        resetRaffle();\n    }\n\n    function resetRaffle() private {\n        raffleId++;\n        nextTicket = 1;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket <= totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket > totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n        uint winningNumber = getRandom();\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(\n            raffleId, winningNumber, winningAddress, block.timestamp,\n            block.number, block.gaslimit, block.difficulty, msg.gas,\n            msg.value, msg.sender, block.coinbase, getSha()\n        );\n\n        resetRaffle();\n        winningAddress.transfer(prize);\n        rakeAddress.transfer(rake);\n    }\n\n    // Choose a random int between 1 and totalTickets\n    function getRandom() private returns (uint) {\n        return (uint(getSha()) % totalTickets) + 1;\n    }\n\n    function getSha() private returns (bytes32) {\n        return sha3(\n            block.timestamp +\n            block.number +\n            block.gaslimit +\n            block.difficulty +\n            msg.gas +\n            msg.value +\n            uint(msg.sender) +\n            uint(block.coinbase)\n        );\n    }\n\n    function getRefund() public {\n        uint refunds = 0;\n        for (uint i = 1; i <= totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refunds++;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refunds > 0) {\n            msg.sender.transfer(refunds * pricePerTicket);\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == creatorAddress) {\n            selfdestruct(creatorAddress);\n        }\n    }\n}", "debug": "storage_4: 0x7ffffffffffffffffffffffffffffffbfff80000000000000000000000000000\nstorage_2: 0x0\ncallvalue: 0x470de4df820000\ncalldata_Ethraffle_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle: 0x4\n", "description": "A possible integer overflow exists in the function `buyTickets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "buyTickets()", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3145, "code": "ntract Ethraffle {\n    // Structs\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    // Events\n    event RaffleResult(\n        uint indexed raffleId,\n        uint winningNumber,\n        address winningAddress,\n        uint blockTimestamp,\n        uint blockNumber,\n        uint gasLimit,\n        uint difficulty,\n        uint gas,\n        uint value,\n        address msgSender,\n        address blockCoinbase,\n        bytes32 sha\n    );\n\n    event TicketPurchase(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    address public creatorAddress;\n    address constant public rakeAddress = 0x15887100f3b3cA0b645F007c6AA11348665c69e5;\n    uint constant public prize = 0.1 ether;\n    uint constant public rake = 0.02 ether;\n    uint constant public totalTickets = 6;\n    uint constant public pricePerTicket = (prize + rake) / totalTickets;\n\n    // Variables\n    uint public raffleId = 0;\n    uint public nextTicket = 0;\n    mapping (uint => Contestant) public contestants;\n    uint[] public gaps;\n\n    // Initialization\n    function Ethraffle() public {\n        creatorAddress = msg.sender;\n        resetRaffle();\n    }\n\n    function resetRaffle() private {\n        raffleId++;\n        nextTicket = 1;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket <= totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket > totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n        uint winningNumber = getRandom();\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(\n            raffleId, winningNumber, winningAddress, block.timestamp,\n            block.number, block.gaslimit, block.difficulty, msg.gas,\n            msg.value, msg.sender, block.coinbase, getSha()\n        );\n\n        resetRaffle();\n        winningAddress.transfer(prize);\n        rakeAddress.transfer(rake);\n    }\n\n    // Choose a random int between 1 and totalTickets\n    function getRandom() private returns (uint) {\n        return (uint(getSha()) % totalTickets) + 1;\n    }\n\n    function getSha() private returns (bytes32) {\n        return sha3(\n            block.timestamp +\n            block.number +\n            block.gaslimit +\n            block.difficulty +\n            msg.gas +\n            msg.value +\n            uint(msg.sender) +\n            uint(block.coinbase)\n        );\n    }\n\n    function getRefund() public {\n        uint refunds = 0;\n        for (uint i = 1; i <= totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refunds++;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refunds > 0) {\n            msg.sender.transfer(refunds * pricePerTicket);\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == creatorAddress) {\n            selfdestruct(creatorAddress);\n        }\n    }\n}", "debug": "storage_4: 0x7fffffffffffffdffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_2: 0x0\ncallvalue: 0x470de4df820000\ncalldata_Ethraffle_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle: 0x4\n", "description": "A possible integer overflow exists in the function `buyTickets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x7957eefc49db8e7c7a11ded53f4604aa6afc0b29.sol", "function": "buyTickets()", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}