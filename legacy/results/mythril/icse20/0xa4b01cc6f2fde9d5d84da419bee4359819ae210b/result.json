{
  "contract": "0xa4b01cc6f2fde9d5d84da419bee4359819ae210b",
  "tool": "mythril",
  "start": 1563568537.4870048,
  "end": 1563568669.6775742,
  "duration": 132.19056940078735,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 750,
        "code": " to remove\n    function removeGift(uint256 GiftId)\n    public\n    onlyOwner {\n        // just setting GiftExists equal to false\n        GiftExists[GiftId] = false;\n    }\n    \n    /// @dev withdraw GTO in this contract\n    function withdrawGTO()\n    onlyOwner\n    public {\n        GTO.transfer(owner, GTO.balanceOf(address(this)));\n    }\n    \n}",
        "debug": "calldata_VirtualGift_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_VirtualGift_0: 0x2cfc1f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateGift(uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "updateGift(uint256,uint256,string,string)",
        "lineno": 441,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3238,
        "code": "d) \n    validGift(Gift",
        "debug": "storage_2: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VirtualGift_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VirtualGift_0: 0x525df39d00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `GiftsOfOwner(address)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "GiftsOfOwner(address)",
        "lineno": 161,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 3723,
        "code": "rawGTO()\n    onlyOw",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_VirtualGift_4: 0x0\nstorage_2: 0x0\nstorage_keccac_calldata_VirtualGift_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x2cfc1f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "updateGift(uint256,uint256,string,string)",
        "lineno": 450,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4223,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "withdrawGTO()",
        "lineno": 456,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4223,
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4415\n",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "withdrawGTO()",
        "lineno": 456,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 4223,
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function withdrawGTO(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "withdrawGTO()",
        "lineno": 456,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 4415,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "withdrawGTO()",
        "lineno": 456,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4415,
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function withdrawGTO(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "withdrawGTO()",
        "lineno": 456,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 4502,
        "code": "operty\n    /// @pa",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_VirtualGift_0: 0x44f6d70c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VirtualGift_4: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "giftOwnerByIndex(address,uint256)",
        "lineno": 382,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 7979,
        "code": "transfer event.",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VirtualGift_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_VirtualGift_32_+_4: 0xff00\ncaller: 0xff\ncalldata_VirtualGift_0: 0x63d9b4b100000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `sendGift(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "sendGift(address,uint256)",
        "lineno": 276,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8195,
        "code": "transfer(address ",
        "debug": "storage_keccac_calldata_VirtualGift_32_+_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncaller: 0xff\ncalldata_VirtualGift_0: 0x63d9b4b100000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `sendGift(address,uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "sendGift(address,uint256)",
        "lineno": 283,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 8346,
        "code": "TO to Virtual Gift contract, to interact with GTO\n    ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    // Gift data\n    struct Gift {\n        // gift price\n        uint256 price;\n        // gift description\n        string description;\n    }\n    \n    address public owner;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _GiftId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _GiftId);\n    event Creation(address indexed _owner, uint256 indexed GiftId);\n    \n    string public constant name = \"VirtualGift\";\n    string public constant symbol = \"VTG\";\n    \n    // Gift object storage in array\n    Gift[] giftStorage;\n    \n    // total Gift of an address\n    mapping(address => uint256) private balances;\n    \n    // index of Gift array to Owner\n    mapping(uint256 => address) private GiftIndexToOwners;\n    \n    // Gift exist or not\n    mapping(uint256 => bool) private GiftExists;\n    \n    // mapping from owner and approved address to GiftId\n    mapping(address => mapping (address => uint256)) private allowed;\n    \n    // mapping from owner and index Gift of owner to GiftId\n    mapping(address => mapping(uint256 => uint256)) private ownerIndexToGifts;\n    \n    // Gift metadata\n    mapping(uint256 => string) GiftLinks;\n\n    modifier onlyOwner(){\n         require(msg.sender == owner);\n         _;\n    }\n\n    modifier onlyGiftOwner(uint256 GiftId){\n        require(msg.sender == GiftIndexToOwners[GiftId]);\n        _;\n    }\n    \n    modifier validGift(uint256 GiftId){\n        require(GiftExists[GiftId]);\n        _;\n    }\n\n    /// @dev constructor\n    function VirtualGift()\n    public{\n        owner = msg.sender;\n        // save temporaryly new Gift\n        Gift memory newGift = Gift({\n            price: 0,\n            description: \"MYTHICAL\"\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 mythicalGift = giftStorage.push(newGift) - 1; // id = 0\n        // mythical Gift is not exist\n        GiftExists[mythicalGift] = false;\n        // assign url for Gift\n        GiftLinks[mythicalGift] = \"mythicalGift\";\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, mythicalGift);\n        // event create new Gift for msg.sender\n        Creation(msg.sender, mythicalGift);\n    }\n    \n    /// @dev this function change GTO address, this mean you can use many token to buy gift\n    /// by change GTO address to BNB address\n    /// @param newAddress is new address of GTO or another Gift like BNB\n    function changeGTOAddress(address newAddress)\n    public\n    onlyOwner{\n        GTO = ERC20(newAddress);\n    }\n    \n    /// @dev return current GTO address\n    function getGTOAddress()\n    public\n    constant\n    returns (address) {\n        return address(GTO);\n    }\n    \n    /// @dev return total supply of Gift\n    /// @return length of Gift storage array, except Gift Zero\n    function totalSupply()\n    public \n    constant\n    returns (uint256){\n        // exclusive Gift Zero\n        return giftStorage.length - 1;\n    }\n    \n    /// @dev allow people to buy Gift\n    /// @param GiftId : id of gift user want to buy\n    function buy(uint256 GiftId) \n    validGift(GiftId)\n    public {\n        // get old owner of Gift\n        address oldowner = ownerOf(GiftId);\n        // tell gifto transfer GTO from new owner to oldowner\n        // NOTE: new owner MUST approve for Virtual Gift contract to take his balance\n        require(GTO.transferFrom(msg.sender, oldowner, giftStorage[GiftId].price) == true);\n        // assign new owner for GiftId\n        // TODO: old owner should have something to confirm that he want to sell this Gift\n        _transfer(oldowner, msg.sender, GiftId);\n    }\n    \n    /// @dev owner send gift to recipient when VG was approved\n    /// @param recipient : received gift\n    /// @param GiftId : id of gift which recipient want to buy\n    function sendGift(address recipient, uint256 GiftId)\n    onlyGiftOwner(GiftId)\n    validGift(GiftId)\n    public {\n        // transfer GTO to owner\n        // require(GTO.transfer(msg.sender, giftStorage[GiftId].price) == true);\n        // transfer gift to recipient\n        _transfer(msg.sender, recipient, GiftId);\n    }\n    \n    /// @dev get total Gift of an address\n    /// @param _owner to get balance\n    /// @return balance of an address\n    function balanceOf(address _owner) \n    public \n    constant \n    returns (uint256 balance){\n        return balances[_owner];\n    }\n    \n    function isExist(uint256 GiftId)\n    public\n    constant\n    returns(bool){\n        return GiftExists[GiftId];\n    }\n    \n    /// @dev get owner of an Gift id\n    /// @param _GiftId : id of Gift to get owner\n    /// @return owner : owner of an Gift id\n    function ownerOf(uint256 _GiftId)\n    public\n    constant \n    returns (address _owner) {\n        require(GiftExists[_GiftId]);\n        return GiftIndexToOwners[_GiftId];\n    }\n    \n    /// @dev approve Gift id from msg.sender to an address\n    /// @param _to : address is approved\n    /// @param _GiftId : id of Gift in array\n    function approve(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        require(msg.sender == ownerOf(_GiftId));\n        require(msg.sender != _to);\n        \n        allowed[msg.sender][_to] = _GiftId;\n        Approval(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev get id of Gift was approved from owner to spender\n    /// @param _owner : address owner of Gift\n    /// @param _spender : spender was approved\n    /// @return GiftId\n    function allowance(address _owner, address _spender) \n    public \n    constant \n    returns (uint256 GiftId) {\n        return allowed[_owner][_spender];\n    }\n    \n    /// @dev a spender take owner ship of Gift id, when he was approved\n    /// @param _GiftId : id of Gift has being takeOwnership\n    function takeOwnership(uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        // get oldowner of Giftid\n        address oldOwner = ownerOf(_GiftId);\n        // new owner is msg sender\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        // newOwner must be approved by oldOwner\n        require(allowed[oldOwner][newOwner] == _GiftId);\n\n        // transfer Gift for new owner\n        _transfer(oldOwner, newOwner, _GiftId);\n\n        // delete approve when being done take owner ship\n        delete allowed[oldOwner][newOwner];\n\n        Transfer(oldOwner, newOwner, _GiftId);\n    }\n    \n    /// @dev transfer ownership of a specific Gift to an address.\n    /// @param _from : address owner of Giftid\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function _transfer(address _from, address _to, uint256 _GiftId) \n    internal {\n        // Since the number of Gift is capped to 2^32 we can't overflow this\n        balances[_to]++;\n        // transfer ownership\n        GiftIndexToOwners[_GiftId] = _to;\n        // When creating new Gift _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        // Emit the transfer event.\n        Transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev transfer ownership of Giftid from msg sender to an address\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function transfer(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        // not transfer to zero\n        require(_to != 0x0);\n        // address received different from sender\n        require(msg.sender != _to);\n        // sender must be owner of Giftid\n        require(msg.sender == ownerOf(_GiftId));\n        // do not send to Gift contract\n        require(_to != address(this));\n        \n        _transfer(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev transfer Giftid was approved by _from to _to\n    /// @param _from : address owner of Giftid\n    /// @param _to : address is received\n    /// @param _GiftId : Gift id\n    function transferFrom(address _from, address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        require(_from == ownerOf(_GiftId));\n        // Check for approval and valid ownership\n        require(allowance(_from, msg.sender) == _GiftId);\n        // address received different from _owner\n        require(_from != _to);\n        \n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any Gift\n        require(_to != address(this));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev Returns a list of all Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    /// @return ownerGifts : list Gift of owner\n    function GiftsOfOwner(address _owner) \n    public \n    view \n    returns(uint256[] ownerGifts) {\n        \n        uint256 GiftCount = balanceOf(_owner);\n        if (GiftCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](GiftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all Gift have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 GiftId;\n            \n            // scan array and filter Gift of owner\n            for (GiftId = 0; GiftId <= total; GiftId++) {\n                if (GiftIndexToOwners[GiftId] == _owner) {\n                    result[resultIndex] = GiftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    /// @dev Returns a Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @param _index to owner Gift list\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    ///  it is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function giftOwnerByIndex(address _owner, uint256 _index)\n    external\n    constant \n    returns (uint256 GiftId) {\n        uint256[] memory ownerGifts = GiftsOfOwner(_owner);\n        return ownerGifts[_index];\n    }\n    \n    /// @dev get Gift metadata (url) from GiftLinks\n    /// @param _GiftId : Gift id\n    /// @return infoUrl : url of Gift\n    function GiftMetadata(uint256 _GiftId)\n    public\n    constant\n    returns (string infoUrl) {\n        return GiftLinks[_GiftId];\n    }\n    \n    /// @dev function create new Gift\n    /// @param _price : Gift property\n    /// @param _description : Gift property\n    /// @return GiftId\n    function createGift(uint256 _price, string _description, string _url)\n    public\n    onlyOwner\n    returns (uint256) {\n        // save temporarily new Gift\n        Gift memory newGift = Gift({\n            price: _price,\n            description: _description\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 newGiftId = giftStorage.push(newGift) - 1;\n        // turn on existen\n        GiftExists[newGiftId] = true;\n        // assin gift url\n        GiftLinks[newGiftId] = _url;\n        // event create new Gift for msg.sender\n        Creation(msg.sender, newGiftId);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, newGiftId);\n        \n        return newGiftId;\n    }\n    \n    /// @dev get Gift property\n    /// @param GiftId : id of Gift\n    /// @return properties of Gift\n    function getGift(uint256 GiftId)\n    public\n    constant \n    returns (uint256, string){\n        if(GiftId > giftStorage.length){\n            return (0, \"\");\n        }\n        Gift memory newGift = giftStorage[GiftId];\n        return (newGift.price, newGift.description);\n    }\n    \n    /// @dev change gift properties\n    /// @param GiftId : to change\n    /// @param _price : new price of gift\n    /// @param _description : new description\n    /// @param _giftUrl : new url \n    function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl)\n    public\n    onlyOwner {\n        // check Gift exist First\n        require(GiftExists[GiftId]);\n        // setting new properties\n        giftStorage[GiftId].price = _price;\n        giftStorage[GiftId].description = _description;\n        GiftLinks[GiftId] = _giftUrl;\n    }\n    \n    /// @dev remove gift \n    /// @param GiftId : gift id to remove\n    function removeGift(uint256 GiftId)\n    public\n    onlyOwner {\n        // just setting GiftExists equal to false\n        GiftExists[GiftId] = false;\n    }\n    \n    /// @dev withdraw GTO in this contract\n    function withdrawGTO()\n    onlyOwner\n    public {\n        GTO.transfer(owner, GTO.balanceOf(address(this)));\n    }\n    \n}",
        "debug": "keccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*calldata_VirtualGift_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*calldata_VirtualGift_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncalldata_VirtualGift_4: 0x0\nstorage_2: 0x1\nstorage_keccac_calldata_VirtualGift_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x2cfc1f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateGift(uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "updateGift(uint256,uint256,string,string)",
        "lineno": 54,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8375,
        "code": "TO to Virtual Gift contract, to interact with GTO\n    ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    // Gift data\n    struct Gift {\n        // gift price\n        uint256 price;\n        // gift description\n        string description;\n    }\n    \n    address public owner;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _GiftId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _GiftId);\n    event Creation(address indexed _owner, uint256 indexed GiftId);\n    \n    string public constant name = \"VirtualGift\";\n    string public constant symbol = \"VTG\";\n    \n    // Gift object storage in array\n    Gift[] giftStorage;\n    \n    // total Gift of an address\n    mapping(address => uint256) private balances;\n    \n    // index of Gift array to Owner\n    mapping(uint256 => address) private GiftIndexToOwners;\n    \n    // Gift exist or not\n    mapping(uint256 => bool) private GiftExists;\n    \n    // mapping from owner and approved address to GiftId\n    mapping(address => mapping (address => uint256)) private allowed;\n    \n    // mapping from owner and index Gift of owner to GiftId\n    mapping(address => mapping(uint256 => uint256)) private ownerIndexToGifts;\n    \n    // Gift metadata\n    mapping(uint256 => string) GiftLinks;\n\n    modifier onlyOwner(){\n         require(msg.sender == owner);\n         _;\n    }\n\n    modifier onlyGiftOwner(uint256 GiftId){\n        require(msg.sender == GiftIndexToOwners[GiftId]);\n        _;\n    }\n    \n    modifier validGift(uint256 GiftId){\n        require(GiftExists[GiftId]);\n        _;\n    }\n\n    /// @dev constructor\n    function VirtualGift()\n    public{\n        owner = msg.sender;\n        // save temporaryly new Gift\n        Gift memory newGift = Gift({\n            price: 0,\n            description: \"MYTHICAL\"\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 mythicalGift = giftStorage.push(newGift) - 1; // id = 0\n        // mythical Gift is not exist\n        GiftExists[mythicalGift] = false;\n        // assign url for Gift\n        GiftLinks[mythicalGift] = \"mythicalGift\";\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, mythicalGift);\n        // event create new Gift for msg.sender\n        Creation(msg.sender, mythicalGift);\n    }\n    \n    /// @dev this function change GTO address, this mean you can use many token to buy gift\n    /// by change GTO address to BNB address\n    /// @param newAddress is new address of GTO or another Gift like BNB\n    function changeGTOAddress(address newAddress)\n    public\n    onlyOwner{\n        GTO = ERC20(newAddress);\n    }\n    \n    /// @dev return current GTO address\n    function getGTOAddress()\n    public\n    constant\n    returns (address) {\n        return address(GTO);\n    }\n    \n    /// @dev return total supply of Gift\n    /// @return length of Gift storage array, except Gift Zero\n    function totalSupply()\n    public \n    constant\n    returns (uint256){\n        // exclusive Gift Zero\n        return giftStorage.length - 1;\n    }\n    \n    /// @dev allow people to buy Gift\n    /// @param GiftId : id of gift user want to buy\n    function buy(uint256 GiftId) \n    validGift(GiftId)\n    public {\n        // get old owner of Gift\n        address oldowner = ownerOf(GiftId);\n        // tell gifto transfer GTO from new owner to oldowner\n        // NOTE: new owner MUST approve for Virtual Gift contract to take his balance\n        require(GTO.transferFrom(msg.sender, oldowner, giftStorage[GiftId].price) == true);\n        // assign new owner for GiftId\n        // TODO: old owner should have something to confirm that he want to sell this Gift\n        _transfer(oldowner, msg.sender, GiftId);\n    }\n    \n    /// @dev owner send gift to recipient when VG was approved\n    /// @param recipient : received gift\n    /// @param GiftId : id of gift which recipient want to buy\n    function sendGift(address recipient, uint256 GiftId)\n    onlyGiftOwner(GiftId)\n    validGift(GiftId)\n    public {\n        // transfer GTO to owner\n        // require(GTO.transfer(msg.sender, giftStorage[GiftId].price) == true);\n        // transfer gift to recipient\n        _transfer(msg.sender, recipient, GiftId);\n    }\n    \n    /// @dev get total Gift of an address\n    /// @param _owner to get balance\n    /// @return balance of an address\n    function balanceOf(address _owner) \n    public \n    constant \n    returns (uint256 balance){\n        return balances[_owner];\n    }\n    \n    function isExist(uint256 GiftId)\n    public\n    constant\n    returns(bool){\n        return GiftExists[GiftId];\n    }\n    \n    /// @dev get owner of an Gift id\n    /// @param _GiftId : id of Gift to get owner\n    /// @return owner : owner of an Gift id\n    function ownerOf(uint256 _GiftId)\n    public\n    constant \n    returns (address _owner) {\n        require(GiftExists[_GiftId]);\n        return GiftIndexToOwners[_GiftId];\n    }\n    \n    /// @dev approve Gift id from msg.sender to an address\n    /// @param _to : address is approved\n    /// @param _GiftId : id of Gift in array\n    function approve(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        require(msg.sender == ownerOf(_GiftId));\n        require(msg.sender != _to);\n        \n        allowed[msg.sender][_to] = _GiftId;\n        Approval(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev get id of Gift was approved from owner to spender\n    /// @param _owner : address owner of Gift\n    /// @param _spender : spender was approved\n    /// @return GiftId\n    function allowance(address _owner, address _spender) \n    public \n    constant \n    returns (uint256 GiftId) {\n        return allowed[_owner][_spender];\n    }\n    \n    /// @dev a spender take owner ship of Gift id, when he was approved\n    /// @param _GiftId : id of Gift has being takeOwnership\n    function takeOwnership(uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        // get oldowner of Giftid\n        address oldOwner = ownerOf(_GiftId);\n        // new owner is msg sender\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        // newOwner must be approved by oldOwner\n        require(allowed[oldOwner][newOwner] == _GiftId);\n\n        // transfer Gift for new owner\n        _transfer(oldOwner, newOwner, _GiftId);\n\n        // delete approve when being done take owner ship\n        delete allowed[oldOwner][newOwner];\n\n        Transfer(oldOwner, newOwner, _GiftId);\n    }\n    \n    /// @dev transfer ownership of a specific Gift to an address.\n    /// @param _from : address owner of Giftid\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function _transfer(address _from, address _to, uint256 _GiftId) \n    internal {\n        // Since the number of Gift is capped to 2^32 we can't overflow this\n        balances[_to]++;\n        // transfer ownership\n        GiftIndexToOwners[_GiftId] = _to;\n        // When creating new Gift _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        // Emit the transfer event.\n        Transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev transfer ownership of Giftid from msg sender to an address\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function transfer(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        // not transfer to zero\n        require(_to != 0x0);\n        // address received different from sender\n        require(msg.sender != _to);\n        // sender must be owner of Giftid\n        require(msg.sender == ownerOf(_GiftId));\n        // do not send to Gift contract\n        require(_to != address(this));\n        \n        _transfer(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev transfer Giftid was approved by _from to _to\n    /// @param _from : address owner of Giftid\n    /// @param _to : address is received\n    /// @param _GiftId : Gift id\n    function transferFrom(address _from, address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        require(_from == ownerOf(_GiftId));\n        // Check for approval and valid ownership\n        require(allowance(_from, msg.sender) == _GiftId);\n        // address received different from _owner\n        require(_from != _to);\n        \n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any Gift\n        require(_to != address(this));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev Returns a list of all Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    /// @return ownerGifts : list Gift of owner\n    function GiftsOfOwner(address _owner) \n    public \n    view \n    returns(uint256[] ownerGifts) {\n        \n        uint256 GiftCount = balanceOf(_owner);\n        if (GiftCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](GiftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all Gift have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 GiftId;\n            \n            // scan array and filter Gift of owner\n            for (GiftId = 0; GiftId <= total; GiftId++) {\n                if (GiftIndexToOwners[GiftId] == _owner) {\n                    result[resultIndex] = GiftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    /// @dev Returns a Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @param _index to owner Gift list\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    ///  it is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function giftOwnerByIndex(address _owner, uint256 _index)\n    external\n    constant \n    returns (uint256 GiftId) {\n        uint256[] memory ownerGifts = GiftsOfOwner(_owner);\n        return ownerGifts[_index];\n    }\n    \n    /// @dev get Gift metadata (url) from GiftLinks\n    /// @param _GiftId : Gift id\n    /// @return infoUrl : url of Gift\n    function GiftMetadata(uint256 _GiftId)\n    public\n    constant\n    returns (string infoUrl) {\n        return GiftLinks[_GiftId];\n    }\n    \n    /// @dev function create new Gift\n    /// @param _price : Gift property\n    /// @param _description : Gift property\n    /// @return GiftId\n    function createGift(uint256 _price, string _description, string _url)\n    public\n    onlyOwner\n    returns (uint256) {\n        // save temporarily new Gift\n        Gift memory newGift = Gift({\n            price: _price,\n            description: _description\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 newGiftId = giftStorage.push(newGift) - 1;\n        // turn on existen\n        GiftExists[newGiftId] = true;\n        // assin gift url\n        GiftLinks[newGiftId] = _url;\n        // event create new Gift for msg.sender\n        Creation(msg.sender, newGiftId);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, newGiftId);\n        \n        return newGiftId;\n    }\n    \n    /// @dev get Gift property\n    /// @param GiftId : id of Gift\n    /// @return properties of Gift\n    function getGift(uint256 GiftId)\n    public\n    constant \n    returns (uint256, string){\n        if(GiftId > giftStorage.length){\n            return (0, \"\");\n        }\n        Gift memory newGift = giftStorage[GiftId];\n        return (newGift.price, newGift.description);\n    }\n    \n    /// @dev change gift properties\n    /// @param GiftId : to change\n    /// @param _price : new price of gift\n    /// @param _description : new description\n    /// @param _giftUrl : new url \n    function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl)\n    public\n    onlyOwner {\n        // check Gift exist First\n        require(GiftExists[GiftId]);\n        // setting new properties\n        giftStorage[GiftId].price = _price;\n        giftStorage[GiftId].description = _description;\n        GiftLinks[GiftId] = _giftUrl;\n    }\n    \n    /// @dev remove gift \n    /// @param GiftId : gift id to remove\n    function removeGift(uint256 GiftId)\n    public\n    onlyOwner {\n        // just setting GiftExists equal to false\n        GiftExists[GiftId] = false;\n    }\n    \n    /// @dev withdraw GTO in this contract\n    function withdrawGTO()\n    onlyOwner\n    public {\n        GTO.transfer(owner, GTO.balanceOf(address(this)));\n    }\n    \n}",
        "debug": "keccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*calldata_VirtualGift_4: 0xfe6c3882c8c219105b1269338c14a907b57fe56d7e7402ce023400000973b6fb\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_VirtualGift_4 + calldata_VirtualGift_32 + 36)): 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_1 +\n29102676481673041902632991033461445430619272659676223336789171408008386403022 +\n2*calldata_VirtualGift_4: 0xfde7dbef9fbcee952ba2fefcee7f3f46f6fffcffffffffffffffffffffffffc5\ncalldata_VirtualGift_4: 0x0\ncalldata_VirtualGift_4 + calldata_VirtualGift_32 + 36: 0x0\nstorage_2: 0x1\nstorage_keccac_calldata_VirtualGift_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x2cfc1f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateGift(uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "updateGift(uint256,uint256,string,string)",
        "lineno": 54,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8389,
        "code": "TO to Virtual Gift contract, to interact with GTO\n    ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    // Gift data\n    struct Gift {\n        // gift price\n        uint256 price;\n        // gift description\n        string description;\n    }\n    \n    address public owner;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _GiftId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _GiftId);\n    event Creation(address indexed _owner, uint256 indexed GiftId);\n    \n    string public constant name = \"VirtualGift\";\n    string public constant symbol = \"VTG\";\n    \n    // Gift object storage in array\n    Gift[] giftStorage;\n    \n    // total Gift of an address\n    mapping(address => uint256) private balances;\n    \n    // index of Gift array to Owner\n    mapping(uint256 => address) private GiftIndexToOwners;\n    \n    // Gift exist or not\n    mapping(uint256 => bool) private GiftExists;\n    \n    // mapping from owner and approved address to GiftId\n    mapping(address => mapping (address => uint256)) private allowed;\n    \n    // mapping from owner and index Gift of owner to GiftId\n    mapping(address => mapping(uint256 => uint256)) private ownerIndexToGifts;\n    \n    // Gift metadata\n    mapping(uint256 => string) GiftLinks;\n\n    modifier onlyOwner(){\n         require(msg.sender == owner);\n         _;\n    }\n\n    modifier onlyGiftOwner(uint256 GiftId){\n        require(msg.sender == GiftIndexToOwners[GiftId]);\n        _;\n    }\n    \n    modifier validGift(uint256 GiftId){\n        require(GiftExists[GiftId]);\n        _;\n    }\n\n    /// @dev constructor\n    function VirtualGift()\n    public{\n        owner = msg.sender;\n        // save temporaryly new Gift\n        Gift memory newGift = Gift({\n            price: 0,\n            description: \"MYTHICAL\"\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 mythicalGift = giftStorage.push(newGift) - 1; // id = 0\n        // mythical Gift is not exist\n        GiftExists[mythicalGift] = false;\n        // assign url for Gift\n        GiftLinks[mythicalGift] = \"mythicalGift\";\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, mythicalGift);\n        // event create new Gift for msg.sender\n        Creation(msg.sender, mythicalGift);\n    }\n    \n    /// @dev this function change GTO address, this mean you can use many token to buy gift\n    /// by change GTO address to BNB address\n    /// @param newAddress is new address of GTO or another Gift like BNB\n    function changeGTOAddress(address newAddress)\n    public\n    onlyOwner{\n        GTO = ERC20(newAddress);\n    }\n    \n    /// @dev return current GTO address\n    function getGTOAddress()\n    public\n    constant\n    returns (address) {\n        return address(GTO);\n    }\n    \n    /// @dev return total supply of Gift\n    /// @return length of Gift storage array, except Gift Zero\n    function totalSupply()\n    public \n    constant\n    returns (uint256){\n        // exclusive Gift Zero\n        return giftStorage.length - 1;\n    }\n    \n    /// @dev allow people to buy Gift\n    /// @param GiftId : id of gift user want to buy\n    function buy(uint256 GiftId) \n    validGift(GiftId)\n    public {\n        // get old owner of Gift\n        address oldowner = ownerOf(GiftId);\n        // tell gifto transfer GTO from new owner to oldowner\n        // NOTE: new owner MUST approve for Virtual Gift contract to take his balance\n        require(GTO.transferFrom(msg.sender, oldowner, giftStorage[GiftId].price) == true);\n        // assign new owner for GiftId\n        // TODO: old owner should have something to confirm that he want to sell this Gift\n        _transfer(oldowner, msg.sender, GiftId);\n    }\n    \n    /// @dev owner send gift to recipient when VG was approved\n    /// @param recipient : received gift\n    /// @param GiftId : id of gift which recipient want to buy\n    function sendGift(address recipient, uint256 GiftId)\n    onlyGiftOwner(GiftId)\n    validGift(GiftId)\n    public {\n        // transfer GTO to owner\n        // require(GTO.transfer(msg.sender, giftStorage[GiftId].price) == true);\n        // transfer gift to recipient\n        _transfer(msg.sender, recipient, GiftId);\n    }\n    \n    /// @dev get total Gift of an address\n    /// @param _owner to get balance\n    /// @return balance of an address\n    function balanceOf(address _owner) \n    public \n    constant \n    returns (uint256 balance){\n        return balances[_owner];\n    }\n    \n    function isExist(uint256 GiftId)\n    public\n    constant\n    returns(bool){\n        return GiftExists[GiftId];\n    }\n    \n    /// @dev get owner of an Gift id\n    /// @param _GiftId : id of Gift to get owner\n    /// @return owner : owner of an Gift id\n    function ownerOf(uint256 _GiftId)\n    public\n    constant \n    returns (address _owner) {\n        require(GiftExists[_GiftId]);\n        return GiftIndexToOwners[_GiftId];\n    }\n    \n    /// @dev approve Gift id from msg.sender to an address\n    /// @param _to : address is approved\n    /// @param _GiftId : id of Gift in array\n    function approve(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        require(msg.sender == ownerOf(_GiftId));\n        require(msg.sender != _to);\n        \n        allowed[msg.sender][_to] = _GiftId;\n        Approval(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev get id of Gift was approved from owner to spender\n    /// @param _owner : address owner of Gift\n    /// @param _spender : spender was approved\n    /// @return GiftId\n    function allowance(address _owner, address _spender) \n    public \n    constant \n    returns (uint256 GiftId) {\n        return allowed[_owner][_spender];\n    }\n    \n    /// @dev a spender take owner ship of Gift id, when he was approved\n    /// @param _GiftId : id of Gift has being takeOwnership\n    function takeOwnership(uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        // get oldowner of Giftid\n        address oldOwner = ownerOf(_GiftId);\n        // new owner is msg sender\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        // newOwner must be approved by oldOwner\n        require(allowed[oldOwner][newOwner] == _GiftId);\n\n        // transfer Gift for new owner\n        _transfer(oldOwner, newOwner, _GiftId);\n\n        // delete approve when being done take owner ship\n        delete allowed[oldOwner][newOwner];\n\n        Transfer(oldOwner, newOwner, _GiftId);\n    }\n    \n    /// @dev transfer ownership of a specific Gift to an address.\n    /// @param _from : address owner of Giftid\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function _transfer(address _from, address _to, uint256 _GiftId) \n    internal {\n        // Since the number of Gift is capped to 2^32 we can't overflow this\n        balances[_to]++;\n        // transfer ownership\n        GiftIndexToOwners[_GiftId] = _to;\n        // When creating new Gift _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        // Emit the transfer event.\n        Transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev transfer ownership of Giftid from msg sender to an address\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function transfer(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        // not transfer to zero\n        require(_to != 0x0);\n        // address received different from sender\n        require(msg.sender != _to);\n        // sender must be owner of Giftid\n        require(msg.sender == ownerOf(_GiftId));\n        // do not send to Gift contract\n        require(_to != address(this));\n        \n        _transfer(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev transfer Giftid was approved by _from to _to\n    /// @param _from : address owner of Giftid\n    /// @param _to : address is received\n    /// @param _GiftId : Gift id\n    function transferFrom(address _from, address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        require(_from == ownerOf(_GiftId));\n        // Check for approval and valid ownership\n        require(allowance(_from, msg.sender) == _GiftId);\n        // address received different from _owner\n        require(_from != _to);\n        \n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any Gift\n        require(_to != address(this));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev Returns a list of all Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    /// @return ownerGifts : list Gift of owner\n    function GiftsOfOwner(address _owner) \n    public \n    view \n    returns(uint256[] ownerGifts) {\n        \n        uint256 GiftCount = balanceOf(_owner);\n        if (GiftCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](GiftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all Gift have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 GiftId;\n            \n            // scan array and filter Gift of owner\n            for (GiftId = 0; GiftId <= total; GiftId++) {\n                if (GiftIndexToOwners[GiftId] == _owner) {\n                    result[resultIndex] = GiftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    /// @dev Returns a Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @param _index to owner Gift list\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    ///  it is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function giftOwnerByIndex(address _owner, uint256 _index)\n    external\n    constant \n    returns (uint256 GiftId) {\n        uint256[] memory ownerGifts = GiftsOfOwner(_owner);\n        return ownerGifts[_index];\n    }\n    \n    /// @dev get Gift metadata (url) from GiftLinks\n    /// @param _GiftId : Gift id\n    /// @return infoUrl : url of Gift\n    function GiftMetadata(uint256 _GiftId)\n    public\n    constant\n    returns (string infoUrl) {\n        return GiftLinks[_GiftId];\n    }\n    \n    /// @dev function create new Gift\n    /// @param _price : Gift property\n    /// @param _description : Gift property\n    /// @return GiftId\n    function createGift(uint256 _price, string _description, string _url)\n    public\n    onlyOwner\n    returns (uint256) {\n        // save temporarily new Gift\n        Gift memory newGift = Gift({\n            price: _price,\n            description: _description\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 newGiftId = giftStorage.push(newGift) - 1;\n        // turn on existen\n        GiftExists[newGiftId] = true;\n        // assin gift url\n        GiftLinks[newGiftId] = _url;\n        // event create new Gift for msg.sender\n        Creation(msg.sender, newGiftId);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, newGiftId);\n        \n        return newGiftId;\n    }\n    \n    /// @dev get Gift property\n    /// @param GiftId : id of Gift\n    /// @return properties of Gift\n    function getGift(uint256 GiftId)\n    public\n    constant \n    returns (uint256, string){\n        if(GiftId > giftStorage.length){\n            return (0, \"\");\n        }\n        Gift memory newGift = giftStorage[GiftId];\n        return (newGift.price, newGift.description);\n    }\n    \n    /// @dev change gift properties\n    /// @param GiftId : to change\n    /// @param _price : new price of gift\n    /// @param _description : new description\n    /// @param _giftUrl : new url \n    function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl)\n    public\n    onlyOwner {\n        // check Gift exist First\n        require(GiftExists[GiftId]);\n        // setting new properties\n        giftStorage[GiftId].price = _price;\n        giftStorage[GiftId].description = _description;\n        GiftLinks[GiftId] = _giftUrl;\n    }\n    \n    /// @dev remove gift \n    /// @param GiftId : gift id to remove\n    function removeGift(uint256 GiftId)\n    public\n    onlyOwner {\n        // just setting GiftExists equal to false\n        GiftExists[GiftId] = false;\n    }\n    \n    /// @dev withdraw GTO in this contract\n    function withdrawGTO()\n    onlyOwner\n    public {\n        GTO.transfer(owner, GTO.balanceOf(address(this)));\n    }\n    \n}",
        "debug": "calldata_VirtualGift_4 + calldata_VirtualGift_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_VirtualGift_4: 0x0\nstorage_2: 0x1\nstorage_keccac_calldata_VirtualGift_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x2cfc1f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateGift(uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "updateGift(uint256,uint256,string,string)",
        "lineno": 54,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8411,
        "code": "TO to Virtual Gift contract, to interact with GTO\n    ERC20 GTO = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    // Gift data\n    struct Gift {\n        // gift price\n        uint256 price;\n        // gift description\n        string description;\n    }\n    \n    address public owner;\n    \n    event Transfer(address indexed _from, address indexed _to, uint256 _GiftId);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _GiftId);\n    event Creation(address indexed _owner, uint256 indexed GiftId);\n    \n    string public constant name = \"VirtualGift\";\n    string public constant symbol = \"VTG\";\n    \n    // Gift object storage in array\n    Gift[] giftStorage;\n    \n    // total Gift of an address\n    mapping(address => uint256) private balances;\n    \n    // index of Gift array to Owner\n    mapping(uint256 => address) private GiftIndexToOwners;\n    \n    // Gift exist or not\n    mapping(uint256 => bool) private GiftExists;\n    \n    // mapping from owner and approved address to GiftId\n    mapping(address => mapping (address => uint256)) private allowed;\n    \n    // mapping from owner and index Gift of owner to GiftId\n    mapping(address => mapping(uint256 => uint256)) private ownerIndexToGifts;\n    \n    // Gift metadata\n    mapping(uint256 => string) GiftLinks;\n\n    modifier onlyOwner(){\n         require(msg.sender == owner);\n         _;\n    }\n\n    modifier onlyGiftOwner(uint256 GiftId){\n        require(msg.sender == GiftIndexToOwners[GiftId]);\n        _;\n    }\n    \n    modifier validGift(uint256 GiftId){\n        require(GiftExists[GiftId]);\n        _;\n    }\n\n    /// @dev constructor\n    function VirtualGift()\n    public{\n        owner = msg.sender;\n        // save temporaryly new Gift\n        Gift memory newGift = Gift({\n            price: 0,\n            description: \"MYTHICAL\"\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 mythicalGift = giftStorage.push(newGift) - 1; // id = 0\n        // mythical Gift is not exist\n        GiftExists[mythicalGift] = false;\n        // assign url for Gift\n        GiftLinks[mythicalGift] = \"mythicalGift\";\n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, mythicalGift);\n        // event create new Gift for msg.sender\n        Creation(msg.sender, mythicalGift);\n    }\n    \n    /// @dev this function change GTO address, this mean you can use many token to buy gift\n    /// by change GTO address to BNB address\n    /// @param newAddress is new address of GTO or another Gift like BNB\n    function changeGTOAddress(address newAddress)\n    public\n    onlyOwner{\n        GTO = ERC20(newAddress);\n    }\n    \n    /// @dev return current GTO address\n    function getGTOAddress()\n    public\n    constant\n    returns (address) {\n        return address(GTO);\n    }\n    \n    /// @dev return total supply of Gift\n    /// @return length of Gift storage array, except Gift Zero\n    function totalSupply()\n    public \n    constant\n    returns (uint256){\n        // exclusive Gift Zero\n        return giftStorage.length - 1;\n    }\n    \n    /// @dev allow people to buy Gift\n    /// @param GiftId : id of gift user want to buy\n    function buy(uint256 GiftId) \n    validGift(GiftId)\n    public {\n        // get old owner of Gift\n        address oldowner = ownerOf(GiftId);\n        // tell gifto transfer GTO from new owner to oldowner\n        // NOTE: new owner MUST approve for Virtual Gift contract to take his balance\n        require(GTO.transferFrom(msg.sender, oldowner, giftStorage[GiftId].price) == true);\n        // assign new owner for GiftId\n        // TODO: old owner should have something to confirm that he want to sell this Gift\n        _transfer(oldowner, msg.sender, GiftId);\n    }\n    \n    /// @dev owner send gift to recipient when VG was approved\n    /// @param recipient : received gift\n    /// @param GiftId : id of gift which recipient want to buy\n    function sendGift(address recipient, uint256 GiftId)\n    onlyGiftOwner(GiftId)\n    validGift(GiftId)\n    public {\n        // transfer GTO to owner\n        // require(GTO.transfer(msg.sender, giftStorage[GiftId].price) == true);\n        // transfer gift to recipient\n        _transfer(msg.sender, recipient, GiftId);\n    }\n    \n    /// @dev get total Gift of an address\n    /// @param _owner to get balance\n    /// @return balance of an address\n    function balanceOf(address _owner) \n    public \n    constant \n    returns (uint256 balance){\n        return balances[_owner];\n    }\n    \n    function isExist(uint256 GiftId)\n    public\n    constant\n    returns(bool){\n        return GiftExists[GiftId];\n    }\n    \n    /// @dev get owner of an Gift id\n    /// @param _GiftId : id of Gift to get owner\n    /// @return owner : owner of an Gift id\n    function ownerOf(uint256 _GiftId)\n    public\n    constant \n    returns (address _owner) {\n        require(GiftExists[_GiftId]);\n        return GiftIndexToOwners[_GiftId];\n    }\n    \n    /// @dev approve Gift id from msg.sender to an address\n    /// @param _to : address is approved\n    /// @param _GiftId : id of Gift in array\n    function approve(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        require(msg.sender == ownerOf(_GiftId));\n        require(msg.sender != _to);\n        \n        allowed[msg.sender][_to] = _GiftId;\n        Approval(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev get id of Gift was approved from owner to spender\n    /// @param _owner : address owner of Gift\n    /// @param _spender : spender was approved\n    /// @return GiftId\n    function allowance(address _owner, address _spender) \n    public \n    constant \n    returns (uint256 GiftId) {\n        return allowed[_owner][_spender];\n    }\n    \n    /// @dev a spender take owner ship of Gift id, when he was approved\n    /// @param _GiftId : id of Gift has being takeOwnership\n    function takeOwnership(uint256 _GiftId)\n    validGift(_GiftId)\n    public {\n        // get oldowner of Giftid\n        address oldOwner = ownerOf(_GiftId);\n        // new owner is msg sender\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        // newOwner must be approved by oldOwner\n        require(allowed[oldOwner][newOwner] == _GiftId);\n\n        // transfer Gift for new owner\n        _transfer(oldOwner, newOwner, _GiftId);\n\n        // delete approve when being done take owner ship\n        delete allowed[oldOwner][newOwner];\n\n        Transfer(oldOwner, newOwner, _GiftId);\n    }\n    \n    /// @dev transfer ownership of a specific Gift to an address.\n    /// @param _from : address owner of Giftid\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function _transfer(address _from, address _to, uint256 _GiftId) \n    internal {\n        // Since the number of Gift is capped to 2^32 we can't overflow this\n        balances[_to]++;\n        // transfer ownership\n        GiftIndexToOwners[_GiftId] = _to;\n        // When creating new Gift _from is 0x0, but we can't account that address.\n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        // Emit the transfer event.\n        Transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev transfer ownership of Giftid from msg sender to an address\n    /// @param _to : address's received\n    /// @param _GiftId : Gift id\n    function transfer(address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        // not transfer to zero\n        require(_to != 0x0);\n        // address received different from sender\n        require(msg.sender != _to);\n        // sender must be owner of Giftid\n        require(msg.sender == ownerOf(_GiftId));\n        // do not send to Gift contract\n        require(_to != address(this));\n        \n        _transfer(msg.sender, _to, _GiftId);\n    }\n    \n    /// @dev transfer Giftid was approved by _from to _to\n    /// @param _from : address owner of Giftid\n    /// @param _to : address is received\n    /// @param _GiftId : Gift id\n    function transferFrom(address _from, address _to, uint256 _GiftId)\n    validGift(_GiftId)\n    external {\n        require(_from == ownerOf(_GiftId));\n        // Check for approval and valid ownership\n        require(allowance(_from, msg.sender) == _GiftId);\n        // address received different from _owner\n        require(_from != _to);\n        \n        // Safety check to prevent against an unexpected 0x0 default.\n        require(_to != address(0));\n        // Disallow transfers to this contract to prevent accidental misuse.\n        // The contract should never own any Gift\n        require(_to != address(this));\n\n        // Reassign ownership (also clears pending approvals and emits Transfer event).\n        _transfer(_from, _to, _GiftId);\n    }\n    \n    /// @dev Returns a list of all Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    /// @return ownerGifts : list Gift of owner\n    function GiftsOfOwner(address _owner) \n    public \n    view \n    returns(uint256[] ownerGifts) {\n        \n        uint256 GiftCount = balanceOf(_owner);\n        if (GiftCount == 0) {\n            // Return an empty array\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](GiftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            // We count on the fact that all Gift have IDs starting at 1 and increasing\n            // sequentially up to the totalCat count.\n            uint256 GiftId;\n            \n            // scan array and filter Gift of owner\n            for (GiftId = 0; GiftId <= total; GiftId++) {\n                if (GiftIndexToOwners[GiftId] == _owner) {\n                    result[resultIndex] = GiftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n    \n    /// @dev Returns a Gift IDs assigned to an address.\n    /// @param _owner The owner whose Gift we are interested in.\n    /// @param _index to owner Gift list\n    /// @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n    ///  expensive (it walks the entire Gift array looking for Gift belonging to owner),\n    ///  it is only supported for web3 calls, and\n    ///  not contract-to-contract calls.\n    function giftOwnerByIndex(address _owner, uint256 _index)\n    external\n    constant \n    returns (uint256 GiftId) {\n        uint256[] memory ownerGifts = GiftsOfOwner(_owner);\n        return ownerGifts[_index];\n    }\n    \n    /// @dev get Gift metadata (url) from GiftLinks\n    /// @param _GiftId : Gift id\n    /// @return infoUrl : url of Gift\n    function GiftMetadata(uint256 _GiftId)\n    public\n    constant\n    returns (string infoUrl) {\n        return GiftLinks[_GiftId];\n    }\n    \n    /// @dev function create new Gift\n    /// @param _price : Gift property\n    /// @param _description : Gift property\n    /// @return GiftId\n    function createGift(uint256 _price, string _description, string _url)\n    public\n    onlyOwner\n    returns (uint256) {\n        // save temporarily new Gift\n        Gift memory newGift = Gift({\n            price: _price,\n            description: _description\n        });\n        // push to array and return the length is the id of new Gift\n        uint256 newGiftId = giftStorage.push(newGift) - 1;\n        // turn on existen\n        GiftExists[newGiftId] = true;\n        // assin gift url\n        GiftLinks[newGiftId] = _url;\n        // event create new Gift for msg.sender\n        Creation(msg.sender, newGiftId);\n        \n        // This will assign ownership, and also emit the Transfer event as\n        // per ERC721 draft\n        _transfer(0, msg.sender, newGiftId);\n        \n        return newGiftId;\n    }\n    \n    /// @dev get Gift property\n    /// @param GiftId : id of Gift\n    /// @return properties of Gift\n    function getGift(uint256 GiftId)\n    public\n    constant \n    returns (uint256, string){\n        if(GiftId > giftStorage.length){\n            return (0, \"\");\n        }\n        Gift memory newGift = giftStorage[GiftId];\n        return (newGift.price, newGift.description);\n    }\n    \n    /// @dev change gift properties\n    /// @param GiftId : to change\n    /// @param _price : new price of gift\n    /// @param _description : new description\n    /// @param _giftUrl : new url \n    function updateGift(uint256 GiftId, uint256 _price, string _description, string _giftUrl)\n    public\n    onlyOwner {\n        // check Gift exist First\n        require(GiftExists[GiftId]);\n        // setting new properties\n        giftStorage[GiftId].price = _price;\n        giftStorage[GiftId].description = _description;\n        GiftLinks[GiftId] = _giftUrl;\n    }\n    \n    /// @dev remove gift \n    /// @param GiftId : gift id to remove\n    function removeGift(uint256 GiftId)\n    public\n    onlyOwner {\n        // just setting GiftExists equal to false\n        GiftExists[GiftId] = false;\n    }\n    \n    /// @dev withdraw GTO in this contract\n    function withdrawGTO()\n    onlyOwner\n    public {\n        GTO.transfer(owner, GTO.balanceOf(address(this)));\n    }\n    \n}",
        "debug": "calldata_VirtualGift_4 + calldata_VirtualGift_32 + 36: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nkeccac_1_+\n29102676481673041902632991033461445430619272659676223336789171408008386403022_+\n2*calldata_VirtualGift_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_VirtualGift_4: 0x0\nstorage_2: 0x1\nstorage_keccac_calldata_VirtualGift_4: 0xff00\nstorage_1: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x2cfc1f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateGift(uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/15/0xa4b01cc6f2fde9d5d84da419bee4359819ae210b.sol",
        "function": "updateGift(uint256,uint256,string,string)",
        "lineno": 54,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}