{"error": null, "issues": [{"address": 1019, "code": "untBooks(user_));\n        forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]], XPAAssets(oldXPAAssets).getLoanAmount(u", "debug": "calldata_XPAAssets_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_XPAAssets_0: 0x28a20a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferXPAAssetAndProfit(address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "transferXPAAssetAndProfit(address[],uint256)", "lineno": 717, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1908, "code": "length; i++) {\n            if(xpaAsset[i] == newAsset){\n                return;\n            }\n        }\n        xpaAsset.push(newAsset);\n    }\n\n    //\u62b5\u62bc XPA\n    function mortgage(\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        uint256 amount_ = Token(XPA).allowance(msg.sender, this); // get mortgage amount\n        if(\n            amount_ >= 100 ether && \n            Token", "debug": "calldata_XPAAssets_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_XPAAssets_0: 0x5b06053000000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `createToken(string,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "createToken(string,string,uint256)", "lineno": 243, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5514, "code": "ender == operator || msg.se", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_XPAAssets_0: 0x20e979b100000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "assignBank(address)", "lineno": 104, "title": "Exception state", "type": "Informational"}, {"address": 5785, "code": "       assert(powerStatus);\n        _;\n    }\n    func", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_XPAAssets_0: 0x28a20a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "transferXPAAssetAndProfit(address[],uint256)", "lineno": 109, "title": "Exception state", "type": "Informational"}, {"address": 5943, "code": "     onlyOperator\n ", "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0x0\ncalldata_XPAAssets_0: 0x2f8061d400000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "repayment(address,uint256,address)", "lineno": 116, "title": "Exception state", "type": "Informational"}, {"address": 6121, "code": "[user_];\n        require(block.timestamp > in", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "repayment(address,uint256,address)", "lineno": 361, "title": "Message call to external contract", "type": "Warning"}, {"address": 6635, "code": "     onlyOperator\n ", "debug": "The exception is triggered under the following conditions:\n\nstorage_3: 0x0\ncalldata_XPAAssets_0: 0x32d05c6d00000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "withdrawXPA(uint256,address)", "lineno": 116, "title": "Exception state", "type": "Informational"}, {"address": 7025, "code": "Mul(getUsableXPA(user_), getPrice(", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "withdrawXPA(uint256,address)", "lineno": 322, "title": "Message call to external contract", "type": "Informational"}, {"address": 7491, "code": "   public\n        view\n    returns(uint256)", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "getPrice(address)", "lineno": 557, "title": "Message call to external contract", "type": "Informational"}, {"address": 8004, "code": "       assert(powerStatus);\n        _;\n    }\n    func", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_XPAAssets_0: 0x5b06053000000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "createToken(string,string,uint256)", "lineno": 109, "title": "Exception state", "type": "Informational"}, {"address": 8749, "code": "    //fee\n    uint256 pub", "debug": "The exception is triggered under the following conditions:\n\ncalldata_XPAAssets_4: 0x0\nstorage_15: 0x0\ncalldata_XPAAssets_0: 0x66acdd3400000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "_function_0x66acdd34", "lineno": 202, "title": "Exception state", "type": "Informational"}, {"address": 25999, "code": "170;\n    address public oldXPAAssets = 0x0002992af1dd8140193b87d2ab620ca22f6e19f26c;\n    address public newXPAAssets = address(0);\n    address public tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926;\n    // setting\n    uint256 public maxForceOffsetAmount = 1000000 ether;\n    uint256 public minForceOffsetAmount = 10000 ether;\n    \n    // events\n    event eMortgage(address, uint256);\n    event eWithdraw(address, address, uint256);\n    event eRepayment(address, address, uint256);\n    event eOffset(address, address, uint256);\n    event eExecuteOffset(uint256, address, uint256);\n    event eMigrate(address);\n    event eMigrateAmount(address);\n\n    //data\n    mapping(address => uint256) public fromAmountBooks;\n    mapping(address => mapping(address => uint256)) public toAmountBooks;\n    mapping(address => uint256) public forceOffsetBooks;\n    mapping(address => bool) public migrateBooks;\n    address[] public xpaAsset;\n    address public fundAccount;\n    uint256 public profit = 0;\n    mapping(address => uint256) public unPaidFundAccount;\n    uint256 public initCanOffsetTime = 0;\n    \n    //fee\n    uint256 public withdrawFeeRate = 0.02 ether; // \u63d0\u9818\u624b\u7e8c\u8cbb\n    uint256 public offsetFeeRate = 0.02 ether;   // \u5e73\u5009\u624b\u7e8c\u8cbb\n    uint256 public forceOffsetBasicFeeRate = 0.02 ether; // \u5f37\u5236\u5e73\u5009\u57fa\u672c\u8cbb\n    uint256 public forceOffsetExecuteFeeRate = 0.01 ether;// \u5f37\u5236\u5e73\u5009\u57f7\u884c\u8cbb\n    uint256 public forceOffsetExtraFeeRate = 0.05 ether; // \u5f37\u5236\u5e73\u5009\u984d\u5916\u624b\u7e8c\u8cbb\n    uint256 public forceOffsetExecuteMaxFee = 1000 ether; \n    \n    // constructor\n    function XPAAssets(\n        uint256 initCanOffsetTime_,\n        address XPAAddr,\n        address factoryAddr,\n        address oldXPAAssetsAddr\n    ) public {\n        initCanOffsetTime = initCanOffsetTime_;\n        XPA = XPAAddr;\n        tokenFactory = factoryAddr;\n        oldXPAAssets = oldXPAAssetsAddr;\n    }\n\n    function setFundAccount(\n        address fundAccount_\n    )\n        public\n        onlyOperator\n    {\n        if(fundAccount_ != address(0)) {\n            fundAccount = fundAccount_;\n        }\n    }\n\n    function createToken(\n        string symbol_,\n        string name_,\n        uint256 defaultExchangeRate_\n    )\n        public\n        onlyOperator \n    {\n        address newAsset = TokenFactory(tokenFactory).createToken(symbol_, name_, defaultExchangeRate_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            if(xpaAsset[i] == newAsset){\n                return;\n            }\n        }\n        xpaAsset.push(newAsset);\n    }\n\n    //\u62b5\u62bc XPA\n    function mortgage(\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        uint256 amount_ = Token(XPA).allowance(msg.sender, this); // get mortgage amount\n        if(\n            amount_ >= 100 ether && \n            Token(XPA).transferFrom(msg.sender, this, amount_) \n        ){\n            fromAmountBooks[user] = safeAdd(fromAmountBooks[user], amount_); // update books\n            emit eMortgage(user,amount_); // wirte event\n        }\n    }\n    \n    // \u501f\u51fa XPA Assets, amount: \u6307\u5b9a\u501f\u51fa\u91d1\u984d\n    function withdraw(\n        address token_,\n        uint256 amount_,\n        address representor_\n    ) \n        onlyActive \n        public \n    {\n        address user = getUser(representor_);\n        if(\n            token_ != XPA &&\n            amount_ > 0 &&\n            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n        ){\n            toAmountBooks[user][token_] = safeAdd(toAmountBooks[user][token_],amount_);\n            uint256 withdrawFee = safeDiv(safeMul(amount_,withdrawFeeRate),1 ether); // calculate withdraw fee\n            XPAAssetToken(token_).create(user, safeSub(amount_, withdrawFee));\n            XPAAssetToken(token_).create(this, withdrawFee);\n            emit eWithdraw(user, token_, amount_); // write event\n        }\n    }\n    \n    // \u9818\u56de XPA, amount: \u6307\u5b9a\u9818\u56de\u91d1\u984d\n    function withdrawXPA(\n        uint256 amount_,\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        if(\n            amount_ >= 100 ether && \n            amount_ <= getUsableXPA(user)\n        ){\n            fromAmountBooks[user] = safeSub(fromAmountBooks[user], amount_);\n            require(Token(XPA).transfer(user, amount_));\n            emit eWithdraw(user, XPA, amount_); // write event\n        }    \n    }\n    \n    // \u6aa2\u67e5\u984d\u5ea6\u662f\u5426\u8db3\u5920\u501f\u51fa XPA Assets\n    /*function checkWithdraw(\n        address token_,\n        uint256 amount_,\n        address user_\n    ) \n        internal  \n        view\n    returns(bool) {\n        if(\n            token_ != XPA && \n            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n        ){\n            return true;\n        }else if(\n            token_ == XPA && \n            amount_ <= getUsableXPA(user_)\n        ){\n            return true;\n        }else{\n            return false;\n        }\n    }*/\n\n    // \u9084\u6b3e XPA Assets, amount: \u6307\u5b9a\u9084\u56de\u91d1\u984d\n    function repayment(\n        address token_,\n        uint256 amount_,\n        address representor_\n    )\n        onlyActive \n        public\n    {\n        address user = getUser(representor_);\n        if(\n            XPAAssetToken(token_).burnFrom(user, amount_)\n        ) {\n            toAmountBooks[user][token_] = safeSub(toAmountBooks[user][token_],amount_);\n            emit eRepayment(user, token_, amount_);\n        }\n    }\n    \n    // \u5e73\u5009 / \u5f37\u884c\u5e73\u5009, user: \u6307\u5b9a\u5e73\u5009\u5c0d\u8c61\n    function offset(\n        address user_,\n        address token_\n    )\n        onlyActive\n        public\n    {\n        uint256 userFromAmount = fromAmountBooks[user_] >= maxForceOffsetAmount ? maxForceOffsetAmount : fromAmountBooks[user_];\n        require(block.timestamp > initCanOffsetTime);\n        require(userFromAmount > 0);\n        address user = getUser(user_);\n\n        if(\n            user_ == user &&\n            getLoanAmount(user, token_) > 0\n        ){\n            emit eOffset(user, user_, userFromAmount);\n            uint256 remainingXPA = executeOffset(user_, userFromAmount, token_, offsetFeeRate);\n            \n            require(Token(XPA).transfer(fundAccount, safeDiv(safeMul(safeSub(userFromAmount, remainingXPA), 1 ether), safeAdd(1 ether, offsetFeeRate)))); //\u8f49\u5e33\u81f3\u5e73\u5009\u57fa\u91d1\n            fromAmountBooks[user_] = remainingXPA;\n        }else if(\n            user_ != user && \n            block.timestamp > (forceOffsetBooks[user_] + 28800) &&\n            getMortgageRate(user_) >= getClosingLine()\n        ){\n            forceOffsetBooks[user_] = block.timestamp;\n                \n            uint256 punishXPA = getPunishXPA(user_); //get 10% xpa\n            emit eOffset(user, user_, punishXPA);\n\n            uint256[3] memory forceOffsetFee;\n            forceOffsetFee[0] = safeDiv(safeMul(punishXPA, forceOffsetBasicFeeRate), 1 ether); //\u57fa\u672c\u624b\u7e8c\u8cbb(\u6536\u76ca)\n            forceOffsetFee[1] = safeDiv(safeMul(punishXPA, forceOffsetExtraFeeRate), 1 ether); //\u984d\u5916\u624b\u7e8c\u8cbb(\u5e73\u5009\u57fa\u91d1)\n            forceOffsetFee[2] = safeDiv(safeMul(punishXPA, forceOffsetExecuteFeeRate), 1 ether);//\u57f7\u884c\u624b\u7e8c\u8cbb(\u57f7\u884c\u8005)\n            forceOffsetFee[2] = forceOffsetFee[2] > forceOffsetExecuteMaxFee ? forceOffsetExecuteMaxFee : forceOffsetFee[2];\n\n            profit = safeAdd(profit, forceOffsetFee[0]);\n            uint256 allFee = safeAdd(forceOffsetFee[2],safeAdd(forceOffsetFee[0], forceOffsetFee[1]));\n            remainingXPA = safeSub(punishXPA,allFee);\n\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                if(getLoanAmount(user_, xpaAsset[i]) > 0){\n                    remainingXPA = executeOffset(user_, remainingXPA, xpaAsset[i],0);\n                    if(remainingXPA == 0){\n                        break;\n                    }\n                }\n            }\n                \n            fromAmountBooks[user_] = safeSub(fromAmountBooks[user_], safeSub(punishXPA, remainingXPA));\n            require(Token(XPA).transfer(fundAccount, safeAdd(forceOffsetFee[1],safeSub(safeSub(punishXPA, allFee), remainingXPA)))); //\u8f49\u5e33\u81f3\u5e73\u5009\u57fa\u91d1\n            require(Token(XPA).transfer(msg.sender, forceOffsetFee[2])); //\u57f7\u884c\u624b\u7e8c\u8cbb\u8f49\u7d66\u57f7\u884c\u8005\n        }\n    }\n    \n    function executeOffset(\n        address user_,\n        uint256 xpaAmount_,\n        address xpaAssetToken,\n        uint256 feeRate\n    )\n        internal\n    returns(uint256){\n        uint256 fromXPAAsset = safeDiv(safeMul(xpaAmount_,getPrice(xpaAssetToken)),1 ether);\n        uint256 userToAmount = toAmountBooks[user_][xpaAssetToken];\n        uint256 fee = safeDiv(safeMul(userToAmount, feeRate), 1 ether);\n        uint256 burnXPA;\n        uint256 burnXPAAsset;\n        if(fromXPAAsset >= safeAdd(userToAmount, fee)){\n            burnXPA = safeDiv(safeMul(safeAdd(userToAmount, fee), 1 ether), getPrice(xpaAssetToken));\n            emit eExecuteOffset(burnXPA, xpaAssetToken, safeAdd(userToAmount, fee));\n            xpaAmount_ = safeSub(xpaAmount_, burnXPA);\n            toAmountBooks[user_][xpaAssetToken] = 0;\n            profit = safeAdd(profit, safeDiv(safeMul(fee,1 ether), getPrice(xpaAssetToken)));\n            if(\n                !FundAccount(fundAccount).burn(xpaAssetToken, userToAmount)\n            ){\n                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],userToAmount);\n            }\n\n        }else{\n            \n            fee = safeDiv(safeMul(xpaAmount_, feeRate), 1 ether);\n            profit = safeAdd(profit, fee);\n            burnXPAAsset = safeDiv(safeMul(safeSub(xpaAmount_, fee),getPrice(xpaAssetToken)),1 ether);\n            toAmountBooks[user_][xpaAssetToken] = safeSub(userToAmount, burnXPAAsset);\n            emit eExecuteOffset(xpaAmount_, xpaAssetToken, burnXPAAsset);\n            \n            xpaAmount_ = 0;\n            if(\n                !FundAccount(fundAccount).burn(xpaAssetToken, burnXPAAsset)\n            ){\n                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken], burnXPAAsset);\n            }\n            \n        }\n        return xpaAmount_;\n    }\n    \n    function getPunishXPA(\n        address user_\n    )\n        internal\n        view \n    returns(uint256){\n        uint256 userFromAmount = fromAmountBooks[user_];\n        uint256 punishXPA = safeDiv(safeMul(userFromAmount, 0.1 ether),1 ether);\n        if(userFromAmount <= safeAdd(minForceOffsetAmount, 100 ether)){\n            return userFromAmount;\n        }else if(punishXPA < minForceOffsetAmount){\n            return minForceOffsetAmount;\n        }else if(punishXPA > maxForceOffsetAmount){\n            return maxForceOffsetAmount;\n        }else{\n            return punishXPA;\n        }\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u62b5\u62bc\u7387, user: \u6307\u5b9a\u7528\u6236\n    function getMortgageRate(\n        address user_\n    ) \n        public\n        view \n    returns(uint256){\n        if(fromAmountBooks[user_] != 0){\n            uint256 totalLoanXPA = 0;\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n            }\n            return safeDiv(safeMul(totalLoanXPA,1 ether),fromAmountBooks[user_]);\n        }else{\n            return 0;\n        }\n    }\n        \n    // \u53d6\u5f97\u6700\u9ad8\u62b5\u62bc\u7387\n    function getHighestMortgageRate() \n        public\n        view \n    returns(uint256){\n        uint256 totalXPA = Token(XPA).totalSupply();\n        uint256 issueRate = safeDiv(safeMul(Token(XPA).balanceOf(this), 1 ether), totalXPA);\n        if(issueRate >= 0.7 ether){\n            return 0.7 ether;\n        }else if(issueRate >= 0.6 ether){\n            return 0.6 ether;\n        }else if(issueRate >= 0.5 ether){\n            return 0.5 ether;\n        }else if(issueRate >= 0.3 ether){\n            return 0.3 ether;\n        }else{\n            return 0.1 ether;\n        }\n    }\n    \n    // \u53d6\u5f97\u5e73\u5009\u7dda\n    function getClosingLine() \n        public\n        view\n    returns(uint256){\n        uint256 highestMortgageRate = getHighestMortgageRate();\n        if(highestMortgageRate >= 0.6 ether){\n            return safeAdd(highestMortgageRate, 0.1 ether);\n        }else{\n            return 0.6 ether;\n        }\n    }\n    \n    // \u53d6\u5f97 XPA Assets \u532f\u7387 \n    function getPrice(\n        address token_\n    ) \n        public\n        view\n    returns(uint256){\n        return TokenFactory(tokenFactory).getPrice(token_);\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u53ef\u63d0\u9818\u7684XPA(\u6263\u6389\u6700\u9ad8\u62b5\u62bc\u7387\u5f8c\u7684XPA)\n    function getUsableXPA(\n        address user_\n    )\n        public\n        view\n    returns(uint256) {\n        uint256 totalLoanXPA = 0;\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n        }\n        if(fromAmountBooks[user_] > safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate())){\n            return safeSub(fromAmountBooks[user_], safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate()));\n        }else{\n            return 0;\n        }\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u53ef\u501f\u8cb8 XPA Assets \u6700\u5927\u984d\u5ea6, user: \u6307\u5b9a\u7528\u6236\n    /*function getUsableAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        uint256 amount = safeDiv(safeMul(fromAmountBooks[user_], getPrice(token_)), 1 ether);\n        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n    }*/\n    \n    // \u53d6\u5f97\u7528\u6236\u5df2\u501f\u8cb8 XPA Assets \u6578\u91cf, user: \u6307\u5b9a\u7528\u6236\n    function getLoanAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        return toAmountBooks[user_][token_];\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u5269\u9918\u53ef\u501f\u8cb8 XPA Assets \u984d\u5ea6, user: \u6307\u5b9a\u7528\u6236\n    function getRemainingAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        uint256 amount = safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether);\n        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n    }\n    \n    function burnFundAccount(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator\n        public\n    {\n        if(\n            FundAccount(fundAccount).burn(token_, amount_)\n        ){\n            unPaidFundAccount[token_] = safeSub(unPaidFundAccount[token_], amount_);\n        }\n    }\n\n    function transferProfit(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator \n        public\n    {\n        require(amount_ > 0);\n        if(\n            XPA != token_ && \n            Token(token_).balanceOf(this) >= amount_\n        ) {\n            require(Token(token_).transfer(bank, amount_));\n        }\n\n        if(\n            XPA == token_ && \n            Token(XPA).balanceOf(this) >= amount_\n        ) {\n            profit = safeSub(profit,amount_);\n            require(Token(token_).transfer(bank, amount_));\n        }\n\n    }\n        \n    function setFeeRate(\n        uint256 withDrawFeerate_,\n        uint256 offsetFeerate_,\n        uint256 forceOffsetBasicFeerate_,\n        uint256 forceOffsetExecuteFeerate_,\n        uint256 forceOffsetExtraFeerate_,\n        uint256 forceOffsetExecuteMaxFee_\n    )\n        onlyOperator \n        public\n    {\n        require(withDrawFeerate_ < 0.05 ether);\n        require(offsetFeerate_ < 0.05 ether);\n        require(forceOffsetBasicFeerate_ < 0.05 ether);\n        require(forceOffsetExecuteFeerate_ < 0.05 ether);\n        require(forceOffsetExtraFeerate_ < 0.05 ether);\n        withdrawFeeRate = withDrawFeerate_;\n        offsetFeeRate = offsetFeerate_;\n        forceOffsetBasicFeeRate = forceOffsetBasicFeerate_;\n        forceOffsetExecuteFeeRate = forceOffsetExecuteFeerate_;\n        forceOffsetExtraFeeRate = forceOffsetExtraFeerate_;\n        forceOffsetExecuteMaxFee = forceOffsetExecuteMaxFee_;\n    }\n\n    function migrate(\n        address newContract_\n    )\n        public\n        onlyOwner\n    {\n        require(newContract_ != address(0));\n        if(\n            newXPAAssets == address(0) &&\n            XPAAssets(newContract_).transferXPAAssetAndProfit(xpaAsset, profit) &&\n            Token(XPA).transfer(newContract_, Token(XPA).balanceOf(this))\n        ) {\n            forceOff = true;\n            powerStatus = false;\n            newXPAAssets = newContract_;\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                XPAAssets(newContract_).transferUnPaidFundAccount(xpaAsset[i], unPaidFundAccount[xpaAsset[i]]);\n            }\n            emit eMigrate(newContract_);\n        }\n    }\n    \n    function transferXPAAssetAndProfit(\n        address[] xpaAsset_,\n        uint256 profit_\n    )\n        public\n        onlyOperator\n    returns(bool) {\n        require(msg.sender == oldXPAAssets);\n        xpaAsset = xpaAsset_;\n        profit = profit_;\n        return true;\n    }\n    \n    function transferUnPaidFundAccount(\n        address xpaAsset_,\n        uint256 unPaidAmount_\n    )\n        public\n        onlyOperator\n    returns(bool) {\n        require(msg.sender == oldXPAAssets);\n        unPaidFundAccount[xpaAsset_] = unPaidAmount_;\n        return true;\n    }\n    \n    function migratingAmountBooks(\n        address user_,\n        address newContract_\n    )\n        public\n        onlyOperator\n    {\n        XPAAssets(newContract_).migrateAmountBooks(user_); \n    }\n    \n    function migrateAmountBooks(\n        address user_\n    )\n        public\n        onlyOperator \n    {\n        require(msg.sender == oldXPAAssets);\n        require(!migrateBooks[user_]);\n\n        migrateBooks[user_] = true;\n        fromAmountBooks[user_] = safeAdd(fromAmountBooks[user_],XPAAssets(oldXPAAssets).getFromAmountBooks(user_));\n        forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]], XPAAssets(oldXPAAssets).getLoanAmount(user_,xpaAsset[i]));\n        }\n        emit eMigrateAmount(user_);\n    }\n    \n    function getFromAmountBooks(\n        address user_\n    )\n        public\n        view \n    returns(uint256) {\n        return fromAmountBooks[user_];\n    }\n    \n    function getForceOffsetBooks(\n        address user_\n    )\n        public \n        view \n    returns(uint256) {\n        return forceOffsetBooks[user_];\n    }\n}", "debug": "storage_15: 0x9bf67baffb0401fd0d0020003621060fd3fe72febdc200000000000153fa43fe\nstorage_6: 0x0\nstorage_1: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_XPAAssets_0: 0x28a20a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferXPAAssetAndProfit(address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "transferXPAAssetAndProfit(address[],uint256)", "lineno": 174, "title": "Integer Overflow ", "type": "Warning"}, {"address": 26010, "code": "170;\n    address public oldXPAAssets = 0x0002992af1dd8140193b87d2ab620ca22f6e19f26c;\n    address public newXPAAssets = address(0);\n    address public tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926;\n    // setting\n    uint256 public maxForceOffsetAmount = 1000000 ether;\n    uint256 public minForceOffsetAmount = 10000 ether;\n    \n    // events\n    event eMortgage(address, uint256);\n    event eWithdraw(address, address, uint256);\n    event eRepayment(address, address, uint256);\n    event eOffset(address, address, uint256);\n    event eExecuteOffset(uint256, address, uint256);\n    event eMigrate(address);\n    event eMigrateAmount(address);\n\n    //data\n    mapping(address => uint256) public fromAmountBooks;\n    mapping(address => mapping(address => uint256)) public toAmountBooks;\n    mapping(address => uint256) public forceOffsetBooks;\n    mapping(address => bool) public migrateBooks;\n    address[] public xpaAsset;\n    address public fundAccount;\n    uint256 public profit = 0;\n    mapping(address => uint256) public unPaidFundAccount;\n    uint256 public initCanOffsetTime = 0;\n    \n    //fee\n    uint256 public withdrawFeeRate = 0.02 ether; // \u63d0\u9818\u624b\u7e8c\u8cbb\n    uint256 public offsetFeeRate = 0.02 ether;   // \u5e73\u5009\u624b\u7e8c\u8cbb\n    uint256 public forceOffsetBasicFeeRate = 0.02 ether; // \u5f37\u5236\u5e73\u5009\u57fa\u672c\u8cbb\n    uint256 public forceOffsetExecuteFeeRate = 0.01 ether;// \u5f37\u5236\u5e73\u5009\u57f7\u884c\u8cbb\n    uint256 public forceOffsetExtraFeeRate = 0.05 ether; // \u5f37\u5236\u5e73\u5009\u984d\u5916\u624b\u7e8c\u8cbb\n    uint256 public forceOffsetExecuteMaxFee = 1000 ether; \n    \n    // constructor\n    function XPAAssets(\n        uint256 initCanOffsetTime_,\n        address XPAAddr,\n        address factoryAddr,\n        address oldXPAAssetsAddr\n    ) public {\n        initCanOffsetTime = initCanOffsetTime_;\n        XPA = XPAAddr;\n        tokenFactory = factoryAddr;\n        oldXPAAssets = oldXPAAssetsAddr;\n    }\n\n    function setFundAccount(\n        address fundAccount_\n    )\n        public\n        onlyOperator\n    {\n        if(fundAccount_ != address(0)) {\n            fundAccount = fundAccount_;\n        }\n    }\n\n    function createToken(\n        string symbol_,\n        string name_,\n        uint256 defaultExchangeRate_\n    )\n        public\n        onlyOperator \n    {\n        address newAsset = TokenFactory(tokenFactory).createToken(symbol_, name_, defaultExchangeRate_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            if(xpaAsset[i] == newAsset){\n                return;\n            }\n        }\n        xpaAsset.push(newAsset);\n    }\n\n    //\u62b5\u62bc XPA\n    function mortgage(\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        uint256 amount_ = Token(XPA).allowance(msg.sender, this); // get mortgage amount\n        if(\n            amount_ >= 100 ether && \n            Token(XPA).transferFrom(msg.sender, this, amount_) \n        ){\n            fromAmountBooks[user] = safeAdd(fromAmountBooks[user], amount_); // update books\n            emit eMortgage(user,amount_); // wirte event\n        }\n    }\n    \n    // \u501f\u51fa XPA Assets, amount: \u6307\u5b9a\u501f\u51fa\u91d1\u984d\n    function withdraw(\n        address token_,\n        uint256 amount_,\n        address representor_\n    ) \n        onlyActive \n        public \n    {\n        address user = getUser(representor_);\n        if(\n            token_ != XPA &&\n            amount_ > 0 &&\n            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n        ){\n            toAmountBooks[user][token_] = safeAdd(toAmountBooks[user][token_],amount_);\n            uint256 withdrawFee = safeDiv(safeMul(amount_,withdrawFeeRate),1 ether); // calculate withdraw fee\n            XPAAssetToken(token_).create(user, safeSub(amount_, withdrawFee));\n            XPAAssetToken(token_).create(this, withdrawFee);\n            emit eWithdraw(user, token_, amount_); // write event\n        }\n    }\n    \n    // \u9818\u56de XPA, amount: \u6307\u5b9a\u9818\u56de\u91d1\u984d\n    function withdrawXPA(\n        uint256 amount_,\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        if(\n            amount_ >= 100 ether && \n            amount_ <= getUsableXPA(user)\n        ){\n            fromAmountBooks[user] = safeSub(fromAmountBooks[user], amount_);\n            require(Token(XPA).transfer(user, amount_));\n            emit eWithdraw(user, XPA, amount_); // write event\n        }    \n    }\n    \n    // \u6aa2\u67e5\u984d\u5ea6\u662f\u5426\u8db3\u5920\u501f\u51fa XPA Assets\n    /*function checkWithdraw(\n        address token_,\n        uint256 amount_,\n        address user_\n    ) \n        internal  \n        view\n    returns(bool) {\n        if(\n            token_ != XPA && \n            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n        ){\n            return true;\n        }else if(\n            token_ == XPA && \n            amount_ <= getUsableXPA(user_)\n        ){\n            return true;\n        }else{\n            return false;\n        }\n    }*/\n\n    // \u9084\u6b3e XPA Assets, amount: \u6307\u5b9a\u9084\u56de\u91d1\u984d\n    function repayment(\n        address token_,\n        uint256 amount_,\n        address representor_\n    )\n        onlyActive \n        public\n    {\n        address user = getUser(representor_);\n        if(\n            XPAAssetToken(token_).burnFrom(user, amount_)\n        ) {\n            toAmountBooks[user][token_] = safeSub(toAmountBooks[user][token_],amount_);\n            emit eRepayment(user, token_, amount_);\n        }\n    }\n    \n    // \u5e73\u5009 / \u5f37\u884c\u5e73\u5009, user: \u6307\u5b9a\u5e73\u5009\u5c0d\u8c61\n    function offset(\n        address user_,\n        address token_\n    )\n        onlyActive\n        public\n    {\n        uint256 userFromAmount = fromAmountBooks[user_] >= maxForceOffsetAmount ? maxForceOffsetAmount : fromAmountBooks[user_];\n        require(block.timestamp > initCanOffsetTime);\n        require(userFromAmount > 0);\n        address user = getUser(user_);\n\n        if(\n            user_ == user &&\n            getLoanAmount(user, token_) > 0\n        ){\n            emit eOffset(user, user_, userFromAmount);\n            uint256 remainingXPA = executeOffset(user_, userFromAmount, token_, offsetFeeRate);\n            \n            require(Token(XPA).transfer(fundAccount, safeDiv(safeMul(safeSub(userFromAmount, remainingXPA), 1 ether), safeAdd(1 ether, offsetFeeRate)))); //\u8f49\u5e33\u81f3\u5e73\u5009\u57fa\u91d1\n            fromAmountBooks[user_] = remainingXPA;\n        }else if(\n            user_ != user && \n            block.timestamp > (forceOffsetBooks[user_] + 28800) &&\n            getMortgageRate(user_) >= getClosingLine()\n        ){\n            forceOffsetBooks[user_] = block.timestamp;\n                \n            uint256 punishXPA = getPunishXPA(user_); //get 10% xpa\n            emit eOffset(user, user_, punishXPA);\n\n            uint256[3] memory forceOffsetFee;\n            forceOffsetFee[0] = safeDiv(safeMul(punishXPA, forceOffsetBasicFeeRate), 1 ether); //\u57fa\u672c\u624b\u7e8c\u8cbb(\u6536\u76ca)\n            forceOffsetFee[1] = safeDiv(safeMul(punishXPA, forceOffsetExtraFeeRate), 1 ether); //\u984d\u5916\u624b\u7e8c\u8cbb(\u5e73\u5009\u57fa\u91d1)\n            forceOffsetFee[2] = safeDiv(safeMul(punishXPA, forceOffsetExecuteFeeRate), 1 ether);//\u57f7\u884c\u624b\u7e8c\u8cbb(\u57f7\u884c\u8005)\n            forceOffsetFee[2] = forceOffsetFee[2] > forceOffsetExecuteMaxFee ? forceOffsetExecuteMaxFee : forceOffsetFee[2];\n\n            profit = safeAdd(profit, forceOffsetFee[0]);\n            uint256 allFee = safeAdd(forceOffsetFee[2],safeAdd(forceOffsetFee[0], forceOffsetFee[1]));\n            remainingXPA = safeSub(punishXPA,allFee);\n\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                if(getLoanAmount(user_, xpaAsset[i]) > 0){\n                    remainingXPA = executeOffset(user_, remainingXPA, xpaAsset[i],0);\n                    if(remainingXPA == 0){\n                        break;\n                    }\n                }\n            }\n                \n            fromAmountBooks[user_] = safeSub(fromAmountBooks[user_], safeSub(punishXPA, remainingXPA));\n            require(Token(XPA).transfer(fundAccount, safeAdd(forceOffsetFee[1],safeSub(safeSub(punishXPA, allFee), remainingXPA)))); //\u8f49\u5e33\u81f3\u5e73\u5009\u57fa\u91d1\n            require(Token(XPA).transfer(msg.sender, forceOffsetFee[2])); //\u57f7\u884c\u624b\u7e8c\u8cbb\u8f49\u7d66\u57f7\u884c\u8005\n        }\n    }\n    \n    function executeOffset(\n        address user_,\n        uint256 xpaAmount_,\n        address xpaAssetToken,\n        uint256 feeRate\n    )\n        internal\n    returns(uint256){\n        uint256 fromXPAAsset = safeDiv(safeMul(xpaAmount_,getPrice(xpaAssetToken)),1 ether);\n        uint256 userToAmount = toAmountBooks[user_][xpaAssetToken];\n        uint256 fee = safeDiv(safeMul(userToAmount, feeRate), 1 ether);\n        uint256 burnXPA;\n        uint256 burnXPAAsset;\n        if(fromXPAAsset >= safeAdd(userToAmount, fee)){\n            burnXPA = safeDiv(safeMul(safeAdd(userToAmount, fee), 1 ether), getPrice(xpaAssetToken));\n            emit eExecuteOffset(burnXPA, xpaAssetToken, safeAdd(userToAmount, fee));\n            xpaAmount_ = safeSub(xpaAmount_, burnXPA);\n            toAmountBooks[user_][xpaAssetToken] = 0;\n            profit = safeAdd(profit, safeDiv(safeMul(fee,1 ether), getPrice(xpaAssetToken)));\n            if(\n                !FundAccount(fundAccount).burn(xpaAssetToken, userToAmount)\n            ){\n                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],userToAmount);\n            }\n\n        }else{\n            \n            fee = safeDiv(safeMul(xpaAmount_, feeRate), 1 ether);\n            profit = safeAdd(profit, fee);\n            burnXPAAsset = safeDiv(safeMul(safeSub(xpaAmount_, fee),getPrice(xpaAssetToken)),1 ether);\n            toAmountBooks[user_][xpaAssetToken] = safeSub(userToAmount, burnXPAAsset);\n            emit eExecuteOffset(xpaAmount_, xpaAssetToken, burnXPAAsset);\n            \n            xpaAmount_ = 0;\n            if(\n                !FundAccount(fundAccount).burn(xpaAssetToken, burnXPAAsset)\n            ){\n                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken], burnXPAAsset);\n            }\n            \n        }\n        return xpaAmount_;\n    }\n    \n    function getPunishXPA(\n        address user_\n    )\n        internal\n        view \n    returns(uint256){\n        uint256 userFromAmount = fromAmountBooks[user_];\n        uint256 punishXPA = safeDiv(safeMul(userFromAmount, 0.1 ether),1 ether);\n        if(userFromAmount <= safeAdd(minForceOffsetAmount, 100 ether)){\n            return userFromAmount;\n        }else if(punishXPA < minForceOffsetAmount){\n            return minForceOffsetAmount;\n        }else if(punishXPA > maxForceOffsetAmount){\n            return maxForceOffsetAmount;\n        }else{\n            return punishXPA;\n        }\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u62b5\u62bc\u7387, user: \u6307\u5b9a\u7528\u6236\n    function getMortgageRate(\n        address user_\n    ) \n        public\n        view \n    returns(uint256){\n        if(fromAmountBooks[user_] != 0){\n            uint256 totalLoanXPA = 0;\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n            }\n            return safeDiv(safeMul(totalLoanXPA,1 ether),fromAmountBooks[user_]);\n        }else{\n            return 0;\n        }\n    }\n        \n    // \u53d6\u5f97\u6700\u9ad8\u62b5\u62bc\u7387\n    function getHighestMortgageRate() \n        public\n        view \n    returns(uint256){\n        uint256 totalXPA = Token(XPA).totalSupply();\n        uint256 issueRate = safeDiv(safeMul(Token(XPA).balanceOf(this), 1 ether), totalXPA);\n        if(issueRate >= 0.7 ether){\n            return 0.7 ether;\n        }else if(issueRate >= 0.6 ether){\n            return 0.6 ether;\n        }else if(issueRate >= 0.5 ether){\n            return 0.5 ether;\n        }else if(issueRate >= 0.3 ether){\n            return 0.3 ether;\n        }else{\n            return 0.1 ether;\n        }\n    }\n    \n    // \u53d6\u5f97\u5e73\u5009\u7dda\n    function getClosingLine() \n        public\n        view\n    returns(uint256){\n        uint256 highestMortgageRate = getHighestMortgageRate();\n        if(highestMortgageRate >= 0.6 ether){\n            return safeAdd(highestMortgageRate, 0.1 ether);\n        }else{\n            return 0.6 ether;\n        }\n    }\n    \n    // \u53d6\u5f97 XPA Assets \u532f\u7387 \n    function getPrice(\n        address token_\n    ) \n        public\n        view\n    returns(uint256){\n        return TokenFactory(tokenFactory).getPrice(token_);\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u53ef\u63d0\u9818\u7684XPA(\u6263\u6389\u6700\u9ad8\u62b5\u62bc\u7387\u5f8c\u7684XPA)\n    function getUsableXPA(\n        address user_\n    )\n        public\n        view\n    returns(uint256) {\n        uint256 totalLoanXPA = 0;\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n        }\n        if(fromAmountBooks[user_] > safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate())){\n            return safeSub(fromAmountBooks[user_], safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate()));\n        }else{\n            return 0;\n        }\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u53ef\u501f\u8cb8 XPA Assets \u6700\u5927\u984d\u5ea6, user: \u6307\u5b9a\u7528\u6236\n    /*function getUsableAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        uint256 amount = safeDiv(safeMul(fromAmountBooks[user_], getPrice(token_)), 1 ether);\n        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n    }*/\n    \n    // \u53d6\u5f97\u7528\u6236\u5df2\u501f\u8cb8 XPA Assets \u6578\u91cf, user: \u6307\u5b9a\u7528\u6236\n    function getLoanAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        return toAmountBooks[user_][token_];\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u5269\u9918\u53ef\u501f\u8cb8 XPA Assets \u984d\u5ea6, user: \u6307\u5b9a\u7528\u6236\n    function getRemainingAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        uint256 amount = safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether);\n        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n    }\n    \n    function burnFundAccount(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator\n        public\n    {\n        if(\n            FundAccount(fundAccount).burn(token_, amount_)\n        ){\n            unPaidFundAccount[token_] = safeSub(unPaidFundAccount[token_], amount_);\n        }\n    }\n\n    function transferProfit(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator \n        public\n    {\n        require(amount_ > 0);\n        if(\n            XPA != token_ && \n            Token(token_).balanceOf(this) >= amount_\n        ) {\n            require(Token(token_).transfer(bank, amount_));\n        }\n\n        if(\n            XPA == token_ && \n            Token(XPA).balanceOf(this) >= amount_\n        ) {\n            profit = safeSub(profit,amount_);\n            require(Token(token_).transfer(bank, amount_));\n        }\n\n    }\n        \n    function setFeeRate(\n        uint256 withDrawFeerate_,\n        uint256 offsetFeerate_,\n        uint256 forceOffsetBasicFeerate_,\n        uint256 forceOffsetExecuteFeerate_,\n        uint256 forceOffsetExtraFeerate_,\n        uint256 forceOffsetExecuteMaxFee_\n    )\n        onlyOperator \n        public\n    {\n        require(withDrawFeerate_ < 0.05 ether);\n        require(offsetFeerate_ < 0.05 ether);\n        require(forceOffsetBasicFeerate_ < 0.05 ether);\n        require(forceOffsetExecuteFeerate_ < 0.05 ether);\n        require(forceOffsetExtraFeerate_ < 0.05 ether);\n        withdrawFeeRate = withDrawFeerate_;\n        offsetFeeRate = offsetFeerate_;\n        forceOffsetBasicFeeRate = forceOffsetBasicFeerate_;\n        forceOffsetExecuteFeeRate = forceOffsetExecuteFeerate_;\n        forceOffsetExtraFeeRate = forceOffsetExtraFeerate_;\n        forceOffsetExecuteMaxFee = forceOffsetExecuteMaxFee_;\n    }\n\n    function migrate(\n        address newContract_\n    )\n        public\n        onlyOwner\n    {\n        require(newContract_ != address(0));\n        if(\n            newXPAAssets == address(0) &&\n            XPAAssets(newContract_).transferXPAAssetAndProfit(xpaAsset, profit) &&\n            Token(XPA).transfer(newContract_, Token(XPA).balanceOf(this))\n        ) {\n            forceOff = true;\n            powerStatus = false;\n            newXPAAssets = newContract_;\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                XPAAssets(newContract_).transferUnPaidFundAccount(xpaAsset[i], unPaidFundAccount[xpaAsset[i]]);\n            }\n            emit eMigrate(newContract_);\n        }\n    }\n    \n    function transferXPAAssetAndProfit(\n        address[] xpaAsset_,\n        uint256 profit_\n    )\n        public\n        onlyOperator\n    returns(bool) {\n        require(msg.sender == oldXPAAssets);\n        xpaAsset = xpaAsset_;\n        profit = profit_;\n        return true;\n    }\n    \n    function transferUnPaidFundAccount(\n        address xpaAsset_,\n        uint256 unPaidAmount_\n    )\n        public\n        onlyOperator\n    returns(bool) {\n        require(msg.sender == oldXPAAssets);\n        unPaidFundAccount[xpaAsset_] = unPaidAmount_;\n        return true;\n    }\n    \n    function migratingAmountBooks(\n        address user_,\n        address newContract_\n    )\n        public\n        onlyOperator\n    {\n        XPAAssets(newContract_).migrateAmountBooks(user_); \n    }\n    \n    function migrateAmountBooks(\n        address user_\n    )\n        public\n        onlyOperator \n    {\n        require(msg.sender == oldXPAAssets);\n        require(!migrateBooks[user_]);\n\n        migrateBooks[user_] = true;\n        fromAmountBooks[user_] = safeAdd(fromAmountBooks[user_],XPAAssets(oldXPAAssets).getFromAmountBooks(user_));\n        forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]], XPAAssets(oldXPAAssets).getLoanAmount(user_,xpaAsset[i]));\n        }\n        emit eMigrateAmount(user_);\n    }\n    \n    function getFromAmountBooks(\n        address user_\n    )\n        public\n        view \n    returns(uint256) {\n        return fromAmountBooks[user_];\n    }\n    \n    function getForceOffsetBooks(\n        address user_\n    )\n        public \n        view \n    returns(uint256) {\n        return forceOffsetBooks[user_];\n    }\n}", "debug": "calldata_XPAAssets_4 + calldata_XPAAssets_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_6: 0x0\nstorage_1: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_XPAAssets_0: 0x28a20a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferXPAAssetAndProfit(address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "transferXPAAssetAndProfit(address[],uint256)", "lineno": 174, "title": "Integer Overflow ", "type": "Warning"}, {"address": 26012, "code": "170;\n    address public oldXPAAssets = 0x0002992af1dd8140193b87d2ab620ca22f6e19f26c;\n    address public newXPAAssets = address(0);\n    address public tokenFactory = 0x001393F1fb2E243Ee68Efe172eBb6831772633A926;\n    // setting\n    uint256 public maxForceOffsetAmount = 1000000 ether;\n    uint256 public minForceOffsetAmount = 10000 ether;\n    \n    // events\n    event eMortgage(address, uint256);\n    event eWithdraw(address, address, uint256);\n    event eRepayment(address, address, uint256);\n    event eOffset(address, address, uint256);\n    event eExecuteOffset(uint256, address, uint256);\n    event eMigrate(address);\n    event eMigrateAmount(address);\n\n    //data\n    mapping(address => uint256) public fromAmountBooks;\n    mapping(address => mapping(address => uint256)) public toAmountBooks;\n    mapping(address => uint256) public forceOffsetBooks;\n    mapping(address => bool) public migrateBooks;\n    address[] public xpaAsset;\n    address public fundAccount;\n    uint256 public profit = 0;\n    mapping(address => uint256) public unPaidFundAccount;\n    uint256 public initCanOffsetTime = 0;\n    \n    //fee\n    uint256 public withdrawFeeRate = 0.02 ether; // \u63d0\u9818\u624b\u7e8c\u8cbb\n    uint256 public offsetFeeRate = 0.02 ether;   // \u5e73\u5009\u624b\u7e8c\u8cbb\n    uint256 public forceOffsetBasicFeeRate = 0.02 ether; // \u5f37\u5236\u5e73\u5009\u57fa\u672c\u8cbb\n    uint256 public forceOffsetExecuteFeeRate = 0.01 ether;// \u5f37\u5236\u5e73\u5009\u57f7\u884c\u8cbb\n    uint256 public forceOffsetExtraFeeRate = 0.05 ether; // \u5f37\u5236\u5e73\u5009\u984d\u5916\u624b\u7e8c\u8cbb\n    uint256 public forceOffsetExecuteMaxFee = 1000 ether; \n    \n    // constructor\n    function XPAAssets(\n        uint256 initCanOffsetTime_,\n        address XPAAddr,\n        address factoryAddr,\n        address oldXPAAssetsAddr\n    ) public {\n        initCanOffsetTime = initCanOffsetTime_;\n        XPA = XPAAddr;\n        tokenFactory = factoryAddr;\n        oldXPAAssets = oldXPAAssetsAddr;\n    }\n\n    function setFundAccount(\n        address fundAccount_\n    )\n        public\n        onlyOperator\n    {\n        if(fundAccount_ != address(0)) {\n            fundAccount = fundAccount_;\n        }\n    }\n\n    function createToken(\n        string symbol_,\n        string name_,\n        uint256 defaultExchangeRate_\n    )\n        public\n        onlyOperator \n    {\n        address newAsset = TokenFactory(tokenFactory).createToken(symbol_, name_, defaultExchangeRate_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            if(xpaAsset[i] == newAsset){\n                return;\n            }\n        }\n        xpaAsset.push(newAsset);\n    }\n\n    //\u62b5\u62bc XPA\n    function mortgage(\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        uint256 amount_ = Token(XPA).allowance(msg.sender, this); // get mortgage amount\n        if(\n            amount_ >= 100 ether && \n            Token(XPA).transferFrom(msg.sender, this, amount_) \n        ){\n            fromAmountBooks[user] = safeAdd(fromAmountBooks[user], amount_); // update books\n            emit eMortgage(user,amount_); // wirte event\n        }\n    }\n    \n    // \u501f\u51fa XPA Assets, amount: \u6307\u5b9a\u501f\u51fa\u91d1\u984d\n    function withdraw(\n        address token_,\n        uint256 amount_,\n        address representor_\n    ) \n        onlyActive \n        public \n    {\n        address user = getUser(representor_);\n        if(\n            token_ != XPA &&\n            amount_ > 0 &&\n            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n        ){\n            toAmountBooks[user][token_] = safeAdd(toAmountBooks[user][token_],amount_);\n            uint256 withdrawFee = safeDiv(safeMul(amount_,withdrawFeeRate),1 ether); // calculate withdraw fee\n            XPAAssetToken(token_).create(user, safeSub(amount_, withdrawFee));\n            XPAAssetToken(token_).create(this, withdrawFee);\n            emit eWithdraw(user, token_, amount_); // write event\n        }\n    }\n    \n    // \u9818\u56de XPA, amount: \u6307\u5b9a\u9818\u56de\u91d1\u984d\n    function withdrawXPA(\n        uint256 amount_,\n        address representor_\n    )\n        onlyActive\n        public\n    {\n        address user = getUser(representor_);\n        if(\n            amount_ >= 100 ether && \n            amount_ <= getUsableXPA(user)\n        ){\n            fromAmountBooks[user] = safeSub(fromAmountBooks[user], amount_);\n            require(Token(XPA).transfer(user, amount_));\n            emit eWithdraw(user, XPA, amount_); // write event\n        }    \n    }\n    \n    // \u6aa2\u67e5\u984d\u5ea6\u662f\u5426\u8db3\u5920\u501f\u51fa XPA Assets\n    /*function checkWithdraw(\n        address token_,\n        uint256 amount_,\n        address user_\n    ) \n        internal  \n        view\n    returns(bool) {\n        if(\n            token_ != XPA && \n            amount_ <= safeDiv(safeMul(safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether), getHighestMortgageRate()), 1 ether)\n        ){\n            return true;\n        }else if(\n            token_ == XPA && \n            amount_ <= getUsableXPA(user_)\n        ){\n            return true;\n        }else{\n            return false;\n        }\n    }*/\n\n    // \u9084\u6b3e XPA Assets, amount: \u6307\u5b9a\u9084\u56de\u91d1\u984d\n    function repayment(\n        address token_,\n        uint256 amount_,\n        address representor_\n    )\n        onlyActive \n        public\n    {\n        address user = getUser(representor_);\n        if(\n            XPAAssetToken(token_).burnFrom(user, amount_)\n        ) {\n            toAmountBooks[user][token_] = safeSub(toAmountBooks[user][token_],amount_);\n            emit eRepayment(user, token_, amount_);\n        }\n    }\n    \n    // \u5e73\u5009 / \u5f37\u884c\u5e73\u5009, user: \u6307\u5b9a\u5e73\u5009\u5c0d\u8c61\n    function offset(\n        address user_,\n        address token_\n    )\n        onlyActive\n        public\n    {\n        uint256 userFromAmount = fromAmountBooks[user_] >= maxForceOffsetAmount ? maxForceOffsetAmount : fromAmountBooks[user_];\n        require(block.timestamp > initCanOffsetTime);\n        require(userFromAmount > 0);\n        address user = getUser(user_);\n\n        if(\n            user_ == user &&\n            getLoanAmount(user, token_) > 0\n        ){\n            emit eOffset(user, user_, userFromAmount);\n            uint256 remainingXPA = executeOffset(user_, userFromAmount, token_, offsetFeeRate);\n            \n            require(Token(XPA).transfer(fundAccount, safeDiv(safeMul(safeSub(userFromAmount, remainingXPA), 1 ether), safeAdd(1 ether, offsetFeeRate)))); //\u8f49\u5e33\u81f3\u5e73\u5009\u57fa\u91d1\n            fromAmountBooks[user_] = remainingXPA;\n        }else if(\n            user_ != user && \n            block.timestamp > (forceOffsetBooks[user_] + 28800) &&\n            getMortgageRate(user_) >= getClosingLine()\n        ){\n            forceOffsetBooks[user_] = block.timestamp;\n                \n            uint256 punishXPA = getPunishXPA(user_); //get 10% xpa\n            emit eOffset(user, user_, punishXPA);\n\n            uint256[3] memory forceOffsetFee;\n            forceOffsetFee[0] = safeDiv(safeMul(punishXPA, forceOffsetBasicFeeRate), 1 ether); //\u57fa\u672c\u624b\u7e8c\u8cbb(\u6536\u76ca)\n            forceOffsetFee[1] = safeDiv(safeMul(punishXPA, forceOffsetExtraFeeRate), 1 ether); //\u984d\u5916\u624b\u7e8c\u8cbb(\u5e73\u5009\u57fa\u91d1)\n            forceOffsetFee[2] = safeDiv(safeMul(punishXPA, forceOffsetExecuteFeeRate), 1 ether);//\u57f7\u884c\u624b\u7e8c\u8cbb(\u57f7\u884c\u8005)\n            forceOffsetFee[2] = forceOffsetFee[2] > forceOffsetExecuteMaxFee ? forceOffsetExecuteMaxFee : forceOffsetFee[2];\n\n            profit = safeAdd(profit, forceOffsetFee[0]);\n            uint256 allFee = safeAdd(forceOffsetFee[2],safeAdd(forceOffsetFee[0], forceOffsetFee[1]));\n            remainingXPA = safeSub(punishXPA,allFee);\n\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                if(getLoanAmount(user_, xpaAsset[i]) > 0){\n                    remainingXPA = executeOffset(user_, remainingXPA, xpaAsset[i],0);\n                    if(remainingXPA == 0){\n                        break;\n                    }\n                }\n            }\n                \n            fromAmountBooks[user_] = safeSub(fromAmountBooks[user_], safeSub(punishXPA, remainingXPA));\n            require(Token(XPA).transfer(fundAccount, safeAdd(forceOffsetFee[1],safeSub(safeSub(punishXPA, allFee), remainingXPA)))); //\u8f49\u5e33\u81f3\u5e73\u5009\u57fa\u91d1\n            require(Token(XPA).transfer(msg.sender, forceOffsetFee[2])); //\u57f7\u884c\u624b\u7e8c\u8cbb\u8f49\u7d66\u57f7\u884c\u8005\n        }\n    }\n    \n    function executeOffset(\n        address user_,\n        uint256 xpaAmount_,\n        address xpaAssetToken,\n        uint256 feeRate\n    )\n        internal\n    returns(uint256){\n        uint256 fromXPAAsset = safeDiv(safeMul(xpaAmount_,getPrice(xpaAssetToken)),1 ether);\n        uint256 userToAmount = toAmountBooks[user_][xpaAssetToken];\n        uint256 fee = safeDiv(safeMul(userToAmount, feeRate), 1 ether);\n        uint256 burnXPA;\n        uint256 burnXPAAsset;\n        if(fromXPAAsset >= safeAdd(userToAmount, fee)){\n            burnXPA = safeDiv(safeMul(safeAdd(userToAmount, fee), 1 ether), getPrice(xpaAssetToken));\n            emit eExecuteOffset(burnXPA, xpaAssetToken, safeAdd(userToAmount, fee));\n            xpaAmount_ = safeSub(xpaAmount_, burnXPA);\n            toAmountBooks[user_][xpaAssetToken] = 0;\n            profit = safeAdd(profit, safeDiv(safeMul(fee,1 ether), getPrice(xpaAssetToken)));\n            if(\n                !FundAccount(fundAccount).burn(xpaAssetToken, userToAmount)\n            ){\n                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken],userToAmount);\n            }\n\n        }else{\n            \n            fee = safeDiv(safeMul(xpaAmount_, feeRate), 1 ether);\n            profit = safeAdd(profit, fee);\n            burnXPAAsset = safeDiv(safeMul(safeSub(xpaAmount_, fee),getPrice(xpaAssetToken)),1 ether);\n            toAmountBooks[user_][xpaAssetToken] = safeSub(userToAmount, burnXPAAsset);\n            emit eExecuteOffset(xpaAmount_, xpaAssetToken, burnXPAAsset);\n            \n            xpaAmount_ = 0;\n            if(\n                !FundAccount(fundAccount).burn(xpaAssetToken, burnXPAAsset)\n            ){\n                unPaidFundAccount[xpaAssetToken] = safeAdd(unPaidFundAccount[xpaAssetToken], burnXPAAsset);\n            }\n            \n        }\n        return xpaAmount_;\n    }\n    \n    function getPunishXPA(\n        address user_\n    )\n        internal\n        view \n    returns(uint256){\n        uint256 userFromAmount = fromAmountBooks[user_];\n        uint256 punishXPA = safeDiv(safeMul(userFromAmount, 0.1 ether),1 ether);\n        if(userFromAmount <= safeAdd(minForceOffsetAmount, 100 ether)){\n            return userFromAmount;\n        }else if(punishXPA < minForceOffsetAmount){\n            return minForceOffsetAmount;\n        }else if(punishXPA > maxForceOffsetAmount){\n            return maxForceOffsetAmount;\n        }else{\n            return punishXPA;\n        }\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u62b5\u62bc\u7387, user: \u6307\u5b9a\u7528\u6236\n    function getMortgageRate(\n        address user_\n    ) \n        public\n        view \n    returns(uint256){\n        if(fromAmountBooks[user_] != 0){\n            uint256 totalLoanXPA = 0;\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n            }\n            return safeDiv(safeMul(totalLoanXPA,1 ether),fromAmountBooks[user_]);\n        }else{\n            return 0;\n        }\n    }\n        \n    // \u53d6\u5f97\u6700\u9ad8\u62b5\u62bc\u7387\n    function getHighestMortgageRate() \n        public\n        view \n    returns(uint256){\n        uint256 totalXPA = Token(XPA).totalSupply();\n        uint256 issueRate = safeDiv(safeMul(Token(XPA).balanceOf(this), 1 ether), totalXPA);\n        if(issueRate >= 0.7 ether){\n            return 0.7 ether;\n        }else if(issueRate >= 0.6 ether){\n            return 0.6 ether;\n        }else if(issueRate >= 0.5 ether){\n            return 0.5 ether;\n        }else if(issueRate >= 0.3 ether){\n            return 0.3 ether;\n        }else{\n            return 0.1 ether;\n        }\n    }\n    \n    // \u53d6\u5f97\u5e73\u5009\u7dda\n    function getClosingLine() \n        public\n        view\n    returns(uint256){\n        uint256 highestMortgageRate = getHighestMortgageRate();\n        if(highestMortgageRate >= 0.6 ether){\n            return safeAdd(highestMortgageRate, 0.1 ether);\n        }else{\n            return 0.6 ether;\n        }\n    }\n    \n    // \u53d6\u5f97 XPA Assets \u532f\u7387 \n    function getPrice(\n        address token_\n    ) \n        public\n        view\n    returns(uint256){\n        return TokenFactory(tokenFactory).getPrice(token_);\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u53ef\u63d0\u9818\u7684XPA(\u6263\u6389\u6700\u9ad8\u62b5\u62bc\u7387\u5f8c\u7684XPA)\n    function getUsableXPA(\n        address user_\n    )\n        public\n        view\n    returns(uint256) {\n        uint256 totalLoanXPA = 0;\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            totalLoanXPA = safeAdd(totalLoanXPA, safeDiv(safeMul(getLoanAmount(user_,xpaAsset[i]), 1 ether), getPrice(xpaAsset[i])));\n        }\n        if(fromAmountBooks[user_] > safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate())){\n            return safeSub(fromAmountBooks[user_], safeDiv(safeMul(totalLoanXPA, 1 ether), getHighestMortgageRate()));\n        }else{\n            return 0;\n        }\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u53ef\u501f\u8cb8 XPA Assets \u6700\u5927\u984d\u5ea6, user: \u6307\u5b9a\u7528\u6236\n    /*function getUsableAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        uint256 amount = safeDiv(safeMul(fromAmountBooks[user_], getPrice(token_)), 1 ether);\n        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n    }*/\n    \n    // \u53d6\u5f97\u7528\u6236\u5df2\u501f\u8cb8 XPA Assets \u6578\u91cf, user: \u6307\u5b9a\u7528\u6236\n    function getLoanAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        return toAmountBooks[user_][token_];\n    }\n    \n    // \u53d6\u5f97\u7528\u6236\u5269\u9918\u53ef\u501f\u8cb8 XPA Assets \u984d\u5ea6, user: \u6307\u5b9a\u7528\u6236\n    function getRemainingAmount(\n        address user_,\n        address token_\n    ) \n        public\n        view\n    returns(uint256) {\n        uint256 amount = safeDiv(safeMul(getUsableXPA(user_), getPrice(token_)), 1 ether);\n        return safeDiv(safeMul(amount, getHighestMortgageRate()), 1 ether);\n    }\n    \n    function burnFundAccount(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator\n        public\n    {\n        if(\n            FundAccount(fundAccount).burn(token_, amount_)\n        ){\n            unPaidFundAccount[token_] = safeSub(unPaidFundAccount[token_], amount_);\n        }\n    }\n\n    function transferProfit(\n        address token_,\n        uint256 amount_\n    )\n        onlyOperator \n        public\n    {\n        require(amount_ > 0);\n        if(\n            XPA != token_ && \n            Token(token_).balanceOf(this) >= amount_\n        ) {\n            require(Token(token_).transfer(bank, amount_));\n        }\n\n        if(\n            XPA == token_ && \n            Token(XPA).balanceOf(this) >= amount_\n        ) {\n            profit = safeSub(profit,amount_);\n            require(Token(token_).transfer(bank, amount_));\n        }\n\n    }\n        \n    function setFeeRate(\n        uint256 withDrawFeerate_,\n        uint256 offsetFeerate_,\n        uint256 forceOffsetBasicFeerate_,\n        uint256 forceOffsetExecuteFeerate_,\n        uint256 forceOffsetExtraFeerate_,\n        uint256 forceOffsetExecuteMaxFee_\n    )\n        onlyOperator \n        public\n    {\n        require(withDrawFeerate_ < 0.05 ether);\n        require(offsetFeerate_ < 0.05 ether);\n        require(forceOffsetBasicFeerate_ < 0.05 ether);\n        require(forceOffsetExecuteFeerate_ < 0.05 ether);\n        require(forceOffsetExtraFeerate_ < 0.05 ether);\n        withdrawFeeRate = withDrawFeerate_;\n        offsetFeeRate = offsetFeerate_;\n        forceOffsetBasicFeeRate = forceOffsetBasicFeerate_;\n        forceOffsetExecuteFeeRate = forceOffsetExecuteFeerate_;\n        forceOffsetExtraFeeRate = forceOffsetExtraFeerate_;\n        forceOffsetExecuteMaxFee = forceOffsetExecuteMaxFee_;\n    }\n\n    function migrate(\n        address newContract_\n    )\n        public\n        onlyOwner\n    {\n        require(newContract_ != address(0));\n        if(\n            newXPAAssets == address(0) &&\n            XPAAssets(newContract_).transferXPAAssetAndProfit(xpaAsset, profit) &&\n            Token(XPA).transfer(newContract_, Token(XPA).balanceOf(this))\n        ) {\n            forceOff = true;\n            powerStatus = false;\n            newXPAAssets = newContract_;\n            for(uint256 i = 0; i < xpaAsset.length; i++) {\n                XPAAssets(newContract_).transferUnPaidFundAccount(xpaAsset[i], unPaidFundAccount[xpaAsset[i]]);\n            }\n            emit eMigrate(newContract_);\n        }\n    }\n    \n    function transferXPAAssetAndProfit(\n        address[] xpaAsset_,\n        uint256 profit_\n    )\n        public\n        onlyOperator\n    returns(bool) {\n        require(msg.sender == oldXPAAssets);\n        xpaAsset = xpaAsset_;\n        profit = profit_;\n        return true;\n    }\n    \n    function transferUnPaidFundAccount(\n        address xpaAsset_,\n        uint256 unPaidAmount_\n    )\n        public\n        onlyOperator\n    returns(bool) {\n        require(msg.sender == oldXPAAssets);\n        unPaidFundAccount[xpaAsset_] = unPaidAmount_;\n        return true;\n    }\n    \n    function migratingAmountBooks(\n        address user_,\n        address newContract_\n    )\n        public\n        onlyOperator\n    {\n        XPAAssets(newContract_).migrateAmountBooks(user_); \n    }\n    \n    function migrateAmountBooks(\n        address user_\n    )\n        public\n        onlyOperator \n    {\n        require(msg.sender == oldXPAAssets);\n        require(!migrateBooks[user_]);\n\n        migrateBooks[user_] = true;\n        fromAmountBooks[user_] = safeAdd(fromAmountBooks[user_],XPAAssets(oldXPAAssets).getFromAmountBooks(user_));\n        forceOffsetBooks[user_] = XPAAssets(oldXPAAssets).getForceOffsetBooks(user_);\n        for(uint256 i = 0; i < xpaAsset.length; i++) {\n            toAmountBooks[user_][xpaAsset[i]] = safeAdd(toAmountBooks[user_][xpaAsset[i]], XPAAssets(oldXPAAssets).getLoanAmount(user_,xpaAsset[i]));\n        }\n        emit eMigrateAmount(user_);\n    }\n    \n    function getFromAmountBooks(\n        address user_\n    )\n        public\n        view \n    returns(uint256) {\n        return fromAmountBooks[user_];\n    }\n    \n    function getForceOffsetBooks(\n        address user_\n    )\n        public \n        view \n    returns(uint256) {\n        return forceOffsetBooks[user_];\n    }\n}", "debug": "calldata_XPAAssets_4 + calldata_XPAAssets_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_6: 0x0\nstorage_1: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_XPAAssets_0: 0x28a20a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_XPAAssets: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferXPAAssetAndProfit(address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/15/0xd0f7d665996b745b2399a127d5d84dacd42d251f.sol", "function": "transferXPAAssetAndProfit(address[],uint256)", "lineno": 174, "title": "Integer Overflow ", "type": "Warning"}], "success": true}