{
  "contract": "0x80dd619abf9bf9a084cdeead09525e3a02d521bf",
  "tool": "mythril",
  "start": 1563510976.3241794,
  "end": 1563511003.4997978,
  "duration": 27.175618410110474,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 472,
        "code": "rkleProof, uint16 index) external view returns (bool) {\n        require(merkleProof.length >= 32, \"The Merkle Proof given is too short! It must be atleast 32 bytes in size.\");\n        require(merkleProof.length <= 512, \"The Merkle Proof given is too long! It can be upto only 512 bytes as the Merkle Tree is allowed a maximum depth of 16 under conventions of this contract.\");\n        require(merkleProof.length%32 == 0, \"The Merkle Proof given is not a multiple of 32 bytes! It must be a sequence of 32-byte SHA2-256 hashes each representing the sibling at every non-root level starting from leaf level in the Merkle Tree.\");\n        \n        bytes32 root = docHash;\n        bytes32 sibling;\n        bytes memory proof = merkleProof;\n        \n        // This loop runs a maximum of 16 times with i = 32, 64, 96, ... proof.length. As i is uint16, no integer overflow possible.\n        // An upper limit of 16 iterations ensures that the function's gas requirements are within reasonable limits.\n        for(uint16 i=32; i<=proof.length; i+=32) {\n            assembly {\n                sibling := mload(add(proof, i))     // reading 32 bytes\n            }\n            \n            // Now we have to find out if this sibling is on the right or on the left?\n            // This information is encoded in the i/32th bit from the right of the 16 bit integer index.\n            // To find this but we create a 16-bit mask with i/32th position as the only non-zero bit: uint16(1)<<(i/32-1)\n            // For example: for i=32, mask=0x0000000000000001.\n            // Note that since (i/32-1) is in the range 0-15, the left shift operation should be safe to use.\n            if(index & (uint16(1)<<(i/32-1)) == 0) {\n                root = sha256(abi.encodePacked(root, sibling));\n            } else {\n                root = sha256(abi.encodePacked(sibling, root));\n            }\n        }\n        \n        return isSignedMerkleRoot[root];\n    }\n}",
        "debug": "calldata_SignatureContract_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SignatureContract_0: 0xcbe335c100000000000000000000000000000000000000000000000000000000\ncalldatasize_SignatureContract: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `verifyDocument(bytes32,bytes,uint16)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/5/0x80dd619abf9bf9a084cdeead09525e3a02d521bf.sol",
        "function": "verifyDocument(bytes32,bytes,uint16)",
        "lineno": 50,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}