{"error": null, "issues": [{"address": 733, "code": "SMART CONTRACT\n//\n", "debug": "callvalue: 0x8000000000000000000000000000000000000000000000000020000000000000\nstorage_11: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\norigin: 0x0\ncaller: 0x0\ncalldatasize_Zeus: 0x3\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 2, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1268, "code": "     // project fee\n      ", "debug": "callvalue: 0x100000000000000000000000000000000000000220182000f626600000\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffa567fffe3366c00000\nstorage_8771699579958020649669542447745970789256228610209422586650499580826315986665: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\norigin: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldatasize_Zeus: 0x3\nstorage_19: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 261, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1287, "code": "  if (advertAddr.s", "debug": "storage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x21e1cf080f300000000\nstorage_8771699579958020649669542447745970789256228610209422586650499580826315986665: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\norigin: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldatasize_Zeus: 0x3\nstorage_19: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 264, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1469, "code": "      // referrer commissio", "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffa567fffe3366c00000\ncallvalue: 0x100000000000000000000000000000000000000220182000f626600000\nstorage_8771699579958020649669542447745970789256228610209422586650499580826315986665: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\norigin: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldatasize_Zeus: 0x3\nstorage_19: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 268, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1581, "code": "tment / 100 * currentInterest;\n\n       ", "debug": "", "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 269, "title": "Unchecked CALL return value", "type": "Informational"}, {"address": 3760, "code": "i++) {\n            uint id = addresses.length;\n            if (investors[_addr[i]].deposit == 0) {\n                addresses.push(_addr[i]);\n                depositAmount += _deposit[i];\n            }\n\n            investors[_addr[i]] = Investor(id, _deposit[i], 1, 0, _date[i], _referrer[i]);\n\n        }\n        lastPaymentDate = now;\n    }\n\n    // main function, which accept new investments and do dividends payouts\n    // if you send 0 ETH to this function, you will receive your dividends\n    function() payable public {\n\n        // ensure ", "debug": "calldata_Zeus_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Zeus_0: 0xa816d0c000000000000000000000000000000000000000000000000000000000\ncalldatasize_Zeus: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0xa816d0c0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "_function_0xa816d0c0", "lineno": 194, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4657, "debug": "", "description": "Function fallback retrieves the transaction origin (tx.origin) using the ORIGIN opcode. Use msg.sender instead.\nSee also: https://solidity.readthedocs.io/en/develop/security-considerations.html#tx-origin", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 431, "title": "Use of tx.origin", "type": "Warning"}, {"address": 4721, "code": "ount);\n        pause", "debug": "storage_11: 0x0\nstorage_13: 0xff00\norigin: 0x0\ncaller: 0x0\ncalldatasize_Zeus: 0x3\n", "description": "A possible integer underflow exists in the function `fallback`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 358, "title": "Integer Underflow", "type": "Warning"}, {"address": 4751, "code": " 1; // incre", "debug": "The exception is triggered under the following conditions:\n\nstorage_11: 0x0\nstorage_13: 0xff00\norigin: 0x0\ncaller: 0x0\ncalldatasize_Zeus: 0x3\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 360, "title": "Exception state", "type": "Informational"}, {"address": 5099, "code": "t rate for", "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0xff00\norigin: 0x0\ncaller: 0x0\ncalldatasize_Zeus: 0x3\nstorage_11: 0x2\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 374, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8478, "code": "er != tx.origin;\n    }\n\n  ", "debug": "timestamp: 0x0\nstorage_4 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Zeus_4: 0x1\ncalldata_Zeus_0: 0xb1ad4c4800000000000000000000000000000000000000000000000000000000\ncalldatasize_Zeus: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `getInvestorDividendsAmount(address)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "getInvestorDividendsAmount(address)", "lineno": 423, "title": "Integer Underflow", "type": "Warning"}, {"address": 9120, "code": " owner set to 0x0000000000000000000000000000000000000000,\n    address owner = 0x0000000000000000000000000000000000000000;\n\n    uint constant public MINIMUM_INVEST = 10000000000000000 wei;\n\n    // current interest\n    uint public currentInterest = 3;\n\n    // total deposited eth\n    uint public depositAmount;\n\n    // total paid out eth\n    uint public paidAmount;\n\n    // current round (restart)\n    uint public round = 1;\n\n    // last investment date\n    uint public lastPaymentDate;\n\n    // fee for advertising purposes\n    uint public advertFee = 10;\n\n    // project admins fee\n    uint public devFee = 5;\n\n    // maximum profit per investor (x2)\n    uint public profitThreshold = 2;\n\n    // addr of project admins (not owner of the contract)\n    address public devAddr;\n\n    // advert addr\n    address public advertAddr;\n\n    // investors addresses\n    address[] public addresses;\n\n    // mapping address to Investor\n    mapping(address => Investor) public investors;\n\n    // currently on restart phase or not?\n    bool public pause;\n\n    // Thunderstorm structure\n    struct Thunderstorm {\n        address addr;\n        uint deposit;\n        uint from;\n    }\n\n    // Investor structure\n    struct Investor\n    {\n        uint id;\n        uint deposit; // deposit amount\n        uint deposits; // deposits count\n        uint paidOut; // total paid out\n        uint date; // last date of investment or paid out\n        address referrer;\n    }\n\n    event Invest(address indexed addr, uint amount, address referrer);\n    event Payout(address indexed addr, uint amount, string eventType, address from);\n    event NextRoundStarted(uint indexed round, uint date, uint deposit);\n    event ThunderstormUpdate(address addr, string eventType);\n\n    Thunderstorm public thunderstorm;\n    GrowingControl.data private growingControl;\n\n    // only contract creator access\n    modifier onlyOwner {if (msg.sender == owner) _;}\n\n    constructor() public {\n        owner = msg.sender;\n        devAddr = msg.sender;\n\n        addresses.length = 1;\n\n        // set bounces for growingControl service\n        growingControl.min = 30 ether;\n        growingControl.max = 500 ether;\n        \n        advertAddr = 0x404648C63D19DB0d23203CB146C0b573D4E79E0c;\n    }\n\n    // change advert address, only admin access (works before ownership resignation)\n    function setAdvertAddr(address addr) onlyOwner public {\n        advertAddr = addr;\n    }\n    // set date which enables control of growing function (limitation of investments per day)\n    function setGrowingControlStartAt(uint startAt) onlyOwner public {\n        growingControl.startAt = startAt;\n    }\n\n    function getGrowingControlStartAt() public view returns (uint) {\n        return growingControl.startAt;\n    }\n\n    // set max of investments per day. Only devAddr have access to this function\n    function setGrowingMaxPerDay(uint maxAmountPerDay) public {\n        require(maxAmountPerDay >= growingControl.min && maxAmountPerDay <= growingControl.max, \"incorrect amount\");\n        require(msg.sender == devAddr, \"Only dev team have access to this function\");\n        growingControl.maxAmountPerDay = maxAmountPerDay;\n    }\n    \n    function getInvestorData(address[] _addr, uint[] _deposit, uint[] _date, address[] _referrer) onlyOwner public {\n        // add initiated investors\n        for (uint i = 0; i < _addr.length; i++) {\n            uint id = addresses.length;\n            if (investors[_addr[i]].deposit == 0) {\n                addresses.push(_addr[i]);\n                depositAmount += _deposit[i];\n            }\n\n            investors[_addr[i]] = Investor(id, _deposit[i], 1, 0, _date[i], _referrer[i]);\n\n        }\n        lastPaymentDate = now;\n    }\n\n    // main function, which accept new investments and do dividends payouts\n    // if you send 0 ETH to this function, you will receive your dividends\n    function() payable public {\n\n        // ensure that payment not from contract\n        if (isContract()) {\n            revert();\n        }\n\n        // if contract is on restarting phase - do some work before restart\n        if (pause) {\n            doRestart();\n            msg.sender.transfer(msg.value); // return all money to sender\n\n            return;\n        }\n\n        if (0 == msg.value) {\n            payDividends(); // do pay out\n            return;\n        }\n\n        require(msg.value >= MINIMUM_INVEST, \"Too small amount, minimum 0.01 ether\");\n        Investor storage user = investors[msg.sender];\n\n        if (user.id == 0) { // if no saved address, save it\n            user.id = addresses.push(msg.sender);\n            user.date = now;\n\n            // check referrer\n            address referrer = bytesToAddress(msg.data);\n            if (investors[referrer].deposit > 0 && referrer != msg.sender) {\n                user.referrer = referrer;\n            }\n        } else {\n            payDividends(); // else pay dividends before reinvest\n        }\n\n        // get max investment amount for the current day, according to sent amount\n        // all excesses will be returned to sender later\n        uint investment = min(growingControl.getMaxInvestmentToday(), msg.value);\n        require(investment > 0, \"Too much investments today\");\n\n        // update investor\n        user.deposit += investment;\n        user.deposits += 1;\n\n        emit Invest(msg.sender, investment, user.referrer);\n\n        depositAmount += investment;\n        lastPaymentDate = now;\n\n\n        if (devAddr.send(investment / 100 * devFee)) {\n            // project fee\n        }\n\n        if (advertAddr.send(investment / 100 * advertFee)) {\n            // advert fee\n        }\n\n        // referrer commission for all deposits\n        uint bonusAmount = investment / 100 * currentInterest;\n\n        // user have referrer\n        if (user.referrer > 0x0) {\n            if (user.referrer.send(bonusAmount)) { // pay referrer commission\n                emit Payout(user.referrer, bonusAmount, \"referral\", msg.sender);\n            }\n\n            if (user.deposits == 1) { // only the first deposit cashback\n                if (msg.sender.send(bonusAmount)) {\n                    emit Payout(msg.sender, bonusAmount, \"cash-back\", 0);\n                }\n            }\n        } else if (thunderstorm.addr > 0x0 && thunderstorm.from + 10 days > now) { // if investor does not have referrer, Thunderstorm takes the bonus\n            // also check Thunderstorm is active\n            if (thunderstorm.addr.send(bonusAmount)) { // pay bonus to current Thunderstorm\n                emit Payout(thunderstorm.addr, bonusAmount, \"thunderstorm\", msg.sender);\n            }\n        }\n\n        // check and maybe update current interest rate\n        considerCurrentInterest();\n        // add investment to the growingControl service\n        growingControl.addInvestment(investment);\n        // Thunderstorm has changed? do some checks\n        considerThunderstorm(investment);\n\n        // return excess eth (if growingControl is active)\n        if (msg.value > investment) {\n            msg.sender.transfer(msg.value - investment);\n        }\n    }\n\n    function getTodayInvestment() view public returns (uint)\n    {\n        return growingControl.getTodayInvestment();\n    }\n\n    function getMaximumInvestmentPerDay() view public returns (uint)\n    {\n        return growingControl.maxAmountPerDay;\n    }\n\n    function payDividends() private {\n        require(investors[msg.sender].id > 0, \"Investor not found\");\n        uint amount = getInvestorDividendsAmount(msg.sender);\n\n        if (amount == 0) {\n            return;\n        }\n\n        // save last paid out date\n        investors[msg.sender].date = now;\n\n        // save total paid out for investor\n        investors[msg.sender].paidOut += amount;\n\n        // save total paid out for contract\n        paidAmount += amount;\n\n        uint balance = address(this).balance;\n\n        // check contract balance, if not enough - do restart\n        if (balance < amount) {\n            pause = true;\n            amount = balance;\n        }\n\n        msg.sender.transfer(amount);\n        emit Payout(msg.sender, amount, \"payout\", 0);\n\n        // if investor has reached the limit (x2 profit) - delete him\n        if (investors[msg.sender].paidOut >= investors[msg.sender].deposit * profitThreshold) {\n            delete investors[msg.sender];\n        }\n    }\n\n    // remove all investors and prepare data for the new round!\n    function doRestart() private {\n        uint txs;\n\n        for (uint i = addresses.length - 1; i > 0; i--) {\n            delete investors[addresses[i]]; // remove investor\n            addresses.length -= 1; // decrease addr length\n            if (txs++ == 150) { // stop on 150 investors (to prevent out of gas exception)\n                return;\n            }\n        }\n\n        emit NextRoundStarted(round, now, depositAmount);\n        pause = false; // stop pause, play\n        round += 1; // increase round number\n        depositAmount = 0;\n        paidAmount = 0;\n        lastPaymentDate = now;\n    }\n\n    function getInvestorCount() public view returns (uint) {\n        return addresses.length - 1;\n    }\n\n    function considerCurrentInterest() internal\n    {\n        uint interest;\n\n        // if balance is over 2k ETH - set interest rate for 2%\n        if (depositAmount >= 2000 ether) {\n            interest = 2;\n        } else if (depositAmount >= 500 ether) { // if balance is more than 500 ETH - set interest rate for 3%\n            interest = 3;\n        } else {\n            interest = 4; // base = 4%\n        }\n\n        // if interest has not changed, return\n        if (interest >= currentInterest) {\n            return;\n        }\n\n        currentInterest = interest;\n    }\n\n    // Thunderstorm!\n    // make the biggest investment today - and receive ref-commissions from ALL investors who not have a referrer in the next 10 days\n    function considerThunderstorm(uint amount) internal {\n        // if current Thunderstorm dead, delete him\n        if (thunderstorm.addr > 0x0 && thunderstorm.from + 10 days < now) {\n            thunderstorm.addr = 0x0;\n            thunderstorm.deposit = 0;\n            emit ThunderstormUpdate(msg.sender, \"expired\");\n        }\n\n        // if the investment bigger than current Thunderstorm made - change Thunderstorm\n        if (amount > thunderstorm.deposit) {\n            thunderstorm = Thunderstorm(msg.sender, amount, now);\n            emit ThunderstormUpdate(msg.sender, \"change\");\n        }\n    }\n\n    // calculate total dividends for investor from the last investment/payout date\n    // be careful  - max. one-time amount can cover 5 days of work\n    function getInvestorDividendsAmount(address addr) public view returns (uint) {\n        uint time = min(now - investors[addr].date, 5 days);\n        return investors[addr].deposit / 100 * currentInterest * time / 1 days;\n    }\n\n    function bytesToAddress(bytes bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n    // check that there is no contract in the middle\n    function isContract() internal view returns (bool) {\n        return msg.sender != tx.origin;\n    }\n\n    // get min value from a and b\n    function min(uint a, uint b) public pure returns (uint) {\n        if (a < b) return a;\n        else return b;\n    }\n}", "debug": "storage_11: 0xff45c02428c7240200901a1b923fb87e2553478a4110000001e00003fc03e147\nstorage_13: 0xff00\norigin: 0x0\ncaller: 0x0\ncalldatasize_Zeus: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 86, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9122, "code": " owner set to 0x0000000000000000000000000000000000000000,\n    address owner = 0x0000000000000000000000000000000000000000;\n\n    uint constant public MINIMUM_INVEST = 10000000000000000 wei;\n\n    // current interest\n    uint public currentInterest = 3;\n\n    // total deposited eth\n    uint public depositAmount;\n\n    // total paid out eth\n    uint public paidAmount;\n\n    // current round (restart)\n    uint public round = 1;\n\n    // last investment date\n    uint public lastPaymentDate;\n\n    // fee for advertising purposes\n    uint public advertFee = 10;\n\n    // project admins fee\n    uint public devFee = 5;\n\n    // maximum profit per investor (x2)\n    uint public profitThreshold = 2;\n\n    // addr of project admins (not owner of the contract)\n    address public devAddr;\n\n    // advert addr\n    address public advertAddr;\n\n    // investors addresses\n    address[] public addresses;\n\n    // mapping address to Investor\n    mapping(address => Investor) public investors;\n\n    // currently on restart phase or not?\n    bool public pause;\n\n    // Thunderstorm structure\n    struct Thunderstorm {\n        address addr;\n        uint deposit;\n        uint from;\n    }\n\n    // Investor structure\n    struct Investor\n    {\n        uint id;\n        uint deposit; // deposit amount\n        uint deposits; // deposits count\n        uint paidOut; // total paid out\n        uint date; // last date of investment or paid out\n        address referrer;\n    }\n\n    event Invest(address indexed addr, uint amount, address referrer);\n    event Payout(address indexed addr, uint amount, string eventType, address from);\n    event NextRoundStarted(uint indexed round, uint date, uint deposit);\n    event ThunderstormUpdate(address addr, string eventType);\n\n    Thunderstorm public thunderstorm;\n    GrowingControl.data private growingControl;\n\n    // only contract creator access\n    modifier onlyOwner {if (msg.sender == owner) _;}\n\n    constructor() public {\n        owner = msg.sender;\n        devAddr = msg.sender;\n\n        addresses.length = 1;\n\n        // set bounces for growingControl service\n        growingControl.min = 30 ether;\n        growingControl.max = 500 ether;\n        \n        advertAddr = 0x404648C63D19DB0d23203CB146C0b573D4E79E0c;\n    }\n\n    // change advert address, only admin access (works before ownership resignation)\n    function setAdvertAddr(address addr) onlyOwner public {\n        advertAddr = addr;\n    }\n    // set date which enables control of growing function (limitation of investments per day)\n    function setGrowingControlStartAt(uint startAt) onlyOwner public {\n        growingControl.startAt = startAt;\n    }\n\n    function getGrowingControlStartAt() public view returns (uint) {\n        return growingControl.startAt;\n    }\n\n    // set max of investments per day. Only devAddr have access to this function\n    function setGrowingMaxPerDay(uint maxAmountPerDay) public {\n        require(maxAmountPerDay >= growingControl.min && maxAmountPerDay <= growingControl.max, \"incorrect amount\");\n        require(msg.sender == devAddr, \"Only dev team have access to this function\");\n        growingControl.maxAmountPerDay = maxAmountPerDay;\n    }\n    \n    function getInvestorData(address[] _addr, uint[] _deposit, uint[] _date, address[] _referrer) onlyOwner public {\n        // add initiated investors\n        for (uint i = 0; i < _addr.length; i++) {\n            uint id = addresses.length;\n            if (investors[_addr[i]].deposit == 0) {\n                addresses.push(_addr[i]);\n                depositAmount += _deposit[i];\n            }\n\n            investors[_addr[i]] = Investor(id, _deposit[i], 1, 0, _date[i], _referrer[i]);\n\n        }\n        lastPaymentDate = now;\n    }\n\n    // main function, which accept new investments and do dividends payouts\n    // if you send 0 ETH to this function, you will receive your dividends\n    function() payable public {\n\n        // ensure that payment not from contract\n        if (isContract()) {\n            revert();\n        }\n\n        // if contract is on restarting phase - do some work before restart\n        if (pause) {\n            doRestart();\n            msg.sender.transfer(msg.value); // return all money to sender\n\n            return;\n        }\n\n        if (0 == msg.value) {\n            payDividends(); // do pay out\n            return;\n        }\n\n        require(msg.value >= MINIMUM_INVEST, \"Too small amount, minimum 0.01 ether\");\n        Investor storage user = investors[msg.sender];\n\n        if (user.id == 0) { // if no saved address, save it\n            user.id = addresses.push(msg.sender);\n            user.date = now;\n\n            // check referrer\n            address referrer = bytesToAddress(msg.data);\n            if (investors[referrer].deposit > 0 && referrer != msg.sender) {\n                user.referrer = referrer;\n            }\n        } else {\n            payDividends(); // else pay dividends before reinvest\n        }\n\n        // get max investment amount for the current day, according to sent amount\n        // all excesses will be returned to sender later\n        uint investment = min(growingControl.getMaxInvestmentToday(), msg.value);\n        require(investment > 0, \"Too much investments today\");\n\n        // update investor\n        user.deposit += investment;\n        user.deposits += 1;\n\n        emit Invest(msg.sender, investment, user.referrer);\n\n        depositAmount += investment;\n        lastPaymentDate = now;\n\n\n        if (devAddr.send(investment / 100 * devFee)) {\n            // project fee\n        }\n\n        if (advertAddr.send(investment / 100 * advertFee)) {\n            // advert fee\n        }\n\n        // referrer commission for all deposits\n        uint bonusAmount = investment / 100 * currentInterest;\n\n        // user have referrer\n        if (user.referrer > 0x0) {\n            if (user.referrer.send(bonusAmount)) { // pay referrer commission\n                emit Payout(user.referrer, bonusAmount, \"referral\", msg.sender);\n            }\n\n            if (user.deposits == 1) { // only the first deposit cashback\n                if (msg.sender.send(bonusAmount)) {\n                    emit Payout(msg.sender, bonusAmount, \"cash-back\", 0);\n                }\n            }\n        } else if (thunderstorm.addr > 0x0 && thunderstorm.from + 10 days > now) { // if investor does not have referrer, Thunderstorm takes the bonus\n            // also check Thunderstorm is active\n            if (thunderstorm.addr.send(bonusAmount)) { // pay bonus to current Thunderstorm\n                emit Payout(thunderstorm.addr, bonusAmount, \"thunderstorm\", msg.sender);\n            }\n        }\n\n        // check and maybe update current interest rate\n        considerCurrentInterest();\n        // add investment to the growingControl service\n        growingControl.addInvestment(investment);\n        // Thunderstorm has changed? do some checks\n        considerThunderstorm(investment);\n\n        // return excess eth (if growingControl is active)\n        if (msg.value > investment) {\n            msg.sender.transfer(msg.value - investment);\n        }\n    }\n\n    function getTodayInvestment() view public returns (uint)\n    {\n        return growingControl.getTodayInvestment();\n    }\n\n    function getMaximumInvestmentPerDay() view public returns (uint)\n    {\n        return growingControl.maxAmountPerDay;\n    }\n\n    function payDividends() private {\n        require(investors[msg.sender].id > 0, \"Investor not found\");\n        uint amount = getInvestorDividendsAmount(msg.sender);\n\n        if (amount == 0) {\n            return;\n        }\n\n        // save last paid out date\n        investors[msg.sender].date = now;\n\n        // save total paid out for investor\n        investors[msg.sender].paidOut += amount;\n\n        // save total paid out for contract\n        paidAmount += amount;\n\n        uint balance = address(this).balance;\n\n        // check contract balance, if not enough - do restart\n        if (balance < amount) {\n            pause = true;\n            amount = balance;\n        }\n\n        msg.sender.transfer(amount);\n        emit Payout(msg.sender, amount, \"payout\", 0);\n\n        // if investor has reached the limit (x2 profit) - delete him\n        if (investors[msg.sender].paidOut >= investors[msg.sender].deposit * profitThreshold) {\n            delete investors[msg.sender];\n        }\n    }\n\n    // remove all investors and prepare data for the new round!\n    function doRestart() private {\n        uint txs;\n\n        for (uint i = addresses.length - 1; i > 0; i--) {\n            delete investors[addresses[i]]; // remove investor\n            addresses.length -= 1; // decrease addr length\n            if (txs++ == 150) { // stop on 150 investors (to prevent out of gas exception)\n                return;\n            }\n        }\n\n        emit NextRoundStarted(round, now, depositAmount);\n        pause = false; // stop pause, play\n        round += 1; // increase round number\n        depositAmount = 0;\n        paidAmount = 0;\n        lastPaymentDate = now;\n    }\n\n    function getInvestorCount() public view returns (uint) {\n        return addresses.length - 1;\n    }\n\n    function considerCurrentInterest() internal\n    {\n        uint interest;\n\n        // if balance is over 2k ETH - set interest rate for 2%\n        if (depositAmount >= 2000 ether) {\n            interest = 2;\n        } else if (depositAmount >= 500 ether) { // if balance is more than 500 ETH - set interest rate for 3%\n            interest = 3;\n        } else {\n            interest = 4; // base = 4%\n        }\n\n        // if interest has not changed, return\n        if (interest >= currentInterest) {\n            return;\n        }\n\n        currentInterest = interest;\n    }\n\n    // Thunderstorm!\n    // make the biggest investment today - and receive ref-commissions from ALL investors who not have a referrer in the next 10 days\n    function considerThunderstorm(uint amount) internal {\n        // if current Thunderstorm dead, delete him\n        if (thunderstorm.addr > 0x0 && thunderstorm.from + 10 days < now) {\n            thunderstorm.addr = 0x0;\n            thunderstorm.deposit = 0;\n            emit ThunderstormUpdate(msg.sender, \"expired\");\n        }\n\n        // if the investment bigger than current Thunderstorm made - change Thunderstorm\n        if (amount > thunderstorm.deposit) {\n            thunderstorm = Thunderstorm(msg.sender, amount, now);\n            emit ThunderstormUpdate(msg.sender, \"change\");\n        }\n    }\n\n    // calculate total dividends for investor from the last investment/payout date\n    // be careful  - max. one-time amount can cover 5 days of work\n    function getInvestorDividendsAmount(address addr) public view returns (uint) {\n        uint time = min(now - investors[addr].date, 5 days);\n        return investors[addr].deposit / 100 * currentInterest * time / 1 days;\n    }\n\n    function bytesToAddress(bytes bys) private pure returns (address addr) {\n        assembly {\n            addr := mload(add(bys, 20))\n        }\n    }\n\n    // check that there is no contract in the middle\n    function isContract() internal view returns (bool) {\n        return msg.sender != tx.origin;\n    }\n\n    // get min value from a and b\n    function min(uint a, uint b) public pure returns (uint) {\n        if (a < b) return a;\n        else return b;\n    }\n}", "debug": "storage_11: 0xff8b88180000007c070000000000010000000080000000000000000000000000\nstorage_13: 0xff00\norigin: 0x0\ncaller: 0x0\ncalldatasize_Zeus: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xb1518db22ecd0d6621ffe196b8c3046b3b5fed89.sol", "function": "fallback", "lineno": 86, "title": "Integer Overflow ", "type": "Warning"}], "success": true}