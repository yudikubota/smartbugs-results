{"error": null, "issues": [{"address": 264, "code": " {\n        checkLimits();\n\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // make sure this url and also this owner was not registered before.\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\n\n        // add new In3Server\n        In3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n\n        // make sure they are used\n        urlIndex[urlHash] = true;\n        ownerIndex[msg.sender] = true;\n\n        // emit event\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// updates a Server by adding the msg.value to the deposit and setting the prop", "debug": "calldata_ServerRegistry_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 65, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1082, "code": "e the server\");\n\n    ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x3b31173f00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "updateServer(uint256,uint256)", "lineno": 94, "title": "Exception state", "type": "Informational"}, {"address": 1356, "code": "\n        emit LogServerRegi", "debug": "callvalue: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\nstorage_2 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\ncalldata_ServerRegistry_4: 0x0\ncaller: 0x0\nstorage_1 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_0: 0x1\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x3b31173f00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `updateServer(uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "updateServer(uint256,uint256)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2148, "code": "******************", "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x80\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2200, "code": " = true;\n      ", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x40\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 82, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2887, "code": " url and owner\n    mapping", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0x5cf0f35700000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "_function_0x5cf0f357", "lineno": 55, "title": "Exception state", "type": "Informational"}, {"address": 3241, "code": "ress(0) && server.own", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0x6ba3751e00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "cancelUnregisteringServer(uint256)", "lineno": 158, "title": "Exception state", "type": "Informational"}, {"address": 4546, "code": "       uint payout = ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nblockhash_block_calldata_ServerRegistry_32 + 36: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncalldata_ServerRegistry_32 + 4: 0x0\ncalldata_ServerRegistry_0: 0x6ec61caf00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "convict(uint256,bytes32,uint256,uint8,bytes32,bytes32)", "lineno": 189, "title": "Exception state", "type": "Informational"}, {"address": 4758, "code": "deposit\n        if (servers[_serverIndex].deposit > 0) {\n ", "debug": "", "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "convict(uint256,bytes32,uint256,uint8,bytes32,bytes32)", "lineno": 187, "title": "Unchecked CALL return value", "type": "Informational"}, {"address": 5601, "code": "Removed(servers[_serv", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0x840bfca500000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "calcUnregisterDeposit(uint256)", "lineno": 215, "title": "Exception state", "type": "Informational"}, {"address": 5655, "code": "dress(0x0) && server.", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0xdc95f70b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "confirmUnregisteringServer(uint256)", "lineno": 138, "title": "Exception state", "type": "Informational"}, {"address": 6267, "code": "   server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    //", "debug": "", "description": "In the function `confirmUnregisteringServer(uint256)` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "confirmUnregisteringServer(uint256)", "lineno": 147, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 6267, "code": "   server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    //", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6384\n", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "confirmUnregisteringServer(uint256)", "lineno": 147, "title": "Multiple Calls", "type": "Information"}, {"address": 6384, "code": "nregister-process.\n    /// if the c", "debug": "", "description": "In the function `confirmUnregisteringServer(uint256)` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "confirmUnregisteringServer(uint256)", "lineno": 152, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 6437, "code": "registerCaller == add", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ServerRegistry_4: 0x0\nstorage_0: 0x0\ncalldata_ServerRegistry_0: 0xff40ae6900000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "requestUnregisteringServer(uint256)", "lineno": 118, "title": "Exception state", "type": "Informational"}, {"address": 6783, "code": ") \n          ", "debug": "timestamp: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8f0\ncalldata_ServerRegistry_4: 0x0\nstorage_1 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_5 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_0: 0x1\ncalldata_ServerRegistry_0: 0xff40ae6900000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `requestUnregisteringServer(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "requestUnregisteringServer(uint256)", "lineno": 123, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6852, "code": "o spam-protec", "debug": "timestamp: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffef8400\ncalldata_ServerRegistry_4: 0x0\nstorage_1 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*calldata_ServerRegistry_4: 0x0\nstorage_0: 0x1\ncalldata_ServerRegistry_0: 0xff40ae6900000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `requestUnregisteringServer(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "requestUnregisteringServer(uint256)", "lineno": 124, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9559, "code": "y {\n\n    /// server has been registered or updated its registry props or deposit\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n\n    ///  a caller requested to unregister a server.\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n\n    /// the owner canceled the unregister-proccess\n    event LogServerUnregisterCanceled(string url, address owner);\n\n    /// a Server was convicted\n    event LogServerConvicted(string url, address owner);\n\n    /// a Server is removed\n    event LogServerRemoved(string url, address owner);\n\n    struct In3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint128 unregisterTime; // earliest timestamp in to to call unregister\n        uint128 unregisterDeposit; // Deposit for unregistering\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n\n    /// server list of incubed nodes    \n    In3Server[] public servers;\n\n    // index for unique url and owner\n    mapping (address => bool) ownerIndex;\n    mapping (bytes32 => bool) urlIndex;\n    \n    /// length of the serverlist\n    function totalServers() public view returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        checkLimits();\n\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // make sure this url and also this owner was not registered before.\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\n\n        // add new In3Server\n        In3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n\n        // make sure they are used\n        urlIndex[urlHash] = true;\n        ownerIndex[msg.sender] = true;\n\n        // emit event\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// updates a Server by adding the msg.value to the deposit and setting the props    \n    function updateServer(uint _serverIndex, uint _props) public payable {\n        checkLimits();\n\n        In3Server storage server = servers[_serverIndex];\n        require(server.owner == msg.sender, \"only the owner may update the server\");\n\n        if (msg.value>0) \n          server.deposit += msg.value;\n\n        if (_props!=server.props)\n          server.props = _props;\n        emit LogServerRegistered(server.url, _props, msg.sender,server.deposit);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering the service and remove the server.\n    ///    in this case he has to wait for one hour before actually removing the server. \n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller == address(0x0), \"Server is already unregistering\");\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = uint128(now + 1 hours);\n        else {\n            server.unregisterTime = uint128(now + 28 days); // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value == calcUnregisterDeposit(_serverIndex), \"the exact calcUnregisterDeposit is required to request unregister\");\n            server.unregisterDeposit = uint128(msg.value);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender);\n    }\n    \n    /// this function must be called by the caller of the requestUnregisteringServer-function after 28 days\n    /// if the owner did not cancel, the caller will receive 20% of the server deposit + his own deposit.\n    /// the owner will receive 80% of the server deposit before the server will be removed.\n    function confirmUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller != address(0x0) && server.unregisterTime < now, \"Only the caller is allowed to confirm\");\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit / 5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer(server.unregisterDeposit + server.deposit - payBackOwner);\n        }\n\n        if (payBackOwner > 0)\n            server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    /// this function must be called by the owner to cancel the unregister-process.\n    /// if the caller is not the owner, then he will also get the deposit paid by the caller.\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller != address(0) && server.owner == msg.sender, \"only the owner is allowed to cancel unregister\");\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer(server.unregisterDeposit);\n\n        // set back storage values\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        server.unregisterDeposit = 0;\n\n        /// emit event\n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    /// convicts a server that signed a wrong blockhash\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        bytes32 evm_blockhash = blockhash(_blocknumber);\n        \n        // if the blockhash is correct you cannot convict the server\n        require(evm_blockhash != 0x0 && evm_blockhash != _blockhash, \"the block is too old or you try to convict with a correct hash\");\n\n        // make sure the hash was signed by the owner of the server\n        require(\n            ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner, \n            \"the block was not signed by the owner of the server\");\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit > 0) {\n            uint payout = servers[_serverIndex].deposit / 2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            // this is done in order to make it useless trying to convict your own server with a second account\n            // and this getting all the deposit back after signing a wrong hash.\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        // emit event\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        \n        removeServer(_serverIndex);\n    }\n\n    /// calculates the minimum deposit you need to pay in order to request unregistering of a server.\n    function calcUnregisterDeposit(uint _serverIndex) public view returns(uint128) {\n         // cancelUnregisteringServer costs 22k gas, we took about twist that much due to volatility of gasPrices\n        return uint128(servers[_serverIndex].deposit / 50 + tx.gasprice * 50000);\n    }\n\n    // internal helper functions\n    \n    function removeServer(uint _serverIndex) internal {\n        // trigger event\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner);\n\n        // remove from unique index\n        urlIndex[keccak256(bytes(servers[_serverIndex].url))] = false;\n        ownerIndex[servers[_serverIndex].owner] = false;\n\n        uint length = servers.length;\n        if (length>0) {\n            // move the last entry to the removed one.\n            In3Server memory m = servers[length - 1];\n            servers[_serverIndex] = m;\n        }\n        servers.length--;\n    }\n\n    function checkLimits() internal view {\n        // within the next 6 months this contract may never hold more than 50 ETH\n        if (now < 1560808800)\n           require(address(this).balance < 50 ether, \"Limit of 50 ETH reached\");\n    }\n\n}", "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x20\nkeccac_0_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n6*storage_0: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n6*storage_0: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 23, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9588, "code": "y {\n\n    /// server has been registered or updated its registry props or deposit\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n\n    ///  a caller requested to unregister a server.\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n\n    /// the owner canceled the unregister-proccess\n    event LogServerUnregisterCanceled(string url, address owner);\n\n    /// a Server was convicted\n    event LogServerConvicted(string url, address owner);\n\n    /// a Server is removed\n    event LogServerRemoved(string url, address owner);\n\n    struct In3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint128 unregisterTime; // earliest timestamp in to to call unregister\n        uint128 unregisterDeposit; // Deposit for unregistering\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n\n    /// server list of incubed nodes    \n    In3Server[] public servers;\n\n    // index for unique url and owner\n    mapping (address => bool) ownerIndex;\n    mapping (bytes32 => bool) urlIndex;\n    \n    /// length of the serverlist\n    function totalServers() public view returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        checkLimits();\n\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // make sure this url and also this owner was not registered before.\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\n\n        // add new In3Server\n        In3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n\n        // make sure they are used\n        urlIndex[urlHash] = true;\n        ownerIndex[msg.sender] = true;\n\n        // emit event\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// updates a Server by adding the msg.value to the deposit and setting the props    \n    function updateServer(uint _serverIndex, uint _props) public payable {\n        checkLimits();\n\n        In3Server storage server = servers[_serverIndex];\n        require(server.owner == msg.sender, \"only the owner may update the server\");\n\n        if (msg.value>0) \n          server.deposit += msg.value;\n\n        if (_props!=server.props)\n          server.props = _props;\n        emit LogServerRegistered(server.url, _props, msg.sender,server.deposit);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering the service and remove the server.\n    ///    in this case he has to wait for one hour before actually removing the server. \n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller == address(0x0), \"Server is already unregistering\");\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = uint128(now + 1 hours);\n        else {\n            server.unregisterTime = uint128(now + 28 days); // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value == calcUnregisterDeposit(_serverIndex), \"the exact calcUnregisterDeposit is required to request unregister\");\n            server.unregisterDeposit = uint128(msg.value);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender);\n    }\n    \n    /// this function must be called by the caller of the requestUnregisteringServer-function after 28 days\n    /// if the owner did not cancel, the caller will receive 20% of the server deposit + his own deposit.\n    /// the owner will receive 80% of the server deposit before the server will be removed.\n    function confirmUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller != address(0x0) && server.unregisterTime < now, \"Only the caller is allowed to confirm\");\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit / 5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer(server.unregisterDeposit + server.deposit - payBackOwner);\n        }\n\n        if (payBackOwner > 0)\n            server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    /// this function must be called by the owner to cancel the unregister-process.\n    /// if the caller is not the owner, then he will also get the deposit paid by the caller.\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller != address(0) && server.owner == msg.sender, \"only the owner is allowed to cancel unregister\");\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer(server.unregisterDeposit);\n\n        // set back storage values\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        server.unregisterDeposit = 0;\n\n        /// emit event\n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    /// convicts a server that signed a wrong blockhash\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        bytes32 evm_blockhash = blockhash(_blocknumber);\n        \n        // if the blockhash is correct you cannot convict the server\n        require(evm_blockhash != 0x0 && evm_blockhash != _blockhash, \"the block is too old or you try to convict with a correct hash\");\n\n        // make sure the hash was signed by the owner of the server\n        require(\n            ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner, \n            \"the block was not signed by the owner of the server\");\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit > 0) {\n            uint payout = servers[_serverIndex].deposit / 2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            // this is done in order to make it useless trying to convict your own server with a second account\n            // and this getting all the deposit back after signing a wrong hash.\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        // emit event\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        \n        removeServer(_serverIndex);\n    }\n\n    /// calculates the minimum deposit you need to pay in order to request unregistering of a server.\n    function calcUnregisterDeposit(uint _serverIndex) public view returns(uint128) {\n         // cancelUnregisteringServer costs 22k gas, we took about twist that much due to volatility of gasPrices\n        return uint128(servers[_serverIndex].deposit / 50 + tx.gasprice * 50000);\n    }\n\n    // internal helper functions\n    \n    function removeServer(uint _serverIndex) internal {\n        // trigger event\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner);\n\n        // remove from unique index\n        urlIndex[keccak256(bytes(servers[_serverIndex].url))] = false;\n        ownerIndex[servers[_serverIndex].owner] = false;\n\n        uint length = servers.length;\n        if (length>0) {\n            // move the last entry to the removed one.\n            In3Server memory m = servers[length - 1];\n            servers[_serverIndex] = m;\n        }\n        servers.length--;\n    }\n\n    function checkLimits() internal view {\n        // within the next 6 months this contract may never hold more than 50 ETH\n        if (now < 1560808800)\n           require(address(this).balance < 50 ether, \"Limit of 50 ETH reached\");\n    }\n\n}", "debug": "calldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x60\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 23, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9602, "code": "y {\n\n    /// server has been registered or updated its registry props or deposit\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n\n    ///  a caller requested to unregister a server.\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n\n    /// the owner canceled the unregister-proccess\n    event LogServerUnregisterCanceled(string url, address owner);\n\n    /// a Server was convicted\n    event LogServerConvicted(string url, address owner);\n\n    /// a Server is removed\n    event LogServerRemoved(string url, address owner);\n\n    struct In3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint128 unregisterTime; // earliest timestamp in to to call unregister\n        uint128 unregisterDeposit; // Deposit for unregistering\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n\n    /// server list of incubed nodes    \n    In3Server[] public servers;\n\n    // index for unique url and owner\n    mapping (address => bool) ownerIndex;\n    mapping (bytes32 => bool) urlIndex;\n    \n    /// length of the serverlist\n    function totalServers() public view returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        checkLimits();\n\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // make sure this url and also this owner was not registered before.\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\n\n        // add new In3Server\n        In3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n\n        // make sure they are used\n        urlIndex[urlHash] = true;\n        ownerIndex[msg.sender] = true;\n\n        // emit event\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// updates a Server by adding the msg.value to the deposit and setting the props    \n    function updateServer(uint _serverIndex, uint _props) public payable {\n        checkLimits();\n\n        In3Server storage server = servers[_serverIndex];\n        require(server.owner == msg.sender, \"only the owner may update the server\");\n\n        if (msg.value>0) \n          server.deposit += msg.value;\n\n        if (_props!=server.props)\n          server.props = _props;\n        emit LogServerRegistered(server.url, _props, msg.sender,server.deposit);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering the service and remove the server.\n    ///    in this case he has to wait for one hour before actually removing the server. \n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller == address(0x0), \"Server is already unregistering\");\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = uint128(now + 1 hours);\n        else {\n            server.unregisterTime = uint128(now + 28 days); // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value == calcUnregisterDeposit(_serverIndex), \"the exact calcUnregisterDeposit is required to request unregister\");\n            server.unregisterDeposit = uint128(msg.value);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender);\n    }\n    \n    /// this function must be called by the caller of the requestUnregisteringServer-function after 28 days\n    /// if the owner did not cancel, the caller will receive 20% of the server deposit + his own deposit.\n    /// the owner will receive 80% of the server deposit before the server will be removed.\n    function confirmUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller != address(0x0) && server.unregisterTime < now, \"Only the caller is allowed to confirm\");\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit / 5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer(server.unregisterDeposit + server.deposit - payBackOwner);\n        }\n\n        if (payBackOwner > 0)\n            server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    /// this function must be called by the owner to cancel the unregister-process.\n    /// if the caller is not the owner, then he will also get the deposit paid by the caller.\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller != address(0) && server.owner == msg.sender, \"only the owner is allowed to cancel unregister\");\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer(server.unregisterDeposit);\n\n        // set back storage values\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        server.unregisterDeposit = 0;\n\n        /// emit event\n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    /// convicts a server that signed a wrong blockhash\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        bytes32 evm_blockhash = blockhash(_blocknumber);\n        \n        // if the blockhash is correct you cannot convict the server\n        require(evm_blockhash != 0x0 && evm_blockhash != _blockhash, \"the block is too old or you try to convict with a correct hash\");\n\n        // make sure the hash was signed by the owner of the server\n        require(\n            ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner, \n            \"the block was not signed by the owner of the server\");\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit > 0) {\n            uint payout = servers[_serverIndex].deposit / 2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            // this is done in order to make it useless trying to convict your own server with a second account\n            // and this getting all the deposit back after signing a wrong hash.\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        // emit event\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        \n        removeServer(_serverIndex);\n    }\n\n    /// calculates the minimum deposit you need to pay in order to request unregistering of a server.\n    function calcUnregisterDeposit(uint _serverIndex) public view returns(uint128) {\n         // cancelUnregisteringServer costs 22k gas, we took about twist that much due to volatility of gasPrices\n        return uint128(servers[_serverIndex].deposit / 50 + tx.gasprice * 50000);\n    }\n\n    // internal helper functions\n    \n    function removeServer(uint _serverIndex) internal {\n        // trigger event\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner);\n\n        // remove from unique index\n        urlIndex[keccak256(bytes(servers[_serverIndex].url))] = false;\n        ownerIndex[servers[_serverIndex].owner] = false;\n\n        uint length = servers.length;\n        if (length>0) {\n            // move the last entry to the removed one.\n            In3Server memory m = servers[length - 1];\n            servers[_serverIndex] = m;\n        }\n        servers.length--;\n    }\n\n    function checkLimits() internal view {\n        // within the next 6 months this contract may never hold more than 50 ETH\n        if (now < 1560808800)\n           require(address(this).balance < 50 ether, \"Limit of 50 ETH reached\");\n    }\n\n}", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x40\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 23, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9619, "code": "y {\n\n    /// server has been registered or updated its registry props or deposit\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n\n    ///  a caller requested to unregister a server.\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n\n    /// the owner canceled the unregister-proccess\n    event LogServerUnregisterCanceled(string url, address owner);\n\n    /// a Server was convicted\n    event LogServerConvicted(string url, address owner);\n\n    /// a Server is removed\n    event LogServerRemoved(string url, address owner);\n\n    struct In3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint128 unregisterTime; // earliest timestamp in to to call unregister\n        uint128 unregisterDeposit; // Deposit for unregistering\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n\n    /// server list of incubed nodes    \n    In3Server[] public servers;\n\n    // index for unique url and owner\n    mapping (address => bool) ownerIndex;\n    mapping (bytes32 => bool) urlIndex;\n    \n    /// length of the serverlist\n    function totalServers() public view returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        checkLimits();\n\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // make sure this url and also this owner was not registered before.\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\n\n        // add new In3Server\n        In3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n\n        // make sure they are used\n        urlIndex[urlHash] = true;\n        ownerIndex[msg.sender] = true;\n\n        // emit event\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// updates a Server by adding the msg.value to the deposit and setting the props    \n    function updateServer(uint _serverIndex, uint _props) public payable {\n        checkLimits();\n\n        In3Server storage server = servers[_serverIndex];\n        require(server.owner == msg.sender, \"only the owner may update the server\");\n\n        if (msg.value>0) \n          server.deposit += msg.value;\n\n        if (_props!=server.props)\n          server.props = _props;\n        emit LogServerRegistered(server.url, _props, msg.sender,server.deposit);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering the service and remove the server.\n    ///    in this case he has to wait for one hour before actually removing the server. \n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller == address(0x0), \"Server is already unregistering\");\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = uint128(now + 1 hours);\n        else {\n            server.unregisterTime = uint128(now + 28 days); // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value == calcUnregisterDeposit(_serverIndex), \"the exact calcUnregisterDeposit is required to request unregister\");\n            server.unregisterDeposit = uint128(msg.value);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender);\n    }\n    \n    /// this function must be called by the caller of the requestUnregisteringServer-function after 28 days\n    /// if the owner did not cancel, the caller will receive 20% of the server deposit + his own deposit.\n    /// the owner will receive 80% of the server deposit before the server will be removed.\n    function confirmUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller != address(0x0) && server.unregisterTime < now, \"Only the caller is allowed to confirm\");\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit / 5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer(server.unregisterDeposit + server.deposit - payBackOwner);\n        }\n\n        if (payBackOwner > 0)\n            server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    /// this function must be called by the owner to cancel the unregister-process.\n    /// if the caller is not the owner, then he will also get the deposit paid by the caller.\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller != address(0) && server.owner == msg.sender, \"only the owner is allowed to cancel unregister\");\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer(server.unregisterDeposit);\n\n        // set back storage values\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        server.unregisterDeposit = 0;\n\n        /// emit event\n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    /// convicts a server that signed a wrong blockhash\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        bytes32 evm_blockhash = blockhash(_blocknumber);\n        \n        // if the blockhash is correct you cannot convict the server\n        require(evm_blockhash != 0x0 && evm_blockhash != _blockhash, \"the block is too old or you try to convict with a correct hash\");\n\n        // make sure the hash was signed by the owner of the server\n        require(\n            ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner, \n            \"the block was not signed by the owner of the server\");\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit > 0) {\n            uint payout = servers[_serverIndex].deposit / 2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            // this is done in order to make it useless trying to convict your own server with a second account\n            // and this getting all the deposit back after signing a wrong hash.\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        // emit event\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        \n        removeServer(_serverIndex);\n    }\n\n    /// calculates the minimum deposit you need to pay in order to request unregistering of a server.\n    function calcUnregisterDeposit(uint _serverIndex) public view returns(uint128) {\n         // cancelUnregisteringServer costs 22k gas, we took about twist that much due to volatility of gasPrices\n        return uint128(servers[_serverIndex].deposit / 50 + tx.gasprice * 50000);\n    }\n\n    // internal helper functions\n    \n    function removeServer(uint _serverIndex) internal {\n        // trigger event\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner);\n\n        // remove from unique index\n        urlIndex[keccak256(bytes(servers[_serverIndex].url))] = false;\n        ownerIndex[servers[_serverIndex].owner] = false;\n\n        uint length = servers.length;\n        if (length>0) {\n            // move the last entry to the removed one.\n            In3Server memory m = servers[length - 1];\n            servers[_serverIndex] = m;\n        }\n        servers.length--;\n    }\n\n    function checkLimits() internal view {\n        // within the next 6 months this contract may never hold more than 50 ETH\n        if (now < 1560808800)\n           require(address(this).balance < 50 ether, \"Limit of 50 ETH reached\");\n    }\n\n}", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x25\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x1f\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 23, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9624, "code": "y {\n\n    /// server has been registered or updated its registry props or deposit\n    event LogServerRegistered(string url, uint props, address owner, uint deposit);\n\n    ///  a caller requested to unregister a server.\n    event LogServerUnregisterRequested(string url, address owner, address caller);\n\n    /// the owner canceled the unregister-proccess\n    event LogServerUnregisterCanceled(string url, address owner);\n\n    /// a Server was convicted\n    event LogServerConvicted(string url, address owner);\n\n    /// a Server is removed\n    event LogServerRemoved(string url, address owner);\n\n    struct In3Server {\n        string url;  // the url of the server\n        address owner; // the owner, which is also the key to sign blockhashes\n        uint deposit; // stored deposit\n        uint props; // a list of properties-flags representing the capabilities of the server\n\n        // unregister state\n        uint128 unregisterTime; // earliest timestamp in to to call unregister\n        uint128 unregisterDeposit; // Deposit for unregistering\n        address unregisterCaller; // address of the caller requesting the unregister\n    }\n\n    /// server list of incubed nodes    \n    In3Server[] public servers;\n\n    // index for unique url and owner\n    mapping (address => bool) ownerIndex;\n    mapping (bytes32 => bool) urlIndex;\n    \n    /// length of the serverlist\n    function totalServers() public view returns (uint)  {\n        return servers.length;\n    }\n\n    /// register a new Server with the sender as owner    \n    function registerServer(string _url, uint _props) public payable {\n        checkLimits();\n\n        bytes32 urlHash = keccak256(bytes(_url));\n\n        // make sure this url and also this owner was not registered before.\n        require (!urlIndex[urlHash] && !ownerIndex[msg.sender], \"a Server with the same url or owner is already registered\");\n\n        // add new In3Server\n        In3Server memory m;\n        m.url = _url;\n        m.props = _props;\n        m.owner = msg.sender;\n        m.deposit = msg.value;\n        servers.push(m);\n\n        // make sure they are used\n        urlIndex[urlHash] = true;\n        ownerIndex[msg.sender] = true;\n\n        // emit event\n        emit LogServerRegistered(_url, _props, msg.sender,msg.value);\n    }\n\n    /// updates a Server by adding the msg.value to the deposit and setting the props    \n    function updateServer(uint _serverIndex, uint _props) public payable {\n        checkLimits();\n\n        In3Server storage server = servers[_serverIndex];\n        require(server.owner == msg.sender, \"only the owner may update the server\");\n\n        if (msg.value>0) \n          server.deposit += msg.value;\n\n        if (_props!=server.props)\n          server.props = _props;\n        emit LogServerRegistered(server.url, _props, msg.sender,server.deposit);\n    }\n\n    /// this should be called before unregistering a server.\n    /// there are 2 use cases:\n    /// a) the owner wants to stop offering the service and remove the server.\n    ///    in this case he has to wait for one hour before actually removing the server. \n    ///    This is needed in order to give others a chance to convict it in case this server signs wrong hashes\n    /// b) anybody can request to remove a server because it has been inactive.\n    ///    in this case he needs to pay a small deposit, which he will lose \n    //       if the owner become active again \n    //       or the caller will receive 20% of the deposit in case the owner does not react.\n    function requestUnregisteringServer(uint _serverIndex) payable public {\n\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called if nobody requested it before\n        require(server.unregisterCaller == address(0x0), \"Server is already unregistering\");\n\n        if (server.unregisterCaller == server.owner) \n           server.unregisterTime = uint128(now + 1 hours);\n        else {\n            server.unregisterTime = uint128(now + 28 days); // 28 days are always good ;-) \n            // the requester needs to pay the unregisterDeposit in order to spam-protect the server\n            require(msg.value == calcUnregisterDeposit(_serverIndex), \"the exact calcUnregisterDeposit is required to request unregister\");\n            server.unregisterDeposit = uint128(msg.value);\n        }\n        server.unregisterCaller = msg.sender;\n        emit LogServerUnregisterRequested(server.url, server.owner, msg.sender);\n    }\n    \n    /// this function must be called by the caller of the requestUnregisteringServer-function after 28 days\n    /// if the owner did not cancel, the caller will receive 20% of the server deposit + his own deposit.\n    /// the owner will receive 80% of the server deposit before the server will be removed.\n    function confirmUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n        // this can only be called if somebody requested it before\n        require(server.unregisterCaller != address(0x0) && server.unregisterTime < now, \"Only the caller is allowed to confirm\");\n\n        uint payBackOwner = server.deposit;\n        if (server.unregisterCaller != server.owner) {\n            payBackOwner -= server.deposit / 5;  // the owner will only receive 80% of his deposit back.\n            server.unregisterCaller.transfer(server.unregisterDeposit + server.deposit - payBackOwner);\n        }\n\n        if (payBackOwner > 0)\n            server.owner.transfer(payBackOwner);\n\n        removeServer(_serverIndex);\n    }\n\n    /// this function must be called by the owner to cancel the unregister-process.\n    /// if the caller is not the owner, then he will also get the deposit paid by the caller.\n    function cancelUnregisteringServer(uint _serverIndex) public {\n        In3Server storage server = servers[_serverIndex];\n\n        // this can only be called by the owner and if somebody requested it before\n        require(server.unregisterCaller != address(0) && server.owner == msg.sender, \"only the owner is allowed to cancel unregister\");\n\n        // if this was requested by somebody who does not own this server,\n        // the owner will get his deposit\n        if (server.unregisterCaller != server.owner) \n            server.owner.transfer(server.unregisterDeposit);\n\n        // set back storage values\n        server.unregisterCaller = address(0);\n        server.unregisterTime = 0;\n        server.unregisterDeposit = 0;\n\n        /// emit event\n        emit LogServerUnregisterCanceled(server.url, server.owner);\n    }\n\n\n    /// convicts a server that signed a wrong blockhash\n    function convict(uint _serverIndex, bytes32 _blockhash, uint _blocknumber, uint8 _v, bytes32 _r, bytes32 _s) public {\n        bytes32 evm_blockhash = blockhash(_blocknumber);\n        \n        // if the blockhash is correct you cannot convict the server\n        require(evm_blockhash != 0x0 && evm_blockhash != _blockhash, \"the block is too old or you try to convict with a correct hash\");\n\n        // make sure the hash was signed by the owner of the server\n        require(\n            ecrecover(keccak256(_blockhash, _blocknumber), _v, _r, _s) == servers[_serverIndex].owner, \n            \"the block was not signed by the owner of the server\");\n\n        // remove the deposit\n        if (servers[_serverIndex].deposit > 0) {\n            uint payout = servers[_serverIndex].deposit / 2;\n            // send 50% to the caller of this function\n            msg.sender.transfer(payout);\n\n            // and burn the rest by sending it to the 0x0-address\n            // this is done in order to make it useless trying to convict your own server with a second account\n            // and this getting all the deposit back after signing a wrong hash.\n            address(0).transfer(servers[_serverIndex].deposit-payout);\n        }\n\n        // emit event\n        emit LogServerConvicted(servers[_serverIndex].url, servers[_serverIndex].owner );\n        \n        removeServer(_serverIndex);\n    }\n\n    /// calculates the minimum deposit you need to pay in order to request unregistering of a server.\n    function calcUnregisterDeposit(uint _serverIndex) public view returns(uint128) {\n         // cancelUnregisteringServer costs 22k gas, we took about twist that much due to volatility of gasPrices\n        return uint128(servers[_serverIndex].deposit / 50 + tx.gasprice * 50000);\n    }\n\n    // internal helper functions\n    \n    function removeServer(uint _serverIndex) internal {\n        // trigger event\n        emit LogServerRemoved(servers[_serverIndex].url, servers[_serverIndex].owner);\n\n        // remove from unique index\n        urlIndex[keccak256(bytes(servers[_serverIndex].url))] = false;\n        ownerIndex[servers[_serverIndex].owner] = false;\n\n        uint length = servers.length;\n        if (length>0) {\n            // move the last entry to the removed one.\n            In3Server memory m = servers[length - 1];\n            servers[_serverIndex] = m;\n        }\n        servers.length--;\n    }\n\n    function checkLimits() internal view {\n        // within the next 6 months this contract may never hold more than 50 ETH\n        if (now < 1560808800)\n           require(address(this).balance < 50 ether, \"Limit of 50 ETH reached\");\n    }\n\n}", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_ServerRegistry_4 + calldata_ServerRegistry_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nkeccac_0_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n6*storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_ServerRegistry_4_+_calldata_ServerRegistry_4))_+\n224): 0x0\ncalldata_ServerRegistry_4 + calldata_ServerRegistry_4: 0x1f\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x2b5e3af16b187ffff\ntimestamp: 0x5d080d5f\ncalldata_ServerRegistry_0: 0x56a1e06c00000000000000000000000000000000000000000000000000000000\ncalldatasize_ServerRegistry: 0x4\n", "description": "A possible integer overflow exists in the function `registerServer(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/29/0x2736d225f85740f42d17987100dc8d58e9e16252.sol", "function": "registerServer(string,uint256)", "lineno": 23, "title": "Integer Overflow ", "type": "Warning"}], "success": true}