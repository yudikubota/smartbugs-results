{"error": null, "issues": [{"address": 2098, "code": "en deposit to `dep", "debug": "storage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldatasize_WithdrawContract: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "fallback", "lineno": 312, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2124, "code": "t will only work if ", "debug": "The exception is triggered under the following conditions:\n\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldatasize_WithdrawContract: 0x3\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "fallback", "lineno": 313, "title": "Exception state", "type": "Informational"}, {"address": 2728, "code": "available deposits\n    /// @param ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "canWithdraw(address)", "lineno": 459, "title": "Message call to external contract", "type": "Informational"}, {"address": 2728, "code": "available deposits\n    /// @param ", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 2988\n", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "canWithdraw(address)", "lineno": 459, "title": "Multiple Calls", "type": "Information"}, {"address": 2988, "code": "as been skipped\n    /// @param _holder Th", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "canWithdraw(address)", "lineno": 458, "title": "Message call to external contract", "type": "Informational"}, {"address": 3050, "code": "s to see if a specific deposit has been skipped\n    /// @param _holder Th", "debug": "storage_2 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n4*\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x78fefb8b23e336540547be8717586d697fa7e1b3da0e50b125bc9fb9e3a087a\nretval_2988: 0xbffffbffffffffffffffffdffb3ffffffffffffffffbfffffffffff5ffda343f\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_2728: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_3 +\n1546678032441257452667456735582814959992782782816731922691272282333561699760 +\n4*\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WithdrawContract_4: 0x0\ncalldata_WithdrawContract_0: 0x19262d3000000000000000000000000000000000000000000000000000000000\ncalldatasize_WithdrawContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `canWithdraw(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "canWithdraw(address)", "lineno": 458, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4303, "code": "///  wants to skip a payment, can ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "withdraw()", "lineno": 401, "title": "Message call to external contract", "type": "Informational"}, {"address": 4303, "code": "///  wants to skip a payment, can ", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4563\n", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "withdraw()", "lineno": 401, "title": "Multiple Calls", "type": "Information"}, {"address": 4563, "code": "/// @notice This function is a failsafe func", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "withdraw()", "lineno": 400, "title": "Message call to external contract", "type": "Informational"}, {"address": 5355, "code": "mount);\n    }\n\n    /// @notice This function is a fails", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0x44ab1409", "lineno": 341, "title": "Message call to external contract", "type": "Warning"}, {"address": 5432, "code": "en is\n    ///  dep", "debug": "storage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WithdrawContract_32 + 36: 0x0\nreturndatasize: 0x20\nretval_5355: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0x1\ncalldata_WithdrawContract_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_WithdrawContract_0: 0x44ab140900000000000000000000000000000000000000000000000000000000\ncalldatasize_WithdrawContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x44ab1409`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0x44ab1409", "lineno": 344, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5501, "code": "re disabled), can only be called by the `owner`\n", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0x44ab1409", "lineno": 346, "title": "State change after external call", "type": "Warning"}, {"address": 5568, "code": "ram _idDeposit T", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0x44ab1409", "lineno": 347, "title": "State change after external call", "type": "Warning"}, {"address": 5577, "code": "r for the deposit ", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0x44ab1409", "lineno": 347, "title": "State change after external call", "type": "Warning"}, {"address": 7548, "code": "apeHatch()`\n    /// @", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "escapeHatch(address)", "lineno": 192, "title": "Message call to external contract", "type": "Warning"}, {"address": 8094, "code": "bool)) skipDeposits;\n\n///", "debug": "The exception is triggered under the following conditions:\n\ncalldata_WithdrawContract_4: 0x0\nstorage_5: 0x0\ncalldata_WithdrawContract_0: 0xb02c43d000000000000000000000000000000000000000000000000000000000\ncalldatasize_WithdrawContract: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0xb02c43d0", "lineno": 254, "title": "Exception state", "type": "Informational"}, {"address": 9976, "code": "x0 if ether)\n        uint amount;   // The amount deposited in the smallest unit (wei if ETH)\n        bool canceled; // True if canceled by the `owner`\n    }\n\n    Deposit[] public deposits; // Array of deposits to this contract\n    MiniMeToken rewardToken;     // Token that is used for withdraws\n\n    mapping (address => uint) public nextDepositToPayout; // Tracks Payouts\n    mapping (address => mapping(uint => bool)) skipDeposits;\n\n/////////\n// Constructor\n/////////\n\n    /// @notice The Constructor creates the `WithdrawContract` on the blockchain\n    ///  the `owner` role is assigned to the address that deploys this contract\n    /// @param _rewardToken The address of the token that is used to determine the\n    ///  distribution of the deposits according to the balance held at the\n    ///  deposit's specified `block`\n    /// @param _escapeHatchCaller The address of a trusted account or contract\n    ///  to call `escapeHatch()` to send the specified token (or ether) held in\n    ///  this contract to the `escapeHatchDestination`\n    /// @param _escapeHatchDestination The address of a safe location (usu a\n    ///  Multisig) to send the ether and tokens held in this contract when the\n    ///  `escapeHatch()` is called\n    function WithdrawContract(\n        MiniMeToken _rewardToken,\n        address _escapeHatchCaller,\n        address _escapeHatchDestination)\n        Escapable(_escapeHatchCaller, _escapeHatchDestination)\n        public\n    {\n        rewardToken = _rewardToken;\n    }\n\n    /// @dev When ether is sent to this contract `newEtherDeposit()` is called\n    function () payable public {\n        newEtherDeposit(0);\n    }\n/////////\n// Owner Functions\n/////////\n\n    /// @notice Adds an ether deposit to `deposits[]`; only the `owner` can\n    ///  deposit into this contract\n    /// @param _block The block height that determines the snapshot of token\n    ///  holders that will be able to withdraw their share of this deposit; this\n    ///  block must be set in the past, if 0 it defaults to one block before the\n    ///  transaction\n    /// @return _idDeposit The id number for the deposit\n    function newEtherDeposit(uint _block)\n        public onlyOwner payable\n        returns (uint _idDeposit)\n    {\n        require(msg.value>0);\n        require(_block < block.number);\n        _idDeposit = deposits.length ++;\n\n        // Record the deposit\n        Deposit storage d = deposits[_idDeposit];\n        d.block = _block == 0 ? block.number -1 : _block;\n        d.token = ERC20(0);\n        d.amount = msg.value;\n        NewDeposit(_idDeposit, ERC20(0), msg.value);\n    }\n\n    /// @notice Adds a token deposit to `deposits[]`; only the `owner` can\n    ///  call this function and it will only work if the account sending the\n    ///  tokens has called `approve()` so that this contract can call\n    ///  `transferFrom()` and take the tokens\n    /// @param _token The address for the ERC20 that is being deposited\n    /// @param _amount The quantity of tokens that is deposited into the\n    ///  contract in the smallest unit of tokens (if a token has its decimals\n    ///  set to 18 and 1 token is sent, the `_amount` would be 10^18)\n    /// @param _block The block height that determines the snapshot of token\n    ///  holders that will be able to withdraw their share of this deposit; this\n    ///  block must be set in the past, if 0 it defaults to one block before the\n    ///  transaction\n    /// @return _idDeposit The id number for the deposit\n    function newTokenDeposit(ERC20 _token, uint _amount, uint _block)\n        public onlyOwner\n        returns (uint _idDeposit)\n    {\n        require(_amount > 0);\n        require(_block < block.number);\n\n        // Must `approve()` this contract in a previous transaction\n        require( _token.transferFrom(msg.sender, address(this), _amount) );\n        _idDeposit = deposits.length ++;\n\n        // Record the deposit\n        Deposit storage d = deposits[_idDeposit];\n        d.block = _block == 0 ? block.number -1 : _block;\n        d.token = _token;\n        d.amount = _amount;\n        NewDeposit(_idDeposit, _token, _amount);\n    }\n\n    /// @notice This function is a failsafe function in case a token is\n    ///  deposited that has an issue that could prevent it's withdraw loop break\n    ///  (e.g. transfers are disabled), can only be called by the `owner`\n    /// @param _idDeposit The id number for the deposit being canceled\n    function cancelPaymentGlobally(uint _idDeposit) public onlyOwner {\n        require(_idDeposit < deposits.length);\n        deposits[_idDeposit].canceled = true;\n        CancelPaymentGlobally(_idDeposit);\n    }\n\n/////////\n// Public Functions\n/////////\n    /// @notice Sends all the tokens and ether to the token holder by looping\n    ///  through all the deposits, determining the appropriate amount by\n    ///  dividing the `totalSupply` by the number of tokens the token holder had\n    ///  at `deposit.block` for each deposit; this function may have to be\n    ///  called multiple times if their are many deposits\n    function withdraw() public {\n        uint acc = 0; // Accumulates the amount of tokens/ether to be sent\n        uint i = nextDepositToPayout[msg.sender]; // Iterates through the deposits\n        require(i<deposits.length);\n        ERC20 currentToken = deposits[i].token; // Sets the `currentToken` to ether\n\n        require(msg.gas>149000); // Throws if there is no gas to do at least a single transfer.\n        while (( i< deposits.length) && ( msg.gas > 148000)) {\n            Deposit storage d = deposits[i];\n\n            // Make sure `deposit[i]` shouldn't be skipped\n            if ((!d.canceled)&&(!isDepositSkiped(msg.sender, i))) {\n\n                // The current diposti is different of the accumulated until now,\n                // so we return the accumulated tokens until now and resset the\n                // accumulator.\n                if (currentToken != d.token) {\n                    nextDepositToPayout[msg.sender] = i;\n                    require(doPayment(i-1, msg.sender, currentToken, acc));\n                    assert(nextDepositToPayout[msg.sender] == i);\n                    currentToken = d.token;\n                    acc =0;\n                }\n\n                // Accumulate the amount to send for the `currentToken`\n                acc +=  d.amount *\n                        rewardToken.balanceOfAt(msg.sender, d.block) /\n                            rewardToken.totalSupplyAt(d.block);\n            }\n\n            i++; // Next deposit :-D\n        }\n        // Return the accumulated tokens.\n        nextDepositToPayout[msg.sender] = i;\n        require(doPayment(i-1, msg.sender, currentToken, acc));\n        assert(nextDepositToPayout[msg.sender] == i);\n    }\n\n    /// @notice This function is a failsafe function in case a token holder\n    ///  wants to skip a payment, can only be applied to one deposit at a time\n    ///  and only affects the payment for the `msg.sender` calling the function;\n    ///  can be undone by calling again with `skip == false`\n    /// @param _idDeposit The id number for the deposit being canceled\n    /// @param _skip True if the caller wants to skip the payment for `idDeposit`\n    function skipPayment(uint _idDeposit, bool _skip) public {\n        require(_idDeposit < deposits.length);\n        skipDeposits[msg.sender][_idDeposit] = _skip;\n        SkipPayment(_idDeposit, _skip);\n    }\n\n/////////\n// Constant Functions\n/////////\n\n    /// @notice Calculates the amount of a given token (or ether) the holder can\n    ///  receive\n    /// @param _token The address of the token being queried, 0x0 = ether\n    /// @param _holder The address being checked\n    /// @return The amount of `token` able to be collected in the smallest\n    ///  unit of the `token` (wei for ether)\n    function getPendingReward(ERC20 _token, address _holder) public constant returns(uint) {\n        uint acc =0;\n        for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) {\n            Deposit storage d = deposits[i];\n            if ((d.token == _token)&&(!d.canceled) && (!isDepositSkiped(_holder, i))) {\n                acc +=  d.amount *\n                    rewardToken.balanceOfAt(_holder, d.block) /\n                        rewardToken.totalSupplyAt(d.block);\n            }\n        }\n        return acc;\n    }\n\n    /// @notice A check to see if a specific address has anything to collect\n    /// @param _holder The address being checked for available deposits\n    /// @return True if there are payments to be collected\n    function canWithdraw(address _holder) public constant returns (bool) {\n        if (nextDepositToPayout[_holder] == deposits.length) return false;\n        for (uint i=nextDepositToPayout[msg.sender]; i<deposits.length; i++) {\n            Deposit storage d = deposits[i];\n            if ((!d.canceled) && (!isDepositSkiped(_holder, i))) {\n                uint amount =  d.amount *\n                    rewardToken.balanceOfAt(_holder, d.block) /\n                        rewardToken.totalSupplyAt(d.block);\n                if (amount>0) return true;\n            }\n        }\n        return false;\n    }\n\n    /// @notice Checks how many deposits have been made\n    /// @return The number of deposits\n    function nDeposits() public constant returns (uint) {\n        return deposits.length;\n    }\n\n    /// @notice Checks to see if a specific deposit has been skipped\n    /// @param _holder The address being checked for available deposits\n    /// @param _idDeposit The id number for the deposit being canceled\n    /// @return True if the specified deposit has been skipped\n    function isDepositSkiped(address _holder, uint _idDeposit) public constant returns(bool) {\n        return skipDeposits[_holder][_idDeposit];\n    }\n\n/////////\n// Internal Functions\n/////////\n\n    /// @notice Transfers `amount` of `token` to `dest`, only used internally,\n    ///  and does not throw, will always return `true` or `false`\n    /// @param _token The address for the ERC20 that is being transferred\n    /// @param _dest The destination address of the transfer\n    /// @param _amount The quantity of tokens that is being transferred\n    ///  denominated in the smallest unit of tokens (if a token has its decimals\n    ///  set to 18 and 1 token is being transferred the `amount` would be 10^18)\n    /// @return True if the payment succeeded\n    function doPayment(uint _idDeposit,  address _dest, ERC20 _token, uint _amount) internal returns (bool) {\n        if (_amount == 0) return true;\n        if (address(_token) == 0) {\n            if (!_dest.send(_amount)) return false;   // If we can't send, we continue...\n        } else {\n            if (!_token.transfer(_dest, _amount)) return false;\n        }\n        Withdraw(_idDeposit, _dest, _token, _amount);\n        return true;\n    }\n\n    function getBalance(ERC20 _token, address _holder) internal constant returns (uint) {\n        if (address(_token) == 0) {\n            return _holder.balance;\n        } else {\n            return _token.balanceOf(_holder);\n        }\n    }\n\n/////////\n// Events\n/////////\n\n    event Withdraw(uint indexed lastIdPayment, address indexed holder, ERC20 indexed tokenContract, uint amount);\n    event NewDeposit(uint indexed idDeposit, ERC20 indexed tokenContract, uint amount);\n    event CancelPaymentGlobally(uint indexed idDeposit);\n    event SkipPayment(uint indexed idDeposit, bool skip);\n}", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/14/0x0efef0b34638addc8833ba729ae20016b5f24ffc.sol", "function": "_function_0x44ab1409", "lineno": 245, "title": "State change after external call", "type": "Warning"}], "success": true}