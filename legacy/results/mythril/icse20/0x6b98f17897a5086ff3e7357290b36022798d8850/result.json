{
  "contract": "0x6b98f17897a5086ff3e7357290b36022798d8850",
  "tool": "mythril",
  "start": 1563501135.494102,
  "end": 1563501388.5598457,
  "duration": 253.06574368476868,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 332,
        "code": " time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY",
        "debug": "calldata_Verifier_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Verifier_0: 0x15c7a6f800000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x15c7a6f8`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "_function_0x15c7a6f8",
        "lineno": 236,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1275,
        "code": "e vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computatio",
        "debug": "calldata_Verifier_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Verifier_0: 0x96b85c1600000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x96b85c16`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "_function_0x96b85c16",
        "lineno": 223,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2094,
        "code": "eeds to be < vector.le",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Verifier_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Verifier_32_+_4: 0x0\ncalldata_Verifier_0: 0x147af58300000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "getInputBits(uint256,address)",
        "lineno": 262,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2294,
        "code": "other members of the global ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Verifier_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_Verifier_4 + calldata_Verifier_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Verifier_0: 0x15c7a6f800000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "_function_0x15c7a6f8",
        "lineno": 246,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2521,
        "code": "te the linear combination",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Verifier_4: 0x0\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\ncalldata_Verifier_32 + 4: 0x1\ncalldata_Verifier_0: 0x17e4e95400000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "computeVkx(uint256,uint256)",
        "lineno": 279,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2642,
        "code": "k_x\nvk_xs[addr] = Pair",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Verifier_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x3\ncalldata_Verifier_32 + 4: 0x2\ncalldata_Verifier_0: 0x17e4e95400000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "computeVkx(uint256,uint256)",
        "lineno": 279,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2858,
        "code": " Co",
        "debug": "keccac_24_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xb3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x3\ncalldata_Verifier_4: 0x0\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `setKeyLength(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 199,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 5192,
        "code": "EY network; pat. pending.\n*",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Verifier_4 + calldata_Verifier_4: 0x2\ncalldata_Verifier_32 + 4: 0x0\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_Verifier_0: 0x96b85c1600000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "_function_0x96b85c16",
        "lineno": 234,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6676,
        "code": "\" to make gas estimation work\nswitch success cas",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "computeVkx(uint256,uint256)",
        "lineno": 66,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 6676,
        "code": "\" to make gas estimation work\nswitch success cas",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "computeVkx(uint256,uint256)",
        "lineno": 66,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 6693,
        "code": "ting the ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Verifier_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x2\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x3\ncalldata_Verifier_32 + 4: 0x2\ncalldata_Verifier_0: 0x17e4e95400000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\nretval_6676: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "computeVkx(uint256,uint256)",
        "lineno": 71,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10752,
        "code": "g.G1Point gammaBeta1;\nPairing.G2Point gammaBeta2;\nPairing.G2Point Z;\nPairing.G1Point[] IC;\n}\nstruct Proof {\nPairing.G1Point A;\nPairing.G1Point A_p;\nPairing.G2Point B;\nPairing.G1Point B_p;\nPairing.G1Point C;\nPairing.G1Point C_p;\nPairing.G1Point K;\nPairing.G1Point H;\n}\n//uint[] vector; //not used - replaced by a mapping\n//Pairing.G1Point vk_x = Pairing.G1Point(0, 0); //not used - replaced by a mapping\n//VerifyingKey private vk; //not used - replaced by a mapping\nmapping(address => VerifyingKey) private vks;\nmapping(address => uint[]) private vectors;\nmapping(address => Pairing.G1Point) private vk_xs;\n\n\n\n\nfunction setKeyLength(uint l) public {\nvks[msg.sender].IC.length = l;\nvectors[msg.sender].length = l-1;\n}\n\n\n\n\nfunction loadVerifyingKeyPreamble(\nuint[2][2] A,\nuint[2] B,\nuint[2][2] C,\nuint[2][2] gamma,\nuint[2] gammaBeta1,\nuint[2][2] gammaBeta2,\nuint[2][2] Z\n) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nvks[msg.sender].A = Pairing.G2Point([A[0][0],A[0][1]],[A[1][0],A[1][1]]);\nvks[msg.sender].B = Pairing.G1Point(B[0],B[1]);\nvks[msg.sender].C = Pairing.G2Point([C[0][0],C[0][1]],[C[1][0],C[1][1]]);\nvks[msg.sender].gamma = Pairing.G2Point([gamma[0][0],gamma[0][1]],[gamma[1][0],gamma[1][1]]);\nvks[msg.sender].gammaBeta1 = Pairing.G1Point(gammaBeta1[0],gammaBeta1[1]);\nvks[msg.sender].gammaBeta2 = Pairing.G2Point([gammaBeta2[0][0],gammaBeta2[0][1]],[gammaBeta2[1][0],gammaBeta2[1][1]]);\nvks[msg.sender].Z = Pairing.G2Point([Z[0][0],Z[0][1]],[Z[1][0],Z[1][1]]);\n//this seems a good place to initialise the vk_x computation\nvk_xs[msg.sender] = Pairing.G1Point(0, 0); //initialise\n\n\n\n\n}\n\n\n\n\nfunction loadVerifyingKey(uint[2][] points, uint start) public{\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_xs[addr].X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nparam = 0x0; bytes8 b = bytes8(1);\nfor (uint i=0; i<64; i++){\nif (vectors[addr][i+start] == 1) param = param | (b<<(63-i));\n}\nreturn param;\n}\n\n\n\n\nfunction computeVkx(uint start, uint end) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//end needs to be < vector.length\nfor (uint i = start; i < end; i++)\nvk_xs[msg.sender] = Pairing.addition(vk_xs[msg.sender], Pairing.scalar_mul(vks[msg.sender].IC[i + 1], vectors[msg.sender][i]));\n}\n\n\n\n\nfunction getAddress() public returns(address){\nreturn address(this);\n}\n\n\n\n\nfunction verify(Proof proof, address addr) internal returns (uint) {\nrequire(vectors[addr].length + 1 == vks[addr].IC.length);\n// Compute the linear combination vk_x\nvk_xs[addr] = Pairing.addition(vk_xs[addr], vks[addr].IC[0]);\nif (!Pairing.pairingProd2(proof.A, vks[addr].A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\nif (!Pairing.pairingProd2(vks[addr].B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\nif (!Pairing.pairingProd2(proof.C, vks[addr].C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\nif (!Pairing.pairingProd3(\nproof.K, vks[addr].gamma,\nPairing.negate(Pairing.addition(vk_xs[addr], Pairing.addition(proof.A, proof.C))), vks[addr].gammaBeta2,\nPairing.negate(vks[addr].gammaBeta1), proof.B\n)) return 4;\nif (!Pairing.pairingProd3(\nPairing.addition(vk_xs[addr], proof.A), proof.B,\nPairing.negate(proof.H), vks[addr].Z,\nPairing.negate(proof.C), Pairing.P2()\n)) return 5;\nreturn 0;\n}\n// @dev Fired by function verifyTx\n// @param _decodeFlag = dec0de\n// @param _verified A message to output through this event\nevent Verified(bytes4 indexed _decodeFlag, bytes32 indexed _verified);\n\n\n\n\nfunction verifyTx(\nuint[2] a,\nuint[2] a_p,\nuint[2][2] b,\nuint[2] b_p,\nuint[2] c,\nuint[2] c_p,\nuint[2] h,\nuint[2] k,\naddress addr\n) public returns (bool r) {\nProof memory proof;\nproof.A = Pairing.G1Point(a[0], a[1]);\nproof.A_p = Pairing.G1Point(a_p[0], a_p[1]);\nproof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\nproof.B_p = Pairing.G1Point(b_p[0], b_p[1]);\nproof.C = Pairing.G1Point(c[0], c[1]);\nproof.C_p = Pairing.G1Point(c_p[0], c_p[1]);\nproof.H = Pairing.G1Point(h[0], h[1]);\nproof.K = Pairing.G1Point(k[0], k[1]);\nbytes4 decodeFlag = 0xdec0de; // flag to tell humans that _verified is a hex encoding of an ascii string\nbytes32 verified; // a hex encoding of a string - returned by event Verified\nif (verify(proof, addr) == 0) {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d20547820566572696669656421203a29; //\"EY Opschain - Tx Verified! :)\" in hex\nemit Verified(decodeFlag, verified);\nreturn true;\n} else {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d205478204e4f54205665726966696564203a28; //\"EY Opschain - Tx NOT Verified :(\" in hex\nemit Verified(decodeFlag, verified);\nreturn false;\n}\n}\n}",
        "debug": "storage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_Verifier_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setKeyLength(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10756,
        "code": "g.G1Point gammaBeta1;\nPairing.G2Point gammaBeta2;\nPairing.G2Point Z;\nPairing.G1Point[] IC;\n}\nstruct Proof {\nPairing.G1Point A;\nPairing.G1Point A_p;\nPairing.G2Point B;\nPairing.G1Point B_p;\nPairing.G1Point C;\nPairing.G1Point C_p;\nPairing.G1Point K;\nPairing.G1Point H;\n}\n//uint[] vector; //not used - replaced by a mapping\n//Pairing.G1Point vk_x = Pairing.G1Point(0, 0); //not used - replaced by a mapping\n//VerifyingKey private vk; //not used - replaced by a mapping\nmapping(address => VerifyingKey) private vks;\nmapping(address => uint[]) private vectors;\nmapping(address => Pairing.G1Point) private vk_xs;\n\n\n\n\nfunction setKeyLength(uint l) public {\nvks[msg.sender].IC.length = l;\nvectors[msg.sender].length = l-1;\n}\n\n\n\n\nfunction loadVerifyingKeyPreamble(\nuint[2][2] A,\nuint[2] B,\nuint[2][2] C,\nuint[2][2] gamma,\nuint[2] gammaBeta1,\nuint[2][2] gammaBeta2,\nuint[2][2] Z\n) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nvks[msg.sender].A = Pairing.G2Point([A[0][0],A[0][1]],[A[1][0],A[1][1]]);\nvks[msg.sender].B = Pairing.G1Point(B[0],B[1]);\nvks[msg.sender].C = Pairing.G2Point([C[0][0],C[0][1]],[C[1][0],C[1][1]]);\nvks[msg.sender].gamma = Pairing.G2Point([gamma[0][0],gamma[0][1]],[gamma[1][0],gamma[1][1]]);\nvks[msg.sender].gammaBeta1 = Pairing.G1Point(gammaBeta1[0],gammaBeta1[1]);\nvks[msg.sender].gammaBeta2 = Pairing.G2Point([gammaBeta2[0][0],gammaBeta2[0][1]],[gammaBeta2[1][0],gammaBeta2[1][1]]);\nvks[msg.sender].Z = Pairing.G2Point([Z[0][0],Z[0][1]],[Z[1][0],Z[1][1]]);\n//this seems a good place to initialise the vk_x computation\nvk_xs[msg.sender] = Pairing.G1Point(0, 0); //initialise\n\n\n\n\n}\n\n\n\n\nfunction loadVerifyingKey(uint[2][] points, uint start) public{\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_xs[addr].X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nparam = 0x0; bytes8 b = bytes8(1);\nfor (uint i=0; i<64; i++){\nif (vectors[addr][i+start] == 1) param = param | (b<<(63-i));\n}\nreturn param;\n}\n\n\n\n\nfunction computeVkx(uint start, uint end) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//end needs to be < vector.length\nfor (uint i = start; i < end; i++)\nvk_xs[msg.sender] = Pairing.addition(vk_xs[msg.sender], Pairing.scalar_mul(vks[msg.sender].IC[i + 1], vectors[msg.sender][i]));\n}\n\n\n\n\nfunction getAddress() public returns(address){\nreturn address(this);\n}\n\n\n\n\nfunction verify(Proof proof, address addr) internal returns (uint) {\nrequire(vectors[addr].length + 1 == vks[addr].IC.length);\n// Compute the linear combination vk_x\nvk_xs[addr] = Pairing.addition(vk_xs[addr], vks[addr].IC[0]);\nif (!Pairing.pairingProd2(proof.A, vks[addr].A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\nif (!Pairing.pairingProd2(vks[addr].B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\nif (!Pairing.pairingProd2(proof.C, vks[addr].C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\nif (!Pairing.pairingProd3(\nproof.K, vks[addr].gamma,\nPairing.negate(Pairing.addition(vk_xs[addr], Pairing.addition(proof.A, proof.C))), vks[addr].gammaBeta2,\nPairing.negate(vks[addr].gammaBeta1), proof.B\n)) return 4;\nif (!Pairing.pairingProd3(\nPairing.addition(vk_xs[addr], proof.A), proof.B,\nPairing.negate(proof.H), vks[addr].Z,\nPairing.negate(proof.C), Pairing.P2()\n)) return 5;\nreturn 0;\n}\n// @dev Fired by function verifyTx\n// @param _decodeFlag = dec0de\n// @param _verified A message to output through this event\nevent Verified(bytes4 indexed _decodeFlag, bytes32 indexed _verified);\n\n\n\n\nfunction verifyTx(\nuint[2] a,\nuint[2] a_p,\nuint[2][2] b,\nuint[2] b_p,\nuint[2] c,\nuint[2] c_p,\nuint[2] h,\nuint[2] k,\naddress addr\n) public returns (bool r) {\nProof memory proof;\nproof.A = Pairing.G1Point(a[0], a[1]);\nproof.A_p = Pairing.G1Point(a_p[0], a_p[1]);\nproof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\nproof.B_p = Pairing.G1Point(b_p[0], b_p[1]);\nproof.C = Pairing.G1Point(c[0], c[1]);\nproof.C_p = Pairing.G1Point(c_p[0], c_p[1]);\nproof.H = Pairing.G1Point(h[0], h[1]);\nproof.K = Pairing.G1Point(k[0], k[1]);\nbytes4 decodeFlag = 0xdec0de; // flag to tell humans that _verified is a hex encoding of an ascii string\nbytes32 verified; // a hex encoding of a string - returned by event Verified\nif (verify(proof, addr) == 0) {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d20547820566572696669656421203a29; //\"EY Opschain - Tx Verified! :)\" in hex\nemit Verified(decodeFlag, verified);\nreturn true;\n} else {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d205478204e4f54205665726966696564203a28; //\"EY Opschain - Tx NOT Verified :(\" in hex\nemit Verified(decodeFlag, verified);\nreturn false;\n}\n}\n}",
        "debug": "calldata_Verifier_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8000000000000000000000000000000000000000000000000000000000000001\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setKeyLength(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10768,
        "code": "g.G1Point gammaBeta1;\nPairing.G2Point gammaBeta2;\nPairing.G2Point Z;\nPairing.G1Point[] IC;\n}\nstruct Proof {\nPairing.G1Point A;\nPairing.G1Point A_p;\nPairing.G2Point B;\nPairing.G1Point B_p;\nPairing.G1Point C;\nPairing.G1Point C_p;\nPairing.G1Point K;\nPairing.G1Point H;\n}\n//uint[] vector; //not used - replaced by a mapping\n//Pairing.G1Point vk_x = Pairing.G1Point(0, 0); //not used - replaced by a mapping\n//VerifyingKey private vk; //not used - replaced by a mapping\nmapping(address => VerifyingKey) private vks;\nmapping(address => uint[]) private vectors;\nmapping(address => Pairing.G1Point) private vk_xs;\n\n\n\n\nfunction setKeyLength(uint l) public {\nvks[msg.sender].IC.length = l;\nvectors[msg.sender].length = l-1;\n}\n\n\n\n\nfunction loadVerifyingKeyPreamble(\nuint[2][2] A,\nuint[2] B,\nuint[2][2] C,\nuint[2][2] gamma,\nuint[2] gammaBeta1,\nuint[2][2] gammaBeta2,\nuint[2][2] Z\n) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nvks[msg.sender].A = Pairing.G2Point([A[0][0],A[0][1]],[A[1][0],A[1][1]]);\nvks[msg.sender].B = Pairing.G1Point(B[0],B[1]);\nvks[msg.sender].C = Pairing.G2Point([C[0][0],C[0][1]],[C[1][0],C[1][1]]);\nvks[msg.sender].gamma = Pairing.G2Point([gamma[0][0],gamma[0][1]],[gamma[1][0],gamma[1][1]]);\nvks[msg.sender].gammaBeta1 = Pairing.G1Point(gammaBeta1[0],gammaBeta1[1]);\nvks[msg.sender].gammaBeta2 = Pairing.G2Point([gammaBeta2[0][0],gammaBeta2[0][1]],[gammaBeta2[1][0],gammaBeta2[1][1]]);\nvks[msg.sender].Z = Pairing.G2Point([Z[0][0],Z[0][1]],[Z[1][0],Z[1][1]]);\n//this seems a good place to initialise the vk_x computation\nvk_xs[msg.sender] = Pairing.G1Point(0, 0); //initialise\n\n\n\n\n}\n\n\n\n\nfunction loadVerifyingKey(uint[2][] points, uint start) public{\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_xs[addr].X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nparam = 0x0; bytes8 b = bytes8(1);\nfor (uint i=0; i<64; i++){\nif (vectors[addr][i+start] == 1) param = param | (b<<(63-i));\n}\nreturn param;\n}\n\n\n\n\nfunction computeVkx(uint start, uint end) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//end needs to be < vector.length\nfor (uint i = start; i < end; i++)\nvk_xs[msg.sender] = Pairing.addition(vk_xs[msg.sender], Pairing.scalar_mul(vks[msg.sender].IC[i + 1], vectors[msg.sender][i]));\n}\n\n\n\n\nfunction getAddress() public returns(address){\nreturn address(this);\n}\n\n\n\n\nfunction verify(Proof proof, address addr) internal returns (uint) {\nrequire(vectors[addr].length + 1 == vks[addr].IC.length);\n// Compute the linear combination vk_x\nvk_xs[addr] = Pairing.addition(vk_xs[addr], vks[addr].IC[0]);\nif (!Pairing.pairingProd2(proof.A, vks[addr].A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\nif (!Pairing.pairingProd2(vks[addr].B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\nif (!Pairing.pairingProd2(proof.C, vks[addr].C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\nif (!Pairing.pairingProd3(\nproof.K, vks[addr].gamma,\nPairing.negate(Pairing.addition(vk_xs[addr], Pairing.addition(proof.A, proof.C))), vks[addr].gammaBeta2,\nPairing.negate(vks[addr].gammaBeta1), proof.B\n)) return 4;\nif (!Pairing.pairingProd3(\nPairing.addition(vk_xs[addr], proof.A), proof.B,\nPairing.negate(proof.H), vks[addr].Z,\nPairing.negate(proof.C), Pairing.P2()\n)) return 5;\nreturn 0;\n}\n// @dev Fired by function verifyTx\n// @param _decodeFlag = dec0de\n// @param _verified A message to output through this event\nevent Verified(bytes4 indexed _decodeFlag, bytes32 indexed _verified);\n\n\n\n\nfunction verifyTx(\nuint[2] a,\nuint[2] a_p,\nuint[2][2] b,\nuint[2] b_p,\nuint[2] c,\nuint[2] c_p,\nuint[2] h,\nuint[2] k,\naddress addr\n) public returns (bool r) {\nProof memory proof;\nproof.A = Pairing.G1Point(a[0], a[1]);\nproof.A_p = Pairing.G1Point(a_p[0], a_p[1]);\nproof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\nproof.B_p = Pairing.G1Point(b_p[0], b_p[1]);\nproof.C = Pairing.G1Point(c[0], c[1]);\nproof.C_p = Pairing.G1Point(c_p[0], c_p[1]);\nproof.H = Pairing.G1Point(h[0], h[1]);\nproof.K = Pairing.G1Point(k[0], k[1]);\nbytes4 decodeFlag = 0xdec0de; // flag to tell humans that _verified is a hex encoding of an ascii string\nbytes32 verified; // a hex encoding of a string - returned by event Verified\nif (verify(proof, addr) == 0) {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d20547820566572696669656421203a29; //\"EY Opschain - Tx Verified! :)\" in hex\nemit Verified(decodeFlag, verified);\nreturn true;\n} else {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d205478204e4f54205665726966696564203a28; //\"EY Opschain - Tx NOT Verified :(\" in hex\nemit Verified(decodeFlag, verified);\nreturn false;\n}\n}\n}",
        "debug": "storage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x55a0a796dafddae645f95fcb655e56032628d35094e7b6a87a8630f6f021852d\nkeccac_24_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8be283adf5a142035949876408b4a739e090206031bf37c389c725e19245225c\ncalldata_Verifier_4: 0x55a0a796dafddae645f95fcb655e56032628d35094e7b6a87a8630f6f021852c\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setKeyLength(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10770,
        "code": "g.G1Point gammaBeta1;\nPairing.G2Point gammaBeta2;\nPairing.G2Point Z;\nPairing.G1Point[] IC;\n}\nstruct Proof {\nPairing.G1Point A;\nPairing.G1Point A_p;\nPairing.G2Point B;\nPairing.G1Point B_p;\nPairing.G1Point C;\nPairing.G1Point C_p;\nPairing.G1Point K;\nPairing.G1Point H;\n}\n//uint[] vector; //not used - replaced by a mapping\n//Pairing.G1Point vk_x = Pairing.G1Point(0, 0); //not used - replaced by a mapping\n//VerifyingKey private vk; //not used - replaced by a mapping\nmapping(address => VerifyingKey) private vks;\nmapping(address => uint[]) private vectors;\nmapping(address => Pairing.G1Point) private vk_xs;\n\n\n\n\nfunction setKeyLength(uint l) public {\nvks[msg.sender].IC.length = l;\nvectors[msg.sender].length = l-1;\n}\n\n\n\n\nfunction loadVerifyingKeyPreamble(\nuint[2][2] A,\nuint[2] B,\nuint[2][2] C,\nuint[2][2] gamma,\nuint[2] gammaBeta1,\nuint[2][2] gammaBeta2,\nuint[2][2] Z\n) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nvks[msg.sender].A = Pairing.G2Point([A[0][0],A[0][1]],[A[1][0],A[1][1]]);\nvks[msg.sender].B = Pairing.G1Point(B[0],B[1]);\nvks[msg.sender].C = Pairing.G2Point([C[0][0],C[0][1]],[C[1][0],C[1][1]]);\nvks[msg.sender].gamma = Pairing.G2Point([gamma[0][0],gamma[0][1]],[gamma[1][0],gamma[1][1]]);\nvks[msg.sender].gammaBeta1 = Pairing.G1Point(gammaBeta1[0],gammaBeta1[1]);\nvks[msg.sender].gammaBeta2 = Pairing.G2Point([gammaBeta2[0][0],gammaBeta2[0][1]],[gammaBeta2[1][0],gammaBeta2[1][1]]);\nvks[msg.sender].Z = Pairing.G2Point([Z[0][0],Z[0][1]],[Z[1][0],Z[1][1]]);\n//this seems a good place to initialise the vk_x computation\nvk_xs[msg.sender] = Pairing.G1Point(0, 0); //initialise\n\n\n\n\n}\n\n\n\n\nfunction loadVerifyingKey(uint[2][] points, uint start) public{\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_xs[addr].X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nparam = 0x0; bytes8 b = bytes8(1);\nfor (uint i=0; i<64; i++){\nif (vectors[addr][i+start] == 1) param = param | (b<<(63-i));\n}\nreturn param;\n}\n\n\n\n\nfunction computeVkx(uint start, uint end) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//end needs to be < vector.length\nfor (uint i = start; i < end; i++)\nvk_xs[msg.sender] = Pairing.addition(vk_xs[msg.sender], Pairing.scalar_mul(vks[msg.sender].IC[i + 1], vectors[msg.sender][i]));\n}\n\n\n\n\nfunction getAddress() public returns(address){\nreturn address(this);\n}\n\n\n\n\nfunction verify(Proof proof, address addr) internal returns (uint) {\nrequire(vectors[addr].length + 1 == vks[addr].IC.length);\n// Compute the linear combination vk_x\nvk_xs[addr] = Pairing.addition(vk_xs[addr], vks[addr].IC[0]);\nif (!Pairing.pairingProd2(proof.A, vks[addr].A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\nif (!Pairing.pairingProd2(vks[addr].B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\nif (!Pairing.pairingProd2(proof.C, vks[addr].C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\nif (!Pairing.pairingProd3(\nproof.K, vks[addr].gamma,\nPairing.negate(Pairing.addition(vk_xs[addr], Pairing.addition(proof.A, proof.C))), vks[addr].gammaBeta2,\nPairing.negate(vks[addr].gammaBeta1), proof.B\n)) return 4;\nif (!Pairing.pairingProd3(\nPairing.addition(vk_xs[addr], proof.A), proof.B,\nPairing.negate(proof.H), vks[addr].Z,\nPairing.negate(proof.C), Pairing.P2()\n)) return 5;\nreturn 0;\n}\n// @dev Fired by function verifyTx\n// @param _decodeFlag = dec0de\n// @param _verified A message to output through this event\nevent Verified(bytes4 indexed _decodeFlag, bytes32 indexed _verified);\n\n\n\n\nfunction verifyTx(\nuint[2] a,\nuint[2] a_p,\nuint[2][2] b,\nuint[2] b_p,\nuint[2] c,\nuint[2] c_p,\nuint[2] h,\nuint[2] k,\naddress addr\n) public returns (bool r) {\nProof memory proof;\nproof.A = Pairing.G1Point(a[0], a[1]);\nproof.A_p = Pairing.G1Point(a_p[0], a_p[1]);\nproof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\nproof.B_p = Pairing.G1Point(b_p[0], b_p[1]);\nproof.C = Pairing.G1Point(c[0], c[1]);\nproof.C_p = Pairing.G1Point(c_p[0], c_p[1]);\nproof.H = Pairing.G1Point(h[0], h[1]);\nproof.K = Pairing.G1Point(k[0], k[1]);\nbytes4 decodeFlag = 0xdec0de; // flag to tell humans that _verified is a hex encoding of an ascii string\nbytes32 verified; // a hex encoding of a string - returned by event Verified\nif (verify(proof, addr) == 0) {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d20547820566572696669656421203a29; //\"EY Opschain - Tx Verified! :)\" in hex\nemit Verified(decodeFlag, verified);\nreturn true;\n} else {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d205478204e4f54205665726966696564203a28; //\"EY Opschain - Tx NOT Verified :(\" in hex\nemit Verified(decodeFlag, verified);\nreturn false;\n}\n}\n}",
        "debug": "calldata_Verifier_4: 0x6560173309cc362accee7ec9f8498c9f1364659e2a2a93b8f71b9799b9b65ce5\nkeccac_24_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x658ecd4e034e7d45d9d18190010be598c692d2201b55b77dce87cffb7bef3806\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x6560173309cc362accee7ec9f8498c9f1364659e2a2a93b8f71b9799b9b65ce6\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setKeyLength(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10812,
        "code": "g.G1Point gammaBeta1;\nPairing.G2Point gammaBeta2;\nPairing.G2Point Z;\nPairing.G1Point[] IC;\n}\nstruct Proof {\nPairing.G1Point A;\nPairing.G1Point A_p;\nPairing.G2Point B;\nPairing.G1Point B_p;\nPairing.G1Point C;\nPairing.G1Point C_p;\nPairing.G1Point K;\nPairing.G1Point H;\n}\n//uint[] vector; //not used - replaced by a mapping\n//Pairing.G1Point vk_x = Pairing.G1Point(0, 0); //not used - replaced by a mapping\n//VerifyingKey private vk; //not used - replaced by a mapping\nmapping(address => VerifyingKey) private vks;\nmapping(address => uint[]) private vectors;\nmapping(address => Pairing.G1Point) private vk_xs;\n\n\n\n\nfunction setKeyLength(uint l) public {\nvks[msg.sender].IC.length = l;\nvectors[msg.sender].length = l-1;\n}\n\n\n\n\nfunction loadVerifyingKeyPreamble(\nuint[2][2] A,\nuint[2] B,\nuint[2][2] C,\nuint[2][2] gamma,\nuint[2] gammaBeta1,\nuint[2][2] gammaBeta2,\nuint[2][2] Z\n) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nvks[msg.sender].A = Pairing.G2Point([A[0][0],A[0][1]],[A[1][0],A[1][1]]);\nvks[msg.sender].B = Pairing.G1Point(B[0],B[1]);\nvks[msg.sender].C = Pairing.G2Point([C[0][0],C[0][1]],[C[1][0],C[1][1]]);\nvks[msg.sender].gamma = Pairing.G2Point([gamma[0][0],gamma[0][1]],[gamma[1][0],gamma[1][1]]);\nvks[msg.sender].gammaBeta1 = Pairing.G1Point(gammaBeta1[0],gammaBeta1[1]);\nvks[msg.sender].gammaBeta2 = Pairing.G2Point([gammaBeta2[0][0],gammaBeta2[0][1]],[gammaBeta2[1][0],gammaBeta2[1][1]]);\nvks[msg.sender].Z = Pairing.G2Point([Z[0][0],Z[0][1]],[Z[1][0],Z[1][1]]);\n//this seems a good place to initialise the vk_x computation\nvk_xs[msg.sender] = Pairing.G1Point(0, 0); //initialise\n\n\n\n\n}\n\n\n\n\nfunction loadVerifyingKey(uint[2][] points, uint start) public{\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_xs[addr].X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nparam = 0x0; bytes8 b = bytes8(1);\nfor (uint i=0; i<64; i++){\nif (vectors[addr][i+start] == 1) param = param | (b<<(63-i));\n}\nreturn param;\n}\n\n\n\n\nfunction computeVkx(uint start, uint end) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//end needs to be < vector.length\nfor (uint i = start; i < end; i++)\nvk_xs[msg.sender] = Pairing.addition(vk_xs[msg.sender], Pairing.scalar_mul(vks[msg.sender].IC[i + 1], vectors[msg.sender][i]));\n}\n\n\n\n\nfunction getAddress() public returns(address){\nreturn address(this);\n}\n\n\n\n\nfunction verify(Proof proof, address addr) internal returns (uint) {\nrequire(vectors[addr].length + 1 == vks[addr].IC.length);\n// Compute the linear combination vk_x\nvk_xs[addr] = Pairing.addition(vk_xs[addr], vks[addr].IC[0]);\nif (!Pairing.pairingProd2(proof.A, vks[addr].A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\nif (!Pairing.pairingProd2(vks[addr].B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\nif (!Pairing.pairingProd2(proof.C, vks[addr].C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\nif (!Pairing.pairingProd3(\nproof.K, vks[addr].gamma,\nPairing.negate(Pairing.addition(vk_xs[addr], Pairing.addition(proof.A, proof.C))), vks[addr].gammaBeta2,\nPairing.negate(vks[addr].gammaBeta1), proof.B\n)) return 4;\nif (!Pairing.pairingProd3(\nPairing.addition(vk_xs[addr], proof.A), proof.B,\nPairing.negate(proof.H), vks[addr].Z,\nPairing.negate(proof.C), Pairing.P2()\n)) return 5;\nreturn 0;\n}\n// @dev Fired by function verifyTx\n// @param _decodeFlag = dec0de\n// @param _verified A message to output through this event\nevent Verified(bytes4 indexed _decodeFlag, bytes32 indexed _verified);\n\n\n\n\nfunction verifyTx(\nuint[2] a,\nuint[2] a_p,\nuint[2][2] b,\nuint[2] b_p,\nuint[2] c,\nuint[2] c_p,\nuint[2] h,\nuint[2] k,\naddress addr\n) public returns (bool r) {\nProof memory proof;\nproof.A = Pairing.G1Point(a[0], a[1]);\nproof.A_p = Pairing.G1Point(a_p[0], a_p[1]);\nproof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\nproof.B_p = Pairing.G1Point(b_p[0], b_p[1]);\nproof.C = Pairing.G1Point(c[0], c[1]);\nproof.C_p = Pairing.G1Point(c_p[0], c_p[1]);\nproof.H = Pairing.G1Point(h[0], h[1]);\nproof.K = Pairing.G1Point(k[0], k[1]);\nbytes4 decodeFlag = 0xdec0de; // flag to tell humans that _verified is a hex encoding of an ascii string\nbytes32 verified; // a hex encoding of a string - returned by event Verified\nif (verify(proof, addr) == 0) {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d20547820566572696669656421203a29; //\"EY Opschain - Tx Verified! :)\" in hex\nemit Verified(decodeFlag, verified);\nreturn true;\n} else {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d205478204e4f54205665726966696564203a28; //\"EY Opschain - Tx NOT Verified :(\" in hex\nemit Verified(decodeFlag, verified);\nreturn false;\n}\n}\n}",
        "debug": "keccac_24_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x5058580000000000000000000000000000000000000000000000000000000000\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xad08d30000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xcfe82dab855610030ead4c92c14ce04718a7ffffffff20000000000000000255\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xc3860e33d465cbfe56165c80efa95fb8e78a400000005fffffffffffffffc63a\ncalldata_Verifier_4: 0x2d08d2ffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setKeyLength(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10814,
        "code": "g.G1Point gammaBeta1;\nPairing.G2Point gammaBeta2;\nPairing.G2Point Z;\nPairing.G1Point[] IC;\n}\nstruct Proof {\nPairing.G1Point A;\nPairing.G1Point A_p;\nPairing.G2Point B;\nPairing.G1Point B_p;\nPairing.G1Point C;\nPairing.G1Point C_p;\nPairing.G1Point K;\nPairing.G1Point H;\n}\n//uint[] vector; //not used - replaced by a mapping\n//Pairing.G1Point vk_x = Pairing.G1Point(0, 0); //not used - replaced by a mapping\n//VerifyingKey private vk; //not used - replaced by a mapping\nmapping(address => VerifyingKey) private vks;\nmapping(address => uint[]) private vectors;\nmapping(address => Pairing.G1Point) private vk_xs;\n\n\n\n\nfunction setKeyLength(uint l) public {\nvks[msg.sender].IC.length = l;\nvectors[msg.sender].length = l-1;\n}\n\n\n\n\nfunction loadVerifyingKeyPreamble(\nuint[2][2] A,\nuint[2] B,\nuint[2][2] C,\nuint[2][2] gamma,\nuint[2] gammaBeta1,\nuint[2][2] gammaBeta2,\nuint[2][2] Z\n) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nvks[msg.sender].A = Pairing.G2Point([A[0][0],A[0][1]],[A[1][0],A[1][1]]);\nvks[msg.sender].B = Pairing.G1Point(B[0],B[1]);\nvks[msg.sender].C = Pairing.G2Point([C[0][0],C[0][1]],[C[1][0],C[1][1]]);\nvks[msg.sender].gamma = Pairing.G2Point([gamma[0][0],gamma[0][1]],[gamma[1][0],gamma[1][1]]);\nvks[msg.sender].gammaBeta1 = Pairing.G1Point(gammaBeta1[0],gammaBeta1[1]);\nvks[msg.sender].gammaBeta2 = Pairing.G2Point([gammaBeta2[0][0],gammaBeta2[0][1]],[gammaBeta2[1][0],gammaBeta2[1][1]]);\nvks[msg.sender].Z = Pairing.G2Point([Z[0][0],Z[0][1]],[Z[1][0],Z[1][1]]);\n//this seems a good place to initialise the vk_x computation\nvk_xs[msg.sender] = Pairing.G1Point(0, 0); //initialise\n\n\n\n\n}\n\n\n\n\nfunction loadVerifyingKey(uint[2][] points, uint start) public{\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_xs[addr].X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<points.length; i++){\nvks[msg.sender].IC[i+start] = Pairing.G1Point(points[i][0],points[i][1]);\n}\n}\n\n\n\n\nfunction loadInputVector(uint[] inp, uint start) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//vk_x.X =0; vk_x.Y=0; //reset the vk_x computation for next time\nfor (uint i=0; i<inp.length; i++){\nvectors[msg.sender][i+start] = inp[i];\n}\n}\n/**\nfunction to get 64 bits from vector and turn it into a bytes8\n*/\nfunction getInputBits(uint start, address addr) public view returns(bytes8 param) {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\nparam = 0x0; bytes8 b = bytes8(1);\nfor (uint i=0; i<64; i++){\nif (vectors[addr][i+start] == 1) param = param | (b<<(63-i));\n}\nreturn param;\n}\n\n\n\n\nfunction computeVkx(uint start, uint end) public {\n/**\n@notice \u00a9 Copyright 2018 EYGS LLP and/or other members of the global Ernst & Young/EY network; pat. pending.\n*/\n//end needs to be < vector.length\nfor (uint i = start; i < end; i++)\nvk_xs[msg.sender] = Pairing.addition(vk_xs[msg.sender], Pairing.scalar_mul(vks[msg.sender].IC[i + 1], vectors[msg.sender][i]));\n}\n\n\n\n\nfunction getAddress() public returns(address){\nreturn address(this);\n}\n\n\n\n\nfunction verify(Proof proof, address addr) internal returns (uint) {\nrequire(vectors[addr].length + 1 == vks[addr].IC.length);\n// Compute the linear combination vk_x\nvk_xs[addr] = Pairing.addition(vk_xs[addr], vks[addr].IC[0]);\nif (!Pairing.pairingProd2(proof.A, vks[addr].A, Pairing.negate(proof.A_p), Pairing.P2())) return 1;\nif (!Pairing.pairingProd2(vks[addr].B, proof.B, Pairing.negate(proof.B_p), Pairing.P2())) return 2;\nif (!Pairing.pairingProd2(proof.C, vks[addr].C, Pairing.negate(proof.C_p), Pairing.P2())) return 3;\nif (!Pairing.pairingProd3(\nproof.K, vks[addr].gamma,\nPairing.negate(Pairing.addition(vk_xs[addr], Pairing.addition(proof.A, proof.C))), vks[addr].gammaBeta2,\nPairing.negate(vks[addr].gammaBeta1), proof.B\n)) return 4;\nif (!Pairing.pairingProd3(\nPairing.addition(vk_xs[addr], proof.A), proof.B,\nPairing.negate(proof.H), vks[addr].Z,\nPairing.negate(proof.C), Pairing.P2()\n)) return 5;\nreturn 0;\n}\n// @dev Fired by function verifyTx\n// @param _decodeFlag = dec0de\n// @param _verified A message to output through this event\nevent Verified(bytes4 indexed _decodeFlag, bytes32 indexed _verified);\n\n\n\n\nfunction verifyTx(\nuint[2] a,\nuint[2] a_p,\nuint[2][2] b,\nuint[2] b_p,\nuint[2] c,\nuint[2] c_p,\nuint[2] h,\nuint[2] k,\naddress addr\n) public returns (bool r) {\nProof memory proof;\nproof.A = Pairing.G1Point(a[0], a[1]);\nproof.A_p = Pairing.G1Point(a_p[0], a_p[1]);\nproof.B = Pairing.G2Point([b[0][0], b[0][1]], [b[1][0], b[1][1]]);\nproof.B_p = Pairing.G1Point(b_p[0], b_p[1]);\nproof.C = Pairing.G1Point(c[0], c[1]);\nproof.C_p = Pairing.G1Point(c_p[0], c_p[1]);\nproof.H = Pairing.G1Point(h[0], h[1]);\nproof.K = Pairing.G1Point(k[0], k[1]);\nbytes4 decodeFlag = 0xdec0de; // flag to tell humans that _verified is a hex encoding of an ascii string\nbytes32 verified; // a hex encoding of a string - returned by event Verified\nif (verify(proof, addr) == 0) {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d20547820566572696669656421203a29; //\"EY Opschain - Tx Verified! :)\" in hex\nemit Verified(decodeFlag, verified);\nreturn true;\n} else {\nvk_xs[addr].X =0; vk_xs[addr].Y=0; //reset the vk_x computation for next time\nverified = 0x4559204f7073636861696e202d205478204e4f54205665726966696564203a28; //\"EY Opschain - Tx NOT Verified :(\" in hex\nemit Verified(decodeFlag, verified);\nreturn false;\n}\n}\n}",
        "debug": "keccac_24_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x2ec8fff9e5309ffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_24 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x4bc47ffb0d67b000000000000000000000000000000000000000000000000001\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xf62459b3302de800000000000000000000000000000000000000000000000000\ncalldata_Verifier_4: 0x4bc47ffb0d67b000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x4bc47ffb0d67b000000000000000000000000000000000000000000000000000\ncalldata_Verifier_0: 0x841fea8900000000000000000000000000000000000000000000000000000000\ncalldatasize_Verifier: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setKeyLength(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/7/0x6b98f17897a5086ff3e7357290b36022798d8850.sol",
        "function": "setKeyLength(uint256)",
        "lineno": 156,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}