{"error": null, "issues": [{"address": 378, "code": "pNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  c", "debug": "calldata_TweedentityStore_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TweedentityStore_0: 0x194c78d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setApp(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "setApp(string,uint256)", "lineno": 218, "title": "Integer Overflow ", "type": "Warning"}, {"address": 384, "code": "pNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  c", "debug": "calldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_TweedentityStore_0: 0x194c78d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setApp(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "setApp(string,uint256)", "lineno": 218, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1017, "code": " return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  exter", "debug": "calldata_TweedentityStore_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TweedentityStore_0: 0x686e177b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `isUpgradable(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "isUpgradable(address,string)", "lineno": 242, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1029, "code": " return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  exter", "debug": "calldata_TweedentityStore_4 + calldata_TweedentityStore_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_TweedentityStore_0: 0x686e177b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `isUpgradable(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "isUpgradable(address,string)", "lineno": 242, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1038, "code": " return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  exter", "debug": "calldata_TweedentityStore_4 + calldata_TweedentityStore_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_TweedentityStore_0: 0x686e177b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `isUpgradable(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "isUpgradable(address,string)", "lineno": 242, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1044, "code": " return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  exter", "debug": "calldata_TweedentityStore_4 + calldata_TweedentityStore_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_TweedentityStore_0: 0x686e177b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `isUpgradable(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "isUpgradable(address,string)", "lineno": 242, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1544, "code": "nal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new b", "debug": "calldata_TweedentityStore_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TweedentityStore_0: 0x8ec5ff4100000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `isUid(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "isUid(string)", "lineno": 431, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3521, "code": "tion getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0x20\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0xff00\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TweedentityStore_0: 0x28faf21700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `unsetIdentity(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "unsetIdentity(address)", "lineno": 310, "title": "Integer Overflow ", "type": "Warning"}, {"address": 7725, "code": "\n\n/**\n * @title TweedentityStore", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TweedentityStore_0: 0x9f727c2700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\nretval_7713: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "reclaimEther()", "lineno": 84, "title": "Exception state", "type": "Informational"}, {"address": 9427, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "calldata_TweedentityStore_4 + calldata_TweedentityStore_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_TweedentityStore_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TweedentityStore_0: 0x194c78d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setApp(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "setApp(string,uint256)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9441, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "calldata_TweedentityStore_4 + calldata_TweedentityStore_4: 0xd7cc79a21c995001c300e47f8dfffffffffffffffffffffffffffffffffffff6\ncalldata_TweedentityStore_4: 0x516925eaa4980c802a0cf05d3bffffffffffffffffffffffffffffffffffffe9\ncalldata_TweedentityStore_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TweedentityStore_0: 0x194c78d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setApp(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "setApp(string,uint256)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9458, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "calldata_TweedentityStore_4 + calldata_TweedentityStore_4: 0x35\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c\ncalldata_TweedentityStore_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TweedentityStore_0: 0x194c78d000000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setApp(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "setApp(string,uint256)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9526, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "keccac_0_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0x2\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0xff00\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TweedentityStore_0: 0x28faf21700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `unsetIdentity(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "unsetIdentity(address)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9555, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0x20\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0xff00\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TweedentityStore_0: 0x28faf21700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `unsetIdentity(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "unsetIdentity(address)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9569, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0xd6de57ff3fdedfc3fffffffffffffffc6fd5fbfffffffffffffffffffffffffe\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0x7ffffffffffffffbffdffffffffff01f8a2bfffffffffffffffffffffffffffd\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0x20\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0xff00\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TweedentityStore_0: 0x28faf21700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `unsetIdentity(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "unsetIdentity(address)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9586, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0x23\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa2\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0x20\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0xff00\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TweedentityStore_0: 0x28faf21700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `unsetIdentity(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "unsetIdentity(address)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9591, "code": "ppId;\n  string public appNickname;\n\n  uint public identities;\n\n  address public manager;\n  address public newManager;\n\n  struct Uid {\n    string lastUid;\n    uint lastUpdate;\n  }\n\n  struct Address {\n    address lastAddress;\n    uint lastUpdate;\n  }\n\n  mapping(string => Address) internal __addressByUid;\n  mapping(address => Uid) internal __uidByAddress;\n\n  bool public appSet;\n\n\n\n  // events\n\n\n  event IdentitySet(\n    address indexed addr,\n    string uid\n  );\n\n\n  event IdentityUnset(\n    address indexed addr,\n    string uid\n  );\n\n\n\n  // modifiers\n\n\n  modifier onlyManager() {\n    require(msg.sender == manager || (newManager != address(0) && msg.sender == newManager));\n    _;\n  }\n\n\n  modifier whenAppSet() {\n    require(appSet);\n    _;\n  }\n\n\n\n  // config\n\n\n  /**\n  * @dev Sets the manager\n  * @param _address Manager's address\n  */\n  function setManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0));\n    manager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  * @param _address New manager's address\n  */\n  function setNewManager(\n    address _address\n  )\n  external\n  onlyOwner\n  {\n    require(_address != address(0) && manager != address(0));\n    newManager = _address;\n  }\n\n\n  /**\n  * @dev Sets new manager\n  */\n  function switchManagerAndRemoveOldOne()\n  external\n  onlyOwner\n  {\n    manager = newManager;\n    newManager = address(0);\n  }\n\n\n  /**\n  * @dev Sets the app\n  * @param _appNickname Nickname (e.g. twitter)\n  * @param _appId ID (e.g. 1)\n  */\n  function setApp(\n    string _appNickname,\n    uint _appId\n  )\n  external\n  onlyOwner\n  {\n    require(!appSet);\n    require(_appId > 0);\n    require(bytes(_appNickname).length > 0);\n    appId = _appId;\n    appNickname = _appNickname;\n    appSet = true;\n  }\n\n\n\n  // helpers\n\n\n  /**\n   * @dev Checks if a tweedentity is upgradable\n   * @param _address The address\n   * @param _uid The user-id\n   */\n  function isUpgradable(\n    address _address,\n    string _uid\n  )\n  public\n  constant returns (bool)\n  {\n    if (__addressByUid[_uid].lastAddress != address(0)) {\n      return keccak256(getUid(_address)) == keccak256(_uid);\n    }\n    return true;\n  }\n\n\n\n  // primary methods\n\n\n  /**\n   * @dev Sets a tweedentity\n   * @param _address The address of the wallet\n   * @param _uid The user-id of the owner user account\n   */\n  function setIdentity(\n    address _address,\n    string _uid\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(isUid(_uid));\n    require(isUpgradable(_address, _uid));\n\n    if (bytes(__uidByAddress[_address].lastUid).length > 0) {\n      // if _address is associated with an oldUid,\n      // this removes the association between _address and oldUid\n      __addressByUid[__uidByAddress[_address].lastUid] = Address(address(0), __addressByUid[__uidByAddress[_address].lastUid].lastUpdate);\n      identities--;\n    }\n\n    __uidByAddress[_address] = Uid(_uid, now);\n    __addressByUid[_uid] = Address(_address, now);\n    identities++;\n    IdentitySet(_address, _uid);\n  }\n\n\n  /**\n   * @dev Unset a tweedentity\n   * @param _address The address of the wallet\n   */\n  function unsetIdentity(\n    address _address\n  )\n  external\n  onlyManager\n  whenAppSet\n  {\n    require(_address != address(0));\n    require(bytes(__uidByAddress[_address].lastUid).length > 0);\n\n    string memory uid = __uidByAddress[_address].lastUid;\n    __uidByAddress[_address] = Uid('', __uidByAddress[_address].lastUpdate);\n    __addressByUid[uid] = Address(address(0), __addressByUid[uid].lastUpdate);\n    identities--;\n    IdentityUnset(_address, uid);\n  }\n\n\n\n  // getters\n\n\n  /**\n   * @dev Returns the keccak256 of the app nickname\n   */\n  function getAppNickname()\n  external\n  whenAppSet\n  constant returns (bytes32) {\n    return keccak256(appNickname);\n  }\n\n\n  /**\n   * @dev Returns the appId\n   */\n  function getAppId()\n  external\n  whenAppSet\n  constant returns (uint) {\n    return appId;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet\n   * @param _address The address of the wallet\n   */\n  function getUid(\n    address _address\n  )\n  public\n  constant returns (string)\n  {\n    return __uidByAddress[_address].lastUid;\n  }\n\n\n  /**\n   * @dev Returns the user-id associated to a wallet as a unsigned integer\n   * @param _address The address of the wallet\n   */\n  function getUidAsInteger(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __stringToUint(__uidByAddress[_address].lastUid);\n  }\n\n\n  /**\n   * @dev Returns the address associated to a user-id\n   * @param _uid The user-id\n   */\n  function getAddress(\n    string _uid\n  )\n  external\n  constant returns (address)\n  {\n    return __addressByUid[_uid].lastAddress;\n  }\n\n\n  /**\n   * @dev Returns the timestamp of last update by address\n   * @param _address The address of the wallet\n   */\n  function getAddressLastUpdate(\n    address _address\n  )\n  external\n  constant returns (uint)\n  {\n    return __uidByAddress[_address].lastUpdate;\n  }\n\n\n  /**\n * @dev Returns the timestamp of last update by user-id\n * @param _uid The user-id\n */\n  function getUidLastUpdate(\n    string _uid\n  )\n  external\n  constant returns (uint)\n  {\n    return __addressByUid[_uid].lastUpdate;\n  }\n\n\n\n  // utils\n\n\n  function isUid(\n    string _uid\n  )\n  public\n  pure\n  returns (bool)\n  {\n    bytes memory uid = bytes(_uid);\n    if (uid.length == 0) {\n      return false;\n    } else {\n      for (uint i = 0; i < uid.length; i++) {\n        if (uid[i] < 48 || uid[i] > 57) {\n          return false;\n        }\n      }\n    }\n    return true;\n  }\n\n\n\n  // private methods\n\n\n  function __stringToUint(\n    string s\n  )\n  internal\n  pure\n  returns (uint result)\n  {\n    bytes memory b = bytes(s);\n    uint i;\n    result = 0;\n    for (i = 0; i < b.length; i++) {\n      uint c = uint(b[i]);\n      if (c >= 48 && c <= 57) {\n        result = result * 10 + (c - 48);\n      }\n    }\n  }\n\n\n  function __uintToBytes(uint x)\n  internal\n  pure\n  returns (bytes b)\n  {\n    b = new bytes(32);\n    for (uint i = 0; i < 32; i++) {\n      b[i] = byte(uint8(x / (2 ** (8 * (31 - i)))));\n    }\n  }\n\n}", "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0x88d9804706480006400000000030973c000001ffff8044000102400600000054\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4))))) +\n0: 0x6af8ffb3f577dbf8377ebfffffbf57fb7f5f1dfeff9fbbfffefdbff9ffffff8c\nkeccac_0_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TweedentityStore_4: 0x20\ncalldata_TweedentityStore_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_9: 0xff00\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffff00\nstorage_5: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TweedentityStore_0: 0x28faf21700000000000000000000000000000000000000000000000000000000\ncalldatasize_TweedentityStore: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `unsetIdentity(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x95568c9d79f46e8048344e7319754aec4b1965d4.sol", "function": "unsetIdentity(address)", "lineno": 100, "title": "Integer Overflow ", "type": "Warning"}], "success": true}