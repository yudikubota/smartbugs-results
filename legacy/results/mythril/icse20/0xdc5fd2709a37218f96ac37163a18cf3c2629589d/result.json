{
  "contract": "0xdc5fd2709a37218f96ac37163a18cf3c2629589d",
  "tool": "mythril",
  "start": 1563321629.6396525,
  "end": 1563337223.3467624,
  "duration": 15593.707109928131,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 467,
        "code": " memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public o",
        "debug": "calldata_TrustedDocument_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrustedDocument_0: 0x23e798e600000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getDocumentIdWithName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "getDocumentIdWithName(string)",
        "lineno": 222,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 479,
        "code": " memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public o",
        "debug": "calldata_TrustedDocument_4 + calldata_TrustedDocument_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_TrustedDocument_0: 0x23e798e600000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getDocumentIdWithName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "getDocumentIdWithName(string)",
        "lineno": 222,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 488,
        "code": " memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public o",
        "debug": "calldata_TrustedDocument_4 + calldata_TrustedDocument_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_TrustedDocument_0: 0x23e798e600000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getDocumentIdWithName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "getDocumentIdWithName(string)",
        "lineno": 222,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 494,
        "code": " memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public o",
        "debug": "calldata_TrustedDocument_4 + calldata_TrustedDocument_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_TrustedDocument_0: 0x23e798e600000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getDocumentIdWithName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "getDocumentIdWithName(string)",
        "lineno": 222,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1618,
        "code": "rstDocumentIdStartingAtValidFrom(uint _unixTimeFrom) public view\n    returns (uint) \n    {\n",
        "debug": "calldata_TrustedDocument_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrustedDocument_0: 0xc7c3268b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBaseUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "setBaseUrl(string)",
        "lineno": 165,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1723,
        "code": " (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.documentContentSHA256)==documentContentSHA256Keccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithName(string _fileName) public view\n    returns (uint) \n    {\n        bytes32 fileNameKeccak256 = keccak256(_fileName);\n        for ",
        "debug": "calldata_TrustedDocument_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TrustedDocument_0: 0xd59b5d4e00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getDocumentIdWithContentHash(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "getDocumentIdWithContentHash(string)",
        "lineno": 207,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7704,
        "code": "ntract TrustedDocument {\n    // Data structure for keeping document bundles signatures\n    // and metadata\n    struct Document {\n        // Id of the document, starting at 1\n        // 0 reserved for undefined / not found etc\n        uint documentId;\n        // File name\n        bytes32 fileName;\n        // Hash of the file -> (SHA256(TOBASE64(FILECONTENT)))\n        string documentContentSHA256;\n        // Hash of file containing extra metadata\n        // describing file. Secured same way as\n        // content of the file and can be any\n        // size to save gas on transactions\n        string documentMetadataSHA256;\n        // Block time when document was added to\n        // block / was mined\n        uint blockTime;\n        // Block number\n        uint blockNumber;\n        // Document validity date from claimed by\n        // publisher. Documents can be published\n        // before they become valid, or in some\n        // cases later.\n        uint validFrom;\n        // Optional valid date to if relevant\n        uint validTo;\n        // Reference to document update. Document\n        // can be updated/replaced, but such update \n        // history cannot be hidden and it is \n        // persistant and auditable by everyone.\n        // Update can address document itself aswell\n        // as only metadata, where documentContentSHA256\n        // stays same between updates - it can be\n        // compared between versions.\n        // This works as one way linked list\n        uint updatedVersionId;\n    }\n\n    // Owner of the contract\n    address public owner;\n\n    // Needed for keeping new version address.\n    // If 0, then this contract is up to date.\n    // If not 0, no documents can be added to \n    // this version anymore. Contract becomes \n    // retired and documents are read only.\n    address public upgradedVersion;\n\n    // Total count of signed documents\n    uint public documentsCount;\n\n    // Base URL on which files will be stored\n    string public baseUrl;\n\n    // Map of signed documents\n    mapping(uint => Document) private documents;\n\n    // Event for confirmation of adding new document\n    event EventDocumentAdded(uint indexed documentId);\n    // Event for updating document\n    event EventDocumentUpdated(uint indexed referencingDocumentId, uint indexed updatedDocumentId);\n    // Event for going on retirement\n    event Retired(address indexed upgradedVersion);\n\n    // Restricts call to owner\n    modifier onlyOwner() {\n        if (msg.sender == owner) \n        _;\n    }\n\n    // Restricts call only when this version is up to date == upgradedVersion is not set to a new address\n    // or in other words, equal to 0\n    modifier ifNotRetired() {\n        if (upgradedVersion == 0) \n        _;\n    } \n\n    // Constructor\n    function TrustedDocument() public {\n        owner = msg.sender;\n        baseUrl = \"_\";\n    }\n\n    // Enables to transfer ownership. Works even after\n    // retirement. No documents can be added, but some\n    // other tasks still can be performed.\n    function transferOwnership(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n\n    // Adds new document - only owner and if not retired\n    function addDocument(bytes32 _fileName, string _documentContentSHA256, string _documentMetadataSHA256, uint _validFrom, uint _validTo) public onlyOwner ifNotRetired {\n        // Documents incremented before use so documents ids will\n        // start with 1 not 0 (shifter by 1)\n        // 0 is reserved as undefined value\n        uint documentId = documentsCount+1;\n        //\n        EventDocumentAdded(documentId);\n        documents[documentId] = Document(documentId, _fileName, _documentContentSHA256, _documentMetadataSHA256, block.timestamp, block.number, _validFrom, _validTo, 0);\n        documentsCount++;\n    }\n\n    // Gets total count of documents\n    function getDocumentsCount() public view\n    returns (uint)\n    {\n        return documentsCount;\n    }\n\n    // Retire if newer version will be available. To persist\n    // integrity, address of newer version needs to be provided.\n    // After retirement there is no way to add more documents.\n    function retire(address _upgradedVersion) public onlyOwner ifNotRetired {\n        // TODO - check if such contract exists\n        upgradedVersion = _upgradedVersion;\n        Retired(upgradedVersion);\n    }\n\n    // Gets document with ID\n    function getDocument(uint _documentId) public view\n    returns (\n        uint documentId,\n        bytes32 fileName,\n        string documentContentSHA256,\n        string documentMetadataSHA256,\n        uint blockTime,\n        uint blockNumber,\n        uint validFrom,\n        uint validTo,\n        uint updatedVersionId\n    ) {\n        Document memory doc = documents[_documentId];\n        return (doc.documentId, doc.fileName, doc.documentContentSHA256, doc.documentMetadataSHA256, doc.blockTime, doc.blockNumber, doc.validFrom, doc.validTo, doc.updatedVersionId);\n    }\n\n    // Gets document updatedVersionId with ID\n    // 0 - no update for document\n    function getDocumentUpdatedVersionId(uint _documentId) public view\n    returns (uint) \n    {\n        Document memory doc = documents[_documentId];\n        return doc.updatedVersionId;\n    }\n\n    // Gets base URL so GUI will know where to seek for storage.\n    // Multiple URLS can be set in the string and separated by comma\n    function getBaseUrl() public view\n    returns (string) \n    {\n        return baseUrl;\n    }\n\n    // Set base URL even on retirement. Files will have to be maintained\n    // for a very long time, and for example domain name could change.\n    // To manage this, owner should be able to set base url anytime\n    function setBaseUrl(string _baseUrl) public onlyOwner {\n        baseUrl = _baseUrl;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getFirstDocumentIdStartingAtValidFrom(uint _unixTimeFrom) public view\n    returns (uint) \n    {\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (doc.validFrom>=_unixTimeFrom) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getFirstDocumentIdBetweenDatesValidFrom(uint _unixTimeStarting, uint _unixTimeEnding) public view\n    returns (uint firstID, uint lastId) \n    {\n        firstID = 0;\n        lastId = 0;\n        //\n        for (uint i = 0; i < documentsCount; i++) {\n            Document memory doc = documents[i];\n            if (firstID==0) {\n                if (doc.validFrom>=_unixTimeStarting) {\n                    firstID = i;\n                }\n            } else {\n                if (doc.validFrom<=_unixTimeEnding) {\n                    lastId = i;\n                }\n            }\n        }\n        //\n        if ((firstID>0)&&(lastId==0)&&(_unixTimeStarting<_unixTimeEnding)) {\n            lastId = documentsCount;\n        }\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithContentHash(string _documentContentSHA256) public view\n    returns (uint) \n    {\n        bytes32 documentContentSHA256Keccak256 = keccak256(_documentContentSHA256);\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.documentContentSHA256)==documentContentSHA256Keccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithName(string _fileName) public view\n    returns (uint) \n    {\n        bytes32 fileNameKeccak256 = keccak256(_fileName);\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public onlyOwner ifNotRetired {\n        Document storage referenced = documents[referencingDocumentId];\n        Document memory updated = documents[updatedDocumentId];\n        //\n        referenced.updatedVersionId = updated.documentId;\n        EventDocumentUpdated(referenced.updatedVersionId,updated.documentId);\n    }\n}",
        "debug": "calldata_TrustedDocument_4 + calldata_TrustedDocument_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01\ncalldata_TrustedDocument_0: 0x23e798e600000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getDocumentIdWithName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "getDocumentIdWithName(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7843,
        "code": "ntract TrustedDocument {\n    // Data structure for keeping document bundles signatures\n    // and metadata\n    struct Document {\n        // Id of the document, starting at 1\n        // 0 reserved for undefined / not found etc\n        uint documentId;\n        // File name\n        bytes32 fileName;\n        // Hash of the file -> (SHA256(TOBASE64(FILECONTENT)))\n        string documentContentSHA256;\n        // Hash of file containing extra metadata\n        // describing file. Secured same way as\n        // content of the file and can be any\n        // size to save gas on transactions\n        string documentMetadataSHA256;\n        // Block time when document was added to\n        // block / was mined\n        uint blockTime;\n        // Block number\n        uint blockNumber;\n        // Document validity date from claimed by\n        // publisher. Documents can be published\n        // before they become valid, or in some\n        // cases later.\n        uint validFrom;\n        // Optional valid date to if relevant\n        uint validTo;\n        // Reference to document update. Document\n        // can be updated/replaced, but such update \n        // history cannot be hidden and it is \n        // persistant and auditable by everyone.\n        // Update can address document itself aswell\n        // as only metadata, where documentContentSHA256\n        // stays same between updates - it can be\n        // compared between versions.\n        // This works as one way linked list\n        uint updatedVersionId;\n    }\n\n    // Owner of the contract\n    address public owner;\n\n    // Needed for keeping new version address.\n    // If 0, then this contract is up to date.\n    // If not 0, no documents can be added to \n    // this version anymore. Contract becomes \n    // retired and documents are read only.\n    address public upgradedVersion;\n\n    // Total count of signed documents\n    uint public documentsCount;\n\n    // Base URL on which files will be stored\n    string public baseUrl;\n\n    // Map of signed documents\n    mapping(uint => Document) private documents;\n\n    // Event for confirmation of adding new document\n    event EventDocumentAdded(uint indexed documentId);\n    // Event for updating document\n    event EventDocumentUpdated(uint indexed referencingDocumentId, uint indexed updatedDocumentId);\n    // Event for going on retirement\n    event Retired(address indexed upgradedVersion);\n\n    // Restricts call to owner\n    modifier onlyOwner() {\n        if (msg.sender == owner) \n        _;\n    }\n\n    // Restricts call only when this version is up to date == upgradedVersion is not set to a new address\n    // or in other words, equal to 0\n    modifier ifNotRetired() {\n        if (upgradedVersion == 0) \n        _;\n    } \n\n    // Constructor\n    function TrustedDocument() public {\n        owner = msg.sender;\n        baseUrl = \"_\";\n    }\n\n    // Enables to transfer ownership. Works even after\n    // retirement. No documents can be added, but some\n    // other tasks still can be performed.\n    function transferOwnership(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n\n    // Adds new document - only owner and if not retired\n    function addDocument(bytes32 _fileName, string _documentContentSHA256, string _documentMetadataSHA256, uint _validFrom, uint _validTo) public onlyOwner ifNotRetired {\n        // Documents incremented before use so documents ids will\n        // start with 1 not 0 (shifter by 1)\n        // 0 is reserved as undefined value\n        uint documentId = documentsCount+1;\n        //\n        EventDocumentAdded(documentId);\n        documents[documentId] = Document(documentId, _fileName, _documentContentSHA256, _documentMetadataSHA256, block.timestamp, block.number, _validFrom, _validTo, 0);\n        documentsCount++;\n    }\n\n    // Gets total count of documents\n    function getDocumentsCount() public view\n    returns (uint)\n    {\n        return documentsCount;\n    }\n\n    // Retire if newer version will be available. To persist\n    // integrity, address of newer version needs to be provided.\n    // After retirement there is no way to add more documents.\n    function retire(address _upgradedVersion) public onlyOwner ifNotRetired {\n        // TODO - check if such contract exists\n        upgradedVersion = _upgradedVersion;\n        Retired(upgradedVersion);\n    }\n\n    // Gets document with ID\n    function getDocument(uint _documentId) public view\n    returns (\n        uint documentId,\n        bytes32 fileName,\n        string documentContentSHA256,\n        string documentMetadataSHA256,\n        uint blockTime,\n        uint blockNumber,\n        uint validFrom,\n        uint validTo,\n        uint updatedVersionId\n    ) {\n        Document memory doc = documents[_documentId];\n        return (doc.documentId, doc.fileName, doc.documentContentSHA256, doc.documentMetadataSHA256, doc.blockTime, doc.blockNumber, doc.validFrom, doc.validTo, doc.updatedVersionId);\n    }\n\n    // Gets document updatedVersionId with ID\n    // 0 - no update for document\n    function getDocumentUpdatedVersionId(uint _documentId) public view\n    returns (uint) \n    {\n        Document memory doc = documents[_documentId];\n        return doc.updatedVersionId;\n    }\n\n    // Gets base URL so GUI will know where to seek for storage.\n    // Multiple URLS can be set in the string and separated by comma\n    function getBaseUrl() public view\n    returns (string) \n    {\n        return baseUrl;\n    }\n\n    // Set base URL even on retirement. Files will have to be maintained\n    // for a very long time, and for example domain name could change.\n    // To manage this, owner should be able to set base url anytime\n    function setBaseUrl(string _baseUrl) public onlyOwner {\n        baseUrl = _baseUrl;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getFirstDocumentIdStartingAtValidFrom(uint _unixTimeFrom) public view\n    returns (uint) \n    {\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (doc.validFrom>=_unixTimeFrom) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getFirstDocumentIdBetweenDatesValidFrom(uint _unixTimeStarting, uint _unixTimeEnding) public view\n    returns (uint firstID, uint lastId) \n    {\n        firstID = 0;\n        lastId = 0;\n        //\n        for (uint i = 0; i < documentsCount; i++) {\n            Document memory doc = documents[i];\n            if (firstID==0) {\n                if (doc.validFrom>=_unixTimeStarting) {\n                    firstID = i;\n                }\n            } else {\n                if (doc.validFrom<=_unixTimeEnding) {\n                    lastId = i;\n                }\n            }\n        }\n        //\n        if ((firstID>0)&&(lastId==0)&&(_unixTimeStarting<_unixTimeEnding)) {\n            lastId = documentsCount;\n        }\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithContentHash(string _documentContentSHA256) public view\n    returns (uint) \n    {\n        bytes32 documentContentSHA256Keccak256 = keccak256(_documentContentSHA256);\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.documentContentSHA256)==documentContentSHA256Keccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithName(string _fileName) public view\n    returns (uint) \n    {\n        bytes32 fileNameKeccak256 = keccak256(_fileName);\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public onlyOwner ifNotRetired {\n        Document storage referenced = documents[referencingDocumentId];\n        Document memory updated = documents[updatedDocumentId];\n        //\n        referenced.updatedVersionId = updated.documentId;\n        EventDocumentUpdated(referenced.updatedVersionId,updated.documentId);\n    }\n}",
        "debug": "calldata_TrustedDocument_4 + calldata_TrustedDocument_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TrustedDocument_0: 0xc7c3268b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBaseUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "setBaseUrl(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7857,
        "code": "ntract TrustedDocument {\n    // Data structure for keeping document bundles signatures\n    // and metadata\n    struct Document {\n        // Id of the document, starting at 1\n        // 0 reserved for undefined / not found etc\n        uint documentId;\n        // File name\n        bytes32 fileName;\n        // Hash of the file -> (SHA256(TOBASE64(FILECONTENT)))\n        string documentContentSHA256;\n        // Hash of file containing extra metadata\n        // describing file. Secured same way as\n        // content of the file and can be any\n        // size to save gas on transactions\n        string documentMetadataSHA256;\n        // Block time when document was added to\n        // block / was mined\n        uint blockTime;\n        // Block number\n        uint blockNumber;\n        // Document validity date from claimed by\n        // publisher. Documents can be published\n        // before they become valid, or in some\n        // cases later.\n        uint validFrom;\n        // Optional valid date to if relevant\n        uint validTo;\n        // Reference to document update. Document\n        // can be updated/replaced, but such update \n        // history cannot be hidden and it is \n        // persistant and auditable by everyone.\n        // Update can address document itself aswell\n        // as only metadata, where documentContentSHA256\n        // stays same between updates - it can be\n        // compared between versions.\n        // This works as one way linked list\n        uint updatedVersionId;\n    }\n\n    // Owner of the contract\n    address public owner;\n\n    // Needed for keeping new version address.\n    // If 0, then this contract is up to date.\n    // If not 0, no documents can be added to \n    // this version anymore. Contract becomes \n    // retired and documents are read only.\n    address public upgradedVersion;\n\n    // Total count of signed documents\n    uint public documentsCount;\n\n    // Base URL on which files will be stored\n    string public baseUrl;\n\n    // Map of signed documents\n    mapping(uint => Document) private documents;\n\n    // Event for confirmation of adding new document\n    event EventDocumentAdded(uint indexed documentId);\n    // Event for updating document\n    event EventDocumentUpdated(uint indexed referencingDocumentId, uint indexed updatedDocumentId);\n    // Event for going on retirement\n    event Retired(address indexed upgradedVersion);\n\n    // Restricts call to owner\n    modifier onlyOwner() {\n        if (msg.sender == owner) \n        _;\n    }\n\n    // Restricts call only when this version is up to date == upgradedVersion is not set to a new address\n    // or in other words, equal to 0\n    modifier ifNotRetired() {\n        if (upgradedVersion == 0) \n        _;\n    } \n\n    // Constructor\n    function TrustedDocument() public {\n        owner = msg.sender;\n        baseUrl = \"_\";\n    }\n\n    // Enables to transfer ownership. Works even after\n    // retirement. No documents can be added, but some\n    // other tasks still can be performed.\n    function transferOwnership(address _newOwner) public onlyOwner {\n        owner = _newOwner;\n    }\n\n    // Adds new document - only owner and if not retired\n    function addDocument(bytes32 _fileName, string _documentContentSHA256, string _documentMetadataSHA256, uint _validFrom, uint _validTo) public onlyOwner ifNotRetired {\n        // Documents incremented before use so documents ids will\n        // start with 1 not 0 (shifter by 1)\n        // 0 is reserved as undefined value\n        uint documentId = documentsCount+1;\n        //\n        EventDocumentAdded(documentId);\n        documents[documentId] = Document(documentId, _fileName, _documentContentSHA256, _documentMetadataSHA256, block.timestamp, block.number, _validFrom, _validTo, 0);\n        documentsCount++;\n    }\n\n    // Gets total count of documents\n    function getDocumentsCount() public view\n    returns (uint)\n    {\n        return documentsCount;\n    }\n\n    // Retire if newer version will be available. To persist\n    // integrity, address of newer version needs to be provided.\n    // After retirement there is no way to add more documents.\n    function retire(address _upgradedVersion) public onlyOwner ifNotRetired {\n        // TODO - check if such contract exists\n        upgradedVersion = _upgradedVersion;\n        Retired(upgradedVersion);\n    }\n\n    // Gets document with ID\n    function getDocument(uint _documentId) public view\n    returns (\n        uint documentId,\n        bytes32 fileName,\n        string documentContentSHA256,\n        string documentMetadataSHA256,\n        uint blockTime,\n        uint blockNumber,\n        uint validFrom,\n        uint validTo,\n        uint updatedVersionId\n    ) {\n        Document memory doc = documents[_documentId];\n        return (doc.documentId, doc.fileName, doc.documentContentSHA256, doc.documentMetadataSHA256, doc.blockTime, doc.blockNumber, doc.validFrom, doc.validTo, doc.updatedVersionId);\n    }\n\n    // Gets document updatedVersionId with ID\n    // 0 - no update for document\n    function getDocumentUpdatedVersionId(uint _documentId) public view\n    returns (uint) \n    {\n        Document memory doc = documents[_documentId];\n        return doc.updatedVersionId;\n    }\n\n    // Gets base URL so GUI will know where to seek for storage.\n    // Multiple URLS can be set in the string and separated by comma\n    function getBaseUrl() public view\n    returns (string) \n    {\n        return baseUrl;\n    }\n\n    // Set base URL even on retirement. Files will have to be maintained\n    // for a very long time, and for example domain name could change.\n    // To manage this, owner should be able to set base url anytime\n    function setBaseUrl(string _baseUrl) public onlyOwner {\n        baseUrl = _baseUrl;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getFirstDocumentIdStartingAtValidFrom(uint _unixTimeFrom) public view\n    returns (uint) \n    {\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (doc.validFrom>=_unixTimeFrom) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getFirstDocumentIdBetweenDatesValidFrom(uint _unixTimeStarting, uint _unixTimeEnding) public view\n    returns (uint firstID, uint lastId) \n    {\n        firstID = 0;\n        lastId = 0;\n        //\n        for (uint i = 0; i < documentsCount; i++) {\n            Document memory doc = documents[i];\n            if (firstID==0) {\n                if (doc.validFrom>=_unixTimeStarting) {\n                    firstID = i;\n                }\n            } else {\n                if (doc.validFrom<=_unixTimeEnding) {\n                    lastId = i;\n                }\n            }\n        }\n        //\n        if ((firstID>0)&&(lastId==0)&&(_unixTimeStarting<_unixTimeEnding)) {\n            lastId = documentsCount;\n        }\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithContentHash(string _documentContentSHA256) public view\n    returns (uint) \n    {\n        bytes32 documentContentSHA256Keccak256 = keccak256(_documentContentSHA256);\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.documentContentSHA256)==documentContentSHA256Keccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // Utility to help seek fo specyfied document\n    function getDocumentIdWithName(string _fileName) public view\n    returns (uint) \n    {\n        bytes32 fileNameKeccak256 = keccak256(_fileName);\n        for (uint i = 0; i < documentsCount; i++) {\n           Document memory doc = documents[i];\n           if (keccak256(doc.fileName)==fileNameKeccak256) {\n               return i;\n           }\n        }\n        return 0;\n    }\n\n    // To update document:\n    // 1 - Add new version as ordinary document\n    // 2 - Call this function to link old version with update\n    function updateDocument(uint referencingDocumentId, uint updatedDocumentId) public onlyOwner ifNotRetired {\n        Document storage referenced = documents[referencingDocumentId];\n        Document memory updated = documents[updatedDocumentId];\n        //\n        referenced.updatedVersionId = updated.documentId;\n        EventDocumentUpdated(referenced.updatedVersionId,updated.documentId);\n    }\n}",
        "debug": "calldata_TrustedDocument_4 + calldata_TrustedDocument_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TrustedDocument_0: 0xc7c3268b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TrustedDocument: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setBaseUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_contracts/0xdc5fd2709a37218f96ac37163a18cf3c2629589d.sol",
        "function": "setBaseUrl(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}