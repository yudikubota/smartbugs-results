{"error": null, "issues": [{"address": 737, "code": "NS);\n    return true;\n  }\n\n  /**\n   * Lock presale balances after successful presale balance import\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function lockPresaleBalances() public onlyController returns (bool) {\n    presaleBalancesLocked = true;\n    return true;\n  }\n\n  /**\n   * Lock the minting of Servus Tokens - to be called after the presale\n   * @return {bool} success\n  */\n  functio", "debug": "calldata_TokenFactoryInterface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenFactoryInterface_0: 0x128f04e700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenFactoryInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `importPresaleBalances(address[],uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "importPresaleBalances(address[],uint256[])", "lineno": 399, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4112, "code": "cesLocked = ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenFactoryInterface_0: 0x128f04e700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenFactoryInterface: 0x4\nmem_128 +\n32 +\n32*\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "importPresaleBalances(address[],uint256[])", "lineno": 408, "title": "Exception state", "type": "Informational"}, {"address": 5514, "code": "       return getValueAt(balances[_owner], _blockNumber);\n    }\n  }\n\n  ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "balanceOfAt(address,uint256)", "lineno": 245, "title": "Message call to external contract", "type": "Informational"}, {"address": 6889, "code": "{\n        return getValueAt(totalSupplyHistory, _blockNumber);\n  ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "totalSupply()", "lineno": 209, "title": "Message call to external contract", "type": "Informational"}, {"address": 8782, "code": "lock\n  * @param _snap", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0x40\nstorage_0 +\n115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy: 0x3f00\nmem_128 +\n32 +\n32*\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenFactoryInterface_0: 0x128f04e700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenFactoryInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `importPresaleBalances(address[],uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "importPresaleBalances(address[],uint256[])", "lineno": 490, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8803, "code": "en snapshot block\n  * @param _snaps", "debug": "The exception is triggered under the following conditions:\n\nstorage_10: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0x2000000000\nstorage_0 +\n89717814153306320011181716697424560163256864414616650038987186496166826726055 +\nstorage_10: 0x1fffffffff00\nstorage_13: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenFactoryInterface_0: 0x128f04e700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenFactoryInterface: 0x4\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "importPresaleBalances(address[],uint256[])", "lineno": 490, "title": "Exception state", "type": "Informational"}, {"address": 10211, "code": " TokenFactoryInterface public tokenFactory;\n\n  string public name;\n  string public symbol;\n  string public version;\n  uint8 public decimals;\n\n  uint256 public parentSnapShotBlock;\n  uint256 public creationBlock;\n  bool public transfersEnabled;\n\n  bool public masterTransfersEnabled;\n  address public masterWallet = 0x9d23cc4efa366b70f34f1879bc6178e6f3342441;\n\n\n  struct Checkpoint {\n    uint128 fromBlock;\n    uint128 value;\n  }\n\n  Checkpoint[] totalSupplyHistory;\n  mapping(address => Checkpoint[]) balances;\n  mapping (address => mapping (address => uint)) allowed;\n\n  bool public mintingFinished = false;\n  bool public presaleBalancesLocked = false;\n\n  uint256 public constant TOTAL_PRESALE_TOKENS = 2896000000000000000000;\n\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n  event ClaimedTokens(address indexed _token, address indexed _owner, uint _amount);\n  event NewCloneToken(address indexed cloneToken);\n  event Approval(address indexed _owner, address indexed _spender, uint256 _amount);\n  event Transfer(address indexed from, address indexed to, uint256 value);\n\n\n\n\n  function ServusToken(\n    address _tokenFactory,\n    address _parentToken,\n    uint256 _parentSnapShotBlock,\n    string _tokenName,\n    string _tokenSymbol\n    ) public {\n      tokenFactory = TokenFactoryInterface(_tokenFactory);\n      parentToken = ServusTokenInterface(_parentToken);\n      parentSnapShotBlock = _parentSnapShotBlock;\n      name = _tokenName;\n      symbol = _tokenSymbol;\n      decimals = 6;\n      transfersEnabled = false;\n      masterTransfersEnabled = false;\n      creationBlock = block.number;\n      version = '0.1';\n  }\n\n  function() public payable {\n    revert();\n  }\n\n\n  /**\n  * Returns the total Servus token supply at the current block\n  * @return total supply {uint256}\n  */\n  function totalSupply() public constant returns (uint256) {\n    return totalSupplyAt(block.number);\n  }\n\n  /**\n  * Returns the total Servus token supply at the given block number\n  * @param _blockNumber {uint256}\n  * @return total supply {uint256}\n  */\n  function totalSupplyAt(uint256 _blockNumber) public constant returns(uint256) {\n    // These next few lines are used when the totalSupply of the token is\n    //  requested before a check point was ever created for this token, it\n    //  requires that the `parentToken.totalSupplyAt` be queried at the\n    //  genesis block for this token as that contains totalSupply of this\n    //  token at this block number.\n    if ((totalSupplyHistory.length == 0) || (totalSupplyHistory[0].fromBlock > _blockNumber)) {\n        if (address(parentToken) != 0) {\n            return parentToken.totalSupplyAt(min(_blockNumber, parentSnapShotBlock));\n        } else {\n            return 0;\n        }\n\n    // This will return the expected totalSupply during normal situations\n    } else {\n        return getValueAt(totalSupplyHistory, _blockNumber);\n    }\n  }\n\n  /**\n  * Returns the token holder balance at the current block\n  * @param _owner {address}\n  * @return balance {uint256}\n   */\n  function balanceOf(address _owner) public constant returns (uint256 balance) {\n    return balanceOfAt(_owner, block.number);\n  }\n\n  /**\n  * Returns the token holder balance the the given block number\n  * @param _owner {address}\n  * @param _blockNumber {uint256}\n  * @return balance {uint256}\n  */\n  function balanceOfAt(address _owner, uint256 _blockNumber) public constant returns (uint256) {\n    // These next few lines are used when the balance of the token is\n    //  requested before a check point was ever created for this token, it\n    //  requires that the `parentToken.balanceOfAt` be queried at the\n    //  genesis block for that token as this contains initial balance of\n    //  this token\n    if ((balances[_owner].length == 0) || (balances[_owner][0].fromBlock > _blockNumber)) {\n        if (address(parentToken) != 0) {\n            return parentToken.balanceOfAt(_owner, min(_blockNumber, parentSnapShotBlock));\n        } else {\n            // Has no parent\n            return 0;\n        }\n\n    // This will return the expected balance during normal situations\n    } else {\n        return getValueAt(balances[_owner], _blockNumber);\n    }\n  }\n\n  /**\n  * Standard ERC20 transfer tokens function\n  * @param _to {address}\n  * @param _amount {uint}\n  * @return success {bool}\n  */\n  function transfer(address _to, uint256 _amount) public returns (bool success) {\n    return doTransfer(msg.sender, _to, _amount);\n  }\n\n  /**\n  * Standard ERC20 transferFrom function\n  * @param _from {address}\n  * @param _to {address}\n  * @param _amount {uint256}\n  * @return success {bool}\n  */\n  function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) {\n    require(allowed[_from][msg.sender] >= _amount);\n    allowed[_from][msg.sender] -= _amount;\n    return doTransfer(_from, _to, _amount);\n  }\n\n  /**\n  * Standard ERC20 approve function\n  * @param _spender {address}\n  * @param _amount {uint256}\n  * @return success {bool}\n  */\n  function approve(address _spender, uint256 _amount) public returns (bool success) {\n    require(transfersEnabled);\n\n    //https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n    require((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\n    allowed[msg.sender][_spender] = _amount;\n    Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /**\n  * Standard ERC20 approve function\n  * @param _spender {address}\n  * @param _amount {uint256}\n  * @return success {bool}\n  */\n  function approveAndCall(address _spender, uint256 _amount, bytes _extraData) public returns (bool success) {\n    approve(_spender, _amount);\n\n    ApproveAndCallReceiver(_spender).receiveApproval(\n        msg.sender,\n        _amount,\n        this,\n        _extraData\n    );\n\n    return true;\n  }\n\n  /**\n  * Standard ERC20 allowance function\n  * @param _owner {address}\n  * @param _spender {address}\n  * @return remaining {uint256}\n   */\n  function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  /**\n  * Internal Transfer function - Updates the checkpoint ledger\n  * @param _from {address}\n  * @param _to {address}\n  * @param _amount {uint256}\n  * @return success {bool}\n  */\n  function doTransfer(address _from, address _to, uint256 _amount) internal returns(bool) {\n\n    if (msg.sender != masterWallet) {\n      require(transfersEnabled);\n    } else {\n      require(masterTransfersEnabled);\n    }\n\n    require(_amount > 0);\n    require(parentSnapShotBlock < block.number);\n    require((_to != 0) && (_to != address(this)));\n\n    // If the amount being transfered is more than the balance of the\n    // account the transfer returns false\n    uint256 previousBalanceFrom = balanceOfAt(_from, block.number);\n    require(previousBalanceFrom >= _amount);\n\n    // First update the balance array with the new value for the address\n    //  sending the tokens\n    updateValueAtNow(balances[_from], previousBalanceFrom - _amount);\n\n    // Then update the balance array with the new value for the address\n    //  receiving the tokens\n    uint256 previousBalanceTo = balanceOfAt(_to, block.number);\n    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n    updateValueAtNow(balances[_to], previousBalanceTo + _amount);\n\n    // An event to make the transfer easy to find on the blockchain\n    Transfer(_from, _to, _amount);\n    return true;\n  }\n\n\n  /**\n  * Token creation functions - can only be called by the tokensale controller during the tokensale period\n  * @param _owner {address}\n  * @param _amount {uint256}\n  * @return success {bool}\n  */\n  function mint(address _owner, uint256 _amount) public onlyController canMint returns (bool) {\n    uint256 curTotalSupply = totalSupply();\n    uint256 previousBalanceTo = balanceOf(_owner);\n\n    require(curTotalSupply + _amount >= curTotalSupply); // Check for overflow\n    require(previousBalanceTo + _amount >= previousBalanceTo); // Check for overflow\n\n    updateValueAtNow(totalSupplyHistory, curTotalSupply + _amount);\n    updateValueAtNow(balances[_owner], previousBalanceTo + _amount);\n    Transfer(0, _owner, _amount);\n    return true;\n  }\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n\n  /**\n   * Import presale balances before the start of the token sale. After importing\n   * balances, lockPresaleBalances() has to be called to prevent further modification\n   * of presale balances.\n   * @param _addresses {address[]} Array of presale addresses\n   * @param _balances {uint256[]} Array of balances corresponding to presale addresses.\n   * @return success {bool}\n   */\n  function importPresaleBalances(address[] _addresses, uint256[] _balances) public onlyController returns (bool) {\n    require(presaleBalancesLocked == false);\n\n    for (uint256 i = 0; i < _addresses.length; i++) {\n      updateValueAtNow(balances[_addresses[i]], _balances[i]);\n      Transfer(0, _addresses[i], _balances[i]);\n    }\n\n    updateValueAtNow(totalSupplyHistory, TOTAL_PRESALE_TOKENS);\n    return true;\n  }\n\n  /**\n   * Lock presale balances after successful presale balance import\n   * @return A boolean that indicates if the operation was successful.\n   */\n  function lockPresaleBalances() public onlyController returns (bool) {\n    presaleBalancesLocked = true;\n    return true;\n  }\n\n  /**\n   * Lock the minting of Servus Tokens - to be called after the presale\n   * @return {bool} success\n  */\n  function finishMinting() public onlyController returns (bool) {\n    mintingFinished = true;\n    MintFinished();\n    return true;\n  }\n\n  /**\n   * Enable or block transfers - to be called in case of emergency\n   * @param _value {bool}\n  */\n  function enableTransfers(bool _value) public onlyController {\n    transfersEnabled = _value;\n  }\n\n  /**\n   * Enable or block transfers - to be called in case of emergency\n   * @param _value {bool}\n  */\n  function enableMasterTransfers(bool _value) public onlyController {\n    masterTransfersEnabled = _value;\n  }\n\n  /**\n   * Internal balance method - gets a certain checkpoint value a a certain _block\n   * @param _checkpoints {Checkpoint[]} List of checkpoints - supply history or balance history\n   * @return value {uint256} Value of _checkpoints at _block\n  */\n  function getValueAt(Checkpoint[] storage _checkpoints, uint256 _block) constant internal returns (uint256) {\n\n      if (_checkpoints.length == 0)\n        return 0;\n      // Shortcut for the actual value\n      if (_block >= _checkpoints[_checkpoints.length-1].fromBlock)\n        return _checkpoints[_checkpoints.length-1].value;\n      if (_block < _checkpoints[0].fromBlock)\n        return 0;\n\n      // Binary search of the value in the array\n      uint256 min = 0;\n      uint256 max = _checkpoints.length-1;\n      while (max > min) {\n          uint256 mid = (max + min + 1) / 2;\n          if (_checkpoints[mid].fromBlock<=_block) {\n              min = mid;\n          } else {\n              max = mid-1;\n          }\n      }\n      return _checkpoints[min].value;\n  }\n\n\n  /**\n  * Internal update method - updates the checkpoint ledger at the current block\n  * @param _checkpoints {Checkpoint[]}  List of checkpoints - supply history or balance history\n  * @return value {uint256} Value to add to the checkpoints ledger\n   */\n  function updateValueAtNow(Checkpoint[] storage _checkpoints, uint256 _value) internal {\n      if ((_checkpoints.length == 0) || (_checkpoints[_checkpoints.length-1].fromBlock < block.number)) {\n              Checkpoint storage newCheckPoint = _checkpoints[_checkpoints.length++];\n              newCheckPoint.fromBlock = uint128(block.number);\n              newCheckPoint.value = uint128(_value);\n          } else {\n              Checkpoint storage oldCheckPoint = _checkpoints[_checkpoints.length-1];\n              oldCheckPoint.value = uint128(_value);\n          }\n  }\n\n\n  function min(uint256 a, uint256 b) internal constant returns (uint) {\n      return a < b ? a : b;\n  }\n\n  /**\n  * Clones Servus Token at the given snapshot block\n  * @param _snapshotBlock {uint256}\n  * @param _name {string} - The cloned token name\n  * @param _symbol {string} - The cloned token symbol\n  * @return clonedTokenAddress {address}\n   */\n  function createCloneToken(uint256 _snapshotBlock, string _name, string _symbol) public returns(address) {\n\n      if (_snapshotBlock == 0) {\n        _snapshotBlock = block.number;\n      }\n\n      if (_snapshotBlock > block.number) {\n        _snapshotBlock = block.number;\n      }\n\n      ServusToken cloneToken = tokenFactory.createCloneToken(\n          this,\n          _snapshotBlock,\n          _name,\n          _symbol\n        );\n\n\n      cloneToken.transferControl(msg.sender);\n\n      // An event to make the token easy to find on the blockchain\n      NewCloneToken(address(cloneToken));\n      return address(cloneToken);\n    }\n\n}", "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy: 0x7a00000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0x4000000000000000000000000000000\nstorage_0 +\n115792089237316195423570985008687907853269984665640564039457584007913129639935 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy +\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenFactoryInterface_cpy: 0x3ffffffffffffffffffffffffffffff00\nmem_128 +\n32 +\n32*\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenFactoryInterface_4 + calldata_TokenFactoryInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_13: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenFactoryInterface_0: 0x128f04e700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenFactoryInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `importPresaleBalances(address[],uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0x27d4cb2f6be658a6223fce994d55093c4b7250ce.sol", "function": "importPresaleBalances(address[],uint256[])", "lineno": 119, "title": "Integer Overflow ", "type": "Warning"}], "success": true}