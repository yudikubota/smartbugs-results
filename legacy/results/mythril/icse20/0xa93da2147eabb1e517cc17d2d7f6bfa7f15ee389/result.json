{
  "contract": "0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389",
  "tool": "mythril",
  "start": 1563627224.2376502,
  "end": 1563627518.3341384,
  "duration": 294.096488237381,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1135,
        "code": "_username) public view returns(string _url){\n        _url = userNameToPicture[_username];\n        return (_url);\n    }\n\n    function getFineLevelOfAddress(address _user) public vi",
        "debug": "calldata_tokenRecipient_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_tokenRecipient_0: 0x2de3ad0200000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getUserWalletByUsername(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "getUserWalletByUsername(string)",
        "lineno": 229,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1347,
        "code": "rname] = msg.sender;\n        userNameToPicture[_username] = _pictureUrl;\n        userWalletToPicture[msg.sender] = _pictureUrl;\n        fineLevel[msg.sender] = 0;\n\n        users.push(_user) - 1;\n        isUser[msg.sender] = true;\n        hasPicture[msg.sender] = true;\n    }\n\n/*********************************/\n/******** OWNER FUNCTIONS ********/\n/*********************************/\n\n    function resetQuote()public onlyCreator{\n        braggers[braggers.length-1].braggerQuote = initialQuote;\n        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] ",
        "debug": "calldata_tokenRecipient_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_tokenRecipient_0: 0x4dfa3f1800000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createNewUser(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "createNewUser(string,string)",
        "lineno": 332,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1545,
        "code": "l * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getTotalBrags() public view returns(uint256){\n        return totalbrags;\n    }\n\n    function getWinnerPot() public view returns(uint256){\n        return winningpot;\n    }\n\n/*********************************/\n/****** BRAGING FUNCT",
        "debug": "calldata_tokenRecipient_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_tokenRecipient_0: 0x66ec60c700000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `getFineLevelOfUsername(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "getFineLevelOfUsername(string)",
        "lineno": 243,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4220,
        "code": "          _usern",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_tokenRecipient_4: 0x0\nstorage_19: 0x0\ncalldata_tokenRecipient_0: 0x10ed9900000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "fallback",
        "lineno": 200,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4883,
        "code": "ayoutRequested = false;\n   ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_19: 0x0\nstorage_18: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nblock_number: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_tokenRecipient_0: 0x5a95f0400000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "triggerPayout()",
        "lineno": 124,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4991,
        "code": "outReadyState() public returns(b",
        "debug": "",
        "description": "In the function `triggerPayout()` the following predictable state variables are used to determine Ether recipient:\n- block.number\n",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "triggerPayout()",
        "lineno": 127,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 7124,
        "code": "ick\";\n        fineLevel[use",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_19: 0x0\nstorage_9: 0x0\ncaller: 0x0\ncalldata_tokenRecipient_0: 0x69ddaad100000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "resetQuote()",
        "lineno": 353,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 7508,
        "code": "   if(isAlreadyUser(_bragge",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_19: 0x0\ncalldata_tokenRecipient_0: 0x7a55d4bd00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "getCurrentBragKing()",
        "lineno": 173,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 12713,
        "code": "= previousBalances);\n    }\n\n    f",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_4: 0xa34d3d4342afa13970d088c8c001c13e683decbf7fb6eaea41a0e448e639f048\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_32_+_4: 0x8ecd2502510e6b90fed8122af8b9d53a82ffcb383034f2dd693876b2f7ad7b4b\ncalldata_tokenRecipient_32 + 36: 0x211e8500045868936021715fb01dd95aa886815191414081c047c180e88073d5\ncalldata_tokenRecipient_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x211e8500045868936021715fb01dd95aa886815191414081c047c180e88073d5\ncalldata_tokenRecipient_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 384,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13096,
        "code": "g.sender] -= _value;\n        _tra",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_4: 0xffffffff04006281ac06f1a3f609d5bbbbbeb5beeaeaecbaacbabaae807fffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_tokenRecipient_32_+_4: 0x20000000d065989040180a13810e7ef3043c0a37bfc4d2f3fc00f13cffffffff\ncalldata_tokenRecipient_32 + 36: 0x7fffffffffdc38001100003ffffffffffffffffffffff0000000000080200000\ncalldata_tokenRecipient_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x7fffffffffdc38001100003ffffffffffffffffffffff0000000000080200000\ncalldata_tokenRecipient_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 393,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13117,
        "debug": "block_number: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc000\nstorage_17: 0x0\ncalldata_tokenRecipient_0: 0x65058f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `requestPayout()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "requestPayout()",
        "lineno": 452,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13130,
        "debug": "The exception is triggered under the following conditions:\n\nblock_number: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee00\nstorage_17: 0x0\ncalldata_tokenRecipient_0: 0x65058f4c00000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "requestPayout()",
        "lineno": 452,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 13339,
        "code": "ct braggerContract {\n\n/*********************************/\n/*********** MAPPINGS ************/\n/*********************************/\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping (address => bool) private isUser;\n    mapping (address => bool) private hasPicture;\n    mapping (address => string) private userWalletToUserName;\n    mapping (string => address) private userNameToUserWallet;\n    mapping (string => string) private userNameToPicture;\n    mapping (address => string) private userWalletToPicture;\n    mapping (address => uint256) private fineLevel;\n\n/*********************************/\n/************* EVENTS ************/\n/*********************************/\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n/*********************************/\n/******** FREE VARIABLES *********/\n/*********************************/\n\n    address public ownerAddress = 0x000;\n    address private bragAddress = 0x04fd8fcff717754dE3BA18dAC22A5Fda7D69658E;\n\n    string private initialQuote = \"Teach your people with your wisdom.\";\n    /******SET PICTURE*/\n    string private initialPicture = \"https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png\";\n\n    uint256 basicFine = 25000000000000000;\n\n    uint256 totalBraggedValue = 0;\n\n    uint256 winningpot = 0;\n\n    uint256 totalbrags = 0;\n\n    bool payoutReady;\n    bool payoutRequested;\n    uint256 payoutBlock;\n\n/*********************************/\n/*********** DATA TYPES **********/\n/*********************************/\n\n    struct Bragger{\n        address braggerAddress;\n        uint256 braggedAmount;\n        string braggerQuote;\n    }\n\n    Bragger[] private braggers;\n\n    struct User{\n        address userAddress;\n        string userName;\n    }\n\n    User[] private users;\n\n/*********************************/\n/*********** MODIFIER ************/\n/*********************************/\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCreator() {\n        require(msg.sender == ownerAddress);\n        _;\n    }\n\n\n/*********************************/\n/********** CONSTRUCTOR **********/\n/*********************************/\n\n    constructor() public {\n        payoutRequested = false;\n        payoutReady = false;\n        ownerAddress = msg.sender;\n    }\n\n/*********************************/\n/******* PAYOUT FUNCTIONS ********/\n/*********************************/\n\n    function requestPayout() public {\n        //require(isUser[msg.sender]);\n        if(!getPayoutRequestedState()) {\n            payoutRequested = true;\n            payoutBlock = SafeMath.add(block.number, 17280);\n        }\n    }\n\n    function delayPayout() public payable {\n        require(getPayoutRequestedState());\n        //require(isUser[msg.sender]);\n        require(msg.value>=2500000000000000);\n        payoutBlock = SafeMath.add(payoutBlock, 240);\n        bragAddress.transfer(msg.value);\n    }\n\n    function triggerPayout() public {\n        //require(isUser[msg.sender]);\n        require(checkPayoutReadyState());\n        address _winner = braggers[braggers.length-1].braggerAddress;\n        _winner.transfer(getWinnerPot());\n        payoutBlock = 0;\n        payoutRequested = false;\n    }\n\n     function checkPayoutReadyState() public returns(bool){\n        if(block.number >= payoutBlock && payoutBlock != 0){\n            payoutReady = true;\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            payoutReady = false;\n            return false;\n        }\n    }\n\n/*********************************/\n/************ GETTERS ************/\n/*********************************/\n\n    function getPayoutRequestedState() public view returns(bool){\n        return payoutRequested;\n    }\n\n    function getPayoutReadyState() public view returns(bool){\n         if(block.number>=payoutBlock && payoutBlock != 0){\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            return false;\n        }\n    }\n\n    function getCurrentPayoutBlock() public view returns(uint){\n        return payoutBlock;\n    }\n\n    function getRemainingBlocksUntilPayoutk() public view returns(uint){\n        return SafeMath.sub(payoutBlock, block.number);\n    }\n\n    function getTotalBraggedVolume() public view returns (uint256 _amount){\n        return totalBraggedValue;\n    }\n\n    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n        _bragger = braggers[braggers.length-1].braggerAddress;\n        _amount = braggers[braggers.length-1].braggedAmount;\n        _quote = braggers[braggers.length-1].braggerQuote;\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n        if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _amount, _quote, _username, _picture);\n    }\n\n    function arrayLength()public view returns(uint256 length){\n        length = braggers.length;\n        return length;\n    }\n\n    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n        _bragger = braggers[_index].braggerAddress;\n        _brag = braggers[_index].braggedAmount;\n\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n         if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _brag, _username, _picture);\n    }\n\n    function getUserNameByWallet(address _wallet) public view returns (string _username){\n        require(isAlreadyUser(_wallet));\n        _username = userWalletToUserName[_wallet];\n        return _username;\n    }\n\n     function getUserPictureByWallet(address _wallet) public view returns (string _url){\n        require(isAlreadyUser(_wallet));\n        _url = userWalletToPicture[_wallet];\n        return _url;\n    }\n\n    function getUserWalletByUsername(string _username) public view returns(address _address){\n        address _user = userNameToUserWallet[_username];\n        return (_user);\n    }\n\n    function getUserPictureByUsername(string _username) public view returns(string _url){\n        _url = userNameToPicture[_username];\n        return (_url);\n    }\n\n    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        address _user = userNameToUserWallet[_username];\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getTotalBrags() public view returns(uint256){\n        return totalbrags;\n    }\n\n    function getWinnerPot() public view returns(uint256){\n        return winningpot;\n    }\n\n/*********************************/\n/****** BRAGING FUNCTIONS ********/\n/*********************************/\n\n    function getCurrentPot() public view returns (uint256 _amount){\n        return address(this).balance;\n    }\n\n\n    function brag() public payable{\n\n        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n\n        if(braggers.length != 0){\n         require(braggers[braggers.length-1].braggedAmount < msg.value);\n        }\n\n        Bragger memory _bragger = Bragger({\n            braggerAddress: msg.sender,\n            braggedAmount: msg.value,\n            braggerQuote: initialQuote\n        });\n\n        braggers.push(_bragger);\n\n        totalBraggedValue = totalBraggedValue + msg.value;\n\n        winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n\n        bragAddress.transfer(shortage);\n\n        totalbrags += 1;\n    }\n\n/*********************************/\n/******* USER INTERACTION ********/\n/*********************************/\n\n    function setTheKingsQuote(string _message) public payable{\n        if(fineLevel[msg.sender] > 0){\n            require(msg.value >= (basicFine * fineLevel[msg.sender]));\n        }\n        address currentKing = braggers[braggers.length-1].braggerAddress;\n        require(msg.sender == currentKing);\n        braggers[braggers.length-1].braggerQuote = _message;\n    }\n\n/*********************************/\n/********* USER CREATION *********/\n/*********************************/\n\n    function isAlreadyUser(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function hasProfilePicture(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewUser(string _username, string _pictureUrl) public {\n\n        require(!isAlreadyUser(msg.sender));\n\n        User memory _user = User({\n            userAddress: msg.sender,\n            userName: _username\n        });\n\n        userWalletToUserName[msg.sender] = _username;\n        userNameToUserWallet[_username] = msg.sender;\n        userNameToPicture[_username] = _pictureUrl;\n        userWalletToPicture[msg.sender] = _pictureUrl;\n        fineLevel[msg.sender] = 0;\n\n        users.push(_user) - 1;\n        isUser[msg.sender] = true;\n        hasPicture[msg.sender] = true;\n    }\n\n/*********************************/\n/******** OWNER FUNCTIONS ********/\n/*********************************/\n\n    function resetQuote()public onlyCreator{\n        braggers[braggers.length-1].braggerQuote = initialQuote;\n        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n    }\n\n    function resetUsername(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToUserName[user] = \"Mick\";\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    function resetUserPicture(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToPicture[user] = initialPicture;\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    /********** ResetUserPicture */\n\n/*********************************/\n/******** LEGACY FUNCIONS ********/\n/*********************************/\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function reset()public onlyCreator {\n        selfdestruct(ownerAddress);\n    }\n\n}\n\n/*********************************/\n/*********** CALC LIB ************/\n/*********************************/\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity auto",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe65faf4feb7571ab161eefd68581d1e0648333cbb57b9dc36adcf7efaeef00c1\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfe9659011001f8793364331d4369f7b7ca9def0c2c95cd735dcb0b1c3e833003\ncalldata_tokenRecipient_0: 0x4dfa3f1800000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createNewUser(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "createNewUser(string,string)",
        "lineno": 7,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13368,
        "code": "ct braggerContract {\n\n/*********************************/\n/*********** MAPPINGS ************/\n/*********************************/\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping (address => bool) private isUser;\n    mapping (address => bool) private hasPicture;\n    mapping (address => string) private userWalletToUserName;\n    mapping (string => address) private userNameToUserWallet;\n    mapping (string => string) private userNameToPicture;\n    mapping (address => string) private userWalletToPicture;\n    mapping (address => uint256) private fineLevel;\n\n/*********************************/\n/************* EVENTS ************/\n/*********************************/\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n/*********************************/\n/******** FREE VARIABLES *********/\n/*********************************/\n\n    address public ownerAddress = 0x000;\n    address private bragAddress = 0x04fd8fcff717754dE3BA18dAC22A5Fda7D69658E;\n\n    string private initialQuote = \"Teach your people with your wisdom.\";\n    /******SET PICTURE*/\n    string private initialPicture = \"https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png\";\n\n    uint256 basicFine = 25000000000000000;\n\n    uint256 totalBraggedValue = 0;\n\n    uint256 winningpot = 0;\n\n    uint256 totalbrags = 0;\n\n    bool payoutReady;\n    bool payoutRequested;\n    uint256 payoutBlock;\n\n/*********************************/\n/*********** DATA TYPES **********/\n/*********************************/\n\n    struct Bragger{\n        address braggerAddress;\n        uint256 braggedAmount;\n        string braggerQuote;\n    }\n\n    Bragger[] private braggers;\n\n    struct User{\n        address userAddress;\n        string userName;\n    }\n\n    User[] private users;\n\n/*********************************/\n/*********** MODIFIER ************/\n/*********************************/\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCreator() {\n        require(msg.sender == ownerAddress);\n        _;\n    }\n\n\n/*********************************/\n/********** CONSTRUCTOR **********/\n/*********************************/\n\n    constructor() public {\n        payoutRequested = false;\n        payoutReady = false;\n        ownerAddress = msg.sender;\n    }\n\n/*********************************/\n/******* PAYOUT FUNCTIONS ********/\n/*********************************/\n\n    function requestPayout() public {\n        //require(isUser[msg.sender]);\n        if(!getPayoutRequestedState()) {\n            payoutRequested = true;\n            payoutBlock = SafeMath.add(block.number, 17280);\n        }\n    }\n\n    function delayPayout() public payable {\n        require(getPayoutRequestedState());\n        //require(isUser[msg.sender]);\n        require(msg.value>=2500000000000000);\n        payoutBlock = SafeMath.add(payoutBlock, 240);\n        bragAddress.transfer(msg.value);\n    }\n\n    function triggerPayout() public {\n        //require(isUser[msg.sender]);\n        require(checkPayoutReadyState());\n        address _winner = braggers[braggers.length-1].braggerAddress;\n        _winner.transfer(getWinnerPot());\n        payoutBlock = 0;\n        payoutRequested = false;\n    }\n\n     function checkPayoutReadyState() public returns(bool){\n        if(block.number >= payoutBlock && payoutBlock != 0){\n            payoutReady = true;\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            payoutReady = false;\n            return false;\n        }\n    }\n\n/*********************************/\n/************ GETTERS ************/\n/*********************************/\n\n    function getPayoutRequestedState() public view returns(bool){\n        return payoutRequested;\n    }\n\n    function getPayoutReadyState() public view returns(bool){\n         if(block.number>=payoutBlock && payoutBlock != 0){\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            return false;\n        }\n    }\n\n    function getCurrentPayoutBlock() public view returns(uint){\n        return payoutBlock;\n    }\n\n    function getRemainingBlocksUntilPayoutk() public view returns(uint){\n        return SafeMath.sub(payoutBlock, block.number);\n    }\n\n    function getTotalBraggedVolume() public view returns (uint256 _amount){\n        return totalBraggedValue;\n    }\n\n    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n        _bragger = braggers[braggers.length-1].braggerAddress;\n        _amount = braggers[braggers.length-1].braggedAmount;\n        _quote = braggers[braggers.length-1].braggerQuote;\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n        if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _amount, _quote, _username, _picture);\n    }\n\n    function arrayLength()public view returns(uint256 length){\n        length = braggers.length;\n        return length;\n    }\n\n    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n        _bragger = braggers[_index].braggerAddress;\n        _brag = braggers[_index].braggedAmount;\n\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n         if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _brag, _username, _picture);\n    }\n\n    function getUserNameByWallet(address _wallet) public view returns (string _username){\n        require(isAlreadyUser(_wallet));\n        _username = userWalletToUserName[_wallet];\n        return _username;\n    }\n\n     function getUserPictureByWallet(address _wallet) public view returns (string _url){\n        require(isAlreadyUser(_wallet));\n        _url = userWalletToPicture[_wallet];\n        return _url;\n    }\n\n    function getUserWalletByUsername(string _username) public view returns(address _address){\n        address _user = userNameToUserWallet[_username];\n        return (_user);\n    }\n\n    function getUserPictureByUsername(string _username) public view returns(string _url){\n        _url = userNameToPicture[_username];\n        return (_url);\n    }\n\n    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        address _user = userNameToUserWallet[_username];\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getTotalBrags() public view returns(uint256){\n        return totalbrags;\n    }\n\n    function getWinnerPot() public view returns(uint256){\n        return winningpot;\n    }\n\n/*********************************/\n/****** BRAGING FUNCTIONS ********/\n/*********************************/\n\n    function getCurrentPot() public view returns (uint256 _amount){\n        return address(this).balance;\n    }\n\n\n    function brag() public payable{\n\n        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n\n        if(braggers.length != 0){\n         require(braggers[braggers.length-1].braggedAmount < msg.value);\n        }\n\n        Bragger memory _bragger = Bragger({\n            braggerAddress: msg.sender,\n            braggedAmount: msg.value,\n            braggerQuote: initialQuote\n        });\n\n        braggers.push(_bragger);\n\n        totalBraggedValue = totalBraggedValue + msg.value;\n\n        winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n\n        bragAddress.transfer(shortage);\n\n        totalbrags += 1;\n    }\n\n/*********************************/\n/******* USER INTERACTION ********/\n/*********************************/\n\n    function setTheKingsQuote(string _message) public payable{\n        if(fineLevel[msg.sender] > 0){\n            require(msg.value >= (basicFine * fineLevel[msg.sender]));\n        }\n        address currentKing = braggers[braggers.length-1].braggerAddress;\n        require(msg.sender == currentKing);\n        braggers[braggers.length-1].braggerQuote = _message;\n    }\n\n/*********************************/\n/********* USER CREATION *********/\n/*********************************/\n\n    function isAlreadyUser(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function hasProfilePicture(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewUser(string _username, string _pictureUrl) public {\n\n        require(!isAlreadyUser(msg.sender));\n\n        User memory _user = User({\n            userAddress: msg.sender,\n            userName: _username\n        });\n\n        userWalletToUserName[msg.sender] = _username;\n        userNameToUserWallet[_username] = msg.sender;\n        userNameToPicture[_username] = _pictureUrl;\n        userWalletToPicture[msg.sender] = _pictureUrl;\n        fineLevel[msg.sender] = 0;\n\n        users.push(_user) - 1;\n        isUser[msg.sender] = true;\n        hasPicture[msg.sender] = true;\n    }\n\n/*********************************/\n/******** OWNER FUNCTIONS ********/\n/*********************************/\n\n    function resetQuote()public onlyCreator{\n        braggers[braggers.length-1].braggerQuote = initialQuote;\n        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n    }\n\n    function resetUsername(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToUserName[user] = \"Mick\";\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    function resetUserPicture(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToPicture[user] = initialPicture;\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    /********** ResetUserPicture */\n\n/*********************************/\n/******** LEGACY FUNCIONS ********/\n/*********************************/\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function reset()public onlyCreator {\n        selfdestruct(ownerAddress);\n    }\n\n}\n\n/*********************************/\n/*********** CALC LIB ************/\n/*********************************/\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity auto",
        "debug": "calldata_tokenRecipient_4 + calldata_tokenRecipient_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_tokenRecipient_0: 0x4dfa3f1800000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createNewUser(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "createNewUser(string,string)",
        "lineno": 7,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13382,
        "code": "ct braggerContract {\n\n/*********************************/\n/*********** MAPPINGS ************/\n/*********************************/\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping (address => bool) private isUser;\n    mapping (address => bool) private hasPicture;\n    mapping (address => string) private userWalletToUserName;\n    mapping (string => address) private userNameToUserWallet;\n    mapping (string => string) private userNameToPicture;\n    mapping (address => string) private userWalletToPicture;\n    mapping (address => uint256) private fineLevel;\n\n/*********************************/\n/************* EVENTS ************/\n/*********************************/\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n/*********************************/\n/******** FREE VARIABLES *********/\n/*********************************/\n\n    address public ownerAddress = 0x000;\n    address private bragAddress = 0x04fd8fcff717754dE3BA18dAC22A5Fda7D69658E;\n\n    string private initialQuote = \"Teach your people with your wisdom.\";\n    /******SET PICTURE*/\n    string private initialPicture = \"https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png\";\n\n    uint256 basicFine = 25000000000000000;\n\n    uint256 totalBraggedValue = 0;\n\n    uint256 winningpot = 0;\n\n    uint256 totalbrags = 0;\n\n    bool payoutReady;\n    bool payoutRequested;\n    uint256 payoutBlock;\n\n/*********************************/\n/*********** DATA TYPES **********/\n/*********************************/\n\n    struct Bragger{\n        address braggerAddress;\n        uint256 braggedAmount;\n        string braggerQuote;\n    }\n\n    Bragger[] private braggers;\n\n    struct User{\n        address userAddress;\n        string userName;\n    }\n\n    User[] private users;\n\n/*********************************/\n/*********** MODIFIER ************/\n/*********************************/\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCreator() {\n        require(msg.sender == ownerAddress);\n        _;\n    }\n\n\n/*********************************/\n/********** CONSTRUCTOR **********/\n/*********************************/\n\n    constructor() public {\n        payoutRequested = false;\n        payoutReady = false;\n        ownerAddress = msg.sender;\n    }\n\n/*********************************/\n/******* PAYOUT FUNCTIONS ********/\n/*********************************/\n\n    function requestPayout() public {\n        //require(isUser[msg.sender]);\n        if(!getPayoutRequestedState()) {\n            payoutRequested = true;\n            payoutBlock = SafeMath.add(block.number, 17280);\n        }\n    }\n\n    function delayPayout() public payable {\n        require(getPayoutRequestedState());\n        //require(isUser[msg.sender]);\n        require(msg.value>=2500000000000000);\n        payoutBlock = SafeMath.add(payoutBlock, 240);\n        bragAddress.transfer(msg.value);\n    }\n\n    function triggerPayout() public {\n        //require(isUser[msg.sender]);\n        require(checkPayoutReadyState());\n        address _winner = braggers[braggers.length-1].braggerAddress;\n        _winner.transfer(getWinnerPot());\n        payoutBlock = 0;\n        payoutRequested = false;\n    }\n\n     function checkPayoutReadyState() public returns(bool){\n        if(block.number >= payoutBlock && payoutBlock != 0){\n            payoutReady = true;\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            payoutReady = false;\n            return false;\n        }\n    }\n\n/*********************************/\n/************ GETTERS ************/\n/*********************************/\n\n    function getPayoutRequestedState() public view returns(bool){\n        return payoutRequested;\n    }\n\n    function getPayoutReadyState() public view returns(bool){\n         if(block.number>=payoutBlock && payoutBlock != 0){\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            return false;\n        }\n    }\n\n    function getCurrentPayoutBlock() public view returns(uint){\n        return payoutBlock;\n    }\n\n    function getRemainingBlocksUntilPayoutk() public view returns(uint){\n        return SafeMath.sub(payoutBlock, block.number);\n    }\n\n    function getTotalBraggedVolume() public view returns (uint256 _amount){\n        return totalBraggedValue;\n    }\n\n    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n        _bragger = braggers[braggers.length-1].braggerAddress;\n        _amount = braggers[braggers.length-1].braggedAmount;\n        _quote = braggers[braggers.length-1].braggerQuote;\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n        if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _amount, _quote, _username, _picture);\n    }\n\n    function arrayLength()public view returns(uint256 length){\n        length = braggers.length;\n        return length;\n    }\n\n    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n        _bragger = braggers[_index].braggerAddress;\n        _brag = braggers[_index].braggedAmount;\n\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n         if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _brag, _username, _picture);\n    }\n\n    function getUserNameByWallet(address _wallet) public view returns (string _username){\n        require(isAlreadyUser(_wallet));\n        _username = userWalletToUserName[_wallet];\n        return _username;\n    }\n\n     function getUserPictureByWallet(address _wallet) public view returns (string _url){\n        require(isAlreadyUser(_wallet));\n        _url = userWalletToPicture[_wallet];\n        return _url;\n    }\n\n    function getUserWalletByUsername(string _username) public view returns(address _address){\n        address _user = userNameToUserWallet[_username];\n        return (_user);\n    }\n\n    function getUserPictureByUsername(string _username) public view returns(string _url){\n        _url = userNameToPicture[_username];\n        return (_url);\n    }\n\n    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        address _user = userNameToUserWallet[_username];\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getTotalBrags() public view returns(uint256){\n        return totalbrags;\n    }\n\n    function getWinnerPot() public view returns(uint256){\n        return winningpot;\n    }\n\n/*********************************/\n/****** BRAGING FUNCTIONS ********/\n/*********************************/\n\n    function getCurrentPot() public view returns (uint256 _amount){\n        return address(this).balance;\n    }\n\n\n    function brag() public payable{\n\n        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n\n        if(braggers.length != 0){\n         require(braggers[braggers.length-1].braggedAmount < msg.value);\n        }\n\n        Bragger memory _bragger = Bragger({\n            braggerAddress: msg.sender,\n            braggedAmount: msg.value,\n            braggerQuote: initialQuote\n        });\n\n        braggers.push(_bragger);\n\n        totalBraggedValue = totalBraggedValue + msg.value;\n\n        winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n\n        bragAddress.transfer(shortage);\n\n        totalbrags += 1;\n    }\n\n/*********************************/\n/******* USER INTERACTION ********/\n/*********************************/\n\n    function setTheKingsQuote(string _message) public payable{\n        if(fineLevel[msg.sender] > 0){\n            require(msg.value >= (basicFine * fineLevel[msg.sender]));\n        }\n        address currentKing = braggers[braggers.length-1].braggerAddress;\n        require(msg.sender == currentKing);\n        braggers[braggers.length-1].braggerQuote = _message;\n    }\n\n/*********************************/\n/********* USER CREATION *********/\n/*********************************/\n\n    function isAlreadyUser(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function hasProfilePicture(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewUser(string _username, string _pictureUrl) public {\n\n        require(!isAlreadyUser(msg.sender));\n\n        User memory _user = User({\n            userAddress: msg.sender,\n            userName: _username\n        });\n\n        userWalletToUserName[msg.sender] = _username;\n        userNameToUserWallet[_username] = msg.sender;\n        userNameToPicture[_username] = _pictureUrl;\n        userWalletToPicture[msg.sender] = _pictureUrl;\n        fineLevel[msg.sender] = 0;\n\n        users.push(_user) - 1;\n        isUser[msg.sender] = true;\n        hasPicture[msg.sender] = true;\n    }\n\n/*********************************/\n/******** OWNER FUNCTIONS ********/\n/*********************************/\n\n    function resetQuote()public onlyCreator{\n        braggers[braggers.length-1].braggerQuote = initialQuote;\n        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n    }\n\n    function resetUsername(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToUserName[user] = \"Mick\";\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    function resetUserPicture(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToPicture[user] = initialPicture;\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    /********** ResetUserPicture */\n\n/*********************************/\n/******** LEGACY FUNCIONS ********/\n/*********************************/\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function reset()public onlyCreator {\n        selfdestruct(ownerAddress);\n    }\n\n}\n\n/*********************************/\n/*********** CALC LIB ************/\n/*********************************/\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity auto",
        "debug": "calldata_tokenRecipient_4 + calldata_tokenRecipient_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_tokenRecipient_0: 0x4dfa3f1800000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createNewUser(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "createNewUser(string,string)",
        "lineno": 7,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13595,
        "code": "ct braggerContract {\n\n/*********************************/\n/*********** MAPPINGS ************/\n/*********************************/\n\n    // This creates an array with all balances\n    mapping (address => uint256) public balanceOf;\n    mapping (address => mapping (address => uint256)) public allowance;\n\n    mapping (address => bool) private isUser;\n    mapping (address => bool) private hasPicture;\n    mapping (address => string) private userWalletToUserName;\n    mapping (string => address) private userNameToUserWallet;\n    mapping (string => string) private userNameToPicture;\n    mapping (address => string) private userWalletToPicture;\n    mapping (address => uint256) private fineLevel;\n\n/*********************************/\n/************* EVENTS ************/\n/*********************************/\n\n    // This generates a public event on the blockchain that will notify clients\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    // This notifies clients about the amount burnt\n    event Burn(address indexed from, uint256 value);\n\n/*********************************/\n/******** FREE VARIABLES *********/\n/*********************************/\n\n    address public ownerAddress = 0x000;\n    address private bragAddress = 0x04fd8fcff717754dE3BA18dAC22A5Fda7D69658E;\n\n    string private initialQuote = \"Teach your people with your wisdom.\";\n    /******SET PICTURE*/\n    string private initialPicture = \"https://cdn2.iconfinder.com/data/icons/ios-7-icons/50/user_male2-512.png\";\n\n    uint256 basicFine = 25000000000000000;\n\n    uint256 totalBraggedValue = 0;\n\n    uint256 winningpot = 0;\n\n    uint256 totalbrags = 0;\n\n    bool payoutReady;\n    bool payoutRequested;\n    uint256 payoutBlock;\n\n/*********************************/\n/*********** DATA TYPES **********/\n/*********************************/\n\n    struct Bragger{\n        address braggerAddress;\n        uint256 braggedAmount;\n        string braggerQuote;\n    }\n\n    Bragger[] private braggers;\n\n    struct User{\n        address userAddress;\n        string userName;\n    }\n\n    User[] private users;\n\n/*********************************/\n/*********** MODIFIER ************/\n/*********************************/\n\n    /// @dev Access modifier for CEO-only functionality\n    modifier onlyCreator() {\n        require(msg.sender == ownerAddress);\n        _;\n    }\n\n\n/*********************************/\n/********** CONSTRUCTOR **********/\n/*********************************/\n\n    constructor() public {\n        payoutRequested = false;\n        payoutReady = false;\n        ownerAddress = msg.sender;\n    }\n\n/*********************************/\n/******* PAYOUT FUNCTIONS ********/\n/*********************************/\n\n    function requestPayout() public {\n        //require(isUser[msg.sender]);\n        if(!getPayoutRequestedState()) {\n            payoutRequested = true;\n            payoutBlock = SafeMath.add(block.number, 17280);\n        }\n    }\n\n    function delayPayout() public payable {\n        require(getPayoutRequestedState());\n        //require(isUser[msg.sender]);\n        require(msg.value>=2500000000000000);\n        payoutBlock = SafeMath.add(payoutBlock, 240);\n        bragAddress.transfer(msg.value);\n    }\n\n    function triggerPayout() public {\n        //require(isUser[msg.sender]);\n        require(checkPayoutReadyState());\n        address _winner = braggers[braggers.length-1].braggerAddress;\n        _winner.transfer(getWinnerPot());\n        payoutBlock = 0;\n        payoutRequested = false;\n    }\n\n     function checkPayoutReadyState() public returns(bool){\n        if(block.number >= payoutBlock && payoutBlock != 0){\n            payoutReady = true;\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            payoutReady = false;\n            return false;\n        }\n    }\n\n/*********************************/\n/************ GETTERS ************/\n/*********************************/\n\n    function getPayoutRequestedState() public view returns(bool){\n        return payoutRequested;\n    }\n\n    function getPayoutReadyState() public view returns(bool){\n         if(block.number>=payoutBlock && payoutBlock != 0){\n            return true;\n        }\n\n        if(block.number < payoutBlock){\n            return false;\n        }\n    }\n\n    function getCurrentPayoutBlock() public view returns(uint){\n        return payoutBlock;\n    }\n\n    function getRemainingBlocksUntilPayoutk() public view returns(uint){\n        return SafeMath.sub(payoutBlock, block.number);\n    }\n\n    function getTotalBraggedVolume() public view returns (uint256 _amount){\n        return totalBraggedValue;\n    }\n\n    function getCurrentBragKing() public view returns(address _bragger, uint256 _amount, string _quote, string _username, string _picture){\n        _bragger = braggers[braggers.length-1].braggerAddress;\n        _amount = braggers[braggers.length-1].braggedAmount;\n        _quote = braggers[braggers.length-1].braggerQuote;\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n        if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _amount, _quote, _username, _picture);\n    }\n\n    function arrayLength()public view returns(uint256 length){\n        length = braggers.length;\n        return length;\n    }\n\n    function getBraggerAtIndex(uint256 _index) public view returns(address _bragger, uint256 _brag, string _username, string _picture){\n        _bragger = braggers[_index].braggerAddress;\n        _brag = braggers[_index].braggedAmount;\n\n        if(isAlreadyUser(_bragger)){\n            _username = getUserNameByWallet(_bragger);\n        } else {\n            _username = \"\";\n        }\n\n         if(hasPicture[_bragger]){\n            _picture = userWalletToPicture[_bragger];\n        } else {\n            _picture = initialPicture;\n        }\n\n        return (_bragger, _brag, _username, _picture);\n    }\n\n    function getUserNameByWallet(address _wallet) public view returns (string _username){\n        require(isAlreadyUser(_wallet));\n        _username = userWalletToUserName[_wallet];\n        return _username;\n    }\n\n     function getUserPictureByWallet(address _wallet) public view returns (string _url){\n        require(isAlreadyUser(_wallet));\n        _url = userWalletToPicture[_wallet];\n        return _url;\n    }\n\n    function getUserWalletByUsername(string _username) public view returns(address _address){\n        address _user = userNameToUserWallet[_username];\n        return (_user);\n    }\n\n    function getUserPictureByUsername(string _username) public view returns(string _url){\n        _url = userNameToPicture[_username];\n        return (_url);\n    }\n\n    function getFineLevelOfAddress(address _user) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getFineLevelOfUsername(string _username) public view returns(uint256 _fineLevel, uint256 _fineAmount){\n        address _user = userNameToUserWallet[_username];\n        _fineLevel = fineLevel[_user];\n        _fineAmount = _fineLevel * basicFine;\n        return (_fineLevel, _fineAmount);\n    }\n\n    function getTotalBrags() public view returns(uint256){\n        return totalbrags;\n    }\n\n    function getWinnerPot() public view returns(uint256){\n        return winningpot;\n    }\n\n/*********************************/\n/****** BRAGING FUNCTIONS ********/\n/*********************************/\n\n    function getCurrentPot() public view returns (uint256 _amount){\n        return address(this).balance;\n    }\n\n\n    function brag() public payable{\n\n        uint256 shortage = SafeMath.mul(30,SafeMath.div(msg.value, 100));\n\n        if(braggers.length != 0){\n         require(braggers[braggers.length-1].braggedAmount < msg.value);\n        }\n\n        Bragger memory _bragger = Bragger({\n            braggerAddress: msg.sender,\n            braggedAmount: msg.value,\n            braggerQuote: initialQuote\n        });\n\n        braggers.push(_bragger);\n\n        totalBraggedValue = totalBraggedValue + msg.value;\n\n        winningpot = winningpot + SafeMath.sub(msg.value, shortage);\n\n        bragAddress.transfer(shortage);\n\n        totalbrags += 1;\n    }\n\n/*********************************/\n/******* USER INTERACTION ********/\n/*********************************/\n\n    function setTheKingsQuote(string _message) public payable{\n        if(fineLevel[msg.sender] > 0){\n            require(msg.value >= (basicFine * fineLevel[msg.sender]));\n        }\n        address currentKing = braggers[braggers.length-1].braggerAddress;\n        require(msg.sender == currentKing);\n        braggers[braggers.length-1].braggerQuote = _message;\n    }\n\n/*********************************/\n/********* USER CREATION *********/\n/*********************************/\n\n    function isAlreadyUser(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function hasProfilePicture(address _address) public view returns (bool status){\n        if (isUser[_address]){\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function createNewUser(string _username, string _pictureUrl) public {\n\n        require(!isAlreadyUser(msg.sender));\n\n        User memory _user = User({\n            userAddress: msg.sender,\n            userName: _username\n        });\n\n        userWalletToUserName[msg.sender] = _username;\n        userNameToUserWallet[_username] = msg.sender;\n        userNameToPicture[_username] = _pictureUrl;\n        userWalletToPicture[msg.sender] = _pictureUrl;\n        fineLevel[msg.sender] = 0;\n\n        users.push(_user) - 1;\n        isUser[msg.sender] = true;\n        hasPicture[msg.sender] = true;\n    }\n\n/*********************************/\n/******** OWNER FUNCTIONS ********/\n/*********************************/\n\n    function resetQuote()public onlyCreator{\n        braggers[braggers.length-1].braggerQuote = initialQuote;\n        fineLevel[braggers[braggers.length-1].braggerAddress] = fineLevel[braggers[braggers.length-1].braggerAddress] + 1;\n    }\n\n    function resetUsername(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToUserName[user] = \"Mick\";\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    function resetUserPicture(string _username)public onlyCreator{\n        address user = userNameToUserWallet[_username];\n        userWalletToPicture[user] = initialPicture;\n        fineLevel[user] = fineLevel[user] + 1;\n    }\n\n    /********** ResetUserPicture */\n\n/*********************************/\n/******** LEGACY FUNCIONS ********/\n/*********************************/\n\n    function _transfer(address _from, address _to, uint _value) internal {\n        // Prevent transfer to 0x0 address. Use burn() instead\n        require(_to != 0x0);\n        // Check if the sender has enough\n        require(balanceOf[_from] >= _value);\n        // Check for overflows\n        require(balanceOf[_to] + _value > balanceOf[_to]);\n        // Save this for an assertion in the future\n        uint previousBalances = balanceOf[_from] + balanceOf[_to];\n        // Subtract from the sender\n        balanceOf[_from] -= _value;\n        // Add the same to the recipient\n        balanceOf[_to] += _value;\n        emit Transfer(_from, _to, _value);\n        // Asserts are used to use static analysis to find bugs in your code. They should never fail\n        assert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\n    function transfer(address _to, uint256 _value) public {\n        _transfer(msg.sender, _to, _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {\n        require(_value <= allowance[_from][msg.sender]);     // Check allowance\n        allowance[_from][msg.sender] -= _value;\n        _transfer(_from, _to, _value);\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) public\n        returns (bool success) {\n        allowance[msg.sender][_spender] = _value;\n        return true;\n    }\n\n    function approveAndCall(address _spender, uint256 _value, bytes _extraData)\n        public\n        returns (bool success) {\n        tokenRecipient spender = tokenRecipient(_spender);\n        if (approve(_spender, _value)) {\n            spender.receiveApproval(msg.sender, _value, this, _extraData);\n            return true;\n        }\n    }\n\n    function reset()public onlyCreator {\n        selfdestruct(ownerAddress);\n    }\n\n}\n\n/*********************************/\n/*********** CALC LIB ************/\n/*********************************/\n\nlibrary SafeMath {\n\n  function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n    if (a == 0) {\n      return 0;\n    }\n    uint256 c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  function div(uint256 a, uint256 b) internal pure returns (uint256) {\n    // assert(b > 0); // Solidity auto",
        "debug": "keccac_2_+\n46529144392117707452946260303848603952187628831689540306122340668716214558861_+\n3*storage_19: 0xfe012d59c08c80207a00efb40033ff84240700477ffffaeaad3d002005a7fffa\nstorage_19: 0xc000000000000000000000000000000000000000000000000000000000000000\nstorage_2 +\n46529144392117707452946260303848603952187628831689540306122340668716214558861 +\n3*storage_19: 0x803c027f9bb002400000000000000000000000000000000000000000000000c3\nstorage_9: 0x0\ncaller: 0x0\ncalldata_tokenRecipient_0: 0x69ddaad100000000000000000000000000000000000000000000000000000000\ncalldatasize_tokenRecipient: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `resetQuote()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/28/0xa93da2147eabb1e517cc17d2d7f6bfa7f15ee389.sol",
        "function": "resetQuote()",
        "lineno": 7,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}