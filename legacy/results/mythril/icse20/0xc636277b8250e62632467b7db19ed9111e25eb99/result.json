{
  "contract": "0xc636277b8250e62632467b7db19ed9111e25eb99",
  "tool": "mythril",
  "start": 1563756139.4321382,
  "end": 1563756292.2654445,
  "duration": 152.83330631256104,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1640,
        "code": "6Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\t// Check if a specific sha256 hash has been used by another artwork before\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\t// Approve factory contracts\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\t\n\t// Open Zeppelin",
        "debug": "calldata_Registrar_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x21cb1568",
        "lineno": 455,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6595,
        "code": "payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x02581ab3",
        "lineno": 622,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 7439,
        "code": "t);\n\t\t\tc.approveIndexed(",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x0ff244b2",
        "lineno": 552,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 7767,
        "code": "nt);\n\t\t}\n\n\tfunction burnFromBy",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x14a3b19a",
        "lineno": 559,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 10694,
        "code": "amount;\n\t\t\t\t\tbalances[_",
        "debug": "calldatasize_Registrar: 0x800000000000000000000000000000000000000000000000000000000020\ncalldata_Registrar_32 + 36: 0x5b51dac49284d052eede5596fe2ba53f779697e2114bc7bdc6e9f6dddfb2fca1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_32_+_4: 0xc8ad1292fc16ef648490c9b6f6a7ad897261541bdd738f31940d869d9824c19a\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x5b51dac49284d052eede5596fe2ba53f779697e2114bc7bdc6e9f6dddfb2fca1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0x5b51dac49284d052eede5596fe2ba53f779697e2114bc7bdc6e9f6dddfb2fca1\ncalldata_Registrar_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 171,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11444,
        "code": "an unindexed piece owned by",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x23c1236a",
        "lineno": 586,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 19098,
        "code": "ster of all SH",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Registrar_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_14: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_15: 0x0\ncaller: 0x0\ncalldata_Registrar_0: 0x22b1a22600000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x22b1a226",
        "lineno": 248,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 19179,
        "code": "\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\t// Owner of account approves the transfer of an amount of Patron tokens to another account\n\tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// Mitigating ERC20 short address attacks (http://vessenes.com/the-erc20-short-address-attack-explained/)\n\tmodifier onlyPayloadSize(uint size)\n\t{\n\t\trequire(msg.data.length >= size + 4);\n\t\t_;\n\t}\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n\tfunction totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorised the sender of the message via some mechanism; we propose\n \t// these standardised APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\t// To be extra secure set allowance to 0 and check that none of the allowance was spend between you sending the tx and it getting mined. Only then decrease/increase the allowance.\n\t// See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.m9fhqynw2xvt\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// BEGIN safe math functions by Open Zeppelin\n\t// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n\n\tfunction mul(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n\n\t// END safe math functions by Open Zeppelin\n\n\t// Ethart variables\n\t\n\t// Register of all SHA256 Hashes\n    mapping (bytes32 => address) public SHA256HashRegister;\n\t\n\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedFactories;\n\t\n\t// Register of all approved artwork contracts\n\t\n\t// Register of all approved contracts for amending pending withdrawals and issuing Patron tokens\n\tmapping (address => bool) public approvedContracts;\n\t\n\t// Register of all referrers (referee => referrer) used for the affiliate program\n\tmapping (address => address) public referred;\n\t\n\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\tmapping (address => bool) public cantSetReferrer;\n\n\t// Register of all artworks and their details by their respective addresses\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\n\n\t// An indexed register of all of an artist's artworks\n\n\t// Enter artist address and a running number to get the artist's artwork addresses\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\n\n\t// A running number counting an artist's artworks\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t\n\n\t// Keeps track of the number of artwork contracts in the network\n\tuint256 public artworkCount;\n\n\t// An index of all the artwork contracts in the network\n\tmapping (uint256 => address) public artworkIndex;\n\n\t// All pending withdrawals\n\tmapping (address => uint256) public pendingWithdrawals;\n\tuint256 public totalPendingWithdrawals;\n\n\t// The address of the Registrar's owner\n\taddress public owner;\n\t\n\t// Determines how many Patrons are issues per donation\n\tuint256 public donationMultiplier;\n\t\n\t// Determines how many Patrons are issues per purchase of an artwork in basis points (10,000 = 100%)\n\tuint256 public patronRewardMultiplier;\n\t\n\t// Determines how much Ethart is entitled to artworks/revenue percentages in basis points (10,000 = 100%)\n\tuint256 public ethartRevenueReward;\n\tuint256 public ethartArtReward;\n\t\n\t// Determines how much of a percentage a referrer get of ethartRevenueReward\n\tuint256 public referrerReward;\n\n\t// Functions with this modifier can only be executed by a specific address\n\tmodifier onlyBy (address _account)\n\t{\n\t\trequire(msg.sender == _account);\n\t\t_;\n\t\t}\n\n\t// Functions with this modifier can only be executed by approved factory contracts\n\tmodifier registeredFactoriesOnly ()\n\t{\n\t\trequire(approvedFactories[msg.sender]);\n\t\t_;\n\t}\n\n\t// Functions with this modifier can only be executed by approved contracts\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\t// Set the referrer of an artist. This has to be done before an artist creates their first artwork.\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender] && _referrer != msg.sender)\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction getReferrer (address _artist) returns (address _referrer)\n\t\t{\n\t\t\treturn referred[_artist];\n\t\t}\n\t\n\tfunction setReferrerReward (uint256 _referrerReward) onlyBy (owner)\n\t\t{\n\t\t\tuint a;\n\t\t\tif (_referrerReward > 10000 - ethartRevenueReward) {throw;}\n\t\t\ta = 10000 / _referrerReward;\n\t\t\t// 10000 / _referrerReward has to be an even number\n\t\t\tif (a * _referrerReward != 10000) {throw;}\n\t\t\treferrerReward = _referrerReward;\n\t\t}\n\t\n\tfunction getReferrerReward () returns (uint256 _referrerReward)\n\t\t{\n\t\t\treturn referrerReward;\n\t\t}\n\n\t// Constructor\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\t\n\t\t// Donors receive 100 Patrons per 1 wei donation\n\t\tdonationMultiplier = 100;\n\t\t\n\t\t// Patrons receive 2.5 Patrons (25,000 basis points) per 1 wei purchases\n\t\tpatronRewardMultiplier = 25000;\n\t\t\n\t\t// Ethart receives 2.5% of revenues and artwork's edition sizes\n\t\tethartRevenueReward = 250;\n\t\tethartArtReward = 250;\n\t\t\n\t\t// For balanced figures patronRewardMultiplier / donationMultiplier <= ethartRevenueReward\n\t\t\n\t\t// Referrers receive 10% of ethartRevenueReward\n\t\treferrerReward = 1000;\n\t}\n\n\tfunction setPatronReward (uint256 _donationMultiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _donationMultiplier;\n\t\t\tpatronRewardMultiplier = ethartRevenueReward * _donationMultiplier;\n\t\t\tif (patronRewardMultiplier / donationMultiplier > ethartRevenueReward) {throw;}\n\t\t}\n\n\tfunction setEthartRevenueReward (uint256 _ethartRevenueReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart revenue reward can never be greater than 10%\n\t\t\tif (_ethartRevenueReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartRevenueReward;\n\t\t\t// Should 10000 / _ethartRevenueReward not be even throw\n\t\t\tif (a * _ethartRevenueReward < 10000) {throw;}\n\t\t\tethartRevenueReward = _ethartRevenueReward;\n\t\t}\n\t\n\tfunction getEthartRevenueReward () returns (uint256 _ethartRevenueReward)\n\t\t{\n\t\t\treturn ethartRevenueReward;\n\t\t}\n\n\tfunction setEthartArtReward (uint256 _ethartArtReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart art reward can never be greater than 10%\n\t\t\tif (_ethartArtReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartArtReward;\n\t\t\t// Should 10000 / _ethartArtReward not be even throw\n\t\t\tif (a * _ethartArtReward < 10000) {throw;}\n\t\t\tethartArtReward = _ethartArtReward;\n\t\t}\n\n\tfunction getEthartArtReward () returns (uint256 _ethartArtReward)\n\t\t{\n\t\t\treturn ethartArtReward;\n\t\t}\n\n\t// Allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\t// Allows approved contracts to issue Patron tokens\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount / 10000 * patronRewardMultiplier;\n\t\t\t_totalPatronSupply += _amount / 10000 * patronRewardMultiplier;\n\t\t}\n\n\t// Change the amount of Patron tokens a donor receives\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\t// Receive Patron tokens in returns for donations\n\t// Not going to worry about a theoretical Integer overflow here.\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registeredFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\t// Check if a specific sha256 hash has been used by another artwork before\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\t// Approve factory contracts\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\t\n\t// Open Zeppelin asyncSend function for pull payments\n\tfunction asyncSend (address _payee, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tpendingWithdrawals[_payee] = add(pendingWithdrawals[_payee], _amount);\n\t\t\ttotalPendingWithdrawals = add(totalPendingWithdrawals, _amount);\n\t\t}\n\n\tfunction withdrawPaymentsRegistrar (address _dest, uint256 _payment) onlyBy (owner)\n\t\t{\n\t\t\tif (_payment == 0) {\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t\tif (this.balance < _payment) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\t\n\t\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, _payment);\n\t\t\tpendingWithdrawals[this] = sub(pendingWithdrawals[this], _payment);\n\n\t\t\tif (!_dest.send(_payment)) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\tfunction withdrawPayments() {\n\t\taddress payee = msg.sender;\n\t\tuint256 payment = pendingWithdrawals[payee];\n\n\t\tif (payment == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (this.balance < payment) {\n\t\t\tthrow;\n\t\t}\n\n\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, payment);\n\t\tpendingWithdrawals[payee] = 0;\n\n\t\tif (!payee.send(payment)) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\t// Fill a bid with an unindexed piece owned by the registrar\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\t// Sell an indexed piece owned by the registrar.\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\t// Fill a bid with an indexed piece owned by the registrar\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\n\t\t}\n}",
        "debug": "keccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x21cb1568",
        "lineno": 107,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 19208,
        "code": "\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\t// Owner of account approves the transfer of an amount of Patron tokens to another account\n\tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// Mitigating ERC20 short address attacks (http://vessenes.com/the-erc20-short-address-attack-explained/)\n\tmodifier onlyPayloadSize(uint size)\n\t{\n\t\trequire(msg.data.length >= size + 4);\n\t\t_;\n\t}\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n\tfunction totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorised the sender of the message via some mechanism; we propose\n \t// these standardised APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\t// To be extra secure set allowance to 0 and check that none of the allowance was spend between you sending the tx and it getting mined. Only then decrease/increase the allowance.\n\t// See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.m9fhqynw2xvt\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// BEGIN safe math functions by Open Zeppelin\n\t// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n\n\tfunction mul(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n\n\t// END safe math functions by Open Zeppelin\n\n\t// Ethart variables\n\t\n\t// Register of all SHA256 Hashes\n    mapping (bytes32 => address) public SHA256HashRegister;\n\t\n\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedFactories;\n\t\n\t// Register of all approved artwork contracts\n\t\n\t// Register of all approved contracts for amending pending withdrawals and issuing Patron tokens\n\tmapping (address => bool) public approvedContracts;\n\t\n\t// Register of all referrers (referee => referrer) used for the affiliate program\n\tmapping (address => address) public referred;\n\t\n\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\tmapping (address => bool) public cantSetReferrer;\n\n\t// Register of all artworks and their details by their respective addresses\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\n\n\t// An indexed register of all of an artist's artworks\n\n\t// Enter artist address and a running number to get the artist's artwork addresses\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\n\n\t// A running number counting an artist's artworks\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t\n\n\t// Keeps track of the number of artwork contracts in the network\n\tuint256 public artworkCount;\n\n\t// An index of all the artwork contracts in the network\n\tmapping (uint256 => address) public artworkIndex;\n\n\t// All pending withdrawals\n\tmapping (address => uint256) public pendingWithdrawals;\n\tuint256 public totalPendingWithdrawals;\n\n\t// The address of the Registrar's owner\n\taddress public owner;\n\t\n\t// Determines how many Patrons are issues per donation\n\tuint256 public donationMultiplier;\n\t\n\t// Determines how many Patrons are issues per purchase of an artwork in basis points (10,000 = 100%)\n\tuint256 public patronRewardMultiplier;\n\t\n\t// Determines how much Ethart is entitled to artworks/revenue percentages in basis points (10,000 = 100%)\n\tuint256 public ethartRevenueReward;\n\tuint256 public ethartArtReward;\n\t\n\t// Determines how much of a percentage a referrer get of ethartRevenueReward\n\tuint256 public referrerReward;\n\n\t// Functions with this modifier can only be executed by a specific address\n\tmodifier onlyBy (address _account)\n\t{\n\t\trequire(msg.sender == _account);\n\t\t_;\n\t\t}\n\n\t// Functions with this modifier can only be executed by approved factory contracts\n\tmodifier registeredFactoriesOnly ()\n\t{\n\t\trequire(approvedFactories[msg.sender]);\n\t\t_;\n\t}\n\n\t// Functions with this modifier can only be executed by approved contracts\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\t// Set the referrer of an artist. This has to be done before an artist creates their first artwork.\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender] && _referrer != msg.sender)\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction getReferrer (address _artist) returns (address _referrer)\n\t\t{\n\t\t\treturn referred[_artist];\n\t\t}\n\t\n\tfunction setReferrerReward (uint256 _referrerReward) onlyBy (owner)\n\t\t{\n\t\t\tuint a;\n\t\t\tif (_referrerReward > 10000 - ethartRevenueReward) {throw;}\n\t\t\ta = 10000 / _referrerReward;\n\t\t\t// 10000 / _referrerReward has to be an even number\n\t\t\tif (a * _referrerReward != 10000) {throw;}\n\t\t\treferrerReward = _referrerReward;\n\t\t}\n\t\n\tfunction getReferrerReward () returns (uint256 _referrerReward)\n\t\t{\n\t\t\treturn referrerReward;\n\t\t}\n\n\t// Constructor\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\t\n\t\t// Donors receive 100 Patrons per 1 wei donation\n\t\tdonationMultiplier = 100;\n\t\t\n\t\t// Patrons receive 2.5 Patrons (25,000 basis points) per 1 wei purchases\n\t\tpatronRewardMultiplier = 25000;\n\t\t\n\t\t// Ethart receives 2.5% of revenues and artwork's edition sizes\n\t\tethartRevenueReward = 250;\n\t\tethartArtReward = 250;\n\t\t\n\t\t// For balanced figures patronRewardMultiplier / donationMultiplier <= ethartRevenueReward\n\t\t\n\t\t// Referrers receive 10% of ethartRevenueReward\n\t\treferrerReward = 1000;\n\t}\n\n\tfunction setPatronReward (uint256 _donationMultiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _donationMultiplier;\n\t\t\tpatronRewardMultiplier = ethartRevenueReward * _donationMultiplier;\n\t\t\tif (patronRewardMultiplier / donationMultiplier > ethartRevenueReward) {throw;}\n\t\t}\n\n\tfunction setEthartRevenueReward (uint256 _ethartRevenueReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart revenue reward can never be greater than 10%\n\t\t\tif (_ethartRevenueReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartRevenueReward;\n\t\t\t// Should 10000 / _ethartRevenueReward not be even throw\n\t\t\tif (a * _ethartRevenueReward < 10000) {throw;}\n\t\t\tethartRevenueReward = _ethartRevenueReward;\n\t\t}\n\t\n\tfunction getEthartRevenueReward () returns (uint256 _ethartRevenueReward)\n\t\t{\n\t\t\treturn ethartRevenueReward;\n\t\t}\n\n\tfunction setEthartArtReward (uint256 _ethartArtReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart art reward can never be greater than 10%\n\t\t\tif (_ethartArtReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartArtReward;\n\t\t\t// Should 10000 / _ethartArtReward not be even throw\n\t\t\tif (a * _ethartArtReward < 10000) {throw;}\n\t\t\tethartArtReward = _ethartArtReward;\n\t\t}\n\n\tfunction getEthartArtReward () returns (uint256 _ethartArtReward)\n\t\t{\n\t\t\treturn ethartArtReward;\n\t\t}\n\n\t// Allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\t// Allows approved contracts to issue Patron tokens\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount / 10000 * patronRewardMultiplier;\n\t\t\t_totalPatronSupply += _amount / 10000 * patronRewardMultiplier;\n\t\t}\n\n\t// Change the amount of Patron tokens a donor receives\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\t// Receive Patron tokens in returns for donations\n\t// Not going to worry about a theoretical Integer overflow here.\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registeredFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\t// Check if a specific sha256 hash has been used by another artwork before\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\t// Approve factory contracts\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\t\n\t// Open Zeppelin asyncSend function for pull payments\n\tfunction asyncSend (address _payee, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tpendingWithdrawals[_payee] = add(pendingWithdrawals[_payee], _amount);\n\t\t\ttotalPendingWithdrawals = add(totalPendingWithdrawals, _amount);\n\t\t}\n\n\tfunction withdrawPaymentsRegistrar (address _dest, uint256 _payment) onlyBy (owner)\n\t\t{\n\t\t\tif (_payment == 0) {\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t\tif (this.balance < _payment) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\t\n\t\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, _payment);\n\t\t\tpendingWithdrawals[this] = sub(pendingWithdrawals[this], _payment);\n\n\t\t\tif (!_dest.send(_payment)) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\tfunction withdrawPayments() {\n\t\taddress payee = msg.sender;\n\t\tuint256 payment = pendingWithdrawals[payee];\n\n\t\tif (payment == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (this.balance < payment) {\n\t\t\tthrow;\n\t\t}\n\n\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, payment);\n\t\tpendingWithdrawals[payee] = 0;\n\n\t\tif (!payee.send(payment)) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\t// Fill a bid with an unindexed piece owned by the registrar\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\t// Sell an indexed piece owned by the registrar.\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\t// Fill a bid with an indexed piece owned by the registrar\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\n\t\t}\n}",
        "debug": "calldata_Registrar_4 + calldata_Registrar_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x21cb1568",
        "lineno": 107,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 19222,
        "code": "\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\t// Owner of account approves the transfer of an amount of Patron tokens to another account\n\tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// Mitigating ERC20 short address attacks (http://vessenes.com/the-erc20-short-address-attack-explained/)\n\tmodifier onlyPayloadSize(uint size)\n\t{\n\t\trequire(msg.data.length >= size + 4);\n\t\t_;\n\t}\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n\tfunction totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorised the sender of the message via some mechanism; we propose\n \t// these standardised APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\t// To be extra secure set allowance to 0 and check that none of the allowance was spend between you sending the tx and it getting mined. Only then decrease/increase the allowance.\n\t// See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.m9fhqynw2xvt\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// BEGIN safe math functions by Open Zeppelin\n\t// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n\n\tfunction mul(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n\n\t// END safe math functions by Open Zeppelin\n\n\t// Ethart variables\n\t\n\t// Register of all SHA256 Hashes\n    mapping (bytes32 => address) public SHA256HashRegister;\n\t\n\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedFactories;\n\t\n\t// Register of all approved artwork contracts\n\t\n\t// Register of all approved contracts for amending pending withdrawals and issuing Patron tokens\n\tmapping (address => bool) public approvedContracts;\n\t\n\t// Register of all referrers (referee => referrer) used for the affiliate program\n\tmapping (address => address) public referred;\n\t\n\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\tmapping (address => bool) public cantSetReferrer;\n\n\t// Register of all artworks and their details by their respective addresses\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\n\n\t// An indexed register of all of an artist's artworks\n\n\t// Enter artist address and a running number to get the artist's artwork addresses\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\n\n\t// A running number counting an artist's artworks\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t\n\n\t// Keeps track of the number of artwork contracts in the network\n\tuint256 public artworkCount;\n\n\t// An index of all the artwork contracts in the network\n\tmapping (uint256 => address) public artworkIndex;\n\n\t// All pending withdrawals\n\tmapping (address => uint256) public pendingWithdrawals;\n\tuint256 public totalPendingWithdrawals;\n\n\t// The address of the Registrar's owner\n\taddress public owner;\n\t\n\t// Determines how many Patrons are issues per donation\n\tuint256 public donationMultiplier;\n\t\n\t// Determines how many Patrons are issues per purchase of an artwork in basis points (10,000 = 100%)\n\tuint256 public patronRewardMultiplier;\n\t\n\t// Determines how much Ethart is entitled to artworks/revenue percentages in basis points (10,000 = 100%)\n\tuint256 public ethartRevenueReward;\n\tuint256 public ethartArtReward;\n\t\n\t// Determines how much of a percentage a referrer get of ethartRevenueReward\n\tuint256 public referrerReward;\n\n\t// Functions with this modifier can only be executed by a specific address\n\tmodifier onlyBy (address _account)\n\t{\n\t\trequire(msg.sender == _account);\n\t\t_;\n\t\t}\n\n\t// Functions with this modifier can only be executed by approved factory contracts\n\tmodifier registeredFactoriesOnly ()\n\t{\n\t\trequire(approvedFactories[msg.sender]);\n\t\t_;\n\t}\n\n\t// Functions with this modifier can only be executed by approved contracts\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\t// Set the referrer of an artist. This has to be done before an artist creates their first artwork.\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender] && _referrer != msg.sender)\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction getReferrer (address _artist) returns (address _referrer)\n\t\t{\n\t\t\treturn referred[_artist];\n\t\t}\n\t\n\tfunction setReferrerReward (uint256 _referrerReward) onlyBy (owner)\n\t\t{\n\t\t\tuint a;\n\t\t\tif (_referrerReward > 10000 - ethartRevenueReward) {throw;}\n\t\t\ta = 10000 / _referrerReward;\n\t\t\t// 10000 / _referrerReward has to be an even number\n\t\t\tif (a * _referrerReward != 10000) {throw;}\n\t\t\treferrerReward = _referrerReward;\n\t\t}\n\t\n\tfunction getReferrerReward () returns (uint256 _referrerReward)\n\t\t{\n\t\t\treturn referrerReward;\n\t\t}\n\n\t// Constructor\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\t\n\t\t// Donors receive 100 Patrons per 1 wei donation\n\t\tdonationMultiplier = 100;\n\t\t\n\t\t// Patrons receive 2.5 Patrons (25,000 basis points) per 1 wei purchases\n\t\tpatronRewardMultiplier = 25000;\n\t\t\n\t\t// Ethart receives 2.5% of revenues and artwork's edition sizes\n\t\tethartRevenueReward = 250;\n\t\tethartArtReward = 250;\n\t\t\n\t\t// For balanced figures patronRewardMultiplier / donationMultiplier <= ethartRevenueReward\n\t\t\n\t\t// Referrers receive 10% of ethartRevenueReward\n\t\treferrerReward = 1000;\n\t}\n\n\tfunction setPatronReward (uint256 _donationMultiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _donationMultiplier;\n\t\t\tpatronRewardMultiplier = ethartRevenueReward * _donationMultiplier;\n\t\t\tif (patronRewardMultiplier / donationMultiplier > ethartRevenueReward) {throw;}\n\t\t}\n\n\tfunction setEthartRevenueReward (uint256 _ethartRevenueReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart revenue reward can never be greater than 10%\n\t\t\tif (_ethartRevenueReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartRevenueReward;\n\t\t\t// Should 10000 / _ethartRevenueReward not be even throw\n\t\t\tif (a * _ethartRevenueReward < 10000) {throw;}\n\t\t\tethartRevenueReward = _ethartRevenueReward;\n\t\t}\n\t\n\tfunction getEthartRevenueReward () returns (uint256 _ethartRevenueReward)\n\t\t{\n\t\t\treturn ethartRevenueReward;\n\t\t}\n\n\tfunction setEthartArtReward (uint256 _ethartArtReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart art reward can never be greater than 10%\n\t\t\tif (_ethartArtReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartArtReward;\n\t\t\t// Should 10000 / _ethartArtReward not be even throw\n\t\t\tif (a * _ethartArtReward < 10000) {throw;}\n\t\t\tethartArtReward = _ethartArtReward;\n\t\t}\n\n\tfunction getEthartArtReward () returns (uint256 _ethartArtReward)\n\t\t{\n\t\t\treturn ethartArtReward;\n\t\t}\n\n\t// Allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\t// Allows approved contracts to issue Patron tokens\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount / 10000 * patronRewardMultiplier;\n\t\t\t_totalPatronSupply += _amount / 10000 * patronRewardMultiplier;\n\t\t}\n\n\t// Change the amount of Patron tokens a donor receives\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\t// Receive Patron tokens in returns for donations\n\t// Not going to worry about a theoretical Integer overflow here.\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registeredFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\t// Check if a specific sha256 hash has been used by another artwork before\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\t// Approve factory contracts\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\t\n\t// Open Zeppelin asyncSend function for pull payments\n\tfunction asyncSend (address _payee, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tpendingWithdrawals[_payee] = add(pendingWithdrawals[_payee], _amount);\n\t\t\ttotalPendingWithdrawals = add(totalPendingWithdrawals, _amount);\n\t\t}\n\n\tfunction withdrawPaymentsRegistrar (address _dest, uint256 _payment) onlyBy (owner)\n\t\t{\n\t\t\tif (_payment == 0) {\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t\tif (this.balance < _payment) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\t\n\t\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, _payment);\n\t\t\tpendingWithdrawals[this] = sub(pendingWithdrawals[this], _payment);\n\n\t\t\tif (!_dest.send(_payment)) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\tfunction withdrawPayments() {\n\t\taddress payee = msg.sender;\n\t\tuint256 payment = pendingWithdrawals[payee];\n\n\t\tif (payment == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (this.balance < payment) {\n\t\t\tthrow;\n\t\t}\n\n\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, payment);\n\t\tpendingWithdrawals[payee] = 0;\n\n\t\tif (!payee.send(payment)) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\t// Fill a bid with an unindexed piece owned by the registrar\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\t// Sell an indexed piece owned by the registrar.\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\t// Fill a bid with an indexed piece owned by the registrar\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\n\t\t}\n}",
        "debug": "calldata_Registrar_4 + calldata_Registrar_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x21cb1568",
        "lineno": 107,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 19244,
        "code": "\tstring public constant name = \"Patron - Ethart Network Token\";\n\tuint8 public constant decimals = 18;\n\tuint256 _totalPatronSupply;\n\n\tevent Transfer(address indexed _from, address _to, uint256 _value);\n\tevent Approval(address indexed _owner, address _spender, uint256 _value);\n\tevent Burn(address indexed _owner, uint256 _amount);\n\n    // Patron token balances for each account\n\tmapping(address => uint256) public balances;\t\t\t\t\t\t// Patron token balances\n\n\tevent NewArtwork(address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros);\n\n\t// Owner of account approves the transfer of an amount of Patron tokens to another account\n\tmapping(address => mapping (address => uint256)) allowed;\t\t\t// Patron token allowances\n\t\n\t// Mitigating ERC20 short address attacks (http://vessenes.com/the-erc20-short-address-attack-explained/)\n\tmodifier onlyPayloadSize(uint size)\n\t{\n\t\trequire(msg.data.length >= size + 4);\n\t\t_;\n\t}\n\t\n\t// BEGIN ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\n\tfunction totalSupply() constant returns (uint256 totalPatronSupply) {\n\t\ttotalPatronSupply = _totalPatronSupply;\n\t\t}\n\n\t// What is the balance of a particular account?\n\tfunction balanceOf(address _owner) constant returns (uint256 balance) {\n \t\treturn balances[_owner];\n\t\t}\n\n\t// Transfer the balance from owner's account to another account\n\tfunction transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[msg.sender] >= _amount \n\t\t\t&& _amount > 0\n \t\t   \t&& balances[_to] + _amount > balances[_to]\n\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t{\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\n\t\t\tTransfer(msg.sender, _to, _amount);\n \t\t   \treturn true;\n\t\t\t}\n\t\t\telse { return false;}\n \t\t }\n\n\t// Send _value amount of tokens from address _from to address _to\n\t// The transferFrom method is used for a withdraw workflow, allowing contracts to send\n \t// tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n \t// fees in sub-currencies; the command should fail unless the _from account has\n \t// deliberately authorised the sender of the message via some mechanism; we propose\n \t// these standardised APIs for approval:\n \tfunction transferFrom( address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) returns (bool success)\n\t\t{\n\t\t\tif (balances[_from] >= _amount\n\t\t\t\t&& allowed[_from][msg.sender] >= _amount\n\t\t\t\t&& _amount > 0\n\t\t\t\t&& balances[_to] + _amount > balances[_to]\n\t\t\t\t&& _to != 0x0)\t\t\t\t\t\t\t\t\t\t// use burn() instead\n\t\t\t\t\t{\n\t\t\t\t\tbalances[_from] -= _amount;\n\t\t\t\t\tallowed[_from][msg.sender] -= _amount;\n\t\t\t\t\tbalances[_to] += _amount;\n\t\t\t\t\tTransfer(_from, _to, _amount);\n\t\t\t\t\treturn true;\n\t\t\t\t\t} else {return false;}\n\t\t}\n\n\t// Allow _spender to withdraw from your account, multiple times, up to the _value amount.\n\t// If this function is called again it overwrites the current allowance with _value.\n\t// To be extra secure set allowance to 0 and check that none of the allowance was spend between you sending the tx and it getting mined. Only then decrease/increase the allowance.\n\t// See https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/edit#heading=h.m9fhqynw2xvt\n\tfunction approve(address _spender, uint256 _amount) returns (bool success) {\n\t\tallowed[msg.sender][_spender] = _amount;\n\t\tApproval(msg.sender, _spender, _amount);\n\t\treturn true;\n\t\t}\n\n\tfunction allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n\t\treturn allowed[_owner][_spender];\n\t\t}\n\n\t// END ERC20 functions (c) BokkyPooBah 2017. The MIT Licence.\n\t\n\t// Additional Patron token functions\n\t\n\tfunction burn(uint256 _amount) returns (bool success) {\n\t\t\tif (balances[msg.sender] >= _amount) {\n\t\t\t\tbalances[msg.sender] -= _amount;\n\t\t\t\t_totalPatronSupply -= _amount;\n\t\t\t\tBurn(msg.sender, _amount);\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\tfunction burnFrom(address _from, uint256 _value) onlyPayloadSize(2 * 32) returns (bool success) {\n\t\tif (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) {\n\t\t\tbalances[_from] -= _value;\n\t\t\tallowed[_from][msg.sender] -= _value;\n\t\t\t_totalPatronSupply -= _value;\n\t\t\tBurn(_from, _value);\n\t\t\treturn true;\n\t\t}\n\t\telse {throw;}\n\t}\n\n\t// BEGIN safe math functions by Open Zeppelin\n\t// https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol\n\n\tfunction mul(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a * b;\n\t\tassert(a == 0 || c / a == b);\n\t\treturn c;\n\t}\n\n\tfunction div(uint256 a, uint256 b) internal returns (uint256) {\n\t\t// assert(b > 0); // Solidity automatically throws when dividing by 0\n\t\tuint256 c = a / b;\n\t\t// assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\t\treturn c;\n\t}\n\n\tfunction sub(uint256 a, uint256 b) internal returns (uint256) {\n\t\tassert(b <= a);\n\t\treturn a - b;\n\t}\n\n\tfunction add(uint256 a, uint256 b) internal returns (uint256) {\n\t\tuint256 c = a + b;\n\t\tassert(c >= a);\n\t\treturn c;\n\t}\n\n\t// END safe math functions by Open Zeppelin\n\n\t// Ethart variables\n\t\n\t// Register of all SHA256 Hashes\n    mapping (bytes32 => address) public SHA256HashRegister;\n\t\n\t// Register of all approved factory contracts\n\tmapping (address => bool) public approvedFactories;\n\t\n\t// Register of all approved artwork contracts\n\t\n\t// Register of all approved contracts for amending pending withdrawals and issuing Patron tokens\n\tmapping (address => bool) public approvedContracts;\n\t\n\t// Register of all referrers (referee => referrer) used for the affiliate program\n\tmapping (address => address) public referred;\n\t\n\t// Referrer for an artist has to be set _before_ the first piece has been created by an address\n\tmapping (address => bool) public cantSetReferrer;\n\n\t// Register of all artworks and their details by their respective addresses\n\tstruct artwork {\n\t\tbytes32 SHA256Hash;\n\t\tuint256 editionSize;\n\t\tstring title;\n\t\tstring fileLink;\n\t\tuint256 ownerCommission;\n\t\taddress artist;\n\t\taddress factory;\n\t\tbool isIndexed;\n\t\tbool isOuroboros;}\n\t\n\tmapping (address => artwork) public artworkRegister;\n\n\t// An indexed register of all of an artist's artworks\n\n\t// Enter artist address and a running number to get the artist's artwork addresses\n\tmapping(address => mapping (uint256 => address)) public artistsArtworks;\n\n\t// A running number counting an artist's artworks\n\tmapping(address => uint256) public artistsArtworkCount;\t\t\t\t\t\t\n\n\t// Keeps track of the number of artwork contracts in the network\n\tuint256 public artworkCount;\n\n\t// An index of all the artwork contracts in the network\n\tmapping (uint256 => address) public artworkIndex;\n\n\t// All pending withdrawals\n\tmapping (address => uint256) public pendingWithdrawals;\n\tuint256 public totalPendingWithdrawals;\n\n\t// The address of the Registrar's owner\n\taddress public owner;\n\t\n\t// Determines how many Patrons are issues per donation\n\tuint256 public donationMultiplier;\n\t\n\t// Determines how many Patrons are issues per purchase of an artwork in basis points (10,000 = 100%)\n\tuint256 public patronRewardMultiplier;\n\t\n\t// Determines how much Ethart is entitled to artworks/revenue percentages in basis points (10,000 = 100%)\n\tuint256 public ethartRevenueReward;\n\tuint256 public ethartArtReward;\n\t\n\t// Determines how much of a percentage a referrer get of ethartRevenueReward\n\tuint256 public referrerReward;\n\n\t// Functions with this modifier can only be executed by a specific address\n\tmodifier onlyBy (address _account)\n\t{\n\t\trequire(msg.sender == _account);\n\t\t_;\n\t\t}\n\n\t// Functions with this modifier can only be executed by approved factory contracts\n\tmodifier registeredFactoriesOnly ()\n\t{\n\t\trequire(approvedFactories[msg.sender]);\n\t\t_;\n\t}\n\n\t// Functions with this modifier can only be executed by approved contracts\n\tmodifier approvedContractsOnly ()\n\t{\n\t\trequire(approvedContracts[msg.sender]);\n\t\t_;\n\t}\n\n\t// Set the referrer of an artist. This has to be done before an artist creates their first artwork.\n\tfunction setReferrer (address _referrer)\n\t\t{\n\t\t\tif (referred[msg.sender] == 0x0 && !cantSetReferrer[msg.sender] && _referrer != msg.sender)\n\t\t\t{\n\t\t\t\treferred[msg.sender] = _referrer;\n\t\t\t}\n\t\t}\n\n\tfunction getReferrer (address _artist) returns (address _referrer)\n\t\t{\n\t\t\treturn referred[_artist];\n\t\t}\n\t\n\tfunction setReferrerReward (uint256 _referrerReward) onlyBy (owner)\n\t\t{\n\t\t\tuint a;\n\t\t\tif (_referrerReward > 10000 - ethartRevenueReward) {throw;}\n\t\t\ta = 10000 / _referrerReward;\n\t\t\t// 10000 / _referrerReward has to be an even number\n\t\t\tif (a * _referrerReward != 10000) {throw;}\n\t\t\treferrerReward = _referrerReward;\n\t\t}\n\t\n\tfunction getReferrerReward () returns (uint256 _referrerReward)\n\t\t{\n\t\t\treturn referrerReward;\n\t\t}\n\n\t// Constructor\n\tfunction Registrar () {\n\t\towner = msg.sender;\n\t\t\n\t\t// Donors receive 100 Patrons per 1 wei donation\n\t\tdonationMultiplier = 100;\n\t\t\n\t\t// Patrons receive 2.5 Patrons (25,000 basis points) per 1 wei purchases\n\t\tpatronRewardMultiplier = 25000;\n\t\t\n\t\t// Ethart receives 2.5% of revenues and artwork's edition sizes\n\t\tethartRevenueReward = 250;\n\t\tethartArtReward = 250;\n\t\t\n\t\t// For balanced figures patronRewardMultiplier / donationMultiplier <= ethartRevenueReward\n\t\t\n\t\t// Referrers receive 10% of ethartRevenueReward\n\t\treferrerReward = 1000;\n\t}\n\n\tfunction setPatronReward (uint256 _donationMultiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _donationMultiplier;\n\t\t\tpatronRewardMultiplier = ethartRevenueReward * _donationMultiplier;\n\t\t\tif (patronRewardMultiplier / donationMultiplier > ethartRevenueReward) {throw;}\n\t\t}\n\n\tfunction setEthartRevenueReward (uint256 _ethartRevenueReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart revenue reward can never be greater than 10%\n\t\t\tif (_ethartRevenueReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartRevenueReward;\n\t\t\t// Should 10000 / _ethartRevenueReward not be even throw\n\t\t\tif (a * _ethartRevenueReward < 10000) {throw;}\n\t\t\tethartRevenueReward = _ethartRevenueReward;\n\t\t}\n\t\n\tfunction getEthartRevenueReward () returns (uint256 _ethartRevenueReward)\n\t\t{\n\t\t\treturn ethartRevenueReward;\n\t\t}\n\n\tfunction setEthartArtReward (uint256 _ethartArtReward) onlyBy (owner)\n\t\t{\n\t\t\tuint256 a;\n\t\t\t// Ethart art reward can never be greater than 10%\n\t\t\tif (_ethartArtReward >1000) {throw;}\n\t\t\ta = 10000 / _ethartArtReward;\n\t\t\t// Should 10000 / _ethartArtReward not be even throw\n\t\t\tif (a * _ethartArtReward < 10000) {throw;}\n\t\t\tethartArtReward = _ethartArtReward;\n\t\t}\n\n\tfunction getEthartArtReward () returns (uint256 _ethartArtReward)\n\t\t{\n\t\t\treturn ethartArtReward;\n\t\t}\n\n\t// Allows the current owner to assign a new owner\n\tfunction changeOwner (address newOwner) onlyBy (owner) \n\t\t{\n\t\t\towner = newOwner;\n\t\t}\n\n\t// Allows approved contracts to issue Patron tokens\n\tfunction issuePatrons (address _to, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tbalances[_to] += _amount / 10000 * patronRewardMultiplier;\n\t\t\t_totalPatronSupply += _amount / 10000 * patronRewardMultiplier;\n\t\t}\n\n\t// Change the amount of Patron tokens a donor receives\n\tfunction setDonationReward (uint256 _multiplier) onlyBy (owner)\n\t\t{\n\t\t\tdonationMultiplier = _multiplier;\n\t\t}\n\n\t// Receive Patron tokens in returns for donations\n\t// Not going to worry about a theoretical Integer overflow here.\n\tfunction donate () payable\n\t\t{\n\t\t\tbalances[msg.sender] += msg.value * donationMultiplier;\n\t\t\t_totalPatronSupply += msg.value * donationMultiplier;\n\t\t}\n\n\tfunction registerArtwork (address _contract, bytes32 _SHA256Hash, uint256 _editionSize, string _title, string _fileLink, uint256 _ownerCommission, address _artist, bool _indexed, bool _ouroboros) registeredFactoriesOnly\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0) {\n\t\t   \tSHA256HashRegister[_SHA256Hash] = _contract;\n\t\t\tapprovedContracts[_contract] = true;\n\t\t\tcantSetReferrer[_artist] = true;\n\t\t\tartworkRegister[_contract].SHA256Hash = _SHA256Hash;\n\t\t\tartworkRegister[_contract].editionSize = _editionSize;\n\t\t\tartworkRegister[_contract].title = _title;\n\t\t\tartworkRegister[_contract].fileLink = _fileLink;\n\t\t\tartworkRegister[_contract].ownerCommission = _ownerCommission;\n\t\t\tartworkRegister[_contract].artist = _artist;\n\t\t\tartworkRegister[_contract].factory = msg.sender;\n\t\t\tartworkRegister[_contract].isIndexed = _indexed;\n\t\t\tartworkRegister[_contract].isOuroboros = _ouroboros;\n\t\t\tartworkIndex[artworkCount] = _contract;\n\t\t\tartistsArtworks[_artist][artistsArtworkCount[_artist]] = _contract;\n\t\t\tartistsArtworkCount[_artist]++;\n\t\t\tNewArtwork (_contract, _SHA256Hash, _editionSize, _title, _fileLink, _ownerCommission, _artist, _indexed, _ouroboros);\n\t\t\tartworkCount++;\n\t\t\t}\n\t\t\telse {throw;}\n\t\t}\n\n\t// Check if a specific sha256 hash has been used by another artwork before\n\tfunction isSHA256HashRegistered (bytes32 _SHA256Hash) returns (bool _registered)\n\t\t{\n\t\tif (SHA256HashRegister[_SHA256Hash] == 0x0)\n\t\t\t{return false;}\n\t\telse {return true;}\n\t\t}\n\n\t// Approve factory contracts\n\tfunction approveFactoryContract (address _factoryContractAddress, bool _approved) onlyBy (owner)\n\t\t{\n\t\t\tapprovedFactories[_factoryContractAddress] = _approved;\n\t\t}\n\t\n\t// Open Zeppelin asyncSend function for pull payments\n\tfunction asyncSend (address _payee, uint256 _amount) approvedContractsOnly\n\t\t{\n\t\t\tpendingWithdrawals[_payee] = add(pendingWithdrawals[_payee], _amount);\n\t\t\ttotalPendingWithdrawals = add(totalPendingWithdrawals, _amount);\n\t\t}\n\n\tfunction withdrawPaymentsRegistrar (address _dest, uint256 _payment) onlyBy (owner)\n\t\t{\n\t\t\tif (_payment == 0) {\n\t\t\t\tthrow;\n\t\t\t}\n\n\t\t\tif (this.balance < _payment) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t\t\n\t\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, _payment);\n\t\t\tpendingWithdrawals[this] = sub(pendingWithdrawals[this], _payment);\n\n\t\t\tif (!_dest.send(_payment)) {\n\t\t\t\tthrow;\n\t\t\t}\n\t\t}\n\n\tfunction withdrawPayments() {\n\t\taddress payee = msg.sender;\n\t\tuint256 payment = pendingWithdrawals[payee];\n\n\t\tif (payment == 0) {\n\t\t\tthrow;\n\t\t}\n\n\t\tif (this.balance < payment) {\n\t\t\tthrow;\n\t\t}\n\n\t\ttotalPendingWithdrawals = sub(totalPendingWithdrawals, payment);\n\t\tpendingWithdrawals[payee] = 0;\n\n\t\tif (!payee.send(payment)) {\n\t\t\tthrow;\n\t\t}\n\t}\n\n\tfunction transferByAddress (address _contract, uint256 _amount, address _to) onlyBy (owner) \n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transfer(_to, _amount);\n\t\t}\n\n\tfunction transferIndexedByAddress (address _contract, uint256 _index, address _to) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.transferIndexed(_to, _index);\n\t\t}\n\n\tfunction approveByAddress (address _contract, address _spender, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approve(_spender, _amount);\n\t\t}\t\n\n\tfunction approveIndexedByAddress (address _contract, address _spender, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.approveIndexed(_spender, _index);\n\t\t}\n\n\tfunction burnByAddress (address _contract, uint256 _amount) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burn(_amount);\n\t\t}\n\n\tfunction burnFromByAddress (address _contract, uint256 _amount, address _from) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnFrom (_from, _amount);\n\t\t}\n\n\tfunction burnIndexedByAddress (address _contract, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexed(_index);\n\t\t}\n\n\tfunction burnIndexedFromByAddress (address _contract, address _from, uint256 _index) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.burnIndexedFrom(_from, _index);\n\t\t}\n\n\tfunction offerPieceForSaleByAddress (address _contract, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerPieceForSale(_price);\n\t\t}\n\n\t// Fill a bid with an unindexed piece owned by the registrar\n\tfunction fillBidByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillBid();\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelSaleByAddress (address _contract) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelSale();\n\t\t}\n\n\t// Sell an indexed piece owned by the registrar.\n\tfunction offerIndexedPieceForSaleByAddress (address _contract, uint256 _index, uint256 _price) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.offerIndexedPieceForSale(_index, _price);\n\t\t}\n\n\t// Fill a bid with an indexed piece owned by the registrar\n\tfunction fillIndexedBidByAddress (address _contract, uint256 _index) onlyBy (owner)\t\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.fillIndexedBid(_index);\n\t\t}\n\n\t// Cancel the sale of an unindexed piece owned by the registrar\n\tfunction cancelIndexedSaleByAddress (address _contract) onlyBy (owner)\n\t\t{\n\t\t\tInterface c = Interface(_contract);\n\t\t\tc.cancelIndexedSale();\n\t\t}\n\t\n\t// use donate () for donations and you will get donationMultiplier * your donation in Patron tokens. Yay!\n\tfunction() payable\n\t\t{\n\t\t\tif (!approvedContracts[msg.sender]) {throw;}\n\t\t}\n}",
        "debug": "keccac_2_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Registrar_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Registrar_4 + calldata_Registrar_32 + 68: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_Registrar_32_+_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Registrar_0: 0x21cb156800000000000000000000000000000000000000000000000000000000\ncalldatasize_Registrar: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x21cb1568`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/41/0xc636277b8250e62632467b7db19ed9111e25eb99.sol",
        "function": "_function_0x21cb1568",
        "lineno": 107,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}