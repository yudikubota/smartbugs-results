{"error": null, "issues": [{"address": 385, "code": "f(address _owner) public con", "debug": "", "description": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/26/0x5a4cdcb676d40d939d013bb50909e835b8e3cabe.sol", "function": "fallback", "lineno": 138, "title": "Transaction order dependence", "type": "Warning"}, {"address": 958, "code": "\n\t\t\towner = _newOwner;\n\t\t}\n\t}", "debug": "calldata_VEGIGInterface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_VEGIGInterface_0: 0x501a4d6800000000000000000000000000000000000000000000000000000000\ncalldatasize_VEGIGInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `changeNameSymbol(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0x5a4cdcb676d40d939d013bb50909e835b8e3cabe.sol", "function": "changeNameSymbol(string,string)", "lineno": 240, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5518, "code": "btractedValue) public\n\t\t\treturns (bool succe", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VEGIGInterface_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_VEGIGInterface_32 + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_VEGIGInterface_0: 0xd73dd62300000000000000000000000000000000000000000000000000000000\ncalldatasize_VEGIGInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0xd73dd623`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0x5a4cdcb676d40d939d013bb50909e835b8e3cabe.sol", "function": "_function_0xd73dd623", "lineno": 218, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6123, "code": "ing public symbol = \"VGIG\";\n\t\tstring public name = \"VEGIG\";\n\t\tuint8 public constant decimals = 8;\n\t\tuint256 public constant _totalSupply = 19000000000000000;\n      \n\t\t// Owner of this contract\n\t\taddress public owner;\n   \n\t\t// Balances for each account\n\t\tmapping(address => uint256) balances;\n   \n\t\t// Owner of account approves the transfer of an amount to another account\n\t\tmapping(address => mapping (address => uint256)) allowed;\n   \n\t\t// Functions with this modifier can only be executed by the owner\n\t\tmodifier onlyOwner() {          \n\t\t\trequire(msg.sender == owner);\n\t\t\t_;\t\t  \n\t\t}\n\t  \n\t\t// Functions with this modifier can only be executed not to this contract. This is to avoid sending ERC20 tokens to this contract address\n\t\tmodifier notThisContract(address _to) {\t\t\n\t\t\trequire(_to != address(this));\n\t\t\t_;\t\t\t  \n\t\t}\n   \n\t\t// Constructor\n\t\tfunction VEGIGCrypto() public {\t  \n\t\t\towner = msg.sender;\n\t\t\tbalances[owner] = _totalSupply;\t\t  \n\t\t}\n      \n\t\t// This is safety mechanism to allow ETH (if any) in this contract address to be sent to the contract owner\n\t\tfunction () payable public {\n\t\t\tif(this.balance > 1000000000000000000){\n\t\t\t\towner.transfer(this.balance);\n\t\t\t}\n\t\t}\n\n\t\t// Returns the account balance of another account with address _owner.\n\t\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n\t\t\treturn balances[_owner];\n\t\t}\n\t  \n\t\t// Returns the total token supply.\n\t\tfunction totalSupply() public constant returns (uint256 totSupply) {\n\t\t\treturn _totalSupply;\n\t\t}\n\t    \n\t\t// Transfer the balance from owner's account to another account\n\t\tfunction transfer(address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\n\t\t\trequire(_to != 0x0);\n\t\t\trequire(_amount > 0);\n\t\t\trequire(balances[msg.sender] >= _amount);\n\t\t\trequire(balances[_to] + _amount > balances[_to]);\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\t\t  \n\t\t\tTransfer(msg.sender, _to, _amount);\n\t\t\treturn true;\t \n\t\t}\n   \n\t\t// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \n\t\t// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \n\t\t// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\n\t\t// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\n\t\tfunction transferFrom( address _from, address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\t\n\t\t\n\t\t   require(balances[_from] >= _amount);\n\t\t   require(allowed[_from][msg.sender] >= _amount);\n\t\t   require(_amount > 0);\n\t\t   require(balances[_to] + _amount > balances[_to]);\n\t\t   \n\t\t   balances[_from] -= _amount;\n           allowed[_from][msg.sender] -= _amount;\n           balances[_to] += _amount;\n           Transfer(_from, _to, _amount);\n           return true;        \n\t\t}\n\t \n\t\t// Allows _spender to withdraw from your account multiple times, up to the _value amount. \n\t\t// If this function is called again it overwrites the current allowance with _value\n\t\t// To change the approve amount you first have to reduce the addresses`\n\t\t// allowance to zero by calling `approve(_spender, 0)` if it is not\n\t\t// already 0 to mitigate the race condition described here:\n\t\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729   \t\t\n\t\tfunction approve(address _spender, uint256 _amount) public returns (bool) {\t\t\n\t\t\n\t\t\trequire((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\t\t  \n\t\t\tallowed[msg.sender][_spender] = _amount;\n\t\t\tApproval(msg.sender, _spender, _amount);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// Returns the amount which _spender is still allowed to withdraw from _owner\n\t\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\t\t\treturn allowed[_owner][_spender];\n\t\t}\n\t\t\n\t\tfunction send(address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\n\t\t    return transfer(_to, _amount);\n\t\t}\n\t\t\n\t\tfunction sendFrom( address _from, address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\t\n\t\t    return transferFrom(_from, _to, _amount);\n\t\t}\n\t\t   \n\t\t// Approve should be called when allowed[_spender] == 0. To increment\n\t\t// allowed value is better to use this function to avoid 2 calls (and wait until \n\t\t// the first transaction is mined)\n\t\t// From MonolithDAO Token.sol\n\t\tfunction increaseApproval (address _spender, uint _addedValue) public \n\t\t\treturns (bool success) {\n\t\t\t\n\t\t\tallowed[msg.sender][_spender] += _addedValue;\n\t\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Decrease approval\n\t\tfunction decreaseApproval (address _spender, uint _subtractedValue) public\n\t\t\treturns (bool success) {\n\t\t\t\n\t\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\t\t\n\t\t\tif (_subtractedValue > oldValue) {\n\t\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t\t} else {\n\t\t\t\tallowed[msg.sender][_spender] -= _subtractedValue;\n\t\t\t}\n\t\t\t\n\t\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\t\treturn true;\n\t\t}\n\t\t\t\t\t\t\n\t\t// Change the name and symbol assigned to this contract\n\t\tfunction changeNameSymbol(string _name, string _symbol) public onlyOwner {\n\t\t\tname = _name;\n\t\t\tsymbol = _symbol;\n\t\t}\n\t\t\n\t\t// Transfer owner of contract to a new owner\n\t\tfunction transferOwnership(address _newOwner) public onlyOwner {\n\t\t\towner = _newOwner;\n\t\t}\n\t}", "debug": "storage_1: 0x5fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_VEGIGInterface_4 + calldata_VEGIGInterface_4)): 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_VEGIGInterface_4 + calldata_VEGIGInterface_4: 0x0\nstorage_2: 0x0\ncaller: 0x0\ncalldata_VEGIGInterface_0: 0x501a4d6800000000000000000000000000000000000000000000000000000000\ncalldatasize_VEGIGInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `changeNameSymbol(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0x5a4cdcb676d40d939d013bb50909e835b8e3cabe.sol", "function": "changeNameSymbol(string,string)", "lineno": 98, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6137, "code": "ing public symbol = \"VGIG\";\n\t\tstring public name = \"VEGIG\";\n\t\tuint8 public constant decimals = 8;\n\t\tuint256 public constant _totalSupply = 19000000000000000;\n      \n\t\t// Owner of this contract\n\t\taddress public owner;\n   \n\t\t// Balances for each account\n\t\tmapping(address => uint256) balances;\n   \n\t\t// Owner of account approves the transfer of an amount to another account\n\t\tmapping(address => mapping (address => uint256)) allowed;\n   \n\t\t// Functions with this modifier can only be executed by the owner\n\t\tmodifier onlyOwner() {          \n\t\t\trequire(msg.sender == owner);\n\t\t\t_;\t\t  \n\t\t}\n\t  \n\t\t// Functions with this modifier can only be executed not to this contract. This is to avoid sending ERC20 tokens to this contract address\n\t\tmodifier notThisContract(address _to) {\t\t\n\t\t\trequire(_to != address(this));\n\t\t\t_;\t\t\t  \n\t\t}\n   \n\t\t// Constructor\n\t\tfunction VEGIGCrypto() public {\t  \n\t\t\towner = msg.sender;\n\t\t\tbalances[owner] = _totalSupply;\t\t  \n\t\t}\n      \n\t\t// This is safety mechanism to allow ETH (if any) in this contract address to be sent to the contract owner\n\t\tfunction () payable public {\n\t\t\tif(this.balance > 1000000000000000000){\n\t\t\t\towner.transfer(this.balance);\n\t\t\t}\n\t\t}\n\n\t\t// Returns the account balance of another account with address _owner.\n\t\tfunction balanceOf(address _owner) public constant returns (uint256 balance) {\n\t\t\treturn balances[_owner];\n\t\t}\n\t  \n\t\t// Returns the total token supply.\n\t\tfunction totalSupply() public constant returns (uint256 totSupply) {\n\t\t\treturn _totalSupply;\n\t\t}\n\t    \n\t\t// Transfer the balance from owner's account to another account\n\t\tfunction transfer(address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\n\t\t\trequire(_to != 0x0);\n\t\t\trequire(_amount > 0);\n\t\t\trequire(balances[msg.sender] >= _amount);\n\t\t\trequire(balances[_to] + _amount > balances[_to]);\n\t\t\tbalances[msg.sender] -= _amount;\n\t\t\tbalances[_to] += _amount;\t\t  \n\t\t\tTransfer(msg.sender, _to, _amount);\n\t\t\treturn true;\t \n\t\t}\n   \n\t\t// The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. \n\t\t// This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in sub-currencies. \n\t\t// The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism.\n\t\t// Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event.\n\t\tfunction transferFrom( address _from, address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\t\n\t\t\n\t\t   require(balances[_from] >= _amount);\n\t\t   require(allowed[_from][msg.sender] >= _amount);\n\t\t   require(_amount > 0);\n\t\t   require(balances[_to] + _amount > balances[_to]);\n\t\t   \n\t\t   balances[_from] -= _amount;\n           allowed[_from][msg.sender] -= _amount;\n           balances[_to] += _amount;\n           Transfer(_from, _to, _amount);\n           return true;        \n\t\t}\n\t \n\t\t// Allows _spender to withdraw from your account multiple times, up to the _value amount. \n\t\t// If this function is called again it overwrites the current allowance with _value\n\t\t// To change the approve amount you first have to reduce the addresses`\n\t\t// allowance to zero by calling `approve(_spender, 0)` if it is not\n\t\t// already 0 to mitigate the race condition described here:\n\t\t// https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729   \t\t\n\t\tfunction approve(address _spender, uint256 _amount) public returns (bool) {\t\t\n\t\t\n\t\t\trequire((_amount == 0) || (allowed[msg.sender][_spender] == 0));\n\t\t  \n\t\t\tallowed[msg.sender][_spender] = _amount;\n\t\t\tApproval(msg.sender, _spender, _amount);\n\t\t\treturn true;\n\t\t}\n\t\t\n\t\t// Returns the amount which _spender is still allowed to withdraw from _owner\n\t\tfunction allowance(address _owner, address _spender) public constant returns (uint256 remaining) {\n\t\t\treturn allowed[_owner][_spender];\n\t\t}\n\t\t\n\t\tfunction send(address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\n\t\t    return transfer(_to, _amount);\n\t\t}\n\t\t\n\t\tfunction sendFrom( address _from, address _to, uint256 _amount) public notThisContract(_to) returns (bool success) {\t\n\t\t    return transferFrom(_from, _to, _amount);\n\t\t}\n\t\t   \n\t\t// Approve should be called when allowed[_spender] == 0. To increment\n\t\t// allowed value is better to use this function to avoid 2 calls (and wait until \n\t\t// the first transaction is mined)\n\t\t// From MonolithDAO Token.sol\n\t\tfunction increaseApproval (address _spender, uint _addedValue) public \n\t\t\treturns (bool success) {\n\t\t\t\n\t\t\tallowed[msg.sender][_spender] += _addedValue;\n\t\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\t\treturn true;\n\t\t}\n\n\t\t// Decrease approval\n\t\tfunction decreaseApproval (address _spender, uint _subtractedValue) public\n\t\t\treturns (bool success) {\n\t\t\t\n\t\t\tuint oldValue = allowed[msg.sender][_spender];\n\t\t\t\n\t\t\tif (_subtractedValue > oldValue) {\n\t\t\t\tallowed[msg.sender][_spender] = 0;\n\t\t\t} else {\n\t\t\t\tallowed[msg.sender][_spender] -= _subtractedValue;\n\t\t\t}\n\t\t\t\n\t\t\tApproval(msg.sender, _spender, allowed[msg.sender][_spender]);\n\t\t\treturn true;\n\t\t}\n\t\t\t\t\t\t\n\t\t// Change the name and symbol assigned to this contract\n\t\tfunction changeNameSymbol(string _name, string _symbol) public onlyOwner {\n\t\t\tname = _name;\n\t\t\tsymbol = _symbol;\n\t\t}\n\t\t\n\t\t// Transfer owner of contract to a new owner\n\t\tfunction transferOwnership(address _newOwner) public onlyOwner {\n\t\t\towner = _newOwner;\n\t\t}\n\t}", "debug": "calldata_VEGIGInterface_4 + calldata_VEGIGInterface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_2: 0x0\ncaller: 0x0\ncalldata_VEGIGInterface_0: 0x501a4d6800000000000000000000000000000000000000000000000000000000\ncalldatasize_VEGIGInterface: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `changeNameSymbol(string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/26/0x5a4cdcb676d40d939d013bb50909e835b8e3cabe.sol", "function": "changeNameSymbol(string,string)", "lineno": 98, "title": "Integer Overflow ", "type": "Warning"}], "success": true}