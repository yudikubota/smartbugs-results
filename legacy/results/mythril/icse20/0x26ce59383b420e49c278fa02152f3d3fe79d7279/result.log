{"error": null, "issues": [{"address": 180, "code": "\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n", "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}, {"address": 192, "code": "\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}, {"address": 195, "code": "\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}, {"address": 201, "code": "\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}, {"address": 710, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 722, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 725, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 731, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 777, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 789, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 792, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 798, "code": "       uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x3a37216edf01e4bff3729856012c233625106ffffffffffffffffffffffffff\ncalldata_Token_4 + calldata_Token_32 + 4: 0x67cfc752d384fdac7c76a8166cd8454d89836fffffffffffffffffffffffffc\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 876, "code": "t,\n     string _name,\n     uint _countDown,\n     address  _smartContract\n   \n   )\n     public\n     minEth\n     payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount){\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        airdrop.uniqueAirdrop[msg.sender]=_smartContract;\n        idCounter = airdrop.id+1;\n       }else revert('Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop');\n   }\n\n    ///@notice  Distirbutes a different quantity of tokens to all t", "debug": "calldata_Token_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n", "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 47, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1325, "code": "      airdrop.tokenSC.transfer(_addrs[i]", "debug": "storage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0x20\ncalldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe1\nmem_96 + 544 + 32*calldata_Token_4 + calldata_Token_32 + 4: 0x0\ncalldata_Token_4: 0x0\ntimestamp: 0x1\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 109, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1405, "code": "      airdrop.tokenSC.transfer(_addrs[i]", "debug": "storage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0x10\ncalldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nmem_96 + 544 + 32*calldata_Token_4 + calldata_Token_32 + 4: 0x0\ncalldata_Token_4: 0x0\ntimestamp: 0x1\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 109, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1461, "code": "      airdrop.tokenSC.transfer(_addrs[i]", "debug": "storage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc3\ncalldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe3\nmem_96 + 544 + 32*calldata_Token_4 + calldata_Token_32 + 4: 0x0\ncalldata_Token_4: 0x0\ntimestamp: 0x1\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 109, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1485, "code": "      airdrop.tokenSC.transfer(_addrs[i]", "debug": "storage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0x31fe02affe4c4ff87f87fffffffffffffffbfffffffffffffffffffffffff40\ncalldata_Token_4 + calldata_Token_32 + 4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdf\nmem_96 + 544 + 32*calldata_Token_4 + calldata_Token_32 + 4: 0x0\ncalldata_Token_4: 0x0\ntimestamp: 0x1\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 109, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1902, "code": " Countdown not finished yet\");\n    }\n\n    ///@not", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 111, "title": "Message call to external contract", "type": "Warning"}, {"address": 2208, "code": ");\n    }\n      ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x2e75e9f700000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x2e75e9f7", "lineno": 144, "title": "Exception state", "type": "Informational"}, {"address": 2730, "code": "public airdrops;\n    addre", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\ncalldata_Token_0: 0x60db508200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x60db5082", "lineno": 12, "title": "Exception state", "type": "Informational"}, {"address": 4143, "code": "= airdrops.length", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 59, "title": "Message call to external contract", "type": "Warning"}, {"address": 4216, "code": "ops[lastIndex];\n ", "debug": "storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_4143: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n", "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 60, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4242, "code": " airdrop.tokenAmoun", "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_4143: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 62, "title": "Exception state", "type": "Informational"}, {"address": 4941, "code": ",airdrop.tokenA", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0xc29bc14100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "refoundTokens(uint256,address,address)", "lineno": 126, "title": "Exception state", "type": "Informational"}, {"address": 5535, "code": " Refund eth left over from Distribution back to the airdrop creat", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "refoundTokens(uint256,address,address)", "lineno": 131, "title": "Message call to external contract", "type": "Warning"}, {"address": 5817, "code": "\n      \n    ///", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Token_4: 0x0\nstorage_0: 0x0\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 155, "title": "Exception state", "type": "Informational"}, {"address": 5840, "code": "e return (false);\n      }\n      \n    ///", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x533358015344362235a3bbb878130055345dc0c70e060460c00000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0x2ccca7feacbbc9ddca5c444787ecffaacba23f38f1f9fb9f3ffffffffffffed\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 154, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5907, "code": "e return (false);\n      }\n      \n    ///", "debug": "calldata_Token_4 + calldata_Token_32 + 4: 0x503891cb802dffffffffffffffffffffffffdfffff7ffffffffffff800000bc\nstorage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0xf473760dff3fffffffffffffffffffffffffffffffffffffffffffffffffd0c9\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x802036100000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `distributeFixed(uint256,address[],uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "distributeFixed(uint256,address[],uint256)", "lineno": 154, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5920, "code": "e return (false);\n      }\n      \n    ///", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x1f0100000000000000000000000000000000000000000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0x60fefffffffffffffffffffffffffffffffffffffffffffffffffffffffffe7\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 154, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5976, "code": "e return (false);\n      }\n      \n    ///", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x3824840387296c56128b9629800000120304002040000000000000000000000\nstorage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0xc4f88fdf64030503d7390bd1af2e1acc7ba5930f33de5e7741de7fffffffffc1\ncalldata_Token_4 + calldata_Token_32 + 4: 0x237cf6bd7c1fa121fe27c5bf236de6d2b5fbb5d91ac56041ef885dffffbfff2\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 154, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6000, "code": "e return (false);\n      }\n      \n    ///", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x40a0590f0000000000000000000000000000000000000000000000000000000\nstorage_18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*calldata_Token_4 +\n2: 0xf7ffffffffffefffff7efef1dffdffdf7eff97fffffddcb37ffbf7d7f8b3d601\ncalldata_Token_4 + calldata_Token_32 + 4: 0x3f5fa6f0fffffffffffffffffffffffffffffffffffffffffffffffffffffe6\ncalldata_Token_4: 0x0\nstorage_0: 0x1\nstorage_1: 0x0\ncaller: 0x0\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 154, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6459, "code": "xioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount of ether for the function to launch\n    modifier minEth {\n        require(msg.value >= 2000); \n        _;\n    }\n\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n        mapping(address => address) uniqueAirdrop;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n     uint _tokenAmount,\n     string _name,\n     uint _countDown,\n     address  _smartContract\n   \n   )\n     public\n     minEth\n     payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount){\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        airdrop.uniqueAirdrop[msg.sender]=_smartContract;\n        idCounter = airdrop.id+1;\n       }else revert('Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop');\n   }\n\n    ///@notice  Distirbutes a different quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _amoutToEach  The value to be distributed to each address in array form\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n        address receiver,\n        address sc\n    )\n        public\n        onlyOwner\n    {   \n        \n        Airdrop memory airdrop = airdrops[index];\n        if(isAirDropUnique(index,receiver,sc)==true){\n        airdrop.tokenSC.transfer(airdrop.distributor,airdrop.tokenAmount);\n        }else revert();\n        \n    }\n    \n    ///@notice Refund eth left over from Distribution back to the airdrop creator \n    function refundLeftOverEth (\n        uint index,\n        uint amount,\n        address reciever,\n        address sc\n    )\n        public \n        onlyOwner\n    {\n         Airdrop memory airdrop = airdrops[index];\n         if(isAirDropUnique(index,reciever,sc)==true){\n        airdrop.distributor.transfer(amount);\n         }else revert();\n    }\n      \n    ///@notice  Determines whether an aidrop is due to be distributed or not\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    function timeGone(uint index) private view returns(bool){\n        Airdrop memory airdrop = airdrops[index];\n        uint timenow=now;\n        if ( airdrop.countDown <timenow){\n            return (true);\n        }else return (false);\n      }\n      \n    ///@notice  Determines whether an aidrop unique\n    function isAirDropUnique(uint index, address receiver, address sc) private view returns(bool){\n        Airdrop storage airdrop = airdrops[index];\n        if(airdrop.uniqueAirdrop[receiver]==sc){\n            return true;\n        }else return false; \n    }\n\n    ///@notice Transfer smartContract ownership\n    function transferOwnership(address _newOwner) public onlyOwner(){\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }\n}", "debug": "calldata_Token_4 + calldata_Token_32 + 36: 0x73a0050390000c03431011496a80040301e5f9f3a8000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0xc5ffafc6ffff3fcbcefeeb6957ffbfcfe1a060c57ffffffffffffffffffff8\ncalldata_Token_0: 0x7178431200000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x71784312`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "_function_0x71784312", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6639, "code": "xioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount of ether for the function to launch\n    modifier minEth {\n        require(msg.value >= 2000); \n        _;\n    }\n\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n        mapping(address => address) uniqueAirdrop;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n     uint _tokenAmount,\n     string _name,\n     uint _countDown,\n     address  _smartContract\n   \n   )\n     public\n     minEth\n     payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount){\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        airdrop.uniqueAirdrop[msg.sender]=_smartContract;\n        idCounter = airdrop.id+1;\n       }else revert('Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop');\n   }\n\n    ///@notice  Distirbutes a different quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _amoutToEach  The value to be distributed to each address in array form\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n        address receiver,\n        address sc\n    )\n        public\n        onlyOwner\n    {   \n        \n        Airdrop memory airdrop = airdrops[index];\n        if(isAirDropUnique(index,receiver,sc)==true){\n        airdrop.tokenSC.transfer(airdrop.distributor,airdrop.tokenAmount);\n        }else revert();\n        \n    }\n    \n    ///@notice Refund eth left over from Distribution back to the airdrop creator \n    function refundLeftOverEth (\n        uint index,\n        uint amount,\n        address reciever,\n        address sc\n    )\n        public \n        onlyOwner\n    {\n         Airdrop memory airdrop = airdrops[index];\n         if(isAirDropUnique(index,reciever,sc)==true){\n        airdrop.distributor.transfer(amount);\n         }else revert();\n    }\n      \n    ///@notice  Determines whether an aidrop is due to be distributed or not\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    function timeGone(uint index) private view returns(bool){\n        Airdrop memory airdrop = airdrops[index];\n        uint timenow=now;\n        if ( airdrop.countDown <timenow){\n            return (true);\n        }else return (false);\n      }\n      \n    ///@notice  Determines whether an aidrop unique\n    function isAirDropUnique(uint index, address receiver, address sc) private view returns(bool){\n        Airdrop storage airdrop = airdrops[index];\n        if(airdrop.uniqueAirdrop[receiver]==sc){\n            return true;\n        }else return false; \n    }\n\n    ///@notice Transfer smartContract ownership\n    function transferOwnership(address _newOwner) public onlyOwner(){\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }\n}", "debug": "keccac_2_+\n18569430475105882587588266137607568536673111973893317399460219858819262702947_+\n7*storage_0: 0xff8007b08649eba518062bad4024f63b0581e1673f0b574bf7ba80dfcf20ca00\nstorage_2 +\n18569430475105882587588266137607568536673111973893317399460219858819262702947 +\n7*storage_0: 0x7403a9bcd8faddf5d1e685cff3ba22e265c519effac9cb3ec6759905c67efc51\nstorage_0: 0x413eb400000002088020000002000010576c118a884fd9a3152000004b020000\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_4143: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n", "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6668, "code": "xioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount of ether for the function to launch\n    modifier minEth {\n        require(msg.value >= 2000); \n        _;\n    }\n\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n        mapping(address => address) uniqueAirdrop;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n     uint _tokenAmount,\n     string _name,\n     uint _countDown,\n     address  _smartContract\n   \n   )\n     public\n     minEth\n     payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount){\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        airdrop.uniqueAirdrop[msg.sender]=_smartContract;\n        idCounter = airdrop.id+1;\n       }else revert('Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop');\n   }\n\n    ///@notice  Distirbutes a different quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _amoutToEach  The value to be distributed to each address in array form\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n        address receiver,\n        address sc\n    )\n        public\n        onlyOwner\n    {   \n        \n        Airdrop memory airdrop = airdrops[index];\n        if(isAirDropUnique(index,receiver,sc)==true){\n        airdrop.tokenSC.transfer(airdrop.distributor,airdrop.tokenAmount);\n        }else revert();\n        \n    }\n    \n    ///@notice Refund eth left over from Distribution back to the airdrop creator \n    function refundLeftOverEth (\n        uint index,\n        uint amount,\n        address reciever,\n        address sc\n    )\n        public \n        onlyOwner\n    {\n         Airdrop memory airdrop = airdrops[index];\n         if(isAirDropUnique(index,reciever,sc)==true){\n        airdrop.distributor.transfer(amount);\n         }else revert();\n    }\n      \n    ///@notice  Determines whether an aidrop is due to be distributed or not\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    function timeGone(uint index) private view returns(bool){\n        Airdrop memory airdrop = airdrops[index];\n        uint timenow=now;\n        if ( airdrop.countDown <timenow){\n            return (true);\n        }else return (false);\n      }\n      \n    ///@notice  Determines whether an aidrop unique\n    function isAirDropUnique(uint index, address receiver, address sc) private view returns(bool){\n        Airdrop storage airdrop = airdrops[index];\n        if(airdrop.uniqueAirdrop[receiver]==sc){\n            return true;\n        }else return false; \n    }\n\n    ///@notice Transfer smartContract ownership\n    function transferOwnership(address _newOwner) public onlyOwner(){\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }\n}", "debug": "storage_0: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_4 + calldata_Token_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_4143: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n", "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}, {"address": 6682, "code": "xioms {\n    Airdrop [] public airdrops;\n    address owner;\n    uint idCounter;\n    \n    ///@notice  Set the creator of the smart contract to be its sole owner\n    constructor () public {\n        owner = msg.sender;\n    }\n    \n    \n    ///@notice  Modifier to require a minimum amount of ether for the function to launch\n    modifier minEth {\n        require(msg.value >= 2000); \n        _;\n    }\n\n    ///@notice  Modifier that only allows the owner to execute a function\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    ///@notice  Creates a structure for airdrops, which stores all the necessary information for users to look up the history effectively and directly from the smart contract\n    struct Airdrop {\n        uint id;\n        uint tokenAmount;\n        string name;\n        uint countDown;\n        address distributor;\n        Token tokenSC;\n        mapping(address => address) uniqueAirdrop;\n    }\n\n    ///@notice  Adds a new airdrop to the smart contract and starts the count down until it is distributed\n   function addNewAirdrop(\n     uint _tokenAmount,\n     string _name,\n     uint _countDown,\n     address  _smartContract\n   \n   )\n     public\n     minEth\n     payable\n   {\n       Token t = Token(_smartContract);\n       if(t.balanceOf(this)>=_tokenAmount){\n        uint lastIndex = airdrops.length++;\n        Airdrop storage airdrop = airdrops[lastIndex];\n        airdrop.id =idCounter;\n        airdrop.tokenAmount = _tokenAmount;\n        airdrop.name=_name;\n        airdrop.countDown=_countDown;\n        airdrop.distributor = msg.sender;\n        airdrop.tokenSC = Token(_smartContract);\n        airdrop.uniqueAirdrop[msg.sender]=_smartContract;\n        idCounter = airdrop.id+1;\n       }else revert('Air Drop not added, Please make sure you send your ERC20 tokens to the smart contract before adding new airdrop');\n   }\n\n    ///@notice  Distirbutes a different quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _vals  The set of values to be distributed to each address in array form\n    function distributeVariable(\n        uint index,\n        address[] _addrs,\n        uint[] _vals\n    )\n        public\n        onlyOwner\n    {\n        if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _vals[i]);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice  Distirbutes a constant quantity of tokens to all the specified addresses\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    ///@param index  The airdrop to distribute based in the the array in which is saved\n    ///@param _addrs The set of addresses in array form, to which the airdrop will be distributed\n    ///@param _amoutToEach  The value to be distributed to each address in array form\n    function distributeFixed(\n        uint index,\n        address[] _addrs,\n        uint _amoutToEach\n    )\n        public\n        onlyOwner\n    {\n         if(timeGone(index)==true) {\n            Airdrop memory airdrop = airdrops[index];\n            for(uint i = 0; i < _addrs.length; ++i) {\n                airdrop.tokenSC.transfer(_addrs[i], _amoutToEach);\n            }\n        } else revert(\"Distribution Failed: Countdown not finished yet\");\n    }\n\n    ///@notice Refund tokens back to the to airdrop creator \n    function refoundTokens(\n        uint index,\n        address receiver,\n        address sc\n    )\n        public\n        onlyOwner\n    {   \n        \n        Airdrop memory airdrop = airdrops[index];\n        if(isAirDropUnique(index,receiver,sc)==true){\n        airdrop.tokenSC.transfer(airdrop.distributor,airdrop.tokenAmount);\n        }else revert();\n        \n    }\n    \n    ///@notice Refund eth left over from Distribution back to the airdrop creator \n    function refundLeftOverEth (\n        uint index,\n        uint amount,\n        address reciever,\n        address sc\n    )\n        public \n        onlyOwner\n    {\n         Airdrop memory airdrop = airdrops[index];\n         if(isAirDropUnique(index,reciever,sc)==true){\n        airdrop.distributor.transfer(amount);\n         }else revert();\n    }\n      \n    ///@notice  Determines whether an aidrop is due to be distributed or not\n    ///@dev Distribution will only occur when a distribute function is called and passed the correct parameters. It is not the smart contract's job to produce the addresses or determine the amounts\n    function timeGone(uint index) private view returns(bool){\n        Airdrop memory airdrop = airdrops[index];\n        uint timenow=now;\n        if ( airdrop.countDown <timenow){\n            return (true);\n        }else return (false);\n      }\n      \n    ///@notice  Determines whether an aidrop unique\n    function isAirDropUnique(uint index, address receiver, address sc) private view returns(bool){\n        Airdrop storage airdrop = airdrops[index];\n        if(airdrop.uniqueAirdrop[receiver]==sc){\n            return true;\n        }else return false; \n    }\n\n    ///@notice Transfer smartContract ownership\n    function transferOwnership(address _newOwner) public onlyOwner(){\n        require(_newOwner != address(0));\n        owner = _newOwner;\n    }\n}", "debug": "storage_0: 0x3164cdbbd7715000000000000000000000000000000000000000000000000000\ncalldata_Token_4 + calldata_Token_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Token_4 + calldata_Token_32 + 4)): 0x0\ncalldata_Token_4: 0x0\nreturndatasize: 0x20\nretval_4143: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0x7d0\ncalldata_Token_0: 0x8de4f42f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\n", "description": "A possible integer overflow exists in the function `addNewAirdrop(uint256,string,uint256,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/18/0x26ce59383b420e49c278fa02152f3d3fe79d7279.sol", "function": "addNewAirdrop(uint256,string,uint256,address)", "lineno": 11, "title": "Integer Overflow ", "type": "Warning"}], "success": true}