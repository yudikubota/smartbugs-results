{
  "contract": "0x268b7976e94e84a48bf8b2b57ba34b59ed836a74",
  "tool": "mythril",
  "start": 1563474328.8181286,
  "end": 1563474504.8291576,
  "duration": 176.01102900505066,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1047,
        "code": "r == m_administrator);\n\n    /* Create and store the new ballot objects */\n    numBallots++;\n    uint32 ballotId = numBallots;\n    ballotNames[ballotId] = _proposal;\n    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n  }\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function a",
        "debug": "calldata_ERC20Interface_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_ERC20Interface_0: 0x62ec8e5300000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `adminAddBallot(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "adminAddBallot(string,uint256,uint256)",
        "lineno": 166,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3702,
        "code": "] -= _amount;\n      all",
        "debug": "calldata_ERC20Interface_32 + 36: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ERC20Interface_32_+_4: 0x800000000000000000008eb2e34648ee0801030820000000000000000000a000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ERC20Interface_4: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\ncalldata_ERC20Interface_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 110,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5887,
        "code": "r))) {\n      balances[m",
        "debug": "calldata_ERC20Interface_32 + 4: 0xb135d1e4a0020a903239033aa9b45a69384c906b52a71e0575829626809581fd\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ERC20Interface_4: 0xa7e6e147bc0ca40011bf9bbaadf7593cb8cc90b17cb7d73775f0d8eb1435e9c1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xb135d1e4a0020a903239033aa9b45a69384c906b52a71e0575829626809581fd\ncalldata_ERC20Interface_0: 0xa9059cbb00000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transfer(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "transfer(address,uint256)",
        "lineno": 87,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8152,
        "code": "  /* ******************************\n   * COIN data / functions\n   * ******************************/\n\n  /* Token constants */\n  string public constant name = 'AICoin';\n  string public constant symbol = 'XAI';\n  uint8 public constant decimals = 8;\n  string public constant smallestUnit = 'Hofstadter';\n\n  /* Token internal data */\n  address m_administrator;\n  uint256 m_totalSupply;\n\n  /* Current balances for each account */\n  mapping(address => uint256) balances;\n\n  /* Account holder approves the transfer of an amount to another account */\n  mapping(address => mapping (address => uint256)) allowed;\n\n  /* One-time create function: initialize the supply and set the admin address */\n  function AICoin (uint256 _initialSupply) {\n    m_administrator = msg.sender;\n    m_totalSupply = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n  }\n\n  /* Get the admin address */\n  function administrator() constant returns (address adminAddress) {\n    return m_administrator;\n  }\n\n  /* Get the total coin supply */\n  function totalSupply() constant returns (uint256 totalSupply) {\n    return m_totalSupply;\n  }\n\n  /* Get the balance of a specific account by its address */\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /* Transfer an amount from the owner's account to an indicated account */\n  function transfer(address _to, uint256 _amount) returns (bool success) {\n    if (balances[msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(msg.sender))) {\n      balances[msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(msg.sender, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Send _value amount of tokens from address _from to address _to\n   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n   * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n   * fees in sub-currencies; the command should fail unless the _from account has\n   * deliberately authorized the sender of the message via some mechanism; we propose\n   * these standardized APIs for approval:\n   */\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n    if (balances[_from] >= _amount\n        && allowed[_from][msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(_from))) {\n      balances[_from] -= _amount;\n      allowed[_from][msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(_from, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\n   * Doing so (using transferFrom) reduces the remaining authorized amount,\n   * as well as the actual account balance)\n   * Subsequent calls to this function overwrite any existing authorized amount.\n   * Therefore, to cancel an authorization, simply write a zero amount.\n   */\n  function approve(address _spender, uint256 _amount) returns (bool success) {\n    allowed[msg.sender][_spender] = _amount;\n    Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  /* ******************************\n   * BALLOT data / functions\n   * ******************************/\n\n  /* Dev Note: creating a struct that contained a string, uint values and\n   * an array of option structs, etc, would consistently fail.\n   * So the ballot details are held in separate mappings with a common integer\n   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\n   */\n\n  /* Basic ballot details: time frame and number of options */\n  struct BallotDetails {\n    uint256 start;\n    uint256 end;\n    uint32 numOptions; // 1-indexed for readability\n    bool sealed;\n  }\n\n  uint32 public numBallots = 0; // 1-indexed for readability\n  mapping (uint32 => string) public ballotNames;\n  mapping (uint32 => BallotDetails) public ballotDetails;\n  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* Create and store the new ballot objects */\n    numBallots++;\n    uint32 ballotId = numBallots;\n    ballotNames[ballotId] = _proposal;\n    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n  }\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* update the ballot object */\n    ballotNames[_ballotId] = _proposal;\n    ballotDetails[_ballotId].start = _start;\n    ballotDetails[_ballotId].end = _end;\n  }\n\n  /* Add an option to an existing Ballot\n   */\n  function adminAddBallotOption(uint32 _ballotId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* store the new ballot option */\n    ballotDetails[_ballotId].numOptions += 1;\n    uint32 optionId = ballotDetails[_ballotId].numOptions;\n    ballotOptions[_ballotId][optionId] = _option;\n  }\n\n  /* Amend and option in an existing Ballot\n   */\n  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* validate the ballot option */\n    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the ballot option */\n    ballotOptions[_ballotId][_optionId] = _option;\n  }\n\n  /* Seal a ballot - after this the ballot is official and no changes can be made.\n   */\n  function adminSealBallot(uint32 _ballotId) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* set the ballot seal flag */\n    ballotDetails[_ballotId].sealed = true;\n  }\n\n  /* Function to determine if a ballot is currently in progress, based on its\n   * start and end dates, and that it has been sealed.\n   */\n  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\n    return (isBallotSealed(_ballotId)\n            && ballotDetails[_ballotId].start <= now\n            && ballotDetails[_ballotId].end >= now);\n  }\n\n  /* Function to determine if a ballot has ended, based on its end date */\n  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\n    return (ballotDetails[_ballotId].end < now);\n  }\n\n  /* Function to determine if a ballot has been sealed, which means it has been\n   * authorized by the administrator and can no longer be changed.\n   */\n  function isBallotSealed(uint32 _ballotId) private returns (bool) {\n    return ballotDetails[_ballotId].sealed;\n  }\n\n  /* ******************************\n   * VOTING data / functions\n   * ******************************/\n\n  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\n  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\n\n  /* function to allow a coin holder add to the vote count of an option in an\n   * active ballot. The votes added equals the balance of the account. Once this is called successfully\n   * the coins cannot be transferred out of the account until the end of the ballot.\n   *\n   * NB: The timing of the start and end of the voting period is determined by\n   * the timestamp of the block in which the transaction is included. As given by\n   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\n   * given external time source. Therefore, votes should be placed well in advance\n   * of the UTC end time of the Ballot.\n   */\n  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* Ballot must be in progress in order to vote */\n    require(isBallotInProgress(_ballotId));\n\n    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\n     * the current balance for the senders address and the amount they already voted in this ballot.\n     * If the difference is zero, this attempt to vote will fail.\n     */\n    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\n    require(votableBalance > 0);\n\n    /* validate the ballot option */\n    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the vote count and record the voter */\n    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\n    ballotVoters[_ballotId][msg.sender] += votableBalance;\n  }\n\n  /* function to determine if an address has already voted in a given ballot */\n  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\n    return ballotVoters[_ballotId][_voter] > 0;\n  }\n\n  /* function to determine if an account has voted in any current ballot */\n  function accountHasCurrentVote(address _voter) constant returns (bool) {\n    for(uint32 id = 1; id <= numBallots; id++) {\n      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}",
        "debug": "keccac_keccac_4294967295_&\n4294967295_&\n4294967295_&\nUDiv(256*Concat(0,_1_+_Extract(39,_8,_storage_4))_|\n_____Concat(Extract(255,_40,_storage_4),\n____________0,\n____________Extract(7,_0,_storage_4)),\n_____256): 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_keccac_4294967295_&\n4294967295_&\n4294967295_&\nUDiv(256*Concat(0,_1_+_Extract(39,_8,_storage_4))_|\n_____Concat(Extract(255,_40,_storage_4),\n____________0,\n____________Extract(7,_0,_storage_4)),\n_____256): 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_0: 0x0\ncaller: 0x0\ncalldata_ERC20Interface_0: 0x62ec8e5300000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `adminAddBallot(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "adminAddBallot(string,uint256,uint256)",
        "lineno": 40,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8181,
        "code": "  /* ******************************\n   * COIN data / functions\n   * ******************************/\n\n  /* Token constants */\n  string public constant name = 'AICoin';\n  string public constant symbol = 'XAI';\n  uint8 public constant decimals = 8;\n  string public constant smallestUnit = 'Hofstadter';\n\n  /* Token internal data */\n  address m_administrator;\n  uint256 m_totalSupply;\n\n  /* Current balances for each account */\n  mapping(address => uint256) balances;\n\n  /* Account holder approves the transfer of an amount to another account */\n  mapping(address => mapping (address => uint256)) allowed;\n\n  /* One-time create function: initialize the supply and set the admin address */\n  function AICoin (uint256 _initialSupply) {\n    m_administrator = msg.sender;\n    m_totalSupply = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n  }\n\n  /* Get the admin address */\n  function administrator() constant returns (address adminAddress) {\n    return m_administrator;\n  }\n\n  /* Get the total coin supply */\n  function totalSupply() constant returns (uint256 totalSupply) {\n    return m_totalSupply;\n  }\n\n  /* Get the balance of a specific account by its address */\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /* Transfer an amount from the owner's account to an indicated account */\n  function transfer(address _to, uint256 _amount) returns (bool success) {\n    if (balances[msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(msg.sender))) {\n      balances[msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(msg.sender, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Send _value amount of tokens from address _from to address _to\n   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n   * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n   * fees in sub-currencies; the command should fail unless the _from account has\n   * deliberately authorized the sender of the message via some mechanism; we propose\n   * these standardized APIs for approval:\n   */\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n    if (balances[_from] >= _amount\n        && allowed[_from][msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(_from))) {\n      balances[_from] -= _amount;\n      allowed[_from][msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(_from, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\n   * Doing so (using transferFrom) reduces the remaining authorized amount,\n   * as well as the actual account balance)\n   * Subsequent calls to this function overwrite any existing authorized amount.\n   * Therefore, to cancel an authorization, simply write a zero amount.\n   */\n  function approve(address _spender, uint256 _amount) returns (bool success) {\n    allowed[msg.sender][_spender] = _amount;\n    Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  /* ******************************\n   * BALLOT data / functions\n   * ******************************/\n\n  /* Dev Note: creating a struct that contained a string, uint values and\n   * an array of option structs, etc, would consistently fail.\n   * So the ballot details are held in separate mappings with a common integer\n   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\n   */\n\n  /* Basic ballot details: time frame and number of options */\n  struct BallotDetails {\n    uint256 start;\n    uint256 end;\n    uint32 numOptions; // 1-indexed for readability\n    bool sealed;\n  }\n\n  uint32 public numBallots = 0; // 1-indexed for readability\n  mapping (uint32 => string) public ballotNames;\n  mapping (uint32 => BallotDetails) public ballotDetails;\n  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* Create and store the new ballot objects */\n    numBallots++;\n    uint32 ballotId = numBallots;\n    ballotNames[ballotId] = _proposal;\n    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n  }\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* update the ballot object */\n    ballotNames[_ballotId] = _proposal;\n    ballotDetails[_ballotId].start = _start;\n    ballotDetails[_ballotId].end = _end;\n  }\n\n  /* Add an option to an existing Ballot\n   */\n  function adminAddBallotOption(uint32 _ballotId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* store the new ballot option */\n    ballotDetails[_ballotId].numOptions += 1;\n    uint32 optionId = ballotDetails[_ballotId].numOptions;\n    ballotOptions[_ballotId][optionId] = _option;\n  }\n\n  /* Amend and option in an existing Ballot\n   */\n  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* validate the ballot option */\n    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the ballot option */\n    ballotOptions[_ballotId][_optionId] = _option;\n  }\n\n  /* Seal a ballot - after this the ballot is official and no changes can be made.\n   */\n  function adminSealBallot(uint32 _ballotId) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* set the ballot seal flag */\n    ballotDetails[_ballotId].sealed = true;\n  }\n\n  /* Function to determine if a ballot is currently in progress, based on its\n   * start and end dates, and that it has been sealed.\n   */\n  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\n    return (isBallotSealed(_ballotId)\n            && ballotDetails[_ballotId].start <= now\n            && ballotDetails[_ballotId].end >= now);\n  }\n\n  /* Function to determine if a ballot has ended, based on its end date */\n  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\n    return (ballotDetails[_ballotId].end < now);\n  }\n\n  /* Function to determine if a ballot has been sealed, which means it has been\n   * authorized by the administrator and can no longer be changed.\n   */\n  function isBallotSealed(uint32 _ballotId) private returns (bool) {\n    return ballotDetails[_ballotId].sealed;\n  }\n\n  /* ******************************\n   * VOTING data / functions\n   * ******************************/\n\n  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\n  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\n\n  /* function to allow a coin holder add to the vote count of an option in an\n   * active ballot. The votes added equals the balance of the account. Once this is called successfully\n   * the coins cannot be transferred out of the account until the end of the ballot.\n   *\n   * NB: The timing of the start and end of the voting period is determined by\n   * the timestamp of the block in which the transaction is included. As given by\n   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\n   * given external time source. Therefore, votes should be placed well in advance\n   * of the UTC end time of the Ballot.\n   */\n  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* Ballot must be in progress in order to vote */\n    require(isBallotInProgress(_ballotId));\n\n    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\n     * the current balance for the senders address and the amount they already voted in this ballot.\n     * If the difference is zero, this attempt to vote will fail.\n     */\n    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\n    require(votableBalance > 0);\n\n    /* validate the ballot option */\n    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the vote count and record the voter */\n    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\n    ballotVoters[_ballotId][msg.sender] += votableBalance;\n  }\n\n  /* function to determine if an address has already voted in a given ballot */\n  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\n    return ballotVoters[_ballotId][_voter] > 0;\n  }\n\n  /* function to determine if an account has voted in any current ballot */\n  function accountHasCurrentVote(address _voter) constant returns (bool) {\n    for(uint32 id = 1; id <= numBallots; id++) {\n      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}",
        "debug": "calldata_ERC20Interface_4 + calldata_ERC20Interface_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\ncaller: 0x0\ncalldata_ERC20Interface_0: 0x62ec8e5300000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `adminAddBallot(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "adminAddBallot(string,uint256,uint256)",
        "lineno": 40,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8195,
        "code": "  /* ******************************\n   * COIN data / functions\n   * ******************************/\n\n  /* Token constants */\n  string public constant name = 'AICoin';\n  string public constant symbol = 'XAI';\n  uint8 public constant decimals = 8;\n  string public constant smallestUnit = 'Hofstadter';\n\n  /* Token internal data */\n  address m_administrator;\n  uint256 m_totalSupply;\n\n  /* Current balances for each account */\n  mapping(address => uint256) balances;\n\n  /* Account holder approves the transfer of an amount to another account */\n  mapping(address => mapping (address => uint256)) allowed;\n\n  /* One-time create function: initialize the supply and set the admin address */\n  function AICoin (uint256 _initialSupply) {\n    m_administrator = msg.sender;\n    m_totalSupply = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n  }\n\n  /* Get the admin address */\n  function administrator() constant returns (address adminAddress) {\n    return m_administrator;\n  }\n\n  /* Get the total coin supply */\n  function totalSupply() constant returns (uint256 totalSupply) {\n    return m_totalSupply;\n  }\n\n  /* Get the balance of a specific account by its address */\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /* Transfer an amount from the owner's account to an indicated account */\n  function transfer(address _to, uint256 _amount) returns (bool success) {\n    if (balances[msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(msg.sender))) {\n      balances[msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(msg.sender, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Send _value amount of tokens from address _from to address _to\n   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n   * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n   * fees in sub-currencies; the command should fail unless the _from account has\n   * deliberately authorized the sender of the message via some mechanism; we propose\n   * these standardized APIs for approval:\n   */\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n    if (balances[_from] >= _amount\n        && allowed[_from][msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(_from))) {\n      balances[_from] -= _amount;\n      allowed[_from][msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(_from, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\n   * Doing so (using transferFrom) reduces the remaining authorized amount,\n   * as well as the actual account balance)\n   * Subsequent calls to this function overwrite any existing authorized amount.\n   * Therefore, to cancel an authorization, simply write a zero amount.\n   */\n  function approve(address _spender, uint256 _amount) returns (bool success) {\n    allowed[msg.sender][_spender] = _amount;\n    Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  /* ******************************\n   * BALLOT data / functions\n   * ******************************/\n\n  /* Dev Note: creating a struct that contained a string, uint values and\n   * an array of option structs, etc, would consistently fail.\n   * So the ballot details are held in separate mappings with a common integer\n   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\n   */\n\n  /* Basic ballot details: time frame and number of options */\n  struct BallotDetails {\n    uint256 start;\n    uint256 end;\n    uint32 numOptions; // 1-indexed for readability\n    bool sealed;\n  }\n\n  uint32 public numBallots = 0; // 1-indexed for readability\n  mapping (uint32 => string) public ballotNames;\n  mapping (uint32 => BallotDetails) public ballotDetails;\n  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* Create and store the new ballot objects */\n    numBallots++;\n    uint32 ballotId = numBallots;\n    ballotNames[ballotId] = _proposal;\n    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n  }\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* update the ballot object */\n    ballotNames[_ballotId] = _proposal;\n    ballotDetails[_ballotId].start = _start;\n    ballotDetails[_ballotId].end = _end;\n  }\n\n  /* Add an option to an existing Ballot\n   */\n  function adminAddBallotOption(uint32 _ballotId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* store the new ballot option */\n    ballotDetails[_ballotId].numOptions += 1;\n    uint32 optionId = ballotDetails[_ballotId].numOptions;\n    ballotOptions[_ballotId][optionId] = _option;\n  }\n\n  /* Amend and option in an existing Ballot\n   */\n  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* validate the ballot option */\n    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the ballot option */\n    ballotOptions[_ballotId][_optionId] = _option;\n  }\n\n  /* Seal a ballot - after this the ballot is official and no changes can be made.\n   */\n  function adminSealBallot(uint32 _ballotId) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* set the ballot seal flag */\n    ballotDetails[_ballotId].sealed = true;\n  }\n\n  /* Function to determine if a ballot is currently in progress, based on its\n   * start and end dates, and that it has been sealed.\n   */\n  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\n    return (isBallotSealed(_ballotId)\n            && ballotDetails[_ballotId].start <= now\n            && ballotDetails[_ballotId].end >= now);\n  }\n\n  /* Function to determine if a ballot has ended, based on its end date */\n  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\n    return (ballotDetails[_ballotId].end < now);\n  }\n\n  /* Function to determine if a ballot has been sealed, which means it has been\n   * authorized by the administrator and can no longer be changed.\n   */\n  function isBallotSealed(uint32 _ballotId) private returns (bool) {\n    return ballotDetails[_ballotId].sealed;\n  }\n\n  /* ******************************\n   * VOTING data / functions\n   * ******************************/\n\n  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\n  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\n\n  /* function to allow a coin holder add to the vote count of an option in an\n   * active ballot. The votes added equals the balance of the account. Once this is called successfully\n   * the coins cannot be transferred out of the account until the end of the ballot.\n   *\n   * NB: The timing of the start and end of the voting period is determined by\n   * the timestamp of the block in which the transaction is included. As given by\n   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\n   * given external time source. Therefore, votes should be placed well in advance\n   * of the UTC end time of the Ballot.\n   */\n  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* Ballot must be in progress in order to vote */\n    require(isBallotInProgress(_ballotId));\n\n    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\n     * the current balance for the senders address and the amount they already voted in this ballot.\n     * If the difference is zero, this attempt to vote will fail.\n     */\n    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\n    require(votableBalance > 0);\n\n    /* validate the ballot option */\n    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the vote count and record the voter */\n    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\n    ballotVoters[_ballotId][msg.sender] += votableBalance;\n  }\n\n  /* function to determine if an address has already voted in a given ballot */\n  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\n    return ballotVoters[_ballotId][_voter] > 0;\n  }\n\n  /* function to determine if an account has voted in any current ballot */\n  function accountHasCurrentVote(address _voter) constant returns (bool) {\n    for(uint32 id = 1; id <= numBallots; id++) {\n      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}",
        "debug": "calldata_ERC20Interface_4 + calldata_ERC20Interface_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_ERC20Interface_0: 0x62ec8e5300000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `adminAddBallot(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "adminAddBallot(string,uint256,uint256)",
        "lineno": 40,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8217,
        "code": "  /* ******************************\n   * COIN data / functions\n   * ******************************/\n\n  /* Token constants */\n  string public constant name = 'AICoin';\n  string public constant symbol = 'XAI';\n  uint8 public constant decimals = 8;\n  string public constant smallestUnit = 'Hofstadter';\n\n  /* Token internal data */\n  address m_administrator;\n  uint256 m_totalSupply;\n\n  /* Current balances for each account */\n  mapping(address => uint256) balances;\n\n  /* Account holder approves the transfer of an amount to another account */\n  mapping(address => mapping (address => uint256)) allowed;\n\n  /* One-time create function: initialize the supply and set the admin address */\n  function AICoin (uint256 _initialSupply) {\n    m_administrator = msg.sender;\n    m_totalSupply = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n  }\n\n  /* Get the admin address */\n  function administrator() constant returns (address adminAddress) {\n    return m_administrator;\n  }\n\n  /* Get the total coin supply */\n  function totalSupply() constant returns (uint256 totalSupply) {\n    return m_totalSupply;\n  }\n\n  /* Get the balance of a specific account by its address */\n  function balanceOf(address _owner) constant returns (uint256 balance) {\n    return balances[_owner];\n  }\n\n  /* Transfer an amount from the owner's account to an indicated account */\n  function transfer(address _to, uint256 _amount) returns (bool success) {\n    if (balances[msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(msg.sender))) {\n      balances[msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(msg.sender, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Send _value amount of tokens from address _from to address _to\n   * The transferFrom method is used for a withdraw workflow, allowing contracts to send\n   * tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge\n   * fees in sub-currencies; the command should fail unless the _from account has\n   * deliberately authorized the sender of the message via some mechanism; we propose\n   * these standardized APIs for approval:\n   */\n  function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) {\n    if (balances[_from] >= _amount\n        && allowed[_from][msg.sender] >= _amount\n        && _amount > 0\n        && balances[_to] + _amount > balances[_to]\n        && (! accountHasCurrentVote(_from))) {\n      balances[_from] -= _amount;\n      allowed[_from][msg.sender] -= _amount;\n      balances[_to] += _amount;\n      Transfer(_from, _to, _amount);\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /* Pre-authorize an address to withdraw from your account, up to the _value amount.\n   * Doing so (using transferFrom) reduces the remaining authorized amount,\n   * as well as the actual account balance)\n   * Subsequent calls to this function overwrite any existing authorized amount.\n   * Therefore, to cancel an authorization, simply write a zero amount.\n   */\n  function approve(address _spender, uint256 _amount) returns (bool success) {\n    allowed[msg.sender][_spender] = _amount;\n    Approval(msg.sender, _spender, _amount);\n    return true;\n  }\n\n  /* Get the currently authorized that can be withdrawn by account _spender from account _owner */\n  function allowance(address _owner, address _spender) constant returns (uint256 remaining) {\n    return allowed[_owner][_spender];\n  }\n\n  /* ******************************\n   * BALLOT data / functions\n   * ******************************/\n\n  /* Dev Note: creating a struct that contained a string, uint values and\n   * an array of option structs, etc, would consistently fail.\n   * So the ballot details are held in separate mappings with a common integer\n   * key for each ballot. The IDs are 1-indexed, sequential and contiguous.\n   */\n\n  /* Basic ballot details: time frame and number of options */\n  struct BallotDetails {\n    uint256 start;\n    uint256 end;\n    uint32 numOptions; // 1-indexed for readability\n    bool sealed;\n  }\n\n  uint32 public numBallots = 0; // 1-indexed for readability\n  mapping (uint32 => string) public ballotNames;\n  mapping (uint32 => BallotDetails) public ballotDetails;\n  mapping (uint32 => mapping (uint32 => string) ) public ballotOptions;\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAddBallot(string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* Create and store the new ballot objects */\n    numBallots++;\n    uint32 ballotId = numBallots;\n    ballotNames[ballotId] = _proposal;\n    ballotDetails[ballotId] = BallotDetails(_start, _end, 0, false);\n  }\n\n  /* Create a new ballot and set the basic details (proposal description, dates)\n   * The ballot still need to have options added and then to be sealed\n   */\n  function adminAmendBallot(uint32 _ballotId, string _proposal, uint256 _start, uint256 _end) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* update the ballot object */\n    ballotNames[_ballotId] = _proposal;\n    ballotDetails[_ballotId].start = _start;\n    ballotDetails[_ballotId].end = _end;\n  }\n\n  /* Add an option to an existing Ballot\n   */\n  function adminAddBallotOption(uint32 _ballotId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* store the new ballot option */\n    ballotDetails[_ballotId].numOptions += 1;\n    uint32 optionId = ballotDetails[_ballotId].numOptions;\n    ballotOptions[_ballotId][optionId] = _option;\n  }\n\n  /* Amend and option in an existing Ballot\n   */\n  function adminEditBallotOption(uint32 _ballotId, uint32 _optionId, string _option) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* validate the ballot option */\n    require(_optionId > 0 && _optionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the ballot option */\n    ballotOptions[_ballotId][_optionId] = _option;\n  }\n\n  /* Seal a ballot - after this the ballot is official and no changes can be made.\n   */\n  function adminSealBallot(uint32 _ballotId) {\n\n    /* Admin functions must be called by the contract creator. */\n    require(msg.sender == m_administrator);\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* cannot change a ballot once it is sealed */\n    if(isBallotSealed(_ballotId)) {\n      revert();\n    }\n\n    /* set the ballot seal flag */\n    ballotDetails[_ballotId].sealed = true;\n  }\n\n  /* Function to determine if a ballot is currently in progress, based on its\n   * start and end dates, and that it has been sealed.\n   */\n  function isBallotInProgress(uint32 _ballotId) private constant returns (bool) {\n    return (isBallotSealed(_ballotId)\n            && ballotDetails[_ballotId].start <= now\n            && ballotDetails[_ballotId].end >= now);\n  }\n\n  /* Function to determine if a ballot has ended, based on its end date */\n  function hasBallotEnded(uint32 _ballotId) private constant returns (bool) {\n    return (ballotDetails[_ballotId].end < now);\n  }\n\n  /* Function to determine if a ballot has been sealed, which means it has been\n   * authorized by the administrator and can no longer be changed.\n   */\n  function isBallotSealed(uint32 _ballotId) private returns (bool) {\n    return ballotDetails[_ballotId].sealed;\n  }\n\n  /* ******************************\n   * VOTING data / functions\n   * ******************************/\n\n  mapping (uint32 => mapping (address => uint256) ) public ballotVoters;\n  mapping (uint32 => mapping (uint32 => uint256) ) public ballotVoteCount;\n\n  /* function to allow a coin holder add to the vote count of an option in an\n   * active ballot. The votes added equals the balance of the account. Once this is called successfully\n   * the coins cannot be transferred out of the account until the end of the ballot.\n   *\n   * NB: The timing of the start and end of the voting period is determined by\n   * the timestamp of the block in which the transaction is included. As given by\n   * the current Ethereum standard this is *NOT* guaranteed to be accurate to any\n   * given external time source. Therefore, votes should be placed well in advance\n   * of the UTC end time of the Ballot.\n   */\n  function vote(uint32 _ballotId, uint32 _selectedOptionId) {\n\n    /* verify that the ballot exists */\n    require(_ballotId > 0 && _ballotId <= numBallots);\n\n    /* Ballot must be in progress in order to vote */\n    require(isBallotInProgress(_ballotId));\n\n    /* Calculate the balance which which the coin holder has not yet voted, which is the difference between\n     * the current balance for the senders address and the amount they already voted in this ballot.\n     * If the difference is zero, this attempt to vote will fail.\n     */\n    uint256 votableBalance = balanceOf(msg.sender) - ballotVoters[_ballotId][msg.sender];\n    require(votableBalance > 0);\n\n    /* validate the ballot option */\n    require(_selectedOptionId > 0 && _selectedOptionId <= ballotDetails[_ballotId].numOptions);\n\n    /* update the vote count and record the voter */\n    ballotVoteCount[_ballotId][_selectedOptionId] += votableBalance;\n    ballotVoters[_ballotId][msg.sender] += votableBalance;\n  }\n\n  /* function to determine if an address has already voted in a given ballot */\n  function hasAddressVotedInBallot(uint32 _ballotId, address _voter) constant returns (bool hasVoted) {\n    return ballotVoters[_ballotId][_voter] > 0;\n  }\n\n  /* function to determine if an account has voted in any current ballot */\n  function accountHasCurrentVote(address _voter) constant returns (bool) {\n    for(uint32 id = 1; id <= numBallots; id++) {\n      if (isBallotInProgress(id) && hasAddressVotedInBallot(id, _voter)) {\n        return true;\n      }\n    }\n    return false;\n  }\n}",
        "debug": "keccac_keccac_4294967295_&\n4294967295_&\n4294967295_&\nUDiv(256*Concat(0,_1_+_Extract(39,_8,_storage_4))_|\n_____Concat(Extract(255,_40,_storage_4),\n____________0,\n____________Extract(7,_0,_storage_4)),\n_____256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ERC20Interface_4 + calldata_ERC20Interface_4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_ERC20Interface_0: 0x62ec8e5300000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC20Interface: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `adminAddBallot(string,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/3/0x268b7976e94e84a48bf8b2b57ba34b59ed836a74.sol",
        "function": "adminAddBallot(string,uint256,uint256)",
        "lineno": 40,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}