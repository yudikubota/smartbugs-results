{
  "contract": "0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059",
  "tool": "mythril",
  "start": 1563577209.827494,
  "end": 1563577539.3927338,
  "duration": 329.56523990631104,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 4613,
        "code": "(decimals);\n\t\trequire(balanceOf[this] >=",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x57f2c1f800000000000000000000000000000000000000000000000000000100\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0xa870d5e7fffffffffffffffffffffffffffffffffffffffffffffffffffffefe\ncalldata_Token_0: 0x95e596f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AccountVoid(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "AccountVoid(address)",
        "lineno": 369,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4762,
        "code": "rnValue);\n\t}\n\t\n\tfunction bonus(uint amou",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa923bc2c35ea58231bc6409900885b40fedbadcbd5004fbf0bfef9fcf6f50329\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0x95e493df09774eb49bd48003c0850b30f8d10a2a1341043d4c008560e08500c4\ncalldata_Token_0: 0x95e596f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `AccountVoid(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "AccountVoid(address)",
        "lineno": 373,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5936,
        "code": "           return",
        "debug": "storage_3: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `kill()`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "kill()",
        "lineno": 133,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 5961,
        "code": ") public{",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\nstorage_3: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "kill()",
        "lineno": 136,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6241,
        "code": "ansaction metadata.\n */\n    func",
        "debug": "10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xde9aa0007ffff9dbbb05d00001000207fffdffbfffbfbfbfffbfbfefbfbff7f6\ncalldata_Token_4: 0xff3717ddf147ba7fd6976a72ee859c9c251431c6dd4346e384e0fd941c87b69c\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x24749b5900000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `bonus(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "bonus(uint256)",
        "lineno": 391,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6471,
        "debug": "storage_7: 0xb5431bc79bd0647c7f6bafd75d8f3a76a3ef379e5c64804f813fef3144013fdb\nstorage_106974352148254247443002424860746200082415828814647159066518186632126350659435: 0x27df6fcfa638253effdebbfa1d0bc2c1437f5edbc0f2112102fbbfefdfefe235\ncalldata_Token_4: 0x1\n10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xa2411387aa3f431a80514c1861e4406023acb1484d2684d9f5a4cc306fd8a211\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x24749b5900000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `bonus(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "bonus(uint256)",
        "lineno": 394,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6918,
        "code": "us(BonusValue);\n\t}\n}\n\ncontract E",
        "debug": "10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xde9aa0007ffff9dbbb05d00001000207fffdffbfffbfbfbfffbfbfefbfbff7f6\ncalldata_Token_4: 0xff3717ddf147ba7fd6976a72ee859c9c251431c6dd4346e384e0fd941c87b69c\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `burn(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "burn(uint256)",
        "lineno": 381,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7084,
        "code": "incoming token transfers",
        "debug": "storage_7: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_106974352148254247443002424860746200082415828814647159066518186632126350659435: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_4: 0x1\n10_EXP_Concat(0, Extract(15, 8, storage_6)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `burn(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "burn(uint256)",
        "lineno": 387,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 8118,
        "code": ";\n// -------------",
        "debug": "storage_3: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x7065cb4800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "addOwner(address)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13365,
        "code": "ply = 700000000 * 10 ** uint256(decimals);\n\tuint256 public EthPerToken = 700000;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction Token(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tbalanceOf[msg.sender] = totalSupply;\n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the sender\n        balanceOf[_to] = balanceOf[_to].add(_value);                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n    }\n    \n    function transfer(address _to, uint _value, bytes _data) public {\n        require(_value > 0 );\n        if(isContract(_to)) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n            receiver.tokenFallback(msg.sender, _value, _data);\n        }\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        Transfer(msg.sender, _to, _value, _data);\n    }\n    \n    function isContract(address _addr) private view returns (bool is_contract) {\n        uint length;\n        assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        return (length>0);\n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _collect_fee(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the sender\n        balanceOf[_to] = balanceOf[_to].add(_value);                           // Add the same to the recipient\n\t\tFeePaid(_from, _to, _value);\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\t\n\tfunction transferFrom(address _from, address _to, uint256 _value, bool _feed, uint256 _fees) onlyOwner public returns (bool success) {\n\t\tuint256 charge = 0 ;\n\t\tuint256 t_value = _value;\n\t\tif(_feed){\n\t\t\tcharge = _value * _fees / 100;\n\t\t}else{\n\t\t\tcharge = _value - (_value / (_fees + 100) * 100);\n\t\t}\n\t\tt_value = _value.sub(charge);\n\t\trequire(t_value.add(charge) == _value);\n        _transfer(_from, _to, t_value);\n\t\t_collect_fee(_from, this, charge);\n        return true;\n    }\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n\t\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable public{\n\t\trequire(msg.value > 0);\n\t\tuint amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1 ether;\n        _transfer(this, msg.sender, amount);\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = keccak256(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction AccountVoid(address _from) onlyOwner public{\n\t\trequire (balanceOf[_from] > 0); \n\t\tuint256 CurrentBalances = balanceOf[_from];\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\n        balanceOf[_from] -= CurrentBalances;                         \n        balanceOf[msg.sender] += CurrentBalances;\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\n\t}\n\t\n\tfunction burn(uint amount) onlyOwner public{\n\t\tuint BurnValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] >= BurnValue);\n\t\tbalanceOf[this] -= BurnValue;\n\t\ttotalSupply -= BurnValue;\n\t\tBurn(BurnValue);\n\t}\n\t\n\tfunction bonus(uint amount) onlyOwner public{\n\t\tuint BonusValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] + BonusValue > balanceOf[this]);\n\t\tbalanceOf[this] += BonusValue;\n\t\ttotalSupply += BonusValue;\n\t\tBonus(BonusValue);\n\t}\n}\n\ncontract ERC223ReceivingContract { \n/**\n * @dev Standard ERC223 function that will handle incoming token transfers.\n *\n * @param _from  Token sender address.\n * @param _value Amount of tokens.\n * @param _data  Transaction metadata.\n */\n    function tokenFallback(address _from, uint _value, bytes _data) public;\n}",
        "debug": "storage_3: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_4: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037083: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "removeOwner(address)",
        "lineno": 183,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 13367,
        "code": "ply = 700000000 * 10 ** uint256(decimals);\n\tuint256 public EthPerToken = 700000;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction Token(address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tbalanceOf[msg.sender] = totalSupply;\n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the sender\n        balanceOf[_to] = balanceOf[_to].add(_value);                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n    }\n    \n    function transfer(address _to, uint _value, bytes _data) public {\n        require(_value > 0 );\n        if(isContract(_to)) {\n            ERC223ReceivingContract receiver = ERC223ReceivingContract(_to);\n            receiver.tokenFallback(msg.sender, _value, _data);\n        }\n        balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);\n        balanceOf[_to] = balanceOf[_to].add(_value);\n        Transfer(msg.sender, _to, _value, _data);\n    }\n    \n    function isContract(address _addr) private view returns (bool is_contract) {\n        uint length;\n        assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        return (length>0);\n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _collect_fee(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] >= _value);                // Check if the sender has enough\n        require (balanceOf[_to].add(_value) >= balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from].add(balanceOf[_to]);\n        balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the sender\n        balanceOf[_to] = balanceOf[_to].add(_value);                           // Add the same to the recipient\n\t\tFeePaid(_from, _to, _value);\n\t\tassert(balanceOf[_from].add(balanceOf[_to]) == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\t\n\tfunction transferFrom(address _from, address _to, uint256 _value, bool _feed, uint256 _fees) onlyOwner public returns (bool success) {\n\t\tuint256 charge = 0 ;\n\t\tuint256 t_value = _value;\n\t\tif(_feed){\n\t\t\tcharge = _value * _fees / 100;\n\t\t}else{\n\t\t\tcharge = _value - (_value / (_fees + 100) * 100);\n\t\t}\n\t\tt_value = _value.sub(charge);\n\t\trequire(t_value.add(charge) == _value);\n        _transfer(_from, _to, t_value);\n\t\t_collect_fee(_from, this, charge);\n        return true;\n    }\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n\t\n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable public{\n\t\trequire(msg.value > 0);\n\t\tuint amount = msg.value * 10 ** uint256(decimals) * EthPerToken / 1 ether;\n        _transfer(this, msg.sender, amount);\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = keccak256(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction AccountVoid(address _from) onlyOwner public{\n\t\trequire (balanceOf[_from] > 0); \n\t\tuint256 CurrentBalances = balanceOf[_from];\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[msg.sender];\n        balanceOf[_from] -= CurrentBalances;                         \n        balanceOf[msg.sender] += CurrentBalances;\n\t\tVoidAccount(_from, msg.sender, CurrentBalances);\n\t\tassert(balanceOf[_from] + balanceOf[msg.sender] == previousBalances);\t\n\t}\n\t\n\tfunction burn(uint amount) onlyOwner public{\n\t\tuint BurnValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] >= BurnValue);\n\t\tbalanceOf[this] -= BurnValue;\n\t\ttotalSupply -= BurnValue;\n\t\tBurn(BurnValue);\n\t}\n\t\n\tfunction bonus(uint amount) onlyOwner public{\n\t\tuint BonusValue = amount * 10 ** uint256(decimals);\n\t\trequire(balanceOf[this] + BonusValue > balanceOf[this]);\n\t\tbalanceOf[this] += BonusValue;\n\t\ttotalSupply += BonusValue;\n\t\tBonus(BonusValue);\n\t}\n}\n\ncontract ERC223ReceivingContract { \n/**\n * @dev Standard ERC223 function that will handle incoming token transfers.\n *\n * @param _from  Token sender address.\n * @param _value Amount of tokens.\n * @param _data  Transaction metadata.\n */\n    function tokenFallback(address _from, uint _value, bytes _data) public;\n}",
        "debug": "storage_3: 0x7fffffffffffffffffffffefffffffffffffffffffffffffffffc00000000000\ncalldata_Token_4: 0x0\nstorage_87903029871075914254377627908054574944891091886930582284385770809450030037083: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_Token_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/18/0xe41df2835d829c0f1f94d2ec56f421b2cc3e9059.sol",
        "function": "removeOwner(address)",
        "lineno": 183,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}