{"error": null, "issues": [{"address": 3260, "code": ";\n\n\n/*\n * Ownable\n", "debug": "storage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0xff00\nstorage_0: 0xffffffffffffffffffffffffffffffffffffff0000\nstorage_1: 0xff00\ncaller: 0xffffffffffffffffffffffffffffffffffffff00\ncalldata_splitterContract_0: 0xa2d83b5e00000000000000000000000000000000000000000000000000000000\ncalldatasize_splitterContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `update(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/41/0xda59ab6e4b9d9fb867b8a952f455c77ad92afa8e.sol", "function": "update(address,uint256)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5778, "code": "able{\n\n    event ev(string msg, address whom, uint256 val);\n\n    struct xRec {\n        bool inList;\n        address next;\n        address prev;\n        uint256 val;\n    }\n\n    struct l8r {\n        address whom;\n        uint256 val;\n    }\n    address public myAddress = this;\n    address public first;\n    address public last;\n    address public ddf;\n    bool    public thinkMode;\n    uint256 public pos;\n\n    mapping (address => xRec) public theList;\n\n    l8r[]  afterParty;\n\n    modifier onlyMeOrDDF() {\n        if (msg.sender == ddf || msg.sender == myAddress || msg.sender == owner) {\n            _;\n            return;\n        }\n    }\n\n    function setDDF(address ddf_) onlyOwner {\n        ddf = ddf_;\n    }\n\n    function splitterContract(address seed, uint256 seedVal) {\n        first = seed;\n        last = seed;\n        theList[seed] = xRec(true,0x0,0x0,seedVal);\n    }\n\n    function startThinking() onlyOwner {\n        thinkMode = true;\n        pos = 0;\n    }\n\n    function stopThinking(uint256 num) onlyOwner {\n        thinkMode = false;\n        for (uint256 i = 0; i < num; i++) {\n            if (pos >= afterParty.length) {\n                delete afterParty;\n                return;\n            }\n            update(afterParty[pos].whom,afterParty[pos].val);\n            pos++;\n        }\n        thinkMode = true;\n    } \n\n    function thinkLength() constant returns (uint256) {\n        return afterParty.length;\n    }\n\n    function addRec4L8R(address whom, uint256 val) internal {\n        afterParty.push(l8r(whom,val));\n    }\n\n    function add(address whom, uint256 value) internal {\n        theList[whom] = xRec(true,0x0,last,value);\n        theList[last].next = whom;\n        last = whom;\n        ev(\"add\",whom,value);\n    }\n\n    function remove(address whom) internal {\n        if (first == whom) {\n            first = theList[whom].next;\n            theList[whom] = xRec(false,0x0,0x0,0);\n            return;\n        }\n        address next = theList[whom].next;\n        address prev = theList[whom].prev;\n        if (prev != 0x0) {\n            theList[prev].next = next;\n        }\n        if (next != 0x0) {\n            theList[next].prev = prev;\n        }\n        theList[whom] = xRec(false,0x0,0x0,0);\n        ev(\"remove\",whom,0);\n    }\n\n    function update(address whom, uint256 value) onlyMeOrDDF {\n        if (thinkMode) {\n            addRec4L8R(whom,value);\n            return;\n        }\n        if (value != 0) {\n            if (!theList[whom].inList) {\n                add(whom,value);\n            } else {\n                theList[whom].val = value;\n                ev(\"update\",whom,value);\n            }\n            return;\n        }\n        if (theList[whom].inList) {\n                remove(whom);\n        }\n    }\n\n}", "debug": "storage_7: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_5: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_splitterContract_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_splitterContract_0: 0x3a6120c500000000000000000000000000000000000000000000000000000000\ncalldatasize_splitterContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `stopThinking(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/41/0xda59ab6e4b9d9fb867b8a952f455c77ad92afa8e.sol", "function": "stopThinking(uint256)", "lineno": 33, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5790, "code": "able{\n\n    event ev(string msg, address whom, uint256 val);\n\n    struct xRec {\n        bool inList;\n        address next;\n        address prev;\n        uint256 val;\n    }\n\n    struct l8r {\n        address whom;\n        uint256 val;\n    }\n    address public myAddress = this;\n    address public first;\n    address public last;\n    address public ddf;\n    bool    public thinkMode;\n    uint256 public pos;\n\n    mapping (address => xRec) public theList;\n\n    l8r[]  afterParty;\n\n    modifier onlyMeOrDDF() {\n        if (msg.sender == ddf || msg.sender == myAddress || msg.sender == owner) {\n            _;\n            return;\n        }\n    }\n\n    function setDDF(address ddf_) onlyOwner {\n        ddf = ddf_;\n    }\n\n    function splitterContract(address seed, uint256 seedVal) {\n        first = seed;\n        last = seed;\n        theList[seed] = xRec(true,0x0,0x0,seedVal);\n    }\n\n    function startThinking() onlyOwner {\n        thinkMode = true;\n        pos = 0;\n    }\n\n    function stopThinking(uint256 num) onlyOwner {\n        thinkMode = false;\n        for (uint256 i = 0; i < num; i++) {\n            if (pos >= afterParty.length) {\n                delete afterParty;\n                return;\n            }\n            update(afterParty[pos].whom,afterParty[pos].val);\n            pos++;\n        }\n        thinkMode = true;\n    } \n\n    function thinkLength() constant returns (uint256) {\n        return afterParty.length;\n    }\n\n    function addRec4L8R(address whom, uint256 val) internal {\n        afterParty.push(l8r(whom,val));\n    }\n\n    function add(address whom, uint256 value) internal {\n        theList[whom] = xRec(true,0x0,last,value);\n        theList[last].next = whom;\n        last = whom;\n        ev(\"add\",whom,value);\n    }\n\n    function remove(address whom) internal {\n        if (first == whom) {\n            first = theList[whom].next;\n            theList[whom] = xRec(false,0x0,0x0,0);\n            return;\n        }\n        address next = theList[whom].next;\n        address prev = theList[whom].prev;\n        if (prev != 0x0) {\n            theList[prev].next = next;\n        }\n        if (next != 0x0) {\n            theList[next].prev = prev;\n        }\n        theList[whom] = xRec(false,0x0,0x0,0);\n        ev(\"remove\",whom,0);\n    }\n\n    function update(address whom, uint256 value) onlyMeOrDDF {\n        if (thinkMode) {\n            addRec4L8R(whom,value);\n            return;\n        }\n        if (value != 0) {\n            if (!theList[whom].inList) {\n                add(whom,value);\n            } else {\n                theList[whom].val = value;\n                ev(\"update\",whom,value);\n            }\n            return;\n        }\n        if (theList[whom].inList) {\n                remove(whom);\n        }\n    }\n\n}", "debug": "storage_7: 0x55b0c5c4854515fa020e83977356fbfffffb5af7debb74eb8ed6b6561d404e1c\nstorage_5: 0x55b0c5c4854515fa020e83977356fbfffffb5af7debb74eb8ed6b6561d404e1c\ncalldata_splitterContract_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_splitterContract_0: 0x3a6120c500000000000000000000000000000000000000000000000000000000\ncalldatasize_splitterContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `stopThinking(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/41/0xda59ab6e4b9d9fb867b8a952f455c77ad92afa8e.sol", "function": "stopThinking(uint256)", "lineno": 33, "title": "Integer Overflow ", "type": "Warning"}], "success": true}