{"error": null, "issues": [{"address": 16010, "code": "         self.list[idx-1] = l", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_10: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\ncalldata_UHCToken_0: 0x221ef94d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UHCToken: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x114f1fc16db3615de301b39914625a79b912ea11.sol", "function": "userMigration(uint256)", "lineno": 69, "title": "Exception state", "type": "Informational"}, {"address": 16263, "code": " >= a", "debug": "storage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_0,_256): 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\nstorage_1: 0x0\ncalldata_UHCToken_0: 0x221ef94d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UHCToken: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `userMigration(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x114f1fc16db3615de301b39914625a79b912ea11.sol", "function": "userMigration(uint256)", "lineno": 25, "title": "Integer Overflow ", "type": "Warning"}, {"address": 16276, "code": "return c;\n    ", "debug": "The exception is triggered under the following conditions:\n\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_0,_256): 0xc63a21246c99b000ea0030728005ea6909080a424a47ca48059be3c0ff803205\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xd2bd697b67b8b7eebcef8ebaf405ca6a0b728a06c347eda3d5dbebfeffbdb977\nstorage_1: 0x0\ncalldata_UHCToken_0: 0x221ef94d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UHCToken: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x114f1fc16db3615de301b39914625a79b912ea11.sol", "function": "userMigration(uint256)", "lineno": 26, "title": "Exception state", "type": "Informational"}, {"address": 20132, "code": "AddressSet.Instance;\n\n    address public owner;\n    address public subowner;\n\n    bool    public              contractEnable = true;\n\n    string  public              name = \"UFOHotelCoin\";\n    string  public              symbol = \"UHC\";\n    uint8   public              decimals = 4;\n    uint256 private             summarySupply;\n    bool    public              isTransferFee;\n    uint8   public              transferFeePercent = 3;\n    uint8   public              refererFeePercent = 1;\n\n    struct account{\n        uint256 balance;\n        uint8 group;\n        uint8 status;\n        address referer;\n        bool isBlocked;\n        bool withoutTransferFee;\n    }\n\n    mapping(address => account)                      private   accounts;\n    mapping(address => mapping (address => uint256)) private   allowed;\n    mapping(bytes => address)                        private   promos;\n\n    AddressSet.Instance                             private   holders;\n\n    struct groupPolicy {\n        uint8 _default;\n        uint8 _backend;\n        uint8 _admin;\n        uint8 _owner;\n    }\n\n    groupPolicy public groupPolicyInstance = groupPolicy(0, 3, 4, 9);\n\n    event EvGroupChanged(address indexed _address, uint8 _oldgroup, uint8 _newgroup);\n    event EvMigration(address indexed _address, uint256 _balance, uint256 _secret);\n    event EvUpdateStatus(address indexed _address, uint8 _oldstatus, uint8 _newstatus);\n    event EvSetReferer(address indexed _referal, address _referer);\n\n    constructor (string _name, string _symbol, uint8 _decimals,uint256 _summarySupply, uint8 _transferFeePercent, uint8 _refererFeePercent) public {\n        require(_refererFeePercent < _transferFeePercent);\n        owner = msg.sender;\n\n        accounts[owner] = account(_summarySupply, groupPolicyInstance._owner, 4, address(0), false, false);\n\n        holders.push(msg.sender);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        summarySupply = _summarySupply;\n        transferFeePercent = _transferFeePercent;\n        refererFeePercent = _refererFeePercent;\n        emit Transfer(address(0), msg.sender, _summarySupply);\n    }\n\n    modifier minGroup(int _require) {\n        require(accounts[msg.sender].group >= _require);\n        _;\n    }\n\n    modifier onlySubowner() {\n        require(msg.sender == subowner);\n        _;\n    }\n\n    modifier whenNotMigrating {\n        require(contractEnable);\n        _;\n    }\n\n    modifier whenMigrating {\n        require(!contractEnable);\n        _;\n    }\n\n    function serviceGroupChange(address _address, uint8 _group) minGroup(groupPolicyInstance._admin) external returns(uint8) {\n        require(_address != address(0));\n        require(_group <= groupPolicyInstance._admin);\n\n        uint8 old = accounts[_address].group;\n        require(old < accounts[msg.sender].group);\n\n        accounts[_address].group = _group;\n        emit EvGroupChanged(_address, old, _group);\n\n        return accounts[_address].group;\n    }\n\n    function serviceTransferOwnership(address newOwner) minGroup(groupPolicyInstance._owner) external {\n        require(newOwner != address(0));\n\n        subowner = newOwner;\n    }\n\n    function serviceClaimOwnership() onlySubowner() external {\n        address temp = owner;\n        uint256 value = accounts[owner].balance;\n\n        accounts[owner].balance = accounts[owner].balance.sub(value);\n        holders.remove(owner);\n        accounts[msg.sender].balance = accounts[msg.sender].balance.add(value);\n        holders.push(msg.sender);\n\n        owner = msg.sender;\n        subowner = address(0);\n\n        delete accounts[temp].group;\n        uint8 oldGroup = accounts[msg.sender].group;\n        accounts[msg.sender].group = groupPolicyInstance._owner;\n\n        emit EvGroupChanged(msg.sender, oldGroup, groupPolicyInstance._owner);\n        emit Transfer(temp, owner, value);\n    }\n\n    function serviceSwitchTransferAbility(address _address) external minGroup(groupPolicyInstance._admin) returns(bool) {\n        require(accounts[_address].group < accounts[msg.sender].group);\n\n        accounts[_address].isBlocked = !accounts[_address].isBlocked;\n\n        return true;\n    }\n\n    function serviceUpdateTransferFeePercent(uint8 newFee) external minGroup(groupPolicyInstance._admin) {\n        require(newFee < 100);\n        require(newFee > refererFeePercent);\n        transferFeePercent = newFee;\n    }\n\n    function serviceUpdateRefererFeePercent(uint8 newFee) external minGroup(groupPolicyInstance._admin) {\n        require(newFee < 100);\n        require(transferFeePercent > newFee);\n        refererFeePercent = newFee;\n    }\n\n    function serviceSetPromo(bytes num, address _address) external minGroup(groupPolicyInstance._admin) {\n        require(promos[num] == address(0), \"Address already set for this promo\");\n        promos[num] = _address;\n    }\n\n    function serviceOnTransferFee() external minGroup(groupPolicyInstance._admin) {\n        require(!isTransferFee);\n        isTransferFee = true;\n    }\n\n    function serviceOffTransferFee() external minGroup(groupPolicyInstance._admin) {\n        require(isTransferFee);\n        isTransferFee = false;\n    }\n    \n    function serviceAccountTransferFee(address _address, bool _withoutTransferFee) external minGroup(groupPolicyInstance._admin) {\n        require(_address != address(0));\n        require(accounts[_address].withoutTransferFee != _withoutTransferFee);\n        accounts[_address].withoutTransferFee = _withoutTransferFee;\n    }\n\n    function backendSetStatus(address _address, uint8 status) external minGroup(groupPolicyInstance._backend) returns(bool){\n        require(_address != address(0));\n        require(status >= 0 && status <= 4);\n        uint8 oldStatus = accounts[_address].status;\n        accounts[_address].status = status;\n\n        emit EvUpdateStatus(_address, oldStatus, status);\n\n        return true;\n    }\n\n    function backendSetReferer(address _referal, address _referer) external minGroup(groupPolicyInstance._backend) returns(bool) {\n        require(accounts[_referal].referer == address(0));\n        require(_referal != address(0));\n        require(_referal != _referer);\n        require(accounts[_referal].referer != _referer);\n\n        accounts[_referal].referer = _referer;\n\n        emit EvSetReferer(_referal, _referer);\n\n        return true;\n    }\n\n    function backendSendBonus(address _to, uint256 _value) external minGroup(groupPolicyInstance._backend) returns(bool) {\n        require(_to != address(0));\n        require(_value > 0);\n        require(accounts[owner].balance >= _value);\n\n        accounts[owner].balance = accounts[owner].balance.sub(_value);\n        accounts[_to].balance = accounts[_to].balance.add(_value);\n\n        emit Transfer(owner, _to, _value);\n\n        return true;\n    }\n\n    function backendRefund(address _from, uint256 _value) external minGroup(groupPolicyInstance._backend) returns(uint256 balance) {\n        require(_from != address(0));\n        require(_value > 0);\n        require(accounts[_from].balance >= _value);\n \n        accounts[_from].balance = accounts[_from].balance.sub(_value);\n        accounts[owner].balance = accounts[owner].balance.add(_value);\n        if(accounts[_from].balance == 0){\n            holders.remove(_from);\n        }\n        emit Transfer(_from, owner, _value);\n        return accounts[_from].balance;\n    }\n\n    function getGroup(address _check) external view returns(uint8 _group) {\n        return accounts[_check].group;\n    }\n\n    function getHoldersLength() external view returns(uint256){\n        return holders.sizeOf();\n    }\n\n    function getHolderByIndex(uint256 _index) external view returns(address){\n        return holders.getAddress(_index);\n    }\n\n    function getPromoAddress(bytes _promo) external view returns(address) {\n        return promos[_promo];\n    }\n\n    function getAddressTransferAbility(address _check) external view returns(bool) {\n        return !accounts[_check].isBlocked;\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool success) {\n        return _transfer(msg.sender, _to, address(0), _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n        return _transfer(_from, _to, msg.sender, _value);\n    }\n\n    function _transfer(address _from, address _to, address _allow, uint256 _value) minGroup(groupPolicyInstance._default) whenNotMigrating internal returns(bool) {\n        require(!accounts[_from].isBlocked);\n        require(_from != address(0));\n        require(_to != address(0));\n        uint256 transferFee = accounts[_from].group == 0 && isTransferFee && !accounts[_from].withoutTransferFee ? _value.mul(accounts[_from].referer == address(0) ? transferFeePercent : transferFeePercent - refererFeePercent).div(100) : 0;\n        uint256 transferRefererFee = accounts[_from].referer == address(0) || accounts[_from].group != 0 ? 0 : _value.mul(refererFeePercent).div(100);\n        uint256 summaryValue = _value.add(transferFee).add(transferRefererFee);\n        require(accounts[_from].balance >= summaryValue);\n        require(_allow == address(0) || allowed[_from][_allow] >= summaryValue);\n\n        accounts[_from].balance = accounts[_from].balance.sub(summaryValue);\n        if(_allow != address(0)) {\n            allowed[_from][_allow] = allowed[_from][_allow].sub(summaryValue);\n        }\n\n        if(accounts[_from].balance == 0){\n            holders.remove(_from);\n        }\n        accounts[_to].balance = accounts[_to].balance.add(_value);\n        holders.push(_to);\n        emit Transfer(_from, _to, _value);\n\n        if(transferFee > 0) {\n            accounts[owner].balance = accounts[owner].balance.add(transferFee);\n            emit Transfer(_from, owner, transferFee);\n        }\n\n        if(transferRefererFee > 0) {\n            accounts[accounts[_from].referer].balance = accounts[accounts[_from].referer].balance.add(transferRefererFee);\n            holders.push(accounts[_from].referer);\n            emit Transfer(_from, accounts[_from].referer, transferRefererFee);\n        }\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) minGroup(groupPolicyInstance._default) external returns (bool success) {\n        require (_value == 0 || allowed[msg.sender][_spender] == 0);\n        require(_spender != address(0));\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint256 _addedValue) minGroup(groupPolicyInstance._default) external returns (bool)\n    {\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint256 _subtractedValue) minGroup(groupPolicyInstance._default) external returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return accounts[_owner].balance;\n    }\n\n    function statusOf(address _owner) external view returns (uint8) {\n        return accounts[_owner].status;\n    }\n\n    function refererOf(address _owner) external constant returns (address) {\n        return accounts[_owner].referer;\n    }\n\n    function totalSupply() external constant returns (uint256 _totalSupply) {\n        _totalSupply = summarySupply;\n    }\n\n    function settingsSwitchState() external minGroup(groupPolicyInstance._owner) returns (bool state) {\n\n        contractEnable = !contractEnable;\n\n        return contractEnable;\n    }\n\n    function userMigration(uint256 _secret) external whenMigrating returns (bool successful) {\n        uint256 balance = accounts[msg.sender].balance;\n\n        require (balance > 0);\n\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(balance);\n        holders.remove(msg.sender);\n        accounts[owner].balance = accounts[owner].balance.add(balance);\n        holders.push(owner);\n        emit EvMigration(msg.sender, balance, _secret);\n        emit Transfer(msg.sender, owner, balance);\n        return true;\n    }\n}", "debug": "storage_10: 0x7fffffffffffffffffffffffffffffffffe367997d26743ca06a70b77c062d55\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\ncalldata_UHCToken_0: 0x221ef94d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UHCToken: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x7fffffffffffffffffffffffffffffffffe367997d26743ca06a70b77c062d55\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `userMigration(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x114f1fc16db3615de301b39914625a79b912ea11.sol", "function": "userMigration(uint256)", "lineno": 89, "title": "Integer Overflow ", "type": "Warning"}, {"address": 20134, "code": "AddressSet.Instance;\n\n    address public owner;\n    address public subowner;\n\n    bool    public              contractEnable = true;\n\n    string  public              name = \"UFOHotelCoin\";\n    string  public              symbol = \"UHC\";\n    uint8   public              decimals = 4;\n    uint256 private             summarySupply;\n    bool    public              isTransferFee;\n    uint8   public              transferFeePercent = 3;\n    uint8   public              refererFeePercent = 1;\n\n    struct account{\n        uint256 balance;\n        uint8 group;\n        uint8 status;\n        address referer;\n        bool isBlocked;\n        bool withoutTransferFee;\n    }\n\n    mapping(address => account)                      private   accounts;\n    mapping(address => mapping (address => uint256)) private   allowed;\n    mapping(bytes => address)                        private   promos;\n\n    AddressSet.Instance                             private   holders;\n\n    struct groupPolicy {\n        uint8 _default;\n        uint8 _backend;\n        uint8 _admin;\n        uint8 _owner;\n    }\n\n    groupPolicy public groupPolicyInstance = groupPolicy(0, 3, 4, 9);\n\n    event EvGroupChanged(address indexed _address, uint8 _oldgroup, uint8 _newgroup);\n    event EvMigration(address indexed _address, uint256 _balance, uint256 _secret);\n    event EvUpdateStatus(address indexed _address, uint8 _oldstatus, uint8 _newstatus);\n    event EvSetReferer(address indexed _referal, address _referer);\n\n    constructor (string _name, string _symbol, uint8 _decimals,uint256 _summarySupply, uint8 _transferFeePercent, uint8 _refererFeePercent) public {\n        require(_refererFeePercent < _transferFeePercent);\n        owner = msg.sender;\n\n        accounts[owner] = account(_summarySupply, groupPolicyInstance._owner, 4, address(0), false, false);\n\n        holders.push(msg.sender);\n        name = _name;\n        symbol = _symbol;\n        decimals = _decimals;\n        summarySupply = _summarySupply;\n        transferFeePercent = _transferFeePercent;\n        refererFeePercent = _refererFeePercent;\n        emit Transfer(address(0), msg.sender, _summarySupply);\n    }\n\n    modifier minGroup(int _require) {\n        require(accounts[msg.sender].group >= _require);\n        _;\n    }\n\n    modifier onlySubowner() {\n        require(msg.sender == subowner);\n        _;\n    }\n\n    modifier whenNotMigrating {\n        require(contractEnable);\n        _;\n    }\n\n    modifier whenMigrating {\n        require(!contractEnable);\n        _;\n    }\n\n    function serviceGroupChange(address _address, uint8 _group) minGroup(groupPolicyInstance._admin) external returns(uint8) {\n        require(_address != address(0));\n        require(_group <= groupPolicyInstance._admin);\n\n        uint8 old = accounts[_address].group;\n        require(old < accounts[msg.sender].group);\n\n        accounts[_address].group = _group;\n        emit EvGroupChanged(_address, old, _group);\n\n        return accounts[_address].group;\n    }\n\n    function serviceTransferOwnership(address newOwner) minGroup(groupPolicyInstance._owner) external {\n        require(newOwner != address(0));\n\n        subowner = newOwner;\n    }\n\n    function serviceClaimOwnership() onlySubowner() external {\n        address temp = owner;\n        uint256 value = accounts[owner].balance;\n\n        accounts[owner].balance = accounts[owner].balance.sub(value);\n        holders.remove(owner);\n        accounts[msg.sender].balance = accounts[msg.sender].balance.add(value);\n        holders.push(msg.sender);\n\n        owner = msg.sender;\n        subowner = address(0);\n\n        delete accounts[temp].group;\n        uint8 oldGroup = accounts[msg.sender].group;\n        accounts[msg.sender].group = groupPolicyInstance._owner;\n\n        emit EvGroupChanged(msg.sender, oldGroup, groupPolicyInstance._owner);\n        emit Transfer(temp, owner, value);\n    }\n\n    function serviceSwitchTransferAbility(address _address) external minGroup(groupPolicyInstance._admin) returns(bool) {\n        require(accounts[_address].group < accounts[msg.sender].group);\n\n        accounts[_address].isBlocked = !accounts[_address].isBlocked;\n\n        return true;\n    }\n\n    function serviceUpdateTransferFeePercent(uint8 newFee) external minGroup(groupPolicyInstance._admin) {\n        require(newFee < 100);\n        require(newFee > refererFeePercent);\n        transferFeePercent = newFee;\n    }\n\n    function serviceUpdateRefererFeePercent(uint8 newFee) external minGroup(groupPolicyInstance._admin) {\n        require(newFee < 100);\n        require(transferFeePercent > newFee);\n        refererFeePercent = newFee;\n    }\n\n    function serviceSetPromo(bytes num, address _address) external minGroup(groupPolicyInstance._admin) {\n        require(promos[num] == address(0), \"Address already set for this promo\");\n        promos[num] = _address;\n    }\n\n    function serviceOnTransferFee() external minGroup(groupPolicyInstance._admin) {\n        require(!isTransferFee);\n        isTransferFee = true;\n    }\n\n    function serviceOffTransferFee() external minGroup(groupPolicyInstance._admin) {\n        require(isTransferFee);\n        isTransferFee = false;\n    }\n    \n    function serviceAccountTransferFee(address _address, bool _withoutTransferFee) external minGroup(groupPolicyInstance._admin) {\n        require(_address != address(0));\n        require(accounts[_address].withoutTransferFee != _withoutTransferFee);\n        accounts[_address].withoutTransferFee = _withoutTransferFee;\n    }\n\n    function backendSetStatus(address _address, uint8 status) external minGroup(groupPolicyInstance._backend) returns(bool){\n        require(_address != address(0));\n        require(status >= 0 && status <= 4);\n        uint8 oldStatus = accounts[_address].status;\n        accounts[_address].status = status;\n\n        emit EvUpdateStatus(_address, oldStatus, status);\n\n        return true;\n    }\n\n    function backendSetReferer(address _referal, address _referer) external minGroup(groupPolicyInstance._backend) returns(bool) {\n        require(accounts[_referal].referer == address(0));\n        require(_referal != address(0));\n        require(_referal != _referer);\n        require(accounts[_referal].referer != _referer);\n\n        accounts[_referal].referer = _referer;\n\n        emit EvSetReferer(_referal, _referer);\n\n        return true;\n    }\n\n    function backendSendBonus(address _to, uint256 _value) external minGroup(groupPolicyInstance._backend) returns(bool) {\n        require(_to != address(0));\n        require(_value > 0);\n        require(accounts[owner].balance >= _value);\n\n        accounts[owner].balance = accounts[owner].balance.sub(_value);\n        accounts[_to].balance = accounts[_to].balance.add(_value);\n\n        emit Transfer(owner, _to, _value);\n\n        return true;\n    }\n\n    function backendRefund(address _from, uint256 _value) external minGroup(groupPolicyInstance._backend) returns(uint256 balance) {\n        require(_from != address(0));\n        require(_value > 0);\n        require(accounts[_from].balance >= _value);\n \n        accounts[_from].balance = accounts[_from].balance.sub(_value);\n        accounts[owner].balance = accounts[owner].balance.add(_value);\n        if(accounts[_from].balance == 0){\n            holders.remove(_from);\n        }\n        emit Transfer(_from, owner, _value);\n        return accounts[_from].balance;\n    }\n\n    function getGroup(address _check) external view returns(uint8 _group) {\n        return accounts[_check].group;\n    }\n\n    function getHoldersLength() external view returns(uint256){\n        return holders.sizeOf();\n    }\n\n    function getHolderByIndex(uint256 _index) external view returns(address){\n        return holders.getAddress(_index);\n    }\n\n    function getPromoAddress(bytes _promo) external view returns(address) {\n        return promos[_promo];\n    }\n\n    function getAddressTransferAbility(address _check) external view returns(bool) {\n        return !accounts[_check].isBlocked;\n    }\n\n    function transfer(address _to, uint256 _value) external returns (bool success) {\n        return _transfer(msg.sender, _to, address(0), _value);\n    }\n\n    function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) {\n        return _transfer(_from, _to, msg.sender, _value);\n    }\n\n    function _transfer(address _from, address _to, address _allow, uint256 _value) minGroup(groupPolicyInstance._default) whenNotMigrating internal returns(bool) {\n        require(!accounts[_from].isBlocked);\n        require(_from != address(0));\n        require(_to != address(0));\n        uint256 transferFee = accounts[_from].group == 0 && isTransferFee && !accounts[_from].withoutTransferFee ? _value.mul(accounts[_from].referer == address(0) ? transferFeePercent : transferFeePercent - refererFeePercent).div(100) : 0;\n        uint256 transferRefererFee = accounts[_from].referer == address(0) || accounts[_from].group != 0 ? 0 : _value.mul(refererFeePercent).div(100);\n        uint256 summaryValue = _value.add(transferFee).add(transferRefererFee);\n        require(accounts[_from].balance >= summaryValue);\n        require(_allow == address(0) || allowed[_from][_allow] >= summaryValue);\n\n        accounts[_from].balance = accounts[_from].balance.sub(summaryValue);\n        if(_allow != address(0)) {\n            allowed[_from][_allow] = allowed[_from][_allow].sub(summaryValue);\n        }\n\n        if(accounts[_from].balance == 0){\n            holders.remove(_from);\n        }\n        accounts[_to].balance = accounts[_to].balance.add(_value);\n        holders.push(_to);\n        emit Transfer(_from, _to, _value);\n\n        if(transferFee > 0) {\n            accounts[owner].balance = accounts[owner].balance.add(transferFee);\n            emit Transfer(_from, owner, transferFee);\n        }\n\n        if(transferRefererFee > 0) {\n            accounts[accounts[_from].referer].balance = accounts[accounts[_from].referer].balance.add(transferRefererFee);\n            holders.push(accounts[_from].referer);\n            emit Transfer(_from, accounts[_from].referer, transferRefererFee);\n        }\n        return true;\n    }\n\n    function approve(address _spender, uint256 _value) minGroup(groupPolicyInstance._default) external returns (bool success) {\n        require (_value == 0 || allowed[msg.sender][_spender] == 0);\n        require(_spender != address(0));\n\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n\n    function increaseApproval(address _spender, uint256 _addedValue) minGroup(groupPolicyInstance._default) external returns (bool)\n    {\n        allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue));\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function decreaseApproval(address _spender, uint256 _subtractedValue) minGroup(groupPolicyInstance._default) external returns (bool)\n    {\n        uint256 oldValue = allowed[msg.sender][_spender];\n        if (_subtractedValue > oldValue) {\n            allowed[msg.sender][_spender] = 0;\n        } else {\n            allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue);\n        }\n        emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]);\n        return true;\n    }\n\n    function allowance(address _owner, address _spender) external view returns (uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n\n    function balanceOf(address _owner) external view returns (uint256 balance) {\n        return accounts[_owner].balance;\n    }\n\n    function statusOf(address _owner) external view returns (uint8) {\n        return accounts[_owner].status;\n    }\n\n    function refererOf(address _owner) external constant returns (address) {\n        return accounts[_owner].referer;\n    }\n\n    function totalSupply() external constant returns (uint256 _totalSupply) {\n        _totalSupply = summarySupply;\n    }\n\n    function settingsSwitchState() external minGroup(groupPolicyInstance._owner) returns (bool state) {\n\n        contractEnable = !contractEnable;\n\n        return contractEnable;\n    }\n\n    function userMigration(uint256 _secret) external whenMigrating returns (bool successful) {\n        uint256 balance = accounts[msg.sender].balance;\n\n        require (balance > 0);\n\n        accounts[msg.sender].balance = accounts[msg.sender].balance.sub(balance);\n        holders.remove(msg.sender);\n        accounts[owner].balance = accounts[owner].balance.add(balance);\n        holders.push(owner);\n        emit EvMigration(msg.sender, balance, _secret);\n        emit Transfer(msg.sender, owner, balance);\n        return true;\n    }\n}", "debug": "storage_10: 0xdfffffffff93f000000000000000000000000000000000000000000000000000\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\ncalldata_UHCToken_0: 0x221ef94d00000000000000000000000000000000000000000000000000000000\ncalldatasize_UHCToken: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xdfffffffff93f000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `userMigration(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x114f1fc16db3615de301b39914625a79b912ea11.sol", "function": "userMigration(uint256)", "lineno": 89, "title": "Integer Overflow ", "type": "Warning"}], "success": true}