{"error": null, "issues": [{"address": 3289, "code": "hold = 1;\n            } els", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Validator_4: 0x0\nstorage_6: 0x0\ncalldata_Validator_0: 0x35aa2e4400000000000000000000000000000000000000000000000000000000\ncalldatasize_Validator: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0xe804ebeff801a63de6e746c24ceb41a9864eb1c1.sol", "function": "_function_0x35aa2e44", "lineno": 2204, "title": "Exception state", "type": "Informational"}, {"address": 4478, "code": "(MIT)\n\n    Copyrig", "debug": "storage_6: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Validator_4: 0x0\nstorage_10: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_Validator_0: 0x4d238c8e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Validator: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addValidator(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xe804ebeff801a63de6e746c24ceb41a9864eb1c1.sol", "function": "addValidator(address)", "lineno": 2, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8581, "code": " = 0; i < (validators.length); i++) {\n            if (validators[i] == _validator) {\n                if (i != (validators.length - 1)) {\n                    validators[i] = validators[validators.length - 1];\n                }\n                validators.length--; \n                break;\n            }\n        }\n\n        if (threshold >= validators.length) {\n            if (validators.length == 1) {\n                threshold = 1;\n            } else {\n                threshold = validators.length - 1;\n            }\n        }\n        emit LogValidatorRemoved(_validator, msg.sender, threshold);\n    }\n\n    /// @notice fetch count of validators\n    function getValidatorsCount() public view returns (uint) { \n        return  validators.length;\n    }\n\n    /// @notice set threshold for validation and minting\n    /// @param _threshold threshold count\n    /// @return true/false\n    function updateThreshold(uint _threshold) public onlyAuthorized returns (bool) {\n        require(isNewThresholdValid(validators.length, _threshold));\n        threshold = _threshold;\n        return true;\n    }\n\n    /// @notice check valid threshold value. Common function for validator and proposal contract\n    /// @param _valCount valicator count\n    /// @param _threshold new threshold value\n    /// @return true/false\n    function isNewThresholdValid(uint _valCount, uint _threshold) public pure returns (bool) {\n        if (_threshold == 1 && _valCount == 2) {\n            return true;\n        } else if (_threshold >= 1 && _threshold < _valCount && (_threshold > (_valCount / 2))) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice set address of Proposals contract\n    /// @param _proposals address of token porter\n    /// @return true/false\n    function setProposalContract(address _proposals) public onlyOwner returns (bool) {\n        require(_proposals != 0x0);\n        proposals = Proposals(_proposals);\n        return true;\n    }\n\n    /// @notice set address of token porter\n    /// @param _tokenPorter address of token porter\n    /// @return true/false\n    function setTokenPorter(address _tokenPorter) public onlyOwner returns (bool) {\n        require(_tokenPorter != 0x0);\n        tokenPorter = TokenPorter(_tokenPorter);\n        return true;\n    }\n\n    /// @notice set contract addresses in validator contract.\n    /// @param _tokenAddr address of MetToken contract\n    /// @param _auctionsAddr address of Auction contract\n    /// @param _tokenPorterAddr address of TokenPorter contract\n    function initValidator(address _tokenAddr, address _auctionsAddr, address _tokenPorterAddr) public onlyOwner {\n        require(_tokenAddr != 0x0);\n        require(_auctionsAddr != 0x0);\n        require(_tokenPorterAddr != 0x0);\n        tokenPorter = TokenPorter(_tokenPorterAddr);\n        auctions = Auctions(_auctionsAddr);\n        token = METToken(_tokenAddr);\n    }\n\n    /// @notice Off chain validator call this function to validate and attest the hash. \n    /// @param _burnHash current burnHash\n    /// @param _originChain source chain\n    /// @param _recipientAddr recipientAddr\n    /// @param _amount amount to import\n    /// @param _fee fee for import-export\n    /// @param _proof proof\n    /// @param _extraData extra information for import\n    /// @param _globalSupplyInOtherChains total supply in all other chains except this chain\n    function attestHash(bytes32 _burnHash, bytes8 _originChain, address _recipientAddr, \n        uint _amount, uint _fee, bytes32[] _proof, bytes _extraData,\n        uint _globalSupplyInOtherChains) public onlyValidator {\n        require(_burnHash != 0x0);\n        require(!hashAttestations[_burnHash][msg.sender]);\n        require(!hashRefutation[_burnHash][msg.sender]);\n        require(verifyProof(tokenPorter.merkleRoots(_burnHash), _burnHash, _proof));\n        hashAttestations[_burnHash][msg.sender] = true;\n        attestationCount[_burnHash]++;\n        emit LogAttestation(_burnHash, _recipientAddr, true);\n        \n        if (attestationCount[_burnHash] >= threshold && !hashClaimed[_burnHash]) {\n            hashClaimed[_burnHash] = true;\n            require(tokenPorter.mintToken(_originChain, _recipientAddr, _amount, _fee, \n                _extraData, _burnHash, _globalSupplyInOtherChains, validators));\n        }\n    }\n\n    /// @notice off chain validator can refute hash, if given export hash is not verified in origin chain.\n    /// @param _burnHash Burn hash\n    function refuteHash(bytes32 _burnHash, address _recipientAddr) public onlyValidator {\n        require(!hashAttestations[_burnHash][msg.sender]);\n        require(!hashRefutation[_burnHash][msg.sender]);\n        hashRefutation[_burnHash][msg.sender] = true;\n        emit LogAttestation(_burnHash, _recipientAddr, false);\n    }\n\n    /// @notice verify that the given leaf is in merkle root.\n    /// @param _root merkle root\n    /// @param _leaf leaf node, current burn hash\n    /// @param _proof merkle path\n    /// @return true/false outcome of the verification.\n    function verifyProof(bytes32 _root, bytes32 _leaf, bytes32[] _proof) private pure returns (bool) {\n        require(_root != 0x0 && _leaf != 0x0 && _proof.length != 0);\n\n        bytes32 _hash = _leaf;\n        for (uint i = 0; i < _proof.length; i++) {\n            _hash = sha256(_proof[i], _hash);\n        } \n        return (_hash == _root);\n    }\n\n}", "debug": "storage_6: 0x7fffffffffffffffffffffffffffffffffffffffffffff36841a60c07fffff81\ncalldata_Validator_4: 0x0\nstorage_111414077815863400510004064629973595961579173665589224203503662149373724986687: 0x0\nstorage_10: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_Validator_0: 0x40a141ff00000000000000000000000000000000000000000000000000000000\ncalldatasize_Validator: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `removeValidator(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xe804ebeff801a63de6e746c24ceb41a9864eb1c1.sol", "function": "removeValidator(address)", "lineno": 2192, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8583, "code": " = 0; i < (validators.length); i++) {\n            if (validators[i] == _validator) {\n                if (i != (validators.length - 1)) {\n                    validators[i] = validators[validators.length - 1];\n                }\n                validators.length--; \n                break;\n            }\n        }\n\n        if (threshold >= validators.length) {\n            if (validators.length == 1) {\n                threshold = 1;\n            } else {\n                threshold = validators.length - 1;\n            }\n        }\n        emit LogValidatorRemoved(_validator, msg.sender, threshold);\n    }\n\n    /// @notice fetch count of validators\n    function getValidatorsCount() public view returns (uint) { \n        return  validators.length;\n    }\n\n    /// @notice set threshold for validation and minting\n    /// @param _threshold threshold count\n    /// @return true/false\n    function updateThreshold(uint _threshold) public onlyAuthorized returns (bool) {\n        require(isNewThresholdValid(validators.length, _threshold));\n        threshold = _threshold;\n        return true;\n    }\n\n    /// @notice check valid threshold value. Common function for validator and proposal contract\n    /// @param _valCount valicator count\n    /// @param _threshold new threshold value\n    /// @return true/false\n    function isNewThresholdValid(uint _valCount, uint _threshold) public pure returns (bool) {\n        if (_threshold == 1 && _valCount == 2) {\n            return true;\n        } else if (_threshold >= 1 && _threshold < _valCount && (_threshold > (_valCount / 2))) {\n            return true;\n        }\n        return false;\n    }\n\n    /// @notice set address of Proposals contract\n    /// @param _proposals address of token porter\n    /// @return true/false\n    function setProposalContract(address _proposals) public onlyOwner returns (bool) {\n        require(_proposals != 0x0);\n        proposals = Proposals(_proposals);\n        return true;\n    }\n\n    /// @notice set address of token porter\n    /// @param _tokenPorter address of token porter\n    /// @return true/false\n    function setTokenPorter(address _tokenPorter) public onlyOwner returns (bool) {\n        require(_tokenPorter != 0x0);\n        tokenPorter = TokenPorter(_tokenPorter);\n        return true;\n    }\n\n    /// @notice set contract addresses in validator contract.\n    /// @param _tokenAddr address of MetToken contract\n    /// @param _auctionsAddr address of Auction contract\n    /// @param _tokenPorterAddr address of TokenPorter contract\n    function initValidator(address _tokenAddr, address _auctionsAddr, address _tokenPorterAddr) public onlyOwner {\n        require(_tokenAddr != 0x0);\n        require(_auctionsAddr != 0x0);\n        require(_tokenPorterAddr != 0x0);\n        tokenPorter = TokenPorter(_tokenPorterAddr);\n        auctions = Auctions(_auctionsAddr);\n        token = METToken(_tokenAddr);\n    }\n\n    /// @notice Off chain validator call this function to validate and attest the hash. \n    /// @param _burnHash current burnHash\n    /// @param _originChain source chain\n    /// @param _recipientAddr recipientAddr\n    /// @param _amount amount to import\n    /// @param _fee fee for import-export\n    /// @param _proof proof\n    /// @param _extraData extra information for import\n    /// @param _globalSupplyInOtherChains total supply in all other chains except this chain\n    function attestHash(bytes32 _burnHash, bytes8 _originChain, address _recipientAddr, \n        uint _amount, uint _fee, bytes32[] _proof, bytes _extraData,\n        uint _globalSupplyInOtherChains) public onlyValidator {\n        require(_burnHash != 0x0);\n        require(!hashAttestations[_burnHash][msg.sender]);\n        require(!hashRefutation[_burnHash][msg.sender]);\n        require(verifyProof(tokenPorter.merkleRoots(_burnHash), _burnHash, _proof));\n        hashAttestations[_burnHash][msg.sender] = true;\n        attestationCount[_burnHash]++;\n        emit LogAttestation(_burnHash, _recipientAddr, true);\n        \n        if (attestationCount[_burnHash] >= threshold && !hashClaimed[_burnHash]) {\n            hashClaimed[_burnHash] = true;\n            require(tokenPorter.mintToken(_originChain, _recipientAddr, _amount, _fee, \n                _extraData, _burnHash, _globalSupplyInOtherChains, validators));\n        }\n    }\n\n    /// @notice off chain validator can refute hash, if given export hash is not verified in origin chain.\n    /// @param _burnHash Burn hash\n    function refuteHash(bytes32 _burnHash, address _recipientAddr) public onlyValidator {\n        require(!hashAttestations[_burnHash][msg.sender]);\n        require(!hashRefutation[_burnHash][msg.sender]);\n        hashRefutation[_burnHash][msg.sender] = true;\n        emit LogAttestation(_burnHash, _recipientAddr, false);\n    }\n\n    /// @notice verify that the given leaf is in merkle root.\n    /// @param _root merkle root\n    /// @param _leaf leaf node, current burn hash\n    /// @param _proof merkle path\n    /// @return true/false outcome of the verification.\n    function verifyProof(bytes32 _root, bytes32 _leaf, bytes32[] _proof) private pure returns (bool) {\n        require(_root != 0x0 && _leaf != 0x0 && _proof.length != 0);\n\n        bytes32 _hash = _leaf;\n        for (uint i = 0; i < _proof.length; i++) {\n            _hash = sha256(_proof[i], _hash);\n        } \n        return (_hash == _root);\n    }\n\n}", "debug": "storage_6: 0x7fffffffffffffffffffffdfffffffffffffc000000000000000000000000000\ncalldata_Validator_4: 0x0\nstorage_111414077815863400510004064629973595961579173665589224203503662149373724986687: 0x0\nstorage_10: 0x0\nstorage_0: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_Validator_0: 0x40a141ff00000000000000000000000000000000000000000000000000000000\ncalldatasize_Validator: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `removeValidator(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0xe804ebeff801a63de6e746c24ceb41a9864eb1c1.sol", "function": "removeValidator(address)", "lineno": 2192, "title": "Integer Overflow ", "type": "Warning"}], "success": true}