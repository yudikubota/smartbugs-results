{
  "contract": "0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0",
  "tool": "mythril",
  "start": 1563554870.6653712,
  "end": 1563555069.714154,
  "duration": 199.04878282546997,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 368,
        "code": "og\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event l",
        "debug": "calldata_Voting_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Voting_0: 0x146d0ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `sendVote(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "sendVote(string)",
        "lineno": 515,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 529,
        "code": " eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n",
        "debug": "calldata_Voting_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Voting_0: 0x1a24418200000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `grantVoter(address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 562,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1468,
        "code": "\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\tretur",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7: 0x8000\ntimestamp: 0x0\nstorage_6: 0x1\ncalldata_Voting_0: 0xa9a3e09500000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "pollStatus()",
        "lineno": 487,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2306,
        "code": "lled by user that is not an authoriz",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_7: 0x8000\ntimestamp: 0x0\nstorage_6: 0x1\ncalldata_Voting_0: 0x146d0ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "sendVote(string)",
        "lineno": 452,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3042,
        "code": "s) public {\n\t\tSCOracles = Orac",
        "debug": "",
        "description": "This contract executes a message call to an address found at storage slot 7. This storage slot can be written to by calling the function `endTesting()`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 460,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 3042,
        "code": "s) public {\n\t\tSCOracles = Orac",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4879\n",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 460,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 3042,
        "code": "s) public {\n\t\tSCOracles = Orac",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function grantVoter(address,bytes). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 460,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 3547,
        "code": "\t\treturn eVotingStatus.Closed;",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "endTesting()",
        "lineno": 469,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 3760,
        "code": "sed);\n}",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "endTesting()",
        "lineno": 579,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3962,
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "endTesting()",
        "lineno": 580,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 4879,
        "code": "s) public {\n\t\tSCOracles = Orac",
        "debug": "",
        "description": "This contract executes a message call to an address found at storage slot 7. This storage slot can be written to by calling the function `endTesting()`. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "_grantVoter(address)",
        "lineno": 460,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 4879,
        "code": "s) public {\n\t\tSCOracles = Orac",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function _grantVoter(address). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "_grantVoter(address)",
        "lineno": 460,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 5266,
        "code": ".sol\n\n/*\nMarketPay",
        "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Voting_4: 0x0\nreturndatasize: 0x20\nretval_4879: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Voting_0: 0x951628e000000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_grantVoter(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "_grantVoter(address)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5371,
        "code": "nt256 l = vo",
        "debug": "storage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Voting_4: 0x0\nreturndatasize: 0x20\nretval_4879: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Voting_0: 0x951628e000000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_grantVoter(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "_grantVoter(address)",
        "lineno": 558,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7469,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_7: 0x0\ncalldata_Voting_4 + calldata_Voting_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ntimestamp: 0x0\nstorage_6: 0x1\ncalldata_Voting_0: 0x146d0ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `sendVote(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "sendVote(string)",
        "lineno": 430,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7483,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_7: 0x0\ncalldata_Voting_4 + calldata_Voting_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60\ntimestamp: 0x0\nstorage_6: 0x1\ncalldata_Voting_0: 0x146d0ca00000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `sendVote(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "sendVote(string)",
        "lineno": 430,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7568,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Voting_4: 0xffa21221c1aad3275e493ea2153c51a703aeff5fe9eabeba109afddddfd6c9f8\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Voting_4: 0xeaf7eb65ffc73599dcdb9aa7660331eed3bffffaffefeffbbe304074094d0081\nretval_4879: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Voting_4 + calldata_Voting_32 + 4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_3042: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Voting_0: 0x1a24418200000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `grantVoter(address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 430,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7597,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "calldata_Voting_4 + calldata_Voting_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Voting_4: 0x0\nretval_4879: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Voting_4 + calldata_Voting_32 + 4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_3042: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Voting_0: 0x1a24418200000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `grantVoter(address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 430,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7602,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 430,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 7611,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "calldata_Voting_4 + calldata_Voting_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Voting_4: 0x0\nretval_4879: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_Voting_4 + calldata_Voting_32 + 4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_3042: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Voting_0: 0x1a24418200000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `grantVoter(address,bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "grantVoter(address,bytes)",
        "lineno": 430,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7714,
        "code": "cles public SCOracles; // Contract that defines who is an oracle. Oracles allow wallets to vote\n\tTellers public SCTellers; // Contract that defines who is a teller. Tellers are allowed to close the poll and have an associated pubKey stored on contract\n\n\tmapping (address => bytes) public pubKeys; // Voters' pubkeys\n\n\n\t// **** MODIFIERS\n\tmodifier votingClosed() { if (now >= deadline || VotingStatus == eVotingStatus.Closed) _; }\n\tmodifier votingActive() { if (now < deadline && VotingStatus != eVotingStatus.Closed) _; }\n\n\t// To limit voteGranting function just to authorized oracles\n\tmodifier onlyOracle() {\n\t\tif (!SCOracles.isOracle(msg.sender)) {\n\t\t\terror('onlyOracle function called by user that is not an authorized oracle');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\t// To limit closeVoting function just to authorized tellers\n\tmodifier onlyTeller() {\n\t\tif (!SCTellers.isOracle(msg.sender)) {\n\t\t\terror('onlyTeller function called by user that is not an authorized teller');\n\t\t} else {\n\t\t\t_;\n\t\t}\n\t}\n\n\n\t// **** METHODS\n\tconstructor(address _SCOracles, address _SCTellers) public {\n\t\tSCOracles = Oracles(_SCOracles);\n\t\tSCTellers = Tellers(_SCTellers);\n\t\tdeadline = now + 60 days;\n\t\tVotingStatus = eVotingStatus.Test;\n\t}\n\n\tfunction pollStatus() public constant returns (eVotingStatus) {\n\t\tif (now >= deadline) {\n\t\t\treturn eVotingStatus.Closed;\n\t\t}\n\t\treturn VotingStatus;\n\t}\n\n\tfunction isACitizen(address _voter) public constant returns (bool) {\n\t\tif (allowed[_voter]) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction amIACitizen() public constant returns (bool) {\n\t\treturn (isACitizen(msg.sender));\n\t}\n\n\tfunction canItVote(address _voter) internal constant returns (bool) {\n\t\tif (bytes(votes[_voter]).length == 0) {\n\t\t\treturn true;\n\t\t} else {\n\t\t\treturn false;\n\t\t}\n\t}\n\n\tfunction canIVote() public constant returns (bool) {\n\t\treturn (canItVote(msg.sender));\n\t}\n\n\tfunction sendVote(string _vote) votingActive public returns (bool) {\n\t\t// Check whether voter has not previously casted a vote\n\t\tif (!canIVote()) {\n\t\t\terror('sendVote: sender cannot vote because it has previously casted another vote');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Check whether vote is not empty\n\t\tif (bytes(_vote).length < 1) {\n\t\t\terror('sendVote: vote is empty');\n\t\t\treturn false;\n\t\t}\n\n\t\t// Cast the vote\n\t\tvotes[msg.sender] = _vote;\n\t\tnumVotes ++;\n\n\t\temit SendVote(msg.sender, _vote); // Event log\n\n\t\treturn true;\n\t}\n\n\tfunction getVoter(uint256 _idVoter) /* votingClosed */ public constant returns (address) {\n\t\treturn (votersArray[_idVoter]);\n\t}\n\n\tfunction readVote(address _voter) /* votingClosed */ public constant returns (string) {\n\t\treturn (votes[_voter]);\n\t}\n\n\t// Low level grantVoter w/o pubKey, avoid adding the same voter twice\n\tfunction _grantVoter(address _voter) onlyOracle public {\n\t\tif(!allowed[_voter]) {\n\t\t\tallowed[_voter] = true;\n\t\t\tvotersArray.push(_voter);\n\t\t\tnumVoters ++;\n\n\t\t\temit GrantVoter(_voter); // Event log\n\t\t}\n\t}\n\n\t// New endpoint that sets pubKey as well\n\tfunction grantVoter(address _voter, bytes _pubKey) onlyOracle public {\n\t\t_grantVoter(_voter);\n\n\t\tpubKeys[_voter] = _pubKey;\n\t}\n\n\tfunction getVoterPubKey(address _voter) public constant returns (bytes) {\n\t\treturn (pubKeys[_voter]);\n\t}\n\n\tfunction closeVoting() onlyTeller public {\n\t\tVotingStatus = eVotingStatus.Closed;\n\n\t\temit CloseVoting(true); // Event log\n\t}\n\n\tfunction endTesting() onlyTeller public {\n\t\tnumVotes = 0;\n\t\tuint256 l = votersArray.length;\n\t\tfor(uint256 i = 0;i<l;i++) {\n\t\t\tdelete votes[votersArray[i]];\n\t\t}\n\t\tVotingStatus = eVotingStatus.Voting;\n\t}\n\n\t// fallback function. This SC doesn't accept any Ether\n\tfunction () payable public {\n\t\trevert();\n\t}\n\n\n\t// **** EVENTS\n\t// Triggered when a voter issues a vote\n\tevent SendVote(address indexed _from, string _vote);\n\n\t// Triggered when a voter is granted by the Oracle\n\tevent GrantVoter(address indexed _voter);\n\n\t// Triggered when Contract Owner closes the voting\n\tevent CloseVoting(bool _VotingClosed);\n}",
        "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_62514009886607029107290561805838585334079798074568712924583230797734656856475,\n_____256): 0xfedf99ff7ffff7ffcfffffffffefffbffe7fffffff5f3fffffc069feffffc800\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_62514009886607029107290561805838585334079798074568712924583230797734656856475,\n_____256): 0xbe806f1fb9a91febe830a18c9b68af7fd7defe83d2ebeeebc7db7ebfffffffc1\nstorage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nreturndatasize: 0x20\nretval_3547: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Voting_0: 0x3ade000600000000000000000000000000000000000000000000000000000000\ncalldatasize_Voting: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `endTesting()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x35ccc20c6b7f1b4bdcc4cdf8cb6820fda921cdf0.sol",
        "function": "endTesting()",
        "lineno": 430,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}