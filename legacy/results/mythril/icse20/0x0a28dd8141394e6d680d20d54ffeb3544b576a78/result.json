{
  "contract": "0x0a28dd8141394e6d680d20d54ffeb3544b576a78",
  "tool": "mythril",
  "start": 1563582107.6982138,
  "end": 1563582221.1699417,
  "duration": 113.47172784805298,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1362,
        "code": "fficialGameUrl = _newOfficialGameUrl;\n    }\n}\n\n\n\ninterface IDividendToken{                           \n    function profitOrgPay(",
        "debug": "calldata_SelectOne_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SelectOne_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "setOfficialGameUrl(string)",
        "lineno": 85,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3314,
        "code": "a);\n ",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\ncallvalue: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\ncalldatasize_SelectOne: 0x3\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "fallback",
        "lineno": 29,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3327,
        "code": "rn c;\n    }\n}\n",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xc63a21246c99b000ea0030728005ea6909080a424a47ca48059be3c0ff803205\ncallvalue: 0xd2bd697b67b8b7eebcef8ebaf405ca6a0b728a06c347eda3d5dbebfeffbdb977\ncalldatasize_SelectOne: 0x3\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "fallback",
        "lineno": 30,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6563,
        "code": "Amount);\n\n\n  function play",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "tokenOf(address)",
        "lineno": 361,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 10496,
        "code": "  return a - b",
        "debug": "The exception is triggered under the following conditions:\n\ntimestamp: 0x0\nstorage_16: 0x1\nstorage_15: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_SelectOne_0: 0x1f1dc61b00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "checkPayLoan()",
        "lineno": 24,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 16765,
        "code": "nts;      \n    uint256 BlockNumber;    \n    uint EventId;           \n    bool IsReturnAward;     \n  }\n  mapping (uint => betInfo) public playerBetInfoOf;               \n  IGameToken public GameToken;\n\n\n  //function SelectOne(uint _maxNum, uint256 _gameMinBetAmount,uint256 _gameMaxBetAmount,uint _winMultiplePer,string _gameName,address _gameToken,bool _isToken) public{\n  function SelectOne(uint256 _gameMinBetAmount,uint256 _gameMaxBetAmount, string _gameName,address _gameToken) public{\n    //require(1 < _maxNum);\n    //require(_maxNum < 100);\n    require(_gameMinBetAmount > 0); \n    require(_gameMaxBetAmount >= _gameMinBetAmount);\n    //require(_winMultiplePer < _maxNum.mul(100));\n    owner = msg.sender;             \n    //maxNum = _maxNum;\n    gameMinBetAmount = _gameMinBetAmount;\n    gameMaxBetAmount = _gameMaxBetAmount;\n    minBankerEther = gameMaxBetAmount * 20;\n    //winMultiplePer = _winMultiplePer;\n    gameName = _gameName;   \n    GameToken = IGameToken(_gameToken);\n    shareholder = _gameToken;\n    shareholderIsToken = true;\n    officialGameUrl='http://select.donquixote.games/';\n  }\n  \n\n  function tokenOf(address _user) view public returns(uint _result){\n    _result = GameToken.balanceOf(_user);\n  }\n\n  event OnPlay(address indexed _player, uint[] _betNums,uint256[] _betAmounts,uint256 _giftToken, uint _blockNumber,uint _playNo, uint _eventTime, uint eventId);\n  event OnGetAward(address indexed _player, uint256 _playNo, uint[] _betNums,uint _blockNumber,uint256[] _betAmounts ,uint _eventId,uint _awardNum,uint256 _awardAmount);\n\n\n  function play(uint[] _betNums,uint256[] _betAmounts) public  payable returns(bool _result){       \n    _result = false;\n    require(_betNums.length > 0);\n    require(_betNums.length == _betAmounts.length);\n    depositEther();\n    _result = _play(_betNums,_betAmounts);\n  }\n\n  function _play(uint[] _betNums, uint256[] _betAmounts) private  returns(bool _result){            \n    _result = false;\n    require (!isStopPlay);\n\n    uint maxBetAmount = 0;\n    uint totalBetAmount = 0;\n    uint8[22] memory betNumOf;                      \n\n    for(uint i=0;i < _betNums.length;i++){\n      require(_betNums[i] > 0 && _betNums[i] <= maxNum );\n      require(betNumOf[_betNums[i] - 1] == 0);       \n\t  betNumOf[_betNums[i] - 1] = 1;      \n      if(_betAmounts[i] > gameMaxBetAmount){\n        _betAmounts[i] = gameMaxBetAmount;\n      }\n      if(_betAmounts[i] > maxBetAmount){\n        maxBetAmount = _betAmounts[i];\n      }\n      totalBetAmount = totalBetAmount.add(_betAmounts[i]);\n    }\n\n    uint256 needAmount = maxBetAmount.mul(winMultiplePer).div(100);\n    if(totalBetAmount > needAmount){\n      needAmount = 0;\n    }else{\n      needAmount = needAmount.sub(totalBetAmount);\n    }\n    require(userEtherOf[shareholder] >= needAmount);\n    require(userEtherOf[msg.sender] >= totalBetAmount);\n    lock();\n    betInfo memory bi = betInfo({\n      Player :  msg.sender,              \n      BetNums : _betNums,                       \n      AwardNum : 0,\n      BetAmounts : _betAmounts,                     \n      BlockNumber : block.number,         \n      EventId : currentEventId,           \n      IsReturnAward: false               \n    });\n    playerBetInfoOf[playNo] = bi;\n    userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(totalBetAmount);                  \n    userEtherOf[shareholder] = userEtherOf[shareholder].sub(needAmount);             \n    userEtherOf[this] = userEtherOf[this].add(needAmount).add(totalBetAmount);\n    \n    uint256 _giftToken = GameToken.mineToken(msg.sender,totalBetAmount);\n    emit OnPlay(msg.sender,_betNums,_betAmounts,_giftToken,block.number,playNo,now, getEventId());      \n    playNo++;       \n    _result = true;\n    unLock();\n\t  autoCheckPayShareholder();             \n  }\n\n  function getAward(uint[] _playNos) public returns(bool _result){\n    require(_playNos.length > 0);\n    _result = false;\n    for(uint i = 0;i < _playNos.length;i++){\n      _result = _getAward(_playNos[i]);\n    }\n  }\n\n  function _getAward(uint _playNo) private  returns(bool _result){\n    require(_playNo < playNo);       \n    _result = false;        \n    betInfo storage bi = playerBetInfoOf[_playNo];        \n    require(block.number > bi.BlockNumber);\n    require(!bi.IsReturnAward);      \n\n    lock();\n    uint awardNum = 0;\n    uint256 awardAmount = 0;\n    uint256 totalBetAmount = 0;\n    uint256 maxBetAmount = 0;\n    uint256 totalAmount = 0;\n    for(uint i=0;i <bi.BetNums.length;i++){\n      if(bi.BetAmounts[i] > maxBetAmount){\n        maxBetAmount = bi.BetAmounts[i];\n      }\n      totalBetAmount = totalBetAmount.add(bi.BetAmounts[i]);\n    }\n    totalAmount = maxBetAmount.mul(winMultiplePer).div(100);\n    if(totalBetAmount >= totalAmount){\n      totalAmount = totalBetAmount;\n    }\n    if(bi.BlockNumber.add(256) >= block.number){\n      uint256 randomNum = bi.EventId%1000000;\n      bytes32 encrptyHash = keccak256(bi.Player,block.blockhash(bi.BlockNumber),uintToString(randomNum));\n      awardNum = uint(encrptyHash)%22;\n      awardNum = awardNum.add(1);\n      bi.AwardNum = awardNum;\n      for(uint n=0;n <bi.BetNums.length;n++){\n        if(bi.BetNums[n] == awardNum){\n          awardAmount = bi.BetAmounts[n].mul(winMultiplePer).div(100);\n          bi.IsReturnAward = true;  \n          userEtherOf[this] = userEtherOf[this].sub(totalAmount);\n          userEtherOf[bi.Player] = userEtherOf[bi.Player].add(awardAmount);\n          userEtherOf[shareholder] = userEtherOf[shareholder].add(totalAmount.sub(awardAmount));\n          break;\n        }\n      }\n    }\n    if(!bi.IsReturnAward){\n      bi.IsReturnAward = true;\n      userEtherOf[this] = userEtherOf[this].sub(totalAmount);\n      userEtherOf[shareholder] = userEtherOf[shareholder].add(totalAmount);\n    }\n    emit OnGetAward(bi.Player,_playNo,bi.BetNums,bi.BlockNumber,bi.BetAmounts,getEventId(),awardNum,awardAmount);  \n    _result = true; \n    unLock();\n  }\n  function getAwardNum(uint _playNo) view public returns(uint _awardNum){\n    betInfo memory bi = playerBetInfoOf[_playNo];\n    if(bi.BlockNumber.add(256) >= block.number){\n      uint256 randomNum = bi.EventId%1000000;\n      bytes32 encrptyHash = keccak256(bi.Player,block.blockhash(bi.BlockNumber),uintToString(randomNum));\n      _awardNum = uint(encrptyHash)%22;\n      _awardNum = _awardNum.add(1);\n    }\n  }\n\n  function uintToString(uint v) private pure returns (string)    \n  {\n    uint maxlength = 10;                     \n    bytes memory reversed = new bytes(maxlength);\n    uint i = 0;\n    while (v != 0) {\n      uint remainder = v % 10;\n      v = v / 10;\n      reversed[i++] = byte(48 + remainder);\n    }\n    bytes memory s = new bytes(i);          \n    for (uint j = 0; j < i; j++) {\n      s[j] = reversed[i - j - 1];         \n    }\n    string memory str = string(s);         \n    return str;                            \n  }\n\n  function () public payable {        \n    if(msg.value > 0){\n      userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n    }\n  }\n\n}",
        "debug": "calldata_SelectOne_4 + calldata_SelectOne_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SelectOne_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "setOfficialGameUrl(string)",
        "lineno": 326,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16779,
        "code": "nts;      \n    uint256 BlockNumber;    \n    uint EventId;           \n    bool IsReturnAward;     \n  }\n  mapping (uint => betInfo) public playerBetInfoOf;               \n  IGameToken public GameToken;\n\n\n  //function SelectOne(uint _maxNum, uint256 _gameMinBetAmount,uint256 _gameMaxBetAmount,uint _winMultiplePer,string _gameName,address _gameToken,bool _isToken) public{\n  function SelectOne(uint256 _gameMinBetAmount,uint256 _gameMaxBetAmount, string _gameName,address _gameToken) public{\n    //require(1 < _maxNum);\n    //require(_maxNum < 100);\n    require(_gameMinBetAmount > 0); \n    require(_gameMaxBetAmount >= _gameMinBetAmount);\n    //require(_winMultiplePer < _maxNum.mul(100));\n    owner = msg.sender;             \n    //maxNum = _maxNum;\n    gameMinBetAmount = _gameMinBetAmount;\n    gameMaxBetAmount = _gameMaxBetAmount;\n    minBankerEther = gameMaxBetAmount * 20;\n    //winMultiplePer = _winMultiplePer;\n    gameName = _gameName;   \n    GameToken = IGameToken(_gameToken);\n    shareholder = _gameToken;\n    shareholderIsToken = true;\n    officialGameUrl='http://select.donquixote.games/';\n  }\n  \n\n  function tokenOf(address _user) view public returns(uint _result){\n    _result = GameToken.balanceOf(_user);\n  }\n\n  event OnPlay(address indexed _player, uint[] _betNums,uint256[] _betAmounts,uint256 _giftToken, uint _blockNumber,uint _playNo, uint _eventTime, uint eventId);\n  event OnGetAward(address indexed _player, uint256 _playNo, uint[] _betNums,uint _blockNumber,uint256[] _betAmounts ,uint _eventId,uint _awardNum,uint256 _awardAmount);\n\n\n  function play(uint[] _betNums,uint256[] _betAmounts) public  payable returns(bool _result){       \n    _result = false;\n    require(_betNums.length > 0);\n    require(_betNums.length == _betAmounts.length);\n    depositEther();\n    _result = _play(_betNums,_betAmounts);\n  }\n\n  function _play(uint[] _betNums, uint256[] _betAmounts) private  returns(bool _result){            \n    _result = false;\n    require (!isStopPlay);\n\n    uint maxBetAmount = 0;\n    uint totalBetAmount = 0;\n    uint8[22] memory betNumOf;                      \n\n    for(uint i=0;i < _betNums.length;i++){\n      require(_betNums[i] > 0 && _betNums[i] <= maxNum );\n      require(betNumOf[_betNums[i] - 1] == 0);       \n\t  betNumOf[_betNums[i] - 1] = 1;      \n      if(_betAmounts[i] > gameMaxBetAmount){\n        _betAmounts[i] = gameMaxBetAmount;\n      }\n      if(_betAmounts[i] > maxBetAmount){\n        maxBetAmount = _betAmounts[i];\n      }\n      totalBetAmount = totalBetAmount.add(_betAmounts[i]);\n    }\n\n    uint256 needAmount = maxBetAmount.mul(winMultiplePer).div(100);\n    if(totalBetAmount > needAmount){\n      needAmount = 0;\n    }else{\n      needAmount = needAmount.sub(totalBetAmount);\n    }\n    require(userEtherOf[shareholder] >= needAmount);\n    require(userEtherOf[msg.sender] >= totalBetAmount);\n    lock();\n    betInfo memory bi = betInfo({\n      Player :  msg.sender,              \n      BetNums : _betNums,                       \n      AwardNum : 0,\n      BetAmounts : _betAmounts,                     \n      BlockNumber : block.number,         \n      EventId : currentEventId,           \n      IsReturnAward: false               \n    });\n    playerBetInfoOf[playNo] = bi;\n    userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(totalBetAmount);                  \n    userEtherOf[shareholder] = userEtherOf[shareholder].sub(needAmount);             \n    userEtherOf[this] = userEtherOf[this].add(needAmount).add(totalBetAmount);\n    \n    uint256 _giftToken = GameToken.mineToken(msg.sender,totalBetAmount);\n    emit OnPlay(msg.sender,_betNums,_betAmounts,_giftToken,block.number,playNo,now, getEventId());      \n    playNo++;       \n    _result = true;\n    unLock();\n\t  autoCheckPayShareholder();             \n  }\n\n  function getAward(uint[] _playNos) public returns(bool _result){\n    require(_playNos.length > 0);\n    _result = false;\n    for(uint i = 0;i < _playNos.length;i++){\n      _result = _getAward(_playNos[i]);\n    }\n  }\n\n  function _getAward(uint _playNo) private  returns(bool _result){\n    require(_playNo < playNo);       \n    _result = false;        \n    betInfo storage bi = playerBetInfoOf[_playNo];        \n    require(block.number > bi.BlockNumber);\n    require(!bi.IsReturnAward);      \n\n    lock();\n    uint awardNum = 0;\n    uint256 awardAmount = 0;\n    uint256 totalBetAmount = 0;\n    uint256 maxBetAmount = 0;\n    uint256 totalAmount = 0;\n    for(uint i=0;i <bi.BetNums.length;i++){\n      if(bi.BetAmounts[i] > maxBetAmount){\n        maxBetAmount = bi.BetAmounts[i];\n      }\n      totalBetAmount = totalBetAmount.add(bi.BetAmounts[i]);\n    }\n    totalAmount = maxBetAmount.mul(winMultiplePer).div(100);\n    if(totalBetAmount >= totalAmount){\n      totalAmount = totalBetAmount;\n    }\n    if(bi.BlockNumber.add(256) >= block.number){\n      uint256 randomNum = bi.EventId%1000000;\n      bytes32 encrptyHash = keccak256(bi.Player,block.blockhash(bi.BlockNumber),uintToString(randomNum));\n      awardNum = uint(encrptyHash)%22;\n      awardNum = awardNum.add(1);\n      bi.AwardNum = awardNum;\n      for(uint n=0;n <bi.BetNums.length;n++){\n        if(bi.BetNums[n] == awardNum){\n          awardAmount = bi.BetAmounts[n].mul(winMultiplePer).div(100);\n          bi.IsReturnAward = true;  \n          userEtherOf[this] = userEtherOf[this].sub(totalAmount);\n          userEtherOf[bi.Player] = userEtherOf[bi.Player].add(awardAmount);\n          userEtherOf[shareholder] = userEtherOf[shareholder].add(totalAmount.sub(awardAmount));\n          break;\n        }\n      }\n    }\n    if(!bi.IsReturnAward){\n      bi.IsReturnAward = true;\n      userEtherOf[this] = userEtherOf[this].sub(totalAmount);\n      userEtherOf[shareholder] = userEtherOf[shareholder].add(totalAmount);\n    }\n    emit OnGetAward(bi.Player,_playNo,bi.BetNums,bi.BlockNumber,bi.BetAmounts,getEventId(),awardNum,awardAmount);  \n    _result = true; \n    unLock();\n  }\n  function getAwardNum(uint _playNo) view public returns(uint _awardNum){\n    betInfo memory bi = playerBetInfoOf[_playNo];\n    if(bi.BlockNumber.add(256) >= block.number){\n      uint256 randomNum = bi.EventId%1000000;\n      bytes32 encrptyHash = keccak256(bi.Player,block.blockhash(bi.BlockNumber),uintToString(randomNum));\n      _awardNum = uint(encrptyHash)%22;\n      _awardNum = _awardNum.add(1);\n    }\n  }\n\n  function uintToString(uint v) private pure returns (string)    \n  {\n    uint maxlength = 10;                     \n    bytes memory reversed = new bytes(maxlength);\n    uint i = 0;\n    while (v != 0) {\n      uint remainder = v % 10;\n      v = v / 10;\n      reversed[i++] = byte(48 + remainder);\n    }\n    bytes memory s = new bytes(i);          \n    for (uint j = 0; j < i; j++) {\n      s[j] = reversed[i - j - 1];         \n    }\n    string memory str = string(s);         \n    return str;                            \n  }\n\n  function () public payable {        \n    if(msg.value > 0){\n      userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n    }\n  }\n\n}",
        "debug": "calldata_SelectOne_4 + calldata_SelectOne_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SelectOne_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SelectOne: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0x0a28dd8141394e6d680d20d54ffeb3544b576a78.sol",
        "function": "setOfficialGameUrl(string)",
        "lineno": 326,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}