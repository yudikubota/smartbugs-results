{
  "contract": "0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6",
  "tool": "mythril",
  "start": 1563596293.355912,
  "end": 1563597243.6964648,
  "duration": 950.3405528068542,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 695,
        "code": "his, msg.sender, _",
        "debug": "storage_9: 0xf77124b52a24e057d8a070024000e4e0e29fe1280e6ec1bac4ce6c09cd081036\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nretval_577: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_6: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "fallback",
        "lineno": 197,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 706,
        "code": "      Claimed[msg.sender] = true;\n    ",
        "debug": "storage_8: 0xf6d14ebf7e33fcecfe2fefad81f75d89c06c6b40002039460fff8eb5eff80000\nstorage_9: 0xd6272c21e28ee2a9aa37d12c12aa92d6ef8a62d929fb586fbd8dc825613\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nretval_577: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_6: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "fallback",
        "lineno": 198,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 799,
        "code": "       if (msg.value >=",
        "debug": "storage_9: 0x30c0a13b47a897a2e806bb57dd6cfbc147e285f48aa90122eec66ddf542f\nstorage_5: 0x8cfcf72bfffccb8c3d575aa5a921c137fc900387f1e53ffe1fa7e65d9d9c0000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nretval_577: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_18: 0xff00\ncalldatasize_Tablow: 0x3\nstorage_6: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "fallback",
        "lineno": 203,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4924,
        "code": "gTokensReceiverAddress, _remainingAmount);\n          ",
        "debug": "storage_6: 0x1\nstorage_18: 0xff00\nstorage_8: 0x2\nstorage_17: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Tablow_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `StopDistrib()`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "StopDistrib()",
        "lineno": 285,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 5039,
        "code": "  IsDistribRunning = false;\n        } else {\n            reve",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_17,_256): 0xca0b416000014175629c58be85d948d81ba0869287028324cd21131dbdaec8b4\nstorage_8: 0x10268100000120017ede3713feedee02fffeffffe3bff40dd8d3adbff621419f\nstorage_6: 0x940e7efffffee1ffc453c844ecaf3d009306789a479485f37b0944eae86247c4\nstorage_18: 0xff00\nstorage_17: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Tablow_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `StopDistrib()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "StopDistrib()",
        "lineno": 289,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5055,
        "code": " return true;\n    }\n\n    functio",
        "debug": "storage_8: 0x10268100000120017ede3713feedee02fffeffffe3bff40dd8d3adbff621419f\nstorage_6: 0x940e7efffffee1ffc453c844ecaf3d009306789a479485f37b0944eae86247c4\nstorage_5: 0xca0b416000014175629c58be85d948d81ba0869287028324cd21131dbdaec8b4\nstorage_18: 0xff00\nstorage_17: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0xff\ncalldata_Tablow_0: 0x18d69faa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `StopDistrib()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "StopDistrib()",
        "lineno": 293,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5503,
        "code": "Supply_() pub",
        "debug": "calldata_Tablow_4: 0xf77124b52a24e057d8a070024000e4e0e29fe1280e6ec1bac4ce6c09cd081036\ncalldata_Tablow_0: 0x2cd3fd7000000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `BurnTokens(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "BurnTokens(uint256)",
        "lineno": 357,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5663,
        "code": "ction OwnerDistribSuppl",
        "debug": "calldata_Tablow_4: 0xf2c71b6ec72a2bc2cbdb1100a6c0a6800901d865bacf0a0402981f33eb\nstorage_5: 0x8311d86797e4b35c6094b1d0993b66af86537eac20e1bf6e2b9a265f94cbffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8311d86797e4b35c6094b1d0993b66af86537eac20e1bf6e2b9a265f94cc0000\ncalldata_Tablow_0: 0x2cd3fd7000000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `BurnTokens(uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "BurnTokens(uint256)",
        "lineno": 361,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 11350,
        "code": "ng public name = \"Tablow Club\";\n    uint8 public decimals = 18;\n    uint256  _totalSupply = 0;\n    uint256 _MaxDistribPublicSupply = 0;\n    uint256 _OwnerDistribSupply = 0;\n    uint256 _CurrentDistribPublicSupply = 0;\n    uint256 _FreeTokens = 0;\n    uint256 _Multiplier1 = 2;\n    uint256 _Multiplier2 = 3;\n    uint256 _LimitMultiplier1 = 4e15;\n    uint256 _LimitMultiplier2 = 8e15;\n    uint256 _HighDonateLimit = 5e16;\n    uint256 _BonusTokensPerETHdonated = 0;\n    address _DistribFundsReceiverAddress = 0;\n    address _remainingTokensReceiverAddress = 0;\n    address owner = 0;\n    bool setupDone = false;\n    bool IsDistribRunning = false;\n    bool DistribStarted = false;\n  \n  \n  // Function to access name of token .\n  function name() constant returns (string _name) {\n      return name;\n  }\n  // Function to access symbol of token .\n  function symbol() constant returns (string _symbol) {\n      return symbol;\n  }\n  // Function to access decimals of token .\n  function decimals() constant returns (uint8 _decimals) {\n      return decimals;\n  }\n  // Function to access total supply of tokens .\n   \n  \n   event Transfer(address indexed _from, address indexed _to, uint256 _value);\n    event Approval(address indexed _owner, address indexed _spender, uint256 _value);\n    event Burn(address indexed _owner, uint256 _value);\n\n   \n    mapping(address => mapping(address => uint256)) allowed;\n    mapping(address => bool) public Claimed;\n\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n    function Tablow() public {\n        owner = msg.sender;\n    }\n\n    function() public payable {\n        if (IsDistribRunning) {\n            uint256 _amount;\n            if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert();\n            if (!_DistribFundsReceiverAddress.send(msg.value)) revert();\n            if (Claimed[msg.sender] == false) {\n                _amount = _FreeTokens * 1e18;\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n                Claimed[msg.sender] = true;\n            }\n\n            require(msg.value <= _HighDonateLimit);\n\n            if (msg.value >= 1e15) {\n                if (msg.value >= _LimitMultiplier2) {\n                    _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier2;\n                } else {\n                    if (msg.value >= _LimitMultiplier1) {\n                        _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier1;\n                    } else {\n\n                        _amount = msg.value * _BonusTokensPerETHdonated;\n\n                    }\n\n                }\n\n                _CurrentDistribPublicSupply += _amount;\n                balances[msg.sender] += _amount;\n                _totalSupply += _amount;\n                Transfer(this, msg.sender, _amount);\n            }\n\n\n\n        } else {\n            revert();\n        }\n    }\n\n    function SetupToken(string tokenName, string tokenSymbol, uint256 BonusTokensPerETHdonated, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public {\n        if (msg.sender == owner && !setupDone) {\n            symbol = tokenSymbol;\n            name = tokenName;\n            _FreeTokens = FreeTokens;\n            _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n            _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18;\n            if (OwnerDistribSupply > 0) {\n                _OwnerDistribSupply = OwnerDistribSupply * 1e18;\n                _totalSupply = _OwnerDistribSupply;\n                balances[owner] = _totalSupply;\n                _CurrentDistribPublicSupply += _totalSupply;\n                Transfer(this, owner, _totalSupply);\n            }\n            _DistribFundsReceiverAddress = DistribFundsReceiverAddress;\n            if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner;\n            _remainingTokensReceiverAddress = remainingTokensReceiverAddress;\n\n            setupDone = true;\n        }\n    }\n\n    function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwner public {\n        _Multiplier1 = Multiplier1inX;\n        _Multiplier2 = Multiplier2inX;\n        _LimitMultiplier1 = LimitMultiplier1inWei;\n        _LimitMultiplier2 = LimitMultiplier2inWei;\n        _HighDonateLimit = HighDonateLimitInWei;\n    }\n\n    function SetBonus(uint256 BonusTokensPerETHdonated) onlyOwner public {\n        _BonusTokensPerETHdonated = BonusTokensPerETHdonated;\n    }\n\n    function SetFreeTokens(uint256 FreeTokens) onlyOwner public {\n        _FreeTokens = FreeTokens;\n    }\n\n    function StartDistrib() public returns(bool success) {\n        if (msg.sender == owner && !DistribStarted && setupDone) {\n            DistribStarted = true;\n            IsDistribRunning = true;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function StopDistrib() public returns(bool success) {\n        if (msg.sender == owner && IsDistribRunning) {\n            if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) {\n                uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n                if (_remainingAmount > 0) {\n                    balances[_remainingTokensReceiverAddress] += _remainingAmount;\n                    _totalSupply += _remainingAmount;\n                    Transfer(this, _remainingTokensReceiverAddress, _remainingAmount);\n                }\n            }\n            DistribStarted = false;\n            IsDistribRunning = false;\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n    function distribution(address[] addresses, uint256 _amount) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        require(addresses.length <= 255);\n        require(_amount <= _remainingAmount);\n        _amount = _amount * 1e18;\n\n        for (uint i = 0; i < addresses.length; i++) {\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[addresses[i]] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n        }\n\n        if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n            DistribStarted = false;\n            IsDistribRunning = false;\n        }\n    }\n\n    function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public {\n\n        uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply;\n        uint256 _amount;\n\n        require(addresses.length <= 255);\n        require(addresses.length == amounts.length);\n\n        for (uint8 i = 0; i < addresses.length; i++) {\n            _amount = amounts[i] * 1e18;\n            require(_amount <= _remainingAmount);\n            _CurrentDistribPublicSupply += _amount;\n            balances[addresses[i]] += _amount;\n            _totalSupply += _amount;\n            Transfer(this, addresses[i], _amount);\n\n\n            if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) {\n                DistribStarted = false;\n                IsDistribRunning = false;\n            }\n        }\n    }\n\n function BurnTokens(uint256 amount) public returns(bool success) {\n        uint256 _amount = amount * 1e18;\n        if (balances[msg.sender] >= _amount) {\n            balances[msg.sender] -= _amount;\n            _totalSupply -= _amount;\n            Burn(msg.sender, _amount);\n            Transfer(msg.sender, 0, _amount);\n        } else {\n            revert();\n        }\n        return true;\n    }\n\n     \n\n    function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) {\n        return _MaxDistribPublicSupply;\n    }\n\n    function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) {\n        return _OwnerDistribSupply;\n    }\n\n    function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) {\n        return _CurrentDistribPublicSupply;\n    }\n\n    function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) {\n        return _remainingTokensReceiverAddress;\n    }\n\n    function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) {\n        return _DistribFundsReceiverAddress;\n    }\n\n    function Owner() public constant returns(address ownerAddress) {\n        return owner;\n    }\n\n    function SetupDone() public constant returns(bool setupDoneFlag) {\n        return setupDone;\n    }\n\n    function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) {\n        return IsDistribRunning;\n    }\n     function totalSupply() public constant returns(uint256 totalSupplyValue) {\n        return _totalSupply;\n    }\n\n    function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) {\n        return DistribStarted;\n    }\n function approve(address _spender, uint256 _amount) public returns(bool success) {\n        allowed[msg.sender][_spender] = _amount;\n        Approval(msg.sender, _spender, _amount);\n        return true;\n    }\n\nfunction withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) {\n        ForeignToken token = ForeignToken(_tokenContract);\n        uint256 amount = token.balanceOf(address(this));\n        return token.transfer(owner, amount);\n    }\n    \n    function allowance(address _owner, address _spender) public constant returns(uint256 remaining) {\n        return allowed[_owner][_spender];\n    }\n    \n  // Function that is called when a user or another contract wants to transfer funds .\n  function transfer(address _to, uint _value, bytes _data) returns (bool success) {\n      \n    if(isContract(_to)) {\n        return transferToContract(_to, _value, _data);\n    }\n    else {\n        return transferToAddress(_to, _value, _data);\n    }\n}\n  \n  // Standard function transfer similar to ERC20 transfer with no _data .\n  // Added due to backwards compatibility reasons .\n  function transfer(address _to, uint _value) returns (bool success) {\n      \n    //standard function transfer similar to ERC20 transfer with no _data\n    //added due to backwards compatibility reasons\n    bytes memory empty;\n    if(isContract(_to)) {\n        return transferToContract(_to, _value, empty);\n    }\n    else {\n        return transferToAddress(_to, _value, empty);\n    }\n}\n\n//assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n  function isContract(address _addr) private returns (bool is_contract) {\n      uint length;\n      assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        if(length>0) {\n            return true;\n        }\n        else {\n            return false;\n        }\n    }\n\n  //function that is called when transaction target is an address\n  function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) {\n    assert(balanceOf(msg.sender) >= _value);\n    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n    balances[_to] = safeAdd(balanceOf(_to), _value);\n    Transfer(msg.sender, _to, _value, _data);\n    Transfer(msg.sender, _to, _value);\n    return true;\n  }\n  \n  //function that is called when transaction target is a contract\n  function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) {\n    assert(balanceOf(msg.sender) >= _value);\n    balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n    balances[_to] = safeAdd(balanceOf(_to), _value);\n    ContractReceiver reciever = ContractReceiver(_to);\n    reciever.tokenFallback(msg.sender, _value, _data);\n    Transfer(msg.sender, _to, _value, _data);\n    Transfer(msg.sender, _to, _value);\n    return true;\n}\n\n\n  function balanceOf(address _owner) constant returns (uint balance) {\n    return balances[_owner];\n  }\n  \n}",
        "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Tablow_4 + calldata_Tablow_4)): 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_18: 0x0\ncaller: 0x0\ncalldata_Tablow_0: 0x74c77b5200000000000000000000000000000000000000000000000000000000\ncalldatasize_Tablow: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/22/0x24c9045c59f6ddfbe145cc6cb618c13ed83727e6.sol",
        "function": "SetupToken(string,string,uint256,uint256,uint256,address,address,uint256)",
        "lineno": 134,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}