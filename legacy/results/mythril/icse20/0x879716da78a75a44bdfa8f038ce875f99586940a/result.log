{"error": null, "issues": [{"address": 249, "code": "   mapping(address => Team)", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x8000\ncalldata_DecenterHackathon_0: 0x604061800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "_function_0x06040618", "lineno": 34, "title": "Exception state", "type": "Informational"}, {"address": 821, "code": "entPeriod == Period.Registration);\n\n        juryMemberAddresses.push(_ethAddress);\n        juryMembers[_ethAddress] = JuryMember({\n            name: _name,\n            hasVoted: false\n        });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool (i.e. either sponsor himself or administrator on behalf ", "debug": "calldata_DecenterHackathon_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 97, "title": "Integer Overflow ", "type": "Warning"}, {"address": 958, "code": "mAddresses.length);\n\n        for(uint i = 0; i < _sortedTeams.length; i++) {\n            // All submitted teams must be registered\n            require(bytes(teams[_sortedTeams[i]].name).length > 0);\n\n            // Teams must be sorted correctly\n            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);\n\n            teams[_sortedTeams[i]].submittedByAdmin = true;\n        }\n\n        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on\n        uint prizePoolDivider = 2;\n\n        for(i = 0; i < _sortedTeams.length; i++) {\n            // Make sure all teams are included in _sortedTeams array\n            // (i.e. the array should contain unique elements)\n            require(teams[_sortedTeams[i]].submittedByAdmin);\n\n            uint _prizeAmount = totalContribution / prizePoolDivider;\n\n            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {\n                _sortedTeams[i].transfer(_prizeAmount);\n                teams[_sortedTeams[i]].reward = _prizeAmount;\n                prizePoolDivider *= 2;\n                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);\n            }\n        }\n\n        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically\n        // This amount is returned to contract owner to cover deployment and transaction costs\n        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally\n        administrator.transfer(this.balance);\n\n        currentPeriod = Period.End;\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can disqualify team\n    function disqualifyTeam(address _teamAddress) onlyOwner {\n        require(bytes(teams[_teamAddress].name).length > 0);\n\n        teams[_teamAddress]", "debug": "calldata_DecenterHackathon_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_DecenterHackathon_0: 0x66ac807500000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `payoutPrizes(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "payoutPrizes(address[])", "lineno": 158, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1843, "code": "ring) {\n        if(_address == administrator) {\n         ", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1843\nCall at address: 1843\n", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "returnContributionsToTheSponsors()", "lineno": 213, "title": "Multiple Calls", "type": "Information"}, {"address": 1920, "code": "       name: _name,\n       ", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x8000\ncalldata_DecenterHackathon_0: 0x1196fb6000000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "contributeToPrizePool(string,string,string)", "lineno": 114, "title": "Exception state", "type": "Informational"}, {"address": 2028, "code": ";\n\ncontract Decent", "debug": "storage_7: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0x0\ncallvalue: 0x16345785d8a0000\ncalldata_DecenterHackathon_0: 0x1196fb6000000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\n", "description": "A possible integer overflow exists in the function `contributeToPrizePool(string,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "contributeToPrizePool(string,string,string)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2080, "code": "           ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n ", "debug": "mem_224 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 36)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\ncallvalue: 0x16345785d8a0000\ncalldata_DecenterHackathon_0: 0x1196fb6000000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\n", "description": "A possible integer overflow exists in the function `contributeToPrizePool(string,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "contributeToPrizePool(string,string,string)", "lineno": 117, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2109, "code": "           ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n ", "debug": "mem_224 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 36)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\nkeccac_0_+\n75276140696391174450305814049576319106646922510300487059720162673006384432776_+\n5*storage_7: 0xffc0097f9e184b3e62080306f4f7fa100800724ffffffffc7dff0080f6605843\nstorage_0 +\n75276140696391174450305814049576319106646922510300487059720162673006384432776 +\n5*storage_7: 0x157230aeaf7961b3d014d0bc732fe487662dba6a0ec6906017c001b3bc779661\nmem_mem_224 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 36)) +\n0: 0x0\ncallvalue: 0x16345785d8a0000\ncalldata_DecenterHackathon_0: 0x1196fb6000000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\n", "description": "A possible integer overflow exists in the function `contributeToPrizePool(string,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "contributeToPrizePool(string,string,string)", "lineno": 117, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2768, "code": "ss].name).length == 0);\n\n        tea", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x8000\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x6305d01000000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerTeam(string,address,string,bool)", "lineno": 79, "title": "Exception state", "type": "Informational"}, {"address": 3023, "code": "memberNames,\n            score: 0,\n            reward: 0,\n            rewardEligible: _rewardEligible,\n            submittedByAdmin: false,\n            disqualified: false\n        });\n\n        teamAddresses.push(_teamAddress);\n        TeamRegistered(_name, _teamAddress,", "debug": "mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_32 + 36)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_DecenterHackathon_32_+_4: 0x0\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x6305d01000000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerTeam(string,address,string,bool)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerTeam(string,address,string,bool)", "lineno": 83, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3752, "code": "uryMembers[_ethAddress] = JuryMember", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x8000\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 100, "title": "Exception state", "type": "Informational"}, {"address": 3775, "code": ";\n\ncontract Decent", "debug": "storage_1: 0x0\nstorage_6: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3970, "code": "  });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool ", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_1: 0x0\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 103, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4366, "code": "{\n            // All submitted teams", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x8000\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x66ac807500000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "payoutPrizes(address[])", "lineno": 160, "title": "Exception state", "type": "Informational"}, {"address": 6869, "code": "d) {\n            return;\n        }\n\n", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x8000\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0xa432e6d600000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "switchToNextPeriod()", "lineno": 67, "title": "Exception state", "type": "Informational"}, {"address": 7372, "code": "].hasVoted == false);\n\n       ", "debug": "The exception is triggered under the following conditions:\n\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfffffffffffffffffffffffffffff7ffffffffffffffffffffffffffffff7f01\nstorage_1: 0x8000\ncalldata_DecenterHackathon_0: 0xed08132900000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "vote(address[])", "lineno": 130, "title": "Exception state", "type": "Informational"}, {"address": 8668, "code": "ntract DecenterHackathon {\n\n    struct Team {\n        string name;\n        string memberNames;\n        uint score;\n        uint reward;\n        bool rewardEligible;\n        bool submittedByAdmin;\n        bool disqualified;\n        mapping(address => bool) votedForByJuryMember;\n    }\n\n    struct JuryMember {\n        string name;\n        bool hasVoted;\n    }\n\n    struct Sponsor {\n        string name;\n        string siteUrl;\n        string logoUrl;\n        address ethAddress;\n        uint contribution;\n    }\n\n    enum Period { Registration, Competition, Voting, Verification, End }\n\n    uint public totalContribution;\n    Period public currentPeriod;\n\n    mapping(address => Team) teams;\n    mapping(address => JuryMember) juryMembers;\n\n    address administrator;\n    address[] teamAddresses;\n    address[] juryMemberAddresses;\n    Sponsor[] sponsors;\n\n    event PeriodChanged(Period newPeriod);\n    event TeamRegistered(string teamName, address teamAddress, string memberNames, bool rewardEligible);\n    event JuryMemberAdded(string juryMemberName, address juryMemberAddress);\n    event SponsorshipReceived(string sponsorName, string sponsorSite, string sponsorLogoUrl, uint amount);\n    event VoteReceived(string juryMemberName, address indexed teamAddress, uint points);\n    event PrizePaid(string teamName, uint amount);\n    event TeamDisqualified(address teamAddress);\n\n    modifier onlyOwner {\n        require(msg.sender == administrator);\n        _;\n    }\n\n    modifier onlyJury {\n        require(bytes(juryMembers[msg.sender].name).length > 0);\n        _;\n    }\n\n   function DecenterHackathon() {\n        administrator = msg.sender;\n        currentPeriod = Period.Registration;\n    }\n\n    // Administrator is able to switch between periods at any time\n    function switchToNextPeriod() onlyOwner {\n        if(currentPeriod == Period.Verification || currentPeriod == Period.End) {\n            return;\n        }\n\n        currentPeriod = Period(uint(currentPeriod) + 1);\n\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can add new teams during registration period, with an option to make a team non-eligible for the prize\n    function registerTeam(string _name, address _teamAddress, string _memberNames, bool _rewardEligible) onlyOwner {\n        require(currentPeriod == Period.Registration);\n        require(bytes(teams[_teamAddress].name).length == 0);\n\n        teams[_teamAddress] = Team({\n            name: _name,\n            memberNames: _memberNames,\n            score: 0,\n            reward: 0,\n            rewardEligible: _rewardEligible,\n            submittedByAdmin: false,\n            disqualified: false\n        });\n\n        teamAddresses.push(_teamAddress);\n        TeamRegistered(_name, _teamAddress, _memberNames, _rewardEligible);\n    }\n\n    // Administrator can add new jury members during registration period\n    function registerJuryMember(string _name, address _ethAddress) onlyOwner {\n        require(currentPeriod == Period.Registration);\n\n        juryMemberAddresses.push(_ethAddress);\n        juryMembers[_ethAddress] = JuryMember({\n            name: _name,\n            hasVoted: false\n        });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool (i.e. either sponsor himself or administrator on behalf of the sponsor) during registration period\n    function contributeToPrizePool(string _name, string _siteUrl, string _logoUrl) payable {\n        require(currentPeriod != Period.End);\n        require(msg.value >= 0.1 ether);\n\n        sponsors.push(Sponsor({\n            name: _name,\n            siteUrl: _siteUrl,\n            logoUrl: _logoUrl,\n            ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n    // Jury members can vote during voting period\n    // The _votes parameter should be an array of team addresses, sorted by score from highest to lowest based on jury member's preferences\n    function vote(address[] _votes) onlyJury {\n        require(currentPeriod == Period.Voting);\n        require(_votes.length == teamAddresses.length);\n        require(juryMembers[msg.sender].hasVoted == false);\n\n        uint _points = _votes.length;\n\n        for(uint i = 0; i < _votes.length; i++) {\n            address teamAddress = _votes[i];\n\n            // All submitted teams must be registered\n            require(bytes(teams[teamAddress].name).length > 0);\n\n            // Judge should not be able to vote for the same team more than once\n            require(teams[teamAddress].votedForByJuryMember[msg.sender] == false);\n\n            teams[teamAddress].score += _points;\n            teams[teamAddress].votedForByJuryMember[msg.sender] = true;\n\n            VoteReceived(juryMembers[msg.sender].name, teamAddress, _points);\n            _points--;\n        }\n\n        // This will prevent jury members from voting more than once\n        juryMembers[msg.sender].hasVoted = true;\n    }\n\n    // Administrator can initiate prize payout during final period\n    // The _sortedTeams parameter should be an array of correctly sorted teams by score, from highest to lowest\n    function payoutPrizes(address[] _sortedTeams) onlyOwner {\n        require(currentPeriod == Period.Verification);\n        require(_sortedTeams.length == teamAddresses.length);\n\n        for(uint i = 0; i < _sortedTeams.length; i++) {\n            // All submitted teams must be registered\n            require(bytes(teams[_sortedTeams[i]].name).length > 0);\n\n            // Teams must be sorted correctly\n            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);\n\n            teams[_sortedTeams[i]].submittedByAdmin = true;\n        }\n\n        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on\n        uint prizePoolDivider = 2;\n\n        for(i = 0; i < _sortedTeams.length; i++) {\n            // Make sure all teams are included in _sortedTeams array\n            // (i.e. the array should contain unique elements)\n            require(teams[_sortedTeams[i]].submittedByAdmin);\n\n            uint _prizeAmount = totalContribution / prizePoolDivider;\n\n            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {\n                _sortedTeams[i].transfer(_prizeAmount);\n                teams[_sortedTeams[i]].reward = _prizeAmount;\n                prizePoolDivider *= 2;\n                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);\n            }\n        }\n\n        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically\n        // This amount is returned to contract owner to cover deployment and transaction costs\n        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally\n        administrator.transfer(this.balance);\n\n        currentPeriod = Period.End;\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can disqualify team\n    function disqualifyTeam(address _teamAddress) onlyOwner {\n        require(bytes(teams[_teamAddress].name).length > 0);\n\n        teams[_teamAddress].disqualified = true;\n        TeamDisqualified(_teamAddress);\n    }\n\n    // In case something goes wrong and contract needs to be redeployed, this is a way to return all contributions to the sponsors\n    function returnContributionsToTheSponsors() onlyOwner {\n        for(uint i = i; i < sponsors.length; i++) {\n            sponsors[i].ethAddress.transfer(sponsors[i].contribution);\n        }\n    }\n\n    // Public function that returns user type for the given address\n    function getUserType(address _address) constant returns (string) {\n        if(_address == administrator) {\n            return \"administrator\";\n        } else if(bytes(juryMembers[_address].name).length > 0) {\n            return \"jury\";\n        } else {\n            return \"other\";\n        }\n    }\n\n    // Check if jury member voted\n    function checkJuryVoted(address _juryAddress) constant returns (bool){\n        require(bytes(juryMembers[_juryAddress].name).length != 0);\n\n        return juryMembers[_juryAddress].hasVoted;\n    }\n\n    // Returns total prize pool size\n    function getPrizePoolSize() constant returns (uint) {\n        return totalContribution;\n    }\n\n    function restartPeriod() onlyOwner {\n        currentPeriod = Period.Registration;\n    }\n}", "debug": "keccac_0_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_DecenterHackathon_32_+_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_DecenterHackathon_32_+_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8697, "code": "ntract DecenterHackathon {\n\n    struct Team {\n        string name;\n        string memberNames;\n        uint score;\n        uint reward;\n        bool rewardEligible;\n        bool submittedByAdmin;\n        bool disqualified;\n        mapping(address => bool) votedForByJuryMember;\n    }\n\n    struct JuryMember {\n        string name;\n        bool hasVoted;\n    }\n\n    struct Sponsor {\n        string name;\n        string siteUrl;\n        string logoUrl;\n        address ethAddress;\n        uint contribution;\n    }\n\n    enum Period { Registration, Competition, Voting, Verification, End }\n\n    uint public totalContribution;\n    Period public currentPeriod;\n\n    mapping(address => Team) teams;\n    mapping(address => JuryMember) juryMembers;\n\n    address administrator;\n    address[] teamAddresses;\n    address[] juryMemberAddresses;\n    Sponsor[] sponsors;\n\n    event PeriodChanged(Period newPeriod);\n    event TeamRegistered(string teamName, address teamAddress, string memberNames, bool rewardEligible);\n    event JuryMemberAdded(string juryMemberName, address juryMemberAddress);\n    event SponsorshipReceived(string sponsorName, string sponsorSite, string sponsorLogoUrl, uint amount);\n    event VoteReceived(string juryMemberName, address indexed teamAddress, uint points);\n    event PrizePaid(string teamName, uint amount);\n    event TeamDisqualified(address teamAddress);\n\n    modifier onlyOwner {\n        require(msg.sender == administrator);\n        _;\n    }\n\n    modifier onlyJury {\n        require(bytes(juryMembers[msg.sender].name).length > 0);\n        _;\n    }\n\n   function DecenterHackathon() {\n        administrator = msg.sender;\n        currentPeriod = Period.Registration;\n    }\n\n    // Administrator is able to switch between periods at any time\n    function switchToNextPeriod() onlyOwner {\n        if(currentPeriod == Period.Verification || currentPeriod == Period.End) {\n            return;\n        }\n\n        currentPeriod = Period(uint(currentPeriod) + 1);\n\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can add new teams during registration period, with an option to make a team non-eligible for the prize\n    function registerTeam(string _name, address _teamAddress, string _memberNames, bool _rewardEligible) onlyOwner {\n        require(currentPeriod == Period.Registration);\n        require(bytes(teams[_teamAddress].name).length == 0);\n\n        teams[_teamAddress] = Team({\n            name: _name,\n            memberNames: _memberNames,\n            score: 0,\n            reward: 0,\n            rewardEligible: _rewardEligible,\n            submittedByAdmin: false,\n            disqualified: false\n        });\n\n        teamAddresses.push(_teamAddress);\n        TeamRegistered(_name, _teamAddress, _memberNames, _rewardEligible);\n    }\n\n    // Administrator can add new jury members during registration period\n    function registerJuryMember(string _name, address _ethAddress) onlyOwner {\n        require(currentPeriod == Period.Registration);\n\n        juryMemberAddresses.push(_ethAddress);\n        juryMembers[_ethAddress] = JuryMember({\n            name: _name,\n            hasVoted: false\n        });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool (i.e. either sponsor himself or administrator on behalf of the sponsor) during registration period\n    function contributeToPrizePool(string _name, string _siteUrl, string _logoUrl) payable {\n        require(currentPeriod != Period.End);\n        require(msg.value >= 0.1 ether);\n\n        sponsors.push(Sponsor({\n            name: _name,\n            siteUrl: _siteUrl,\n            logoUrl: _logoUrl,\n            ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n    // Jury members can vote during voting period\n    // The _votes parameter should be an array of team addresses, sorted by score from highest to lowest based on jury member's preferences\n    function vote(address[] _votes) onlyJury {\n        require(currentPeriod == Period.Voting);\n        require(_votes.length == teamAddresses.length);\n        require(juryMembers[msg.sender].hasVoted == false);\n\n        uint _points = _votes.length;\n\n        for(uint i = 0; i < _votes.length; i++) {\n            address teamAddress = _votes[i];\n\n            // All submitted teams must be registered\n            require(bytes(teams[teamAddress].name).length > 0);\n\n            // Judge should not be able to vote for the same team more than once\n            require(teams[teamAddress].votedForByJuryMember[msg.sender] == false);\n\n            teams[teamAddress].score += _points;\n            teams[teamAddress].votedForByJuryMember[msg.sender] = true;\n\n            VoteReceived(juryMembers[msg.sender].name, teamAddress, _points);\n            _points--;\n        }\n\n        // This will prevent jury members from voting more than once\n        juryMembers[msg.sender].hasVoted = true;\n    }\n\n    // Administrator can initiate prize payout during final period\n    // The _sortedTeams parameter should be an array of correctly sorted teams by score, from highest to lowest\n    function payoutPrizes(address[] _sortedTeams) onlyOwner {\n        require(currentPeriod == Period.Verification);\n        require(_sortedTeams.length == teamAddresses.length);\n\n        for(uint i = 0; i < _sortedTeams.length; i++) {\n            // All submitted teams must be registered\n            require(bytes(teams[_sortedTeams[i]].name).length > 0);\n\n            // Teams must be sorted correctly\n            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);\n\n            teams[_sortedTeams[i]].submittedByAdmin = true;\n        }\n\n        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on\n        uint prizePoolDivider = 2;\n\n        for(i = 0; i < _sortedTeams.length; i++) {\n            // Make sure all teams are included in _sortedTeams array\n            // (i.e. the array should contain unique elements)\n            require(teams[_sortedTeams[i]].submittedByAdmin);\n\n            uint _prizeAmount = totalContribution / prizePoolDivider;\n\n            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {\n                _sortedTeams[i].transfer(_prizeAmount);\n                teams[_sortedTeams[i]].reward = _prizeAmount;\n                prizePoolDivider *= 2;\n                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);\n            }\n        }\n\n        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically\n        // This amount is returned to contract owner to cover deployment and transaction costs\n        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally\n        administrator.transfer(this.balance);\n\n        currentPeriod = Period.End;\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can disqualify team\n    function disqualifyTeam(address _teamAddress) onlyOwner {\n        require(bytes(teams[_teamAddress].name).length > 0);\n\n        teams[_teamAddress].disqualified = true;\n        TeamDisqualified(_teamAddress);\n    }\n\n    // In case something goes wrong and contract needs to be redeployed, this is a way to return all contributions to the sponsors\n    function returnContributionsToTheSponsors() onlyOwner {\n        for(uint i = i; i < sponsors.length; i++) {\n            sponsors[i].ethAddress.transfer(sponsors[i].contribution);\n        }\n    }\n\n    // Public function that returns user type for the given address\n    function getUserType(address _address) constant returns (string) {\n        if(_address == administrator) {\n            return \"administrator\";\n        } else if(bytes(juryMembers[_address].name).length > 0) {\n            return \"jury\";\n        } else {\n            return \"other\";\n        }\n    }\n\n    // Check if jury member voted\n    function checkJuryVoted(address _juryAddress) constant returns (bool){\n        require(bytes(juryMembers[_juryAddress].name).length != 0);\n\n        return juryMembers[_juryAddress].hasVoted;\n    }\n\n    // Returns total prize pool size\n    function getPrizePoolSize() constant returns (uint) {\n        return totalContribution;\n    }\n\n    function restartPeriod() onlyOwner {\n        currentPeriod = Period.Registration;\n    }\n}", "debug": "storage_1: 0x0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8711, "code": "ntract DecenterHackathon {\n\n    struct Team {\n        string name;\n        string memberNames;\n        uint score;\n        uint reward;\n        bool rewardEligible;\n        bool submittedByAdmin;\n        bool disqualified;\n        mapping(address => bool) votedForByJuryMember;\n    }\n\n    struct JuryMember {\n        string name;\n        bool hasVoted;\n    }\n\n    struct Sponsor {\n        string name;\n        string siteUrl;\n        string logoUrl;\n        address ethAddress;\n        uint contribution;\n    }\n\n    enum Period { Registration, Competition, Voting, Verification, End }\n\n    uint public totalContribution;\n    Period public currentPeriod;\n\n    mapping(address => Team) teams;\n    mapping(address => JuryMember) juryMembers;\n\n    address administrator;\n    address[] teamAddresses;\n    address[] juryMemberAddresses;\n    Sponsor[] sponsors;\n\n    event PeriodChanged(Period newPeriod);\n    event TeamRegistered(string teamName, address teamAddress, string memberNames, bool rewardEligible);\n    event JuryMemberAdded(string juryMemberName, address juryMemberAddress);\n    event SponsorshipReceived(string sponsorName, string sponsorSite, string sponsorLogoUrl, uint amount);\n    event VoteReceived(string juryMemberName, address indexed teamAddress, uint points);\n    event PrizePaid(string teamName, uint amount);\n    event TeamDisqualified(address teamAddress);\n\n    modifier onlyOwner {\n        require(msg.sender == administrator);\n        _;\n    }\n\n    modifier onlyJury {\n        require(bytes(juryMembers[msg.sender].name).length > 0);\n        _;\n    }\n\n   function DecenterHackathon() {\n        administrator = msg.sender;\n        currentPeriod = Period.Registration;\n    }\n\n    // Administrator is able to switch between periods at any time\n    function switchToNextPeriod() onlyOwner {\n        if(currentPeriod == Period.Verification || currentPeriod == Period.End) {\n            return;\n        }\n\n        currentPeriod = Period(uint(currentPeriod) + 1);\n\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can add new teams during registration period, with an option to make a team non-eligible for the prize\n    function registerTeam(string _name, address _teamAddress, string _memberNames, bool _rewardEligible) onlyOwner {\n        require(currentPeriod == Period.Registration);\n        require(bytes(teams[_teamAddress].name).length == 0);\n\n        teams[_teamAddress] = Team({\n            name: _name,\n            memberNames: _memberNames,\n            score: 0,\n            reward: 0,\n            rewardEligible: _rewardEligible,\n            submittedByAdmin: false,\n            disqualified: false\n        });\n\n        teamAddresses.push(_teamAddress);\n        TeamRegistered(_name, _teamAddress, _memberNames, _rewardEligible);\n    }\n\n    // Administrator can add new jury members during registration period\n    function registerJuryMember(string _name, address _ethAddress) onlyOwner {\n        require(currentPeriod == Period.Registration);\n\n        juryMemberAddresses.push(_ethAddress);\n        juryMembers[_ethAddress] = JuryMember({\n            name: _name,\n            hasVoted: false\n        });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool (i.e. either sponsor himself or administrator on behalf of the sponsor) during registration period\n    function contributeToPrizePool(string _name, string _siteUrl, string _logoUrl) payable {\n        require(currentPeriod != Period.End);\n        require(msg.value >= 0.1 ether);\n\n        sponsors.push(Sponsor({\n            name: _name,\n            siteUrl: _siteUrl,\n            logoUrl: _logoUrl,\n            ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n    // Jury members can vote during voting period\n    // The _votes parameter should be an array of team addresses, sorted by score from highest to lowest based on jury member's preferences\n    function vote(address[] _votes) onlyJury {\n        require(currentPeriod == Period.Voting);\n        require(_votes.length == teamAddresses.length);\n        require(juryMembers[msg.sender].hasVoted == false);\n\n        uint _points = _votes.length;\n\n        for(uint i = 0; i < _votes.length; i++) {\n            address teamAddress = _votes[i];\n\n            // All submitted teams must be registered\n            require(bytes(teams[teamAddress].name).length > 0);\n\n            // Judge should not be able to vote for the same team more than once\n            require(teams[teamAddress].votedForByJuryMember[msg.sender] == false);\n\n            teams[teamAddress].score += _points;\n            teams[teamAddress].votedForByJuryMember[msg.sender] = true;\n\n            VoteReceived(juryMembers[msg.sender].name, teamAddress, _points);\n            _points--;\n        }\n\n        // This will prevent jury members from voting more than once\n        juryMembers[msg.sender].hasVoted = true;\n    }\n\n    // Administrator can initiate prize payout during final period\n    // The _sortedTeams parameter should be an array of correctly sorted teams by score, from highest to lowest\n    function payoutPrizes(address[] _sortedTeams) onlyOwner {\n        require(currentPeriod == Period.Verification);\n        require(_sortedTeams.length == teamAddresses.length);\n\n        for(uint i = 0; i < _sortedTeams.length; i++) {\n            // All submitted teams must be registered\n            require(bytes(teams[_sortedTeams[i]].name).length > 0);\n\n            // Teams must be sorted correctly\n            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);\n\n            teams[_sortedTeams[i]].submittedByAdmin = true;\n        }\n\n        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on\n        uint prizePoolDivider = 2;\n\n        for(i = 0; i < _sortedTeams.length; i++) {\n            // Make sure all teams are included in _sortedTeams array\n            // (i.e. the array should contain unique elements)\n            require(teams[_sortedTeams[i]].submittedByAdmin);\n\n            uint _prizeAmount = totalContribution / prizePoolDivider;\n\n            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {\n                _sortedTeams[i].transfer(_prizeAmount);\n                teams[_sortedTeams[i]].reward = _prizeAmount;\n                prizePoolDivider *= 2;\n                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);\n            }\n        }\n\n        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically\n        // This amount is returned to contract owner to cover deployment and transaction costs\n        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally\n        administrator.transfer(this.balance);\n\n        currentPeriod = Period.End;\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can disqualify team\n    function disqualifyTeam(address _teamAddress) onlyOwner {\n        require(bytes(teams[_teamAddress].name).length > 0);\n\n        teams[_teamAddress].disqualified = true;\n        TeamDisqualified(_teamAddress);\n    }\n\n    // In case something goes wrong and contract needs to be redeployed, this is a way to return all contributions to the sponsors\n    function returnContributionsToTheSponsors() onlyOwner {\n        for(uint i = i; i < sponsors.length; i++) {\n            sponsors[i].ethAddress.transfer(sponsors[i].contribution);\n        }\n    }\n\n    // Public function that returns user type for the given address\n    function getUserType(address _address) constant returns (string) {\n        if(_address == administrator) {\n            return \"administrator\";\n        } else if(bytes(juryMembers[_address].name).length > 0) {\n            return \"jury\";\n        } else {\n            return \"other\";\n        }\n    }\n\n    // Check if jury member voted\n    function checkJuryVoted(address _juryAddress) constant returns (bool){\n        require(bytes(juryMembers[_juryAddress].name).length != 0);\n\n        return juryMembers[_juryAddress].hasVoted;\n    }\n\n    // Returns total prize pool size\n    function getPrizePoolSize() constant returns (uint) {\n        return totalContribution;\n    }\n\n    function restartPeriod() onlyOwner {\n        currentPeriod = Period.Registration;\n    }\n}", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nstorage_1: 0x0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8728, "code": "ntract DecenterHackathon {\n\n    struct Team {\n        string name;\n        string memberNames;\n        uint score;\n        uint reward;\n        bool rewardEligible;\n        bool submittedByAdmin;\n        bool disqualified;\n        mapping(address => bool) votedForByJuryMember;\n    }\n\n    struct JuryMember {\n        string name;\n        bool hasVoted;\n    }\n\n    struct Sponsor {\n        string name;\n        string siteUrl;\n        string logoUrl;\n        address ethAddress;\n        uint contribution;\n    }\n\n    enum Period { Registration, Competition, Voting, Verification, End }\n\n    uint public totalContribution;\n    Period public currentPeriod;\n\n    mapping(address => Team) teams;\n    mapping(address => JuryMember) juryMembers;\n\n    address administrator;\n    address[] teamAddresses;\n    address[] juryMemberAddresses;\n    Sponsor[] sponsors;\n\n    event PeriodChanged(Period newPeriod);\n    event TeamRegistered(string teamName, address teamAddress, string memberNames, bool rewardEligible);\n    event JuryMemberAdded(string juryMemberName, address juryMemberAddress);\n    event SponsorshipReceived(string sponsorName, string sponsorSite, string sponsorLogoUrl, uint amount);\n    event VoteReceived(string juryMemberName, address indexed teamAddress, uint points);\n    event PrizePaid(string teamName, uint amount);\n    event TeamDisqualified(address teamAddress);\n\n    modifier onlyOwner {\n        require(msg.sender == administrator);\n        _;\n    }\n\n    modifier onlyJury {\n        require(bytes(juryMembers[msg.sender].name).length > 0);\n        _;\n    }\n\n   function DecenterHackathon() {\n        administrator = msg.sender;\n        currentPeriod = Period.Registration;\n    }\n\n    // Administrator is able to switch between periods at any time\n    function switchToNextPeriod() onlyOwner {\n        if(currentPeriod == Period.Verification || currentPeriod == Period.End) {\n            return;\n        }\n\n        currentPeriod = Period(uint(currentPeriod) + 1);\n\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can add new teams during registration period, with an option to make a team non-eligible for the prize\n    function registerTeam(string _name, address _teamAddress, string _memberNames, bool _rewardEligible) onlyOwner {\n        require(currentPeriod == Period.Registration);\n        require(bytes(teams[_teamAddress].name).length == 0);\n\n        teams[_teamAddress] = Team({\n            name: _name,\n            memberNames: _memberNames,\n            score: 0,\n            reward: 0,\n            rewardEligible: _rewardEligible,\n            submittedByAdmin: false,\n            disqualified: false\n        });\n\n        teamAddresses.push(_teamAddress);\n        TeamRegistered(_name, _teamAddress, _memberNames, _rewardEligible);\n    }\n\n    // Administrator can add new jury members during registration period\n    function registerJuryMember(string _name, address _ethAddress) onlyOwner {\n        require(currentPeriod == Period.Registration);\n\n        juryMemberAddresses.push(_ethAddress);\n        juryMembers[_ethAddress] = JuryMember({\n            name: _name,\n            hasVoted: false\n        });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool (i.e. either sponsor himself or administrator on behalf of the sponsor) during registration period\n    function contributeToPrizePool(string _name, string _siteUrl, string _logoUrl) payable {\n        require(currentPeriod != Period.End);\n        require(msg.value >= 0.1 ether);\n\n        sponsors.push(Sponsor({\n            name: _name,\n            siteUrl: _siteUrl,\n            logoUrl: _logoUrl,\n            ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n    // Jury members can vote during voting period\n    // The _votes parameter should be an array of team addresses, sorted by score from highest to lowest based on jury member's preferences\n    function vote(address[] _votes) onlyJury {\n        require(currentPeriod == Period.Voting);\n        require(_votes.length == teamAddresses.length);\n        require(juryMembers[msg.sender].hasVoted == false);\n\n        uint _points = _votes.length;\n\n        for(uint i = 0; i < _votes.length; i++) {\n            address teamAddress = _votes[i];\n\n            // All submitted teams must be registered\n            require(bytes(teams[teamAddress].name).length > 0);\n\n            // Judge should not be able to vote for the same team more than once\n            require(teams[teamAddress].votedForByJuryMember[msg.sender] == false);\n\n            teams[teamAddress].score += _points;\n            teams[teamAddress].votedForByJuryMember[msg.sender] = true;\n\n            VoteReceived(juryMembers[msg.sender].name, teamAddress, _points);\n            _points--;\n        }\n\n        // This will prevent jury members from voting more than once\n        juryMembers[msg.sender].hasVoted = true;\n    }\n\n    // Administrator can initiate prize payout during final period\n    // The _sortedTeams parameter should be an array of correctly sorted teams by score, from highest to lowest\n    function payoutPrizes(address[] _sortedTeams) onlyOwner {\n        require(currentPeriod == Period.Verification);\n        require(_sortedTeams.length == teamAddresses.length);\n\n        for(uint i = 0; i < _sortedTeams.length; i++) {\n            // All submitted teams must be registered\n            require(bytes(teams[_sortedTeams[i]].name).length > 0);\n\n            // Teams must be sorted correctly\n            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);\n\n            teams[_sortedTeams[i]].submittedByAdmin = true;\n        }\n\n        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on\n        uint prizePoolDivider = 2;\n\n        for(i = 0; i < _sortedTeams.length; i++) {\n            // Make sure all teams are included in _sortedTeams array\n            // (i.e. the array should contain unique elements)\n            require(teams[_sortedTeams[i]].submittedByAdmin);\n\n            uint _prizeAmount = totalContribution / prizePoolDivider;\n\n            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {\n                _sortedTeams[i].transfer(_prizeAmount);\n                teams[_sortedTeams[i]].reward = _prizeAmount;\n                prizePoolDivider *= 2;\n                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);\n            }\n        }\n\n        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically\n        // This amount is returned to contract owner to cover deployment and transaction costs\n        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally\n        administrator.transfer(this.balance);\n\n        currentPeriod = Period.End;\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can disqualify team\n    function disqualifyTeam(address _teamAddress) onlyOwner {\n        require(bytes(teams[_teamAddress].name).length > 0);\n\n        teams[_teamAddress].disqualified = true;\n        TeamDisqualified(_teamAddress);\n    }\n\n    // In case something goes wrong and contract needs to be redeployed, this is a way to return all contributions to the sponsors\n    function returnContributionsToTheSponsors() onlyOwner {\n        for(uint i = i; i < sponsors.length; i++) {\n            sponsors[i].ethAddress.transfer(sponsors[i].contribution);\n        }\n    }\n\n    // Public function that returns user type for the given address\n    function getUserType(address _address) constant returns (string) {\n        if(_address == administrator) {\n            return \"administrator\";\n        } else if(bytes(juryMembers[_address].name).length > 0) {\n            return \"jury\";\n        } else {\n            return \"other\";\n        }\n    }\n\n    // Check if jury member voted\n    function checkJuryVoted(address _juryAddress) constant returns (bool){\n        require(bytes(juryMembers[_juryAddress].name).length != 0);\n\n        return juryMembers[_juryAddress].hasVoted;\n    }\n\n    // Returns total prize pool size\n    function getPrizePoolSize() constant returns (uint) {\n        return totalContribution;\n    }\n\n    function restartPeriod() onlyOwner {\n        currentPeriod = Period.Registration;\n    }\n}", "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\nstorage_1: 0x0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0x25\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8733, "code": "ntract DecenterHackathon {\n\n    struct Team {\n        string name;\n        string memberNames;\n        uint score;\n        uint reward;\n        bool rewardEligible;\n        bool submittedByAdmin;\n        bool disqualified;\n        mapping(address => bool) votedForByJuryMember;\n    }\n\n    struct JuryMember {\n        string name;\n        bool hasVoted;\n    }\n\n    struct Sponsor {\n        string name;\n        string siteUrl;\n        string logoUrl;\n        address ethAddress;\n        uint contribution;\n    }\n\n    enum Period { Registration, Competition, Voting, Verification, End }\n\n    uint public totalContribution;\n    Period public currentPeriod;\n\n    mapping(address => Team) teams;\n    mapping(address => JuryMember) juryMembers;\n\n    address administrator;\n    address[] teamAddresses;\n    address[] juryMemberAddresses;\n    Sponsor[] sponsors;\n\n    event PeriodChanged(Period newPeriod);\n    event TeamRegistered(string teamName, address teamAddress, string memberNames, bool rewardEligible);\n    event JuryMemberAdded(string juryMemberName, address juryMemberAddress);\n    event SponsorshipReceived(string sponsorName, string sponsorSite, string sponsorLogoUrl, uint amount);\n    event VoteReceived(string juryMemberName, address indexed teamAddress, uint points);\n    event PrizePaid(string teamName, uint amount);\n    event TeamDisqualified(address teamAddress);\n\n    modifier onlyOwner {\n        require(msg.sender == administrator);\n        _;\n    }\n\n    modifier onlyJury {\n        require(bytes(juryMembers[msg.sender].name).length > 0);\n        _;\n    }\n\n   function DecenterHackathon() {\n        administrator = msg.sender;\n        currentPeriod = Period.Registration;\n    }\n\n    // Administrator is able to switch between periods at any time\n    function switchToNextPeriod() onlyOwner {\n        if(currentPeriod == Period.Verification || currentPeriod == Period.End) {\n            return;\n        }\n\n        currentPeriod = Period(uint(currentPeriod) + 1);\n\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can add new teams during registration period, with an option to make a team non-eligible for the prize\n    function registerTeam(string _name, address _teamAddress, string _memberNames, bool _rewardEligible) onlyOwner {\n        require(currentPeriod == Period.Registration);\n        require(bytes(teams[_teamAddress].name).length == 0);\n\n        teams[_teamAddress] = Team({\n            name: _name,\n            memberNames: _memberNames,\n            score: 0,\n            reward: 0,\n            rewardEligible: _rewardEligible,\n            submittedByAdmin: false,\n            disqualified: false\n        });\n\n        teamAddresses.push(_teamAddress);\n        TeamRegistered(_name, _teamAddress, _memberNames, _rewardEligible);\n    }\n\n    // Administrator can add new jury members during registration period\n    function registerJuryMember(string _name, address _ethAddress) onlyOwner {\n        require(currentPeriod == Period.Registration);\n\n        juryMemberAddresses.push(_ethAddress);\n        juryMembers[_ethAddress] = JuryMember({\n            name: _name,\n            hasVoted: false\n        });\n\n        JuryMemberAdded(_name, _ethAddress);\n    }\n\n    // Anyone can contribute to the prize pool (i.e. either sponsor himself or administrator on behalf of the sponsor) during registration period\n    function contributeToPrizePool(string _name, string _siteUrl, string _logoUrl) payable {\n        require(currentPeriod != Period.End);\n        require(msg.value >= 0.1 ether);\n\n        sponsors.push(Sponsor({\n            name: _name,\n            siteUrl: _siteUrl,\n            logoUrl: _logoUrl,\n            ethAddress: msg.sender,\n            contribution: msg.value\n        }));\n\n        totalContribution += msg.value;\n        SponsorshipReceived(_name, _siteUrl, _logoUrl, msg.value);\n    }\n\n    // Jury members can vote during voting period\n    // The _votes parameter should be an array of team addresses, sorted by score from highest to lowest based on jury member's preferences\n    function vote(address[] _votes) onlyJury {\n        require(currentPeriod == Period.Voting);\n        require(_votes.length == teamAddresses.length);\n        require(juryMembers[msg.sender].hasVoted == false);\n\n        uint _points = _votes.length;\n\n        for(uint i = 0; i < _votes.length; i++) {\n            address teamAddress = _votes[i];\n\n            // All submitted teams must be registered\n            require(bytes(teams[teamAddress].name).length > 0);\n\n            // Judge should not be able to vote for the same team more than once\n            require(teams[teamAddress].votedForByJuryMember[msg.sender] == false);\n\n            teams[teamAddress].score += _points;\n            teams[teamAddress].votedForByJuryMember[msg.sender] = true;\n\n            VoteReceived(juryMembers[msg.sender].name, teamAddress, _points);\n            _points--;\n        }\n\n        // This will prevent jury members from voting more than once\n        juryMembers[msg.sender].hasVoted = true;\n    }\n\n    // Administrator can initiate prize payout during final period\n    // The _sortedTeams parameter should be an array of correctly sorted teams by score, from highest to lowest\n    function payoutPrizes(address[] _sortedTeams) onlyOwner {\n        require(currentPeriod == Period.Verification);\n        require(_sortedTeams.length == teamAddresses.length);\n\n        for(uint i = 0; i < _sortedTeams.length; i++) {\n            // All submitted teams must be registered\n            require(bytes(teams[_sortedTeams[i]].name).length > 0);\n\n            // Teams must be sorted correctly\n            require(i == _sortedTeams.length - 1 || teams[_sortedTeams[i + 1]].score <= teams[_sortedTeams[i]].score);\n\n            teams[_sortedTeams[i]].submittedByAdmin = true;\n        }\n\n        // Prizes are paid based on logarithmic scale, where first teams receives 1/2 of the prize pool, second 1/4 and so on\n        uint prizePoolDivider = 2;\n\n        for(i = 0; i < _sortedTeams.length; i++) {\n            // Make sure all teams are included in _sortedTeams array\n            // (i.e. the array should contain unique elements)\n            require(teams[_sortedTeams[i]].submittedByAdmin);\n\n            uint _prizeAmount = totalContribution / prizePoolDivider;\n\n            if(teams[_sortedTeams[i]].rewardEligible && !teams[_sortedTeams[i]].disqualified) {\n                _sortedTeams[i].transfer(_prizeAmount);\n                teams[_sortedTeams[i]].reward = _prizeAmount;\n                prizePoolDivider *= 2;\n                PrizePaid(teams[_sortedTeams[i]].name, _prizeAmount);\n            }\n        }\n\n        // Some small amount of ETH might remain in the contract after payout, becuase rewards are determened logarithmically\n        // This amount is returned to contract owner to cover deployment and transaction costs\n        // In case this amount turns out to be significantly larger than these costs, the administrator will distribute it to all teams equally\n        administrator.transfer(this.balance);\n\n        currentPeriod = Period.End;\n        PeriodChanged(currentPeriod);\n    }\n\n    // Administrator can disqualify team\n    function disqualifyTeam(address _teamAddress) onlyOwner {\n        require(bytes(teams[_teamAddress].name).length > 0);\n\n        teams[_teamAddress].disqualified = true;\n        TeamDisqualified(_teamAddress);\n    }\n\n    // In case something goes wrong and contract needs to be redeployed, this is a way to return all contributions to the sponsors\n    function returnContributionsToTheSponsors() onlyOwner {\n        for(uint i = i; i < sponsors.length; i++) {\n            sponsors[i].ethAddress.transfer(sponsors[i].contribution);\n        }\n    }\n\n    // Public function that returns user type for the given address\n    function getUserType(address _address) constant returns (string) {\n        if(_address == administrator) {\n            return \"administrator\";\n        } else if(bytes(juryMembers[_address].name).length > 0) {\n            return \"jury\";\n        } else {\n            return \"other\";\n        }\n    }\n\n    // Check if jury member voted\n    function checkJuryVoted(address _juryAddress) constant returns (bool){\n        require(bytes(juryMembers[_juryAddress].name).length != 0);\n\n        return juryMembers[_juryAddress].hasVoted;\n    }\n\n    // Returns total prize pool size\n    function getPrizePoolSize() constant returns (uint) {\n        return totalContribution;\n    }\n\n    function restartPeriod() onlyOwner {\n        currentPeriod = Period.Registration;\n    }\n}", "debug": "keccac_0_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_DecenterHackathon_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\nstorage_1: 0x0\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_DecenterHackathon_4 + calldata_DecenterHackathon_4)) +\n0: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nstorage_4: 0x0\ncaller: 0x0\ncalldata_DecenterHackathon_0: 0x653f23f800000000000000000000000000000000000000000000000000000000\ncalldatasize_DecenterHackathon: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `registerJuryMember(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/17/0x879716da78a75a44bdfa8f038ce875f99586940a.sol", "function": "registerJuryMember(string,address)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}