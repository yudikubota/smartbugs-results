{
  "contract": "0x15f503f23d4d2716e0817714709b5dcf868013ee",
  "tool": "mythril",
  "start": 1563542000.4847236,
  "end": 1563542263.961409,
  "duration": 263.4766855239868,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1226,
        "code": "ract() public view returns(address) {\n        return _upgradeContract;\n    }\n    //\n    /** \n     * @dev Sets SmartContract that could upgrade Tokens to a new ve",
        "debug": "calldata_TokenVoluntaryUpgrade_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenVoluntaryUpgrade_0: 0x6a03de1600000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenVoluntaryUpgrade: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setTrustedIPNS(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x15f503f23d4d2716e0817714709b5dcf868013ee.sol",
        "function": "setTrustedIPNS(string)",
        "lineno": 295,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8121,
        "code": "ub(uint a, uin",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenVoluntaryUpgrade_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_7: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_TokenVoluntaryUpgrade_0: 0x37b33eef00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenVoluntaryUpgrade: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0x15f503f23d4d2716e0817714709b5dcf868013ee.sol",
        "function": "burnAfterUpgrade(uint256)",
        "lineno": 68,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8139,
        "code": "b.com",
        "debug": "calldata_TokenVoluntaryUpgrade_32 + 36: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenVoluntaryUpgrade_32_+_4: 0xc050fffff320c00020003d81af848540000000000000040000110001bd062022\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenVoluntaryUpgrade_4: 0xfe51000008ce80008001c1d33616877ffffffffffffff7ffffe10000398d50ac\ncalldata_TokenVoluntaryUpgrade_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenVoluntaryUpgrade_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenVoluntaryUpgrade_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenVoluntaryUpgrade: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x15f503f23d4d2716e0817714709b5dcf868013ee.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 79,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8152,
        "code": "in/openzeppeli",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenVoluntaryUpgrade_32 + 36: 0x53632f08ddbb360427befb69cb0d577a76825c1eb02b4cefbf971939ae256117\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenVoluntaryUpgrade_32_+_4: 0xd32ba62e013a1e544c40f8298f8c838ef0ca495e903244487f8ba1f8c2a013e7\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x53632f08ddbb360427befb69cb0d577a76825c1eb02b4cefbf971939ae256117\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenVoluntaryUpgrade_4: 0x53632f08ddbb360427befb69cb0d577a76825c1eb02b4cefbf971939ae256117\ncalldata_TokenVoluntaryUpgrade_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenVoluntaryUpgrade_4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenVoluntaryUpgrade_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenVoluntaryUpgrade: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/11/0x15f503f23d4d2716e0817714709b5dcf868013ee.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 79,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 8586,
        "code": "      = \"SPCY\";\n    string  internal _standard          = \"ERC20\";\n    uint8   internal _decimals          = 18;\n    uint    internal _totalSupply       = 100000000 * 1 ether;\n    //\n    string  internal _trustedIPNS       = \"\"; \n    //\n    address internal _upgradeContract   = address(0);\n    //\n    mapping(address => uint256)                     internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    //\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n    //\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    //\n    event UpgradeContractChange(\n        address owner, \n        address indexed _exchangeContractAddress\n    );\n    //\n    event UpgradeBurn(\n        address indexed _upgradeContract,\n        uint256 _value\n    );\n    //\n    constructor () public Ownable() {\n        balances[msg.sender] = totalSupply();\n    }\n    // Try to prevent sending ETH to SmartContract by mistake.\n    function () external payable  {\n        revert(\"This SmartContract is not payable\");\n    }\n    //\n    // Getters and Setters\n    //\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    //\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    //\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n    //\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    //\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    //\n    // Contract common functions\n    //\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        //\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n        //\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n        //\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    //\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require (_spender != address(0), \"_spender address has to be set\");\n        require (_value > 0, \"'_value' parameter has to greater than 0\");\n        //\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    //\n    function safeApprove(address _spender, uint256 _currentValue, uint256 _value)  public returns (bool success) {\n        // If current allowance for _spender is equal to _currentValue, then\n        // overwrite it with _value and return true, otherwise return false.\n        if (allowed[msg.sender][_spender] == _currentValue) return approve(_spender, _value);\n        return false;\n    }\n    //\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        //\n        require(_from != address(0), \"'_from' address has to be set\");\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowance\");\n        //\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n        balances[_from] = SafeMath.sub(balances[_from], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n        //\n        emit Transfer(_from, _to, _value);\n        //\n        return true;\n    }\n    //\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    //\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    // Voluntary token upgrade logic\n    //\n    /**\n     * @dev Gets trusted IPNS address\n     */\n    function trustedIPNS() public view returns(string memory) {\n        return  _trustedIPNS;\n    }\n    /** \n    * @dev Sets trusted IPNS address for use communication chanel for Sapiency Team\n    * @notice For future use - this variable is not used in contract logic and plays olny information role using blockchain as trusted medium\n    */\n    function setTrustedIPNS(string memory _trustedIPNSparam) public onlyOwner returns(bool) {\n        _trustedIPNS = _trustedIPNSparam;\n        return true;\n    }\n    //\n    /** \n     * @dev Gets SmartContract that could upgrade Tokens - empty == no upgrade\n     */\n    function upgradeContract() public view returns(address) {\n        return _upgradeContract;\n    }\n    //\n    /** \n     * @dev Sets SmartContract that could upgrade Tokens to a new version in a future\n     */\n    function setUpgradeContract(address _upgradeContractAddress) public onlyOwner returns(bool) {\n        _upgradeContract = _upgradeContractAddress;\n        emit UpgradeContractChange(msg.sender, _upgradeContract);\n        //\n        return true;\n    }\n    function burnAfterUpgrade(uint256 _value) public returns (bool success) {\n        require(_upgradeContract != address(0), \"upgradeContract is not set\");\n        require(msg.sender == _upgradeContract, \"only upgradeContract can execute token burning\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n        //\n        _totalSupply = SafeMath.sub(_totalSupply, _value);\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);\n        emit UpgradeBurn(msg.sender, _value);\n        //\n        return true;\n    }\n}",
        "debug": "calldata_TokenVoluntaryUpgrade_4 + calldata_TokenVoluntaryUpgrade_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenVoluntaryUpgrade_0: 0x6a03de1600000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenVoluntaryUpgrade: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setTrustedIPNS(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x15f503f23d4d2716e0817714709b5dcf868013ee.sol",
        "function": "setTrustedIPNS(string)",
        "lineno": 157,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8600,
        "code": "      = \"SPCY\";\n    string  internal _standard          = \"ERC20\";\n    uint8   internal _decimals          = 18;\n    uint    internal _totalSupply       = 100000000 * 1 ether;\n    //\n    string  internal _trustedIPNS       = \"\"; \n    //\n    address internal _upgradeContract   = address(0);\n    //\n    mapping(address => uint256)                     internal balances;\n    mapping(address => mapping(address => uint256)) internal allowed;\n    //\n    event Transfer(\n        address indexed _from,\n        address indexed _to,\n        uint256 _value\n    );\n    //\n    event Approval(\n        address indexed _owner,\n        address indexed _spender,\n        uint256 _value\n    );\n    //\n    event UpgradeContractChange(\n        address owner, \n        address indexed _exchangeContractAddress\n    );\n    //\n    event UpgradeBurn(\n        address indexed _upgradeContract,\n        uint256 _value\n    );\n    //\n    constructor () public Ownable() {\n        balances[msg.sender] = totalSupply();\n    }\n    // Try to prevent sending ETH to SmartContract by mistake.\n    function () external payable  {\n        revert(\"This SmartContract is not payable\");\n    }\n    //\n    // Getters and Setters\n    //\n    function name() public view returns (string memory) {\n        return _name;\n    }\n    //\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n    //\n    function standard() public view returns (string memory) {\n        return _standard;\n    }\n    //\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n    //\n    function totalSupply() public view returns (uint256) {\n        return _totalSupply;\n    }\n    \n    //\n    // Contract common functions\n    //\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        //\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n        //\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n        //\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n    //\n    function approve(address _spender, uint256 _value) public returns (bool success) {\n        require (_spender != address(0), \"_spender address has to be set\");\n        require (_value > 0, \"'_value' parameter has to greater than 0\");\n        //\n        allowed[msg.sender][_spender] = _value;\n        emit Approval(msg.sender, _spender, _value);\n        return true;\n    }\n    //\n    function safeApprove(address _spender, uint256 _currentValue, uint256 _value)  public returns (bool success) {\n        // If current allowance for _spender is equal to _currentValue, then\n        // overwrite it with _value and return true, otherwise return false.\n        if (allowed[msg.sender][_spender] == _currentValue) return approve(_spender, _value);\n        return false;\n    }\n    //\n    function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n        //\n        require(_from != address(0), \"'_from' address has to be set\");\n        require(_to != address(0), \"'_to' address has to be set\");\n        require(_value <= balances[_from], \"Insufficient balance\");\n        require(_value <= allowed[_from][msg.sender], \"Insufficient allowance\");\n        //\n        allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value);\n        balances[_from] = SafeMath.sub(balances[_from], _value);\n        balances[_to] = SafeMath.add(balances[_to], _value);\n        //\n        emit Transfer(_from, _to, _value);\n        //\n        return true;\n    }\n    //\n    function allowance(address _owner, address _spender) public view returns (uint256) {\n        return allowed[_owner][_spender];\n    }\n    //\n    function balanceOf(address _owner) public view returns (uint256) {\n        return balances[_owner];\n    }\n    // Voluntary token upgrade logic\n    //\n    /**\n     * @dev Gets trusted IPNS address\n     */\n    function trustedIPNS() public view returns(string memory) {\n        return  _trustedIPNS;\n    }\n    /** \n    * @dev Sets trusted IPNS address for use communication chanel for Sapiency Team\n    * @notice For future use - this variable is not used in contract logic and plays olny information role using blockchain as trusted medium\n    */\n    function setTrustedIPNS(string memory _trustedIPNSparam) public onlyOwner returns(bool) {\n        _trustedIPNS = _trustedIPNSparam;\n        return true;\n    }\n    //\n    /** \n     * @dev Gets SmartContract that could upgrade Tokens - empty == no upgrade\n     */\n    function upgradeContract() public view returns(address) {\n        return _upgradeContract;\n    }\n    //\n    /** \n     * @dev Sets SmartContract that could upgrade Tokens to a new version in a future\n     */\n    function setUpgradeContract(address _upgradeContractAddress) public onlyOwner returns(bool) {\n        _upgradeContract = _upgradeContractAddress;\n        emit UpgradeContractChange(msg.sender, _upgradeContract);\n        //\n        return true;\n    }\n    function burnAfterUpgrade(uint256 _value) public returns (bool success) {\n        require(_upgradeContract != address(0), \"upgradeContract is not set\");\n        require(msg.sender == _upgradeContract, \"only upgradeContract can execute token burning\");\n        require(_value <= balances[msg.sender], \"Insufficient balance\");\n        //\n        _totalSupply = SafeMath.sub(_totalSupply, _value);\n        balances[msg.sender] = SafeMath.sub(balances[msg.sender],_value);\n        emit UpgradeBurn(msg.sender, _value);\n        //\n        return true;\n    }\n}",
        "debug": "calldata_TokenVoluntaryUpgrade_4 + calldata_TokenVoluntaryUpgrade_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_TokenVoluntaryUpgrade_0: 0x6a03de1600000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenVoluntaryUpgrade: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setTrustedIPNS(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/11/0x15f503f23d4d2716e0817714709b5dcf868013ee.sol",
        "function": "setTrustedIPNS(string)",
        "lineno": 157,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}