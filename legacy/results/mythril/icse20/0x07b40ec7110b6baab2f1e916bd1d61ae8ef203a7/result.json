{
  "contract": "0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7",
  "tool": "mythril",
  "start": 1563599118.8718874,
  "end": 1563599820.419648,
  "duration": 701.5477604866028,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 218,
        "code": "Only a trusted oracle can call this function\n      require(addrWhitelist[msg.sender] || owner == msg.sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= GRLC_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= GRLC_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= GRLC_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= GRLC_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {          \n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[gaddrHash].hasRose) {          \n          return;\n      }\n\n      roseOwners[gaddrHash].hasRose = true;\n      roseOwners[gaddrHash].roseType = roseType;\n      roseOwners[gaddrHash].memo = memo;\n  }\n\n  // No refunds fam soz not soz\n  function checkRose(bytes32 h) public constant returns (bool, uint, string) {\n",
        "debug": "calldata_CryptoRoses_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoRoses_0: 0x46a60e9900000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `buyRoseGRLC(bytes32,string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "buyRoseGRLC(bytes32,string,uint256)",
        "lineno": 88,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 508,
        "code": " {\n      uint amntSent = msg.value;\n      address sender = msg.sender;\n      bytes32 senderHash = keccak256(sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= ETH_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= ETH_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= ETH_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= ETH_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[senderHash].hasRose) {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      roseOwners[senderHash].hasRose = true;\n      roseOwners[senderHash].roseType = roseType;\n      roseOwners[senderHash].memo = memo;\n\n      DESTINATION_ADDRESS.transfer(amntSent);\n  }\n\n  uint constant GRLC_GOLD_ROSE_PRICE = 50;\n  uint constant GRLC_WHITE_ROSE_PR",
        "debug": "calldata_CryptoRoses_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_CryptoRoses_0: 0x943fcc9d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyRoseETH(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "buyRoseETH(string)",
        "lineno": 48,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1355,
        "debug": "The exception is triggered under the following conditions:\n\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\ncalldata_CryptoRoses_4: 0xfc00\ncalldata_CryptoRoses_0: 0x856c6bd100000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "checkRose(bytes32)",
        "lineno": 120,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2262,
        "code": "ntract CryptoRoses {\n  address constant DESTINATION_ADDRESS = 0x19Ed10db2960B9B21283FdFDe464e7bF3a87D05D;\n  address owner;\n  bytes32 name;\n\n  enum Rose { Gold, White, Pink, Red }\n\n  struct RoseOwner {\n      bool hasRose;\n      Rose roseType;\n      string memo;\n  }\n\n  mapping (bytes32 => RoseOwner) roseOwners;\n  mapping (address => bool) addrWhitelist;\n\n  function CryptoRoses(bytes32 _name) public {\n      owner = msg.sender;\n      name = _name;\n  }\n\n  function addAddWhitelist(address s) public {      \n      require(msg.sender == owner);\n\n      addrWhitelist[s] = true;\n  }\n\n  // 0.25 ETH (250000000000000000 wei) for a Gold Rose\n  // 50 Garlicoin for a Gold Rose\n\n  // 0.05 ETH (50000000000000000 wei) for a White Rose\n  // 10 Garlicoin for a White Rose\n\n  // 0.02 ETH (20000000000000000 wei) for a Pink rose\n  // 4 Garlicoin for a Pink Rose\n\n  // 0.01 ETH (10000000000000000 wei) for a Red Rose\n  // 2 Garlicoin for a Red Rose\n\n  uint constant ETH_GOLD_ROSE_PRICE = 250000000000000000;\n  uint constant ETH_WHITE_ROSE_PRICE = 50000000000000000;\n  uint constant ETH_PINK_ROSE_PRICE = 20000000000000000;\n  uint constant ETH_RED_ROSE_PRICE = 10000000000000000;\n\n  // Buy Rose with ETH\n  function buyRoseETH(string memo) public payable {\n      uint amntSent = msg.value;\n      address sender = msg.sender;\n      bytes32 senderHash = keccak256(sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= ETH_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= ETH_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= ETH_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= ETH_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[senderHash].hasRose) {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      roseOwners[senderHash].hasRose = true;\n      roseOwners[senderHash].roseType = roseType;\n      roseOwners[senderHash].memo = memo;\n\n      DESTINATION_ADDRESS.transfer(amntSent);\n  }\n\n  uint constant GRLC_GOLD_ROSE_PRICE = 50;\n  uint constant GRLC_WHITE_ROSE_PRICE = 10;\n  uint constant GRLC_PINK_ROSE_PRICE = 4;\n  uint constant GRLC_RED_ROSE_PRICE = 2;\n\n  function buyRoseGRLC(bytes32 gaddrHash, string memo, uint amntSent) public {\n      // Only a trusted oracle can call this function\n      require(addrWhitelist[msg.sender] || owner == msg.sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= GRLC_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= GRLC_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= GRLC_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= GRLC_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {          \n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[gaddrHash].hasRose) {          \n          return;\n      }\n\n      roseOwners[gaddrHash].hasRose = true;\n      roseOwners[gaddrHash].roseType = roseType;\n      roseOwners[gaddrHash].memo = memo;\n  }\n\n  // No refunds fam soz not soz\n  function checkRose(bytes32 h) public constant returns (bool, uint, string) {\n      return (roseOwners[h].hasRose, uint(roseOwners[h].roseType), roseOwners[h].memo);\n  }\n}",
        "debug": "keccac_1_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0x0\ncallvalue: 0x3782dace9d90000\ncalldata_CryptoRoses_0: 0x943fcc9d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyRoseETH(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "buyRoseETH(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2291,
        "code": "ntract CryptoRoses {\n  address constant DESTINATION_ADDRESS = 0x19Ed10db2960B9B21283FdFDe464e7bF3a87D05D;\n  address owner;\n  bytes32 name;\n\n  enum Rose { Gold, White, Pink, Red }\n\n  struct RoseOwner {\n      bool hasRose;\n      Rose roseType;\n      string memo;\n  }\n\n  mapping (bytes32 => RoseOwner) roseOwners;\n  mapping (address => bool) addrWhitelist;\n\n  function CryptoRoses(bytes32 _name) public {\n      owner = msg.sender;\n      name = _name;\n  }\n\n  function addAddWhitelist(address s) public {      \n      require(msg.sender == owner);\n\n      addrWhitelist[s] = true;\n  }\n\n  // 0.25 ETH (250000000000000000 wei) for a Gold Rose\n  // 50 Garlicoin for a Gold Rose\n\n  // 0.05 ETH (50000000000000000 wei) for a White Rose\n  // 10 Garlicoin for a White Rose\n\n  // 0.02 ETH (20000000000000000 wei) for a Pink rose\n  // 4 Garlicoin for a Pink Rose\n\n  // 0.01 ETH (10000000000000000 wei) for a Red Rose\n  // 2 Garlicoin for a Red Rose\n\n  uint constant ETH_GOLD_ROSE_PRICE = 250000000000000000;\n  uint constant ETH_WHITE_ROSE_PRICE = 50000000000000000;\n  uint constant ETH_PINK_ROSE_PRICE = 20000000000000000;\n  uint constant ETH_RED_ROSE_PRICE = 10000000000000000;\n\n  // Buy Rose with ETH\n  function buyRoseETH(string memo) public payable {\n      uint amntSent = msg.value;\n      address sender = msg.sender;\n      bytes32 senderHash = keccak256(sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= ETH_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= ETH_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= ETH_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= ETH_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[senderHash].hasRose) {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      roseOwners[senderHash].hasRose = true;\n      roseOwners[senderHash].roseType = roseType;\n      roseOwners[senderHash].memo = memo;\n\n      DESTINATION_ADDRESS.transfer(amntSent);\n  }\n\n  uint constant GRLC_GOLD_ROSE_PRICE = 50;\n  uint constant GRLC_WHITE_ROSE_PRICE = 10;\n  uint constant GRLC_PINK_ROSE_PRICE = 4;\n  uint constant GRLC_RED_ROSE_PRICE = 2;\n\n  function buyRoseGRLC(bytes32 gaddrHash, string memo, uint amntSent) public {\n      // Only a trusted oracle can call this function\n      require(addrWhitelist[msg.sender] || owner == msg.sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= GRLC_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= GRLC_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= GRLC_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= GRLC_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {          \n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[gaddrHash].hasRose) {          \n          return;\n      }\n\n      roseOwners[gaddrHash].hasRose = true;\n      roseOwners[gaddrHash].roseType = roseType;\n      roseOwners[gaddrHash].memo = memo;\n  }\n\n  // No refunds fam soz not soz\n  function checkRose(bytes32 h) public constant returns (bool, uint, string) {\n      return (roseOwners[h].hasRose, uint(roseOwners[h].roseType), roseOwners[h].memo);\n  }\n}",
        "debug": "calldata_CryptoRoses_4 + calldata_CryptoRoses_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0x0\ncallvalue: 0x3782dace9d90000\ncalldata_CryptoRoses_0: 0x943fcc9d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyRoseETH(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "buyRoseETH(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2305,
        "code": "ntract CryptoRoses {\n  address constant DESTINATION_ADDRESS = 0x19Ed10db2960B9B21283FdFDe464e7bF3a87D05D;\n  address owner;\n  bytes32 name;\n\n  enum Rose { Gold, White, Pink, Red }\n\n  struct RoseOwner {\n      bool hasRose;\n      Rose roseType;\n      string memo;\n  }\n\n  mapping (bytes32 => RoseOwner) roseOwners;\n  mapping (address => bool) addrWhitelist;\n\n  function CryptoRoses(bytes32 _name) public {\n      owner = msg.sender;\n      name = _name;\n  }\n\n  function addAddWhitelist(address s) public {      \n      require(msg.sender == owner);\n\n      addrWhitelist[s] = true;\n  }\n\n  // 0.25 ETH (250000000000000000 wei) for a Gold Rose\n  // 50 Garlicoin for a Gold Rose\n\n  // 0.05 ETH (50000000000000000 wei) for a White Rose\n  // 10 Garlicoin for a White Rose\n\n  // 0.02 ETH (20000000000000000 wei) for a Pink rose\n  // 4 Garlicoin for a Pink Rose\n\n  // 0.01 ETH (10000000000000000 wei) for a Red Rose\n  // 2 Garlicoin for a Red Rose\n\n  uint constant ETH_GOLD_ROSE_PRICE = 250000000000000000;\n  uint constant ETH_WHITE_ROSE_PRICE = 50000000000000000;\n  uint constant ETH_PINK_ROSE_PRICE = 20000000000000000;\n  uint constant ETH_RED_ROSE_PRICE = 10000000000000000;\n\n  // Buy Rose with ETH\n  function buyRoseETH(string memo) public payable {\n      uint amntSent = msg.value;\n      address sender = msg.sender;\n      bytes32 senderHash = keccak256(sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= ETH_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= ETH_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= ETH_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= ETH_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[senderHash].hasRose) {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      roseOwners[senderHash].hasRose = true;\n      roseOwners[senderHash].roseType = roseType;\n      roseOwners[senderHash].memo = memo;\n\n      DESTINATION_ADDRESS.transfer(amntSent);\n  }\n\n  uint constant GRLC_GOLD_ROSE_PRICE = 50;\n  uint constant GRLC_WHITE_ROSE_PRICE = 10;\n  uint constant GRLC_PINK_ROSE_PRICE = 4;\n  uint constant GRLC_RED_ROSE_PRICE = 2;\n\n  function buyRoseGRLC(bytes32 gaddrHash, string memo, uint amntSent) public {\n      // Only a trusted oracle can call this function\n      require(addrWhitelist[msg.sender] || owner == msg.sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= GRLC_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= GRLC_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= GRLC_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= GRLC_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {          \n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[gaddrHash].hasRose) {          \n          return;\n      }\n\n      roseOwners[gaddrHash].hasRose = true;\n      roseOwners[gaddrHash].roseType = roseType;\n      roseOwners[gaddrHash].memo = memo;\n  }\n\n  // No refunds fam soz not soz\n  function checkRose(bytes32 h) public constant returns (bool, uint, string) {\n      return (roseOwners[h].hasRose, uint(roseOwners[h].roseType), roseOwners[h].memo);\n  }\n}",
        "debug": "calldata_CryptoRoses_4 + calldata_CryptoRoses_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0x0\ncallvalue: 0x3782dace9d90000\ncalldata_CryptoRoses_0: 0x943fcc9d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyRoseETH(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "buyRoseETH(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2327,
        "code": "ntract CryptoRoses {\n  address constant DESTINATION_ADDRESS = 0x19Ed10db2960B9B21283FdFDe464e7bF3a87D05D;\n  address owner;\n  bytes32 name;\n\n  enum Rose { Gold, White, Pink, Red }\n\n  struct RoseOwner {\n      bool hasRose;\n      Rose roseType;\n      string memo;\n  }\n\n  mapping (bytes32 => RoseOwner) roseOwners;\n  mapping (address => bool) addrWhitelist;\n\n  function CryptoRoses(bytes32 _name) public {\n      owner = msg.sender;\n      name = _name;\n  }\n\n  function addAddWhitelist(address s) public {      \n      require(msg.sender == owner);\n\n      addrWhitelist[s] = true;\n  }\n\n  // 0.25 ETH (250000000000000000 wei) for a Gold Rose\n  // 50 Garlicoin for a Gold Rose\n\n  // 0.05 ETH (50000000000000000 wei) for a White Rose\n  // 10 Garlicoin for a White Rose\n\n  // 0.02 ETH (20000000000000000 wei) for a Pink rose\n  // 4 Garlicoin for a Pink Rose\n\n  // 0.01 ETH (10000000000000000 wei) for a Red Rose\n  // 2 Garlicoin for a Red Rose\n\n  uint constant ETH_GOLD_ROSE_PRICE = 250000000000000000;\n  uint constant ETH_WHITE_ROSE_PRICE = 50000000000000000;\n  uint constant ETH_PINK_ROSE_PRICE = 20000000000000000;\n  uint constant ETH_RED_ROSE_PRICE = 10000000000000000;\n\n  // Buy Rose with ETH\n  function buyRoseETH(string memo) public payable {\n      uint amntSent = msg.value;\n      address sender = msg.sender;\n      bytes32 senderHash = keccak256(sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= ETH_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= ETH_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= ETH_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= ETH_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[senderHash].hasRose) {\n          sender.transfer(amntSent);\n          return;\n      }\n\n      roseOwners[senderHash].hasRose = true;\n      roseOwners[senderHash].roseType = roseType;\n      roseOwners[senderHash].memo = memo;\n\n      DESTINATION_ADDRESS.transfer(amntSent);\n  }\n\n  uint constant GRLC_GOLD_ROSE_PRICE = 50;\n  uint constant GRLC_WHITE_ROSE_PRICE = 10;\n  uint constant GRLC_PINK_ROSE_PRICE = 4;\n  uint constant GRLC_RED_ROSE_PRICE = 2;\n\n  function buyRoseGRLC(bytes32 gaddrHash, string memo, uint amntSent) public {\n      // Only a trusted oracle can call this function\n      require(addrWhitelist[msg.sender] || owner == msg.sender);\n\n      Rose roseType;\n\n      // Assign rose \n      if (amntSent >= GRLC_GOLD_ROSE_PRICE) {\n          roseType = Rose.Gold;\n      } else if (amntSent >= GRLC_WHITE_ROSE_PRICE) {\n          roseType = Rose.White;\n      } else if (amntSent >= GRLC_PINK_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else if (amntSent >= GRLC_RED_ROSE_PRICE) {\n          roseType = Rose.Pink;\n      } else {          \n          return;\n      }\n\n      // No double buying roses\n      if (roseOwners[gaddrHash].hasRose) {          \n          return;\n      }\n\n      roseOwners[gaddrHash].hasRose = true;\n      roseOwners[gaddrHash].roseType = roseType;\n      roseOwners[gaddrHash].memo = memo;\n  }\n\n  // No refunds fam soz not soz\n  function checkRose(bytes32 h) public constant returns (bool, uint, string) {\n      return (roseOwners[h].hasRose, uint(roseOwners[h].roseType), roseOwners[h].memo);\n  }\n}",
        "debug": "keccac_1_+\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_CryptoRoses_4 + calldata_CryptoRoses_4: 0x4000f04100100000000000000000000000000000d6401413fffffffffffffe0\nstorage_0 +\nkeccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_CryptoRoses_4_+_calldata_CryptoRoses_4))): 0x0\ncallvalue: 0x3782dace9d90000\ncalldata_CryptoRoses_0: 0x943fcc9d00000000000000000000000000000000000000000000000000000000\ncalldatasize_CryptoRoses: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyRoseETH(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x07b40ec7110b6baab2f1e916bd1d61ae8ef203a7.sol",
        "function": "buyRoseETH(string)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}