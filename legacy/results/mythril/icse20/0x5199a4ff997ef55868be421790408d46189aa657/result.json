{
  "contract": "0x5199a4ff997ef55868be421790408d46189aa657",
  "tool": "mythril",
  "start": 1563527079.363675,
  "end": 1563527182.2152328,
  "duration": 102.85155773162842,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 2961,
        "code": "herosForSale[_id]",
        "debug": "storage_2 + keccac_calldata_SuperHeroes_4: 0x22222225c761bccd1f6c220023fbd66fdbcc1c4556175964555555641fffc1d\nstorage_0: 0x800000000000000000000000000000000000000000\ncallvalue: 0x22222225c761bccd1f6c220023fbd66fdbcc1c4556175964555555641fffc1d\ncalldata_SuperHeroes_0: 0x24edd7500000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "buyHero(uint256)",
        "lineno": 283,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2988,
        "code": "\n  }\n\n  fun",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0xffffffffffffefffffffffffffffffffffffff0000\ncalldata_SuperHeroes_4: 0x0\nstorage_2 + keccac_calldata_SuperHeroes_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x24edd7500000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "buyHero(uint256)",
        "lineno": 283,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3887,
        "code": ");\n  }\n}",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x0\nstorage_keccac_calldata_SuperHeroes_4: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x51d5f44f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "saleHero(uint256)",
        "lineno": 292,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4219,
        "code": "alue - real",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x0\nstorage_0: 0x0\ncalldata_SuperHeroes_0: 0x642c7aa200000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "snatchHero(uint256)",
        "lineno": 259,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 7289,
        "code": "IndexToApproved[_tokenId];",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SuperHeroes_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\ncaller: 0x0\nstorage_keccac_calldata_SuperHeroes_32_+_36: 0x0\ncalldata_SuperHeroes_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 159,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7505,
        "code": "turns (uint256 tokenId) {\n  ",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_SuperHeroes_4: 0x0\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_SuperHeroes_32_+_36: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_SuperHeroes_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferFrom(address,address,uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 163,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 8572,
        "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    string src;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, string _src, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      src: _src,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, string _src, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, _src, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, string _src, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _src = token.src;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}",
        "debug": "storage_keccac_calldata_SuperHeroes_4 + 0: 0x0\nstorage_0: 0x800000000000000000000000000000000000000000\nkeccac_keccac_calldata_SuperHeroes_4_+_1: 0xfde17fc4b4109c15beac251d866e78902a106c76498cc05e4900115358a5a19c\nstorage_keccac_calldata_SuperHeroes_4 + 1: 0x8852c8314067edccbffbbad607b2b7bff6faddaaaa7f8b7b7ffaa1663fffffc9\ncalldata_SuperHeroes_4: 0x0\nstorage_2 + keccac_calldata_SuperHeroes_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x1\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_SuperHeroes_0: 0x24edd7500000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\n",
        "description": "A possible integer overflow exists in the function `buyHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "buyHero(uint256)",
        "lineno": 115,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8626,
        "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    string src;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, string _src, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      src: _src,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, string _src, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, _src, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, string _src, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _src = token.src;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}",
        "debug": "storage_0 + keccac_calldata_SuperHeroes_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_0_+_keccac_calldata_SuperHeroes_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x1\nstorage_keccac_calldata_SuperHeroes_4: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x51d5f44f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `saleHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "saleHero(uint256)",
        "lineno": 115,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8676,
        "code": " string public constant symbol = \"SH\";\n  \n  /** VARIABLES **/\n  uint256 public fee = 2;\n  uint256 public snatch = 24 hours;\n\n  /*** DATA TYPES ***/\n\n  struct Token {\n    string name;\n    string src;\n    uint256 price;\n    uint256 purchased;\n  }\n\n  /*** STORAGE ***/\n\n  Token[] tokens;\n\n  mapping (uint256 => address) public tokenIndexToOwner;\n  mapping (address => uint256) ownershipTokenCount;\n  mapping (uint256 => address) public tokenIndexToApproved;\n  mapping (uint256 => Token) public herosForSale;\n\n  /*** INTERNAL FUNCTIONS ***/\n\n  function _owns(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  function _approvedFor(address _claimant, uint256 _tokenId) internal view returns (bool) {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  function _approve(address _to, uint256 _tokenId) internal {\n    tokenIndexToApproved[_tokenId] = _to;\n  }\n\n  function _transfer(address _from, address _to, uint256 _tokenId) internal whenNotPaused {\n    ownershipTokenCount[_to]++;\n    tokenIndexToOwner[_tokenId] = _to;\n\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n      delete tokenIndexToApproved[_tokenId];\n    }\n  }\n\n  function _mint(string _name, string _src, uint256 _price) internal returns (uint256 tokenId) {\n    require(tokens.length < 250, \"Max amount of superheroes is reached\");  \n    Token memory token = Token({\n      name: _name,\n      src: _src,\n      price: _price,\n      purchased: now\n    });\n    tokenId = tokens.push(token) - 1;\n    \n    _transfer(0, owner, tokenId);\n  }\n\n\n  function totalSupply() public view returns (uint256) {\n    return tokens.length;\n  }\n\n  function balanceOf(address _owner) public view returns (uint256) {\n    return ownershipTokenCount[_owner];\n  }\n\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  function approve(address _to, uint256 _tokenId) external {\n    require(_owns(msg.sender, _tokenId));\n\n    _approve(_to, _tokenId);\n  }\n\n  function transfer(address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_owns(msg.sender, _tokenId));\n\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  function transferFrom(address _from, address _to, uint256 _tokenId) external {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    _transfer(_from, _to, _tokenId);\n  }\n\n  function tokensOfOwner(address _owner) external view returns (uint256[]) {\n    uint256 balance = balanceOf(_owner);\n\n    if (balance == 0) {\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](balance);\n      uint256 maxTokenId = totalSupply();\n      uint256 idx = 0;\n\n      uint256 tokenId;\n      for (tokenId = 1; tokenId <= maxTokenId; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[idx] = tokenId;\n          idx++;\n        }\n      }\n    }\n\n    return result;\n  }\n\n\n  /*** EXTERNAL FUNCTIONS ***/\n\n  function mint(string _name, string _src, uint256 _price) external onlyOwner returns (uint256) {\n    uint256 pricerecalc = _price;\n    return _mint(_name, _src, pricerecalc);\n  }\n\n  function getToken(uint256 _tokenId) external view returns (string _name, string _src, uint256 _price, uint256 _purchased) {\n    Token memory token = tokens[_tokenId];\n\n    _name = token.name;\n    _src = token.src;\n    _price = token.price;\n    _purchased = token.purchased;\n  }\n  \n  function snatchHero(uint256 _id) external payable whenNotPaused {\n      require(now - tokens[_id].purchased <= snatch);\n      uint256 pricerecalc = tokens[_id].price;\n      require(pricerecalc <= msg.value);\n      address previos = tokenIndexToOwner[_id];\n      uint256 realPriceFee = msg.value * fee / 100;\n      uint256 realPrice = msg.value - realPriceFee;\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      // owner.transfer(realPriceFee);\n      previos.transfer(realPrice);\n      _transfer(previos, msg.sender, _id);\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n  }\n  \n  function buyHero(uint256 _id) external payable whenNotPaused {\n      require(herosForSale[_id].price != 0);\n      uint256 pricerecalc = herosForSale[_id].price;\n      require(msg.value >= pricerecalc);\n      // owner.transfer(msg.value);\n      _transfer(owner, msg.sender, _id);\n      uint256 newPriceRise = pricerecalc * 120 / 100;\n      tokens[_id].purchased = now;\n      tokens[_id].price = newPriceRise;\n      \n      delete herosForSale[_id];\n  }\n  \n  function saleHero(uint256 _id) external onlyOwner whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      herosForSale[_id] = tokens[_id];\n  }\n\n  function changePrice(uint256 _id, uint256 _price) external whenNotPaused {\n      require(msg.sender == tokenIndexToOwner[_id]);\n      tokens[_id].price = _price;\n  }\n  \n  function withdraw(address to, uint256 amount) external onlyOwner {\n      to.transfer(amount);\n  }\n}",
        "debug": "storage_87903029871075914254377627908054574944891091886930582284385770809450030037083 +\n4*calldata_SuperHeroes_4 +\n0: 0x918a1f6ed1bfdbce3d7ffd7ffffffffffc1e22000000062635087fd990f70a01\nkeccac_87903029871075914254377627908054574944891091886930582284385770809450030037083_+\n4*calldata_SuperHeroes_4_+\n0: 0xfeb9d071e446c0400040000400000000000004e4248b6c5c8a034473fb1fad52\nstorage_0: 0x0\ncalldata_SuperHeroes_4: 0x0\nstorage_3: 0x1\nstorage_keccac_calldata_SuperHeroes_4: 0x0\ncaller: 0x0\ncalldata_SuperHeroes_0: 0x51d5f44f00000000000000000000000000000000000000000000000000000000\ncalldatasize_SuperHeroes: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `saleHero(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/13/0x5199a4ff997ef55868be421790408d46189aa657.sol",
        "function": "saleHero(uint256)",
        "lineno": 115,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}