{"error": null, "issues": [{"address": 225, "code": "rn whitelistAddresses.length;\n    }\n\n    function getAllWhitelist() public view returns(address[]) {\n        address[] memory allWhitelist = new address[](whitelistAddresses.length);\n        for (uint256 i = 0; i < whitelistAddresses.", "debug": "calldata_Whitelist_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Whitelist_0: 0x24953eaa00000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `removeAddressesFromWhitelist(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "removeAddressesFromWhitelist(address[])", "lineno": 602, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1075, "code": "nlyOwner\n        returns(bool)\n    {\n        if (inWhitelist(_operator) == true) {\n            uint256 whitelistIndex_ = whitelist[_operator].index;\n            removeItemFromWhitelistAddresses(whitelistIndex_);\n            ", "debug": "calldata_Whitelist_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Whitelist_0: 0xe2ec6ec300000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addAddressesToWhitelist(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "addAddressesToWhitelist(address[])", "lineno": 550, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1835, "code": "@param _operator address\n     * @re", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Whitelist_4: 0x0\nstorage_2: 0x0\ncalldata_Whitelist_0: 0x5d1235d400000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "_function_0x5d1235d4", "lineno": 505, "title": "Exception state", "type": "Informational"}, {"address": 2331, "code": ";\n\n\n/**\n * @title ", "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_cpy: 0x0\ncalldata_Whitelist_4 + calldata_Whitelist_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Whitelist_0: 0xe2ec6ec300000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addAddressesToWhitelist(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "addAddressesToWhitelist(address[])", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2470, "code": "ev remove an address from t", "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_cpy: 0x0\ncalldata_Whitelist_4 + calldata_Whitelist_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Whitelist_0: 0xe2ec6ec300000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `addAddressesToWhitelist(address[])`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "addAddressesToWhitelist(address[])", "lineno": 543, "title": "Integer Underflow", "type": "Warning"}, {"address": 3281, "code": "] _operators)\n        public\n        onlyOwner\n", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0x0\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Whitelist_0: 0x286dd3f500000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "removeAddressFromWhitelist(address)", "lineno": 580, "title": "Exception state", "type": "Informational"}, {"address": 3472, "code": "   * @dev check if the giv", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffffffffffffffffffffffffffffffffe0000000000000000000000000000000\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xffffffffffffffffffffffffffffffffe0000000000000000000000000000000\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Whitelist_0: 0x286dd3f500000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "removeAddressFromWhitelist(address)", "lineno": 590, "title": "Exception state", "type": "Informational"}, {"address": 3925, "code": "rows if operator is not whitelisted.\n    * @param _operator address\n    */\n    modifier onlyIfWhitelisted(address _operator) {\n        require(inWhitelist(_operator) == true, \"not whitelisted.\");\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param _operator address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address _operator)\n        public\n        onlyOwner\n        returns(bool)\n    {\n        WhitelistInfo storage whitelistInfo_ = whitelist[_operator];\n\n        if (inWhitelist(_operator) == false) {\n            whitelistAddresses.push(_operator);\n\n            whitelistInfo_.inWhitelist = true;\n            whitelistInfo_.time = block.timestamp;\n            whitelistInfo_.index = whitelistAddresses.length-1;\n\n            emit AddWhitelist(_operator, whitelistAddresses.length-1);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param _operators addresses\n     */\n    function addAddressesToWhitelist(address[] _operators)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _operators.length; i++) {\n            addAddressToWhitelist(_operators[i]);\n        }\n    }\n\n    /**\n    * @dev remove an address from the whitelist\n    * @param _operator address\n    * @return true if the address was removed from the whitelist,\n    * false if the address wasn't in the whitelist in the first place\n    */\n    function removeAddressFromWhitelist(address _operator)\n        public\n        onlyOwner\n        returns(bool)\n    {\n        if (inWhitelist(_operator) == true) {\n            uint256 whitelistIndex_ = whitelist[_operator].index;\n            removeItemFromWhitelistAddresses(whitelistIndex_);\n            whitelist[_operator] = WhitelistInfo(false, 0, 0);\n\n            emit RemoveWhitelist(_operator, whitelistIndex_);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function removeItemFromWhitelistAddresses(uint256 _index) private {\n        address lastWhitelistAddr = whitelistAddresses[whitelistAddresses.length-1];\n        WhitelistInfo storage lastWhitelistInfo = whitelist[lastWhitelistAddr];\n\n        //move last whitelist to the deleted slot\n        whitelistAddresses[_index] = whitelistAddresses[whitelistAddresses.length-1];\n        lastWhitelistInfo.index = _index;\n        delete whitelistAddresses[whitelistAddresses.length-1];\n        whitelistAddresses.length--;\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param _operators addresses\n     */\n    function removeAddressesFromWhitelist(address[] _operators)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _operators.length; i++) {\n            removeAddressFromWhitelist(_operators[i]);\n        }\n    }\n\n    /**\n    * @dev check if the given address already in whitelist.\n    * @return return true if in whitelist.\n    */\n    function inWhitelist(address _operator)\n        public\n        view\n        returns(bool)\n    {\n        return whitelist[_operator].inWhitelist;\n    }\n\n    function getWhitelistCount() public view returns(uint256) {\n        return whitelistAddresses.length;\n    }\n\n    function getAllWhitelist() public view returns(address[]) {\n        address[] memory allWhitelist = new address[](whitelistAddresses.length);\n        for (uint256 i = 0; i < whitelistAddresses.length; i++) {\n            allWhitelist[i] = whitelistAddresses[i];\n        }\n        return allWhitelist;\n    }\n}\n\n/**\n * @title SnapshotToken\n *\n * @dev An ERC20 token which enables taking snapshots of accounts' balances.\n * @dev This can be useful to safely implement voting weighed by balance.\n */\ncontract SnapshotToken is StandardToken {\n    using ArrayUtils for uint256[];\n\n    // The 0 id represents no snapshot was taken yet.\n    uint256 public currSnapshotId;\n\n    mapping (address => uint256[]) internal snapshotIds;\n    mapping (address => uint256[]) internal snapshotBalances;\n\n    event Snapshot(uint256 id);\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        _updateSnapshot(ms", "debug": "storage_2: 0xd025bfbaf743e012ce2440819de8f0013fb4d00ffc5ff77bc000007020000400\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xd025bfbaf743e012ce2440819de8f0013fb4d00ffc5ff77bc0000070200003ff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Whitelist_0: 0x286dd3f500000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `removeAddressFromWhitelist(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "removeAddressFromWhitelist(address)", "lineno": 495, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3927, "code": "rows if operator is not whitelisted.\n    * @param _operator address\n    */\n    modifier onlyIfWhitelisted(address _operator) {\n        require(inWhitelist(_operator) == true, \"not whitelisted.\");\n        _;\n    }\n\n    /**\n     * @dev add an address to the whitelist\n     * @param _operator address\n     * @return true if the address was added to the whitelist, false if the address was already in the whitelist\n     */\n    function addAddressToWhitelist(address _operator)\n        public\n        onlyOwner\n        returns(bool)\n    {\n        WhitelistInfo storage whitelistInfo_ = whitelist[_operator];\n\n        if (inWhitelist(_operator) == false) {\n            whitelistAddresses.push(_operator);\n\n            whitelistInfo_.inWhitelist = true;\n            whitelistInfo_.time = block.timestamp;\n            whitelistInfo_.index = whitelistAddresses.length-1;\n\n            emit AddWhitelist(_operator, whitelistAddresses.length-1);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    /**\n     * @dev add addresses to the whitelist\n     * @param _operators addresses\n     */\n    function addAddressesToWhitelist(address[] _operators)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _operators.length; i++) {\n            addAddressToWhitelist(_operators[i]);\n        }\n    }\n\n    /**\n    * @dev remove an address from the whitelist\n    * @param _operator address\n    * @return true if the address was removed from the whitelist,\n    * false if the address wasn't in the whitelist in the first place\n    */\n    function removeAddressFromWhitelist(address _operator)\n        public\n        onlyOwner\n        returns(bool)\n    {\n        if (inWhitelist(_operator) == true) {\n            uint256 whitelistIndex_ = whitelist[_operator].index;\n            removeItemFromWhitelistAddresses(whitelistIndex_);\n            whitelist[_operator] = WhitelistInfo(false, 0, 0);\n\n            emit RemoveWhitelist(_operator, whitelistIndex_);\n            return true;\n        } else {\n            return false;\n        }\n    }\n\n    function removeItemFromWhitelistAddresses(uint256 _index) private {\n        address lastWhitelistAddr = whitelistAddresses[whitelistAddresses.length-1];\n        WhitelistInfo storage lastWhitelistInfo = whitelist[lastWhitelistAddr];\n\n        //move last whitelist to the deleted slot\n        whitelistAddresses[_index] = whitelistAddresses[whitelistAddresses.length-1];\n        lastWhitelistInfo.index = _index;\n        delete whitelistAddresses[whitelistAddresses.length-1];\n        whitelistAddresses.length--;\n    }\n\n    /**\n     * @dev remove addresses from the whitelist\n     * @param _operators addresses\n     */\n    function removeAddressesFromWhitelist(address[] _operators)\n        public\n        onlyOwner\n    {\n        for (uint256 i = 0; i < _operators.length; i++) {\n            removeAddressFromWhitelist(_operators[i]);\n        }\n    }\n\n    /**\n    * @dev check if the given address already in whitelist.\n    * @return return true if in whitelist.\n    */\n    function inWhitelist(address _operator)\n        public\n        view\n        returns(bool)\n    {\n        return whitelist[_operator].inWhitelist;\n    }\n\n    function getWhitelistCount() public view returns(uint256) {\n        return whitelistAddresses.length;\n    }\n\n    function getAllWhitelist() public view returns(address[]) {\n        address[] memory allWhitelist = new address[](whitelistAddresses.length);\n        for (uint256 i = 0; i < whitelistAddresses.length; i++) {\n            allWhitelist[i] = whitelistAddresses[i];\n        }\n        return allWhitelist;\n    }\n}\n\n/**\n * @title SnapshotToken\n *\n * @dev An ERC20 token which enables taking snapshots of accounts' balances.\n * @dev This can be useful to safely implement voting weighed by balance.\n */\ncontract SnapshotToken is StandardToken {\n    using ArrayUtils for uint256[];\n\n    // The 0 id represents no snapshot was taken yet.\n    uint256 public currSnapshotId;\n\n    mapping (address => uint256[]) internal snapshotIds;\n    mapping (address => uint256[]) internal snapshotBalances;\n\n    event Snapshot(uint256 id);\n\n    function transfer(address _to, uint256 _value) public returns (bool) {\n        _updateSnapshot(ms", "debug": "storage_2: 0xc000000000000000000000000000000000000000000000000000000000000000\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xbfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Whitelist_4: 0xff00\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Whitelist_0: 0x286dd3f500000000000000000000000000000000000000000000000000000000\ncalldatasize_Whitelist: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `removeAddressFromWhitelist(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/35/0xd311ac05ede4e4955ebb08116300ee2834d03362.sol", "function": "removeAddressFromWhitelist(address)", "lineno": 495, "title": "Integer Overflow ", "type": "Warning"}], "success": true}