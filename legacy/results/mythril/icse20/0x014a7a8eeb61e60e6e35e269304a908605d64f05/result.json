{
  "contract": "0x014a7a8eeb61e60e6e35e269304a908605d64f05",
  "tool": "mythril",
  "start": 1563641500.9374661,
  "end": 1563642060.7197723,
  "duration": 559.7823061943054,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 168,
        "code": "n, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @p",
        "debug": "calldata_WhitepaperVersioning_32 + 36: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 60,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 971,
        "code": "] = msg.sender;\n ",
        "debug": "",
        "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 65,
        "title": "Message call to external contract",
        "type": "Warning"
      },
      {
        "address": 1186,
        "code": "heck if the initial version whi",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 67,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 1545,
        "code": ";\n\ncontract Ownabl",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 +\n115792089237316195423570985008687907853269984665640564039457584007913129639934 +\n2*\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncalldata_WhitepaperVersioning_32 + 4: 0x1\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1548,
        "code": "  address public owner;",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 4,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 1591,
        "code": "it Post(_contract, _version, _ipfsHash, msg.sender);\n       ",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 74,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 1607,
        "code": "it Post(_contract, _version, _ipfsHash, msg.sender);\n       ",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)): 0x0\nreturndatasize: 0x20\nretval_971: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 74,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2049,
        "code": ",\n            authors[_contrac",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_WhitepaperVersioning_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncalldata_WhitepaperVersioning_0: 0x943814f000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x943814f0",
        "lineno": 93,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 2464,
        "code": "apping (address => Whitepaper[]) private whitepapers;\n    mapping (address => address) private authors;\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\n\n    struct Whitepaper {\n        uint256 version;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev Constructor\n     * @dev Doing nothing.\n     */\n    constructor () public {}\n\n    /**\n     * @dev Function to post a new whitepaper\n     * @param _version uint256 Version number in integer\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\n     * @return status bool\n     */\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        return (\n            whitepapers[_contract][_index].version,\n            whitepapers[_contract][_index].ipfsHash,\n            authors[_contract]\n        );\n    }\n    \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getLatestWhitepaper (address _contract) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        uint256 latest = whitepapers[_contract].length - 1;\n        return getWhitepaperAt(_contract, latest);\n    }\n}",
        "debug": "keccac_1_+\n2*\n(256*Concat(0,_Extract(159,_0,_caller))_|\n_Concat(Extract(255,\n________________168,\n________________storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4),\n________0,\n________Extract(7,\n________________0,\n________________storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4)))_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_1 +\n2*\n(256*Concat(0, Extract(159, 0, caller)) |\n Concat(Extract(255,\n                168,\n                storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4),\n        0,\n        Extract(7,\n                0,\n                storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4))) +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)): 0x0\nreturndatasize: 0x20\nretval_971: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 39,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2493,
        "code": "apping (address => Whitepaper[]) private whitepapers;\n    mapping (address => address) private authors;\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\n\n    struct Whitepaper {\n        uint256 version;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev Constructor\n     * @dev Doing nothing.\n     */\n    constructor () public {}\n\n    /**\n     * @dev Function to post a new whitepaper\n     * @param _version uint256 Version number in integer\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\n     * @return status bool\n     */\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        return (\n            whitepapers[_contract][_index].version,\n            whitepapers[_contract][_index].ipfsHash,\n            authors[_contract]\n        );\n    }\n    \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getLatestWhitepaper (address _contract) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        uint256 latest = whitepapers[_contract].length - 1;\n        return getWhitepaperAt(_contract, latest);\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)): 0x0\nreturndatasize: 0x20\nretval_971: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 39,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2498,
        "code": "apping (address => Whitepaper[]) private whitepapers;\n    mapping (address => address) private authors;\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\n\n    struct Whitepaper {\n        uint256 version;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev Constructor\n     * @dev Doing nothing.\n     */\n    constructor () public {}\n\n    /**\n     * @dev Function to post a new whitepaper\n     * @param _version uint256 Version number in integer\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\n     * @return status bool\n     */\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        return (\n            whitepapers[_contract][_index].version,\n            whitepapers[_contract][_index].ipfsHash,\n            authors[_contract]\n        );\n    }\n    \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getLatestWhitepaper (address _contract) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        uint256 latest = whitepapers[_contract].length - 1;\n        return getWhitepaperAt(_contract, latest);\n    }\n}",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 39,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 2507,
        "code": "apping (address => Whitepaper[]) private whitepapers;\n    mapping (address => address) private authors;\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\n\n    struct Whitepaper {\n        uint256 version;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev Constructor\n     * @dev Doing nothing.\n     */\n    constructor () public {}\n\n    /**\n     * @dev Function to post a new whitepaper\n     * @param _version uint256 Version number in integer\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\n     * @return status bool\n     */\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        return (\n            whitepapers[_contract][_index].version,\n            whitepapers[_contract][_index].ipfsHash,\n            authors[_contract]\n        );\n    }\n    \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getLatestWhitepaper (address _contract) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        uint256 latest = whitepapers[_contract].length - 1;\n        return getWhitepaperAt(_contract, latest);\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)): 0x0\nreturndatasize: 0x20\nretval_971: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 39,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2524,
        "code": "apping (address => Whitepaper[]) private whitepapers;\n    mapping (address => address) private authors;\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\n\n    struct Whitepaper {\n        uint256 version;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev Constructor\n     * @dev Doing nothing.\n     */\n    constructor () public {}\n\n    /**\n     * @dev Function to post a new whitepaper\n     * @param _version uint256 Version number in integer\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\n     * @return status bool\n     */\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        return (\n            whitepapers[_contract][_index].version,\n            whitepapers[_contract][_index].ipfsHash,\n            authors[_contract]\n        );\n    }\n    \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getLatestWhitepaper (address _contract) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        uint256 latest = whitepapers[_contract].length - 1;\n        return getWhitepaperAt(_contract, latest);\n    }\n}",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0x25\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa0\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)): 0x0\nreturndatasize: 0x20\nretval_971: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 39,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2529,
        "code": "apping (address => Whitepaper[]) private whitepapers;\n    mapping (address => address) private authors;\n    event Post(address indexed _contract, uint256 indexed _version, string _ipfsHash, address _author);\n\n    struct Whitepaper {\n        uint256 version;\n        string ipfsHash;\n    }\n\n    /**\n     * @dev Constructor\n     * @dev Doing nothing.\n     */\n    constructor () public {}\n\n    /**\n     * @dev Function to post a new whitepaper\n     * @param _version uint256 Version number in integer\n     * @param _ipfsHash string IPFS hash of the posting whitepaper\n     * @return status bool\n     */\n    function pushWhitepaper (Ownable _contract, uint256 _version, string _ipfsHash) public returns (bool) {\n        uint256 num = whitepapers[_contract].length;\n        if(num == 0){\n            // If the posting whitepaper is the initial, only the target contract owner can post.\n            require(_contract.owner() == msg.sender);\n            authors[_contract] = msg.sender;\n        }else{\n            // Check if the initial version whitepaper's author is the msg.sender\n            require(authors[_contract] == msg.sender);\n            // Check if the version is greater than the previous version\n            require(whitepapers[_contract][num-1].version < _version);\n        }\n    \n        whitepapers[_contract].push(Whitepaper(_version, _ipfsHash));\n        emit Post(_contract, _version, _ipfsHash, msg.sender);\n        return true;\n    }\n  \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @param _index uint256 Index number of whitepapers associated with the specified contract address\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getWhitepaperAt (address _contract, uint256 _index) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        return (\n            whitepapers[_contract][_index].version,\n            whitepapers[_contract][_index].ipfsHash,\n            authors[_contract]\n        );\n    }\n    \n    /**\n     * @dev Look up whitepaper at the specified index\n     * @param _contract address Target contract address associated with a whitepaper\n     * @return version uint8 Version number in integer\n     * @return ipfsHash string IPFS hash of the whitepaper\n     * @return author address Address of an account who posted the whitepaper\n     */\n    function getLatestWhitepaper (address _contract) public view returns (\n        uint256 version,\n        string ipfsHash,\n        address author\n    ) {\n        uint256 latest = whitepapers[_contract].length - 1;\n        return getWhitepaperAt(_contract, latest);\n    }\n}",
        "debug": "keccac_1_+\n2*\n(256*Concat(0,_Extract(159,_0,_caller))_|\n_Concat(Extract(255,\n________________168,\n________________storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4),\n________0,\n________Extract(7,\n________________0,\n________________storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4)))_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0x2021fda91bfffffffffffffffffffffffffffffffffffffffff8\nmem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)) +\n32: 0x9ffbffffffffd99db48e28ffffffffffffffffffffffffffffffffffffffffe8\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_WhitepaperVersioning_4 + calldata_WhitepaperVersioning_32 + 36)): 0x0\nreturndatasize: 0x20\nretval_971: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_WhitepaperVersioning_0: 0x838dced000000000000000000000000000000000000000000000000000000000\ncalldatasize_WhitepaperVersioning: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_WhitepaperVersioning_4: 0x0\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `_function_0x838dced0`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/27/0x014a7a8eeb61e60e6e35e269304a908605d64f05.sol",
        "function": "_function_0x838dced0",
        "lineno": 39,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}