{"error": null, "issues": [{"address": 1655, "code": "fficialGameUrl;\n    }\n}\n\ncontract SoccerBet is Base\n{\n\tfunction SoccerBet(string _gameName) public {\n\t\tgameName = _gameName;\n   ", "debug": "calldata_SoccerBet_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SoccerBet_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/25/0xe2ef9698900e7deef586e335caa25b2d4f22af5b.sol", "function": "setOfficialGameUrl(string)", "lineno": 107, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4628, "code": ">= a)", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\ncallvalue: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\ntimestamp: 0x0\nstorage_4: 0x1\nstorage_3: 0x0\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0xfaf277500000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\n", "description": "A possible integer overflow exists in the function `newGame(string,string,uint256,uint256,uint256,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/25/0xe2ef9698900e7deef586e335caa25b2d4f22af5b.sol", "function": "newGame(string,string,uint256,uint256,uint256,uint256,uint256,uint256)", "lineno": 22, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4641, "code": "eturn c;\n  }\n}", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xc63a21246c99b000ea0030728005ea6909080a424a47ca48059be3c0ff803205\ncallvalue: 0xd2bd697b67b8b7eebcef8ebaf405ca6a0b728a06c347eda3d5dbebfeffbdb977\ntimestamp: 0x0\nstorage_4: 0x1\nstorage_3: 0x0\nstorage_5: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0xfaf277500000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/25/0xe2ef9698900e7deef586e335caa25b2d4f22af5b.sol", "function": "newGame(string,string,uint256,uint256,uint256,uint256,uint256,uint256)", "lineno": 23, "title": "Exception state", "type": "Informational"}, {"address": 17008, "code": "ner = msg.sender;\n    }\n\t\n\tuint public unpayPooling = 0;\n\tuint public losePooling = 0;\n\tuint public winPooling = 0;\n\tuint public samePooling = 0;\n\tuint public bankerAllDeposit = 0;\n\t\n\taddress public auction;\n\tfunction setAuction(address _newAuction) public onlyOwner{\n        auction = _newAuction;\n    }\n    modifier onlyAuction {\n\t    require(msg.sender == auction);\n        _;\n    }\n\t\n    modifier onlyBanker {\n        require(msg.sender == currentBanker);\n        require(bankerBeginTime <= now);\n        require(now < bankerEndTime);\n        _;\n    }    \n\t\n\tfunction canSetBanker() public view returns (bool _result){\n        _result =  false;\n\t\tif(now < bankerEndTime){\n\t\t\treturn;\n\t\t}\n\t\tif(userEtherOf[this] == 0){\n\t\t\t_result = true;\n\t\t}\n    }\n\t\n\tevent OnSetNewBanker(uint indexed _gameID, address _caller, address _banker, uint _beginTime, uint _endTime, uint _errInfo, uint _eventTime, uint eventId);\n\n    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n    {\n        _result = false;\n        require(_banker != 0x0);\n\n        if(now < bankerEndTime){\n            emit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());\n            return;\n        }\n\t\t\n\t\tif(userEtherOf[this] > 0){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 5, now, getEventId());\n\t\t\treturn;\n\t\t}\n        \n        if(_beginTime > now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId());\n            return;\n        }\n\n        if(_endTime <= now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());\n            return;\n        }\n\n        currentBanker = _banker;\n        bankerBeginTime = _beginTime;\n        bankerEndTime =  _endTime;\n\t\t\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\t\t\n\t\tbankerAllDeposit = 0;\n\t\t\n\t\tgameResult = 9;\n\t\t\n\t\tgameOver = true;\n\n\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 0, now, getEventId());\n        _result = true;\n    }\n\t\n\tstring public team1;\n    string public team2;\n\t\n\tuint public constant loseNum = 1;\n    uint public constant winNum = 3;\n    uint public constant sameNum = 0;\n\n    uint public loseOdd;\n    uint public winOdd;\n    uint public sameOdd;\n\t\n\tuint public betLastTime;\n\t\n\tuint public playNo = 1;\n    uint public gameID = 0;\n\t\n\tuint public gameBeginPlayNo;\n\t\n\tuint public gameResult = 9;\n\t\n\tuint  public gameBeginTime;\n\n    uint256 public gameMaxBetAmount;\n    uint256 public gameMinBetAmount;\n    bool public gameOver = true;\n\t\n\tuint public nextRewardPlayNo=1;\n    uint public currentRewardNum = 100;\n\n\taddress public decider;\n\tfunction setDecider(address _decider) public onlyOwner{\t\n        decider = _decider;\n    }\n    modifier onlyDecider{\n        require(msg.sender == decider);\n        _;\n    }\n\tfunction setGameResult(uint _gameResult) public onlyDecider{\n\t\trequire(!gameOver);\n\t\trequire(betLastTime + 90 minutes < now);\n\t\trequire(now < betLastTime + 30 days);\n\t\trequire(gameResult == 9);\n\t\trequire( _gameResult == loseNum || _gameResult == winNum || _gameResult == sameNum);\n\t\tgameResult = _gameResult;\n\t\tif(gameResult == 3){\n\t\t\tunpayPooling = winPooling;\n\t\t}else if(gameResult == 1){\n\t\t\tunpayPooling = losePooling;\n\t\t}else if(gameResult == 0){\n\t\t\tunpayPooling = samePooling;\n\t\t}\n\t}\n\n    event OnNewGame(uint indexed _gameID, address _banker , uint _betLastTime, uint _gameBeginTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount, uint _eventTime, uint eventId);\n\tevent OnGameInfo(uint indexed _gameID, string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _eventTime, uint eventId);\n\t\n    function newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd,  uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) public onlyBanker payable returns(bool _result){\n        if (msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n        }\n\n        require(bytes(_team1).length < 100);\n\t\trequire(bytes(_team2).length < 100);\n\t\t\n\t\trequire(gameOver);\n        require(now > bankerBeginTime);\n        require(_gameMinBetAmount >= 100000000000000);\n        require(_gameMaxBetAmount >= _gameMinBetAmount);\n\t\trequire(now < _betLastTime);\n\t\trequire(_betLastTime+ 1 days < bankerEndTime);\n\t\t\t\n\t\t\n        _result = _newGame(_team1, _team2, _loseOdd, _winOdd, _sameOdd, _betLastTime, _gameMinBetAmount,  _gameMaxBetAmount);\n    }\n\n    function _newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) private  returns(bool _result){\n        _result = false;\n\t\tgameID = gameID.add(1);\n\t\t\n\t\tteam1 = _team1;\n        team2 = _team2;\n\t\tloseOdd = _loseOdd;\n\t\twinOdd = _winOdd;\n\t\tsameOdd = _sameOdd;\n\t\temit OnGameInfo(gameID, team1, team2, loseOdd, winOdd, sameOdd, now, getEventId());\n\t\t\n\t\tbetLastTime = _betLastTime;\n        gameBeginTime = now;\n\t\tgameMinBetAmount = _gameMinBetAmount;\n        gameMaxBetAmount = _gameMaxBetAmount;\n\t\temit OnNewGame(gameID, msg.sender, betLastTime,  gameBeginTime, gameMinBetAmount,   gameMaxBetAmount, now, getEventId());\n\t\t\n        gameBeginPlayNo = playNo;\n        gameResult = 9;\n        gameOver = false;\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\t\t\n\t\tbankerAllDeposit = 0;\n\t\t\n        _result = true;\n    }\n\t\n    event OnSetOdd(uint indexed _gameID, uint _winOdd, uint _loseOdd, uint _sameOdd, uint _eventTime, uint eventId);\n\tfunction setOdd(uint _winOdd, uint _loseOdd, uint _sameOdd) onlyBanker public{\t\t\n\t\twinOdd = _winOdd;\n\t\tloseOdd = _loseOdd;\n\t\tsameOdd = _sameOdd;\t\n\t\temit OnSetOdd(gameID, winOdd, loseOdd, sameOdd, now, getEventId());\n\t}\n\n    struct betInfo\n    {\n        uint Odd;\n        address Player;\n        uint BetNum;\n        uint256 BetAmount;\n\t\tuint BetTime;\n        bool IsReturnAward;\n\t\tuint ResultNO;\n    }\n\n    mapping (uint => betInfo) public playerBetInfoOf;\n\n    event OnPlay( uint indexed _gameID, uint indexed _playNo, address indexed _player, string _gameName, uint odd, string _team1, uint _betNum, uint256 _betAmount,  uint _eventTime, uint eventId);\n    function play(uint _betNum, uint256 _betAmount) public payable  returns(bool _result){\n        if (msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n        }\n\t\t_result = _play(_betNum, _betAmount);\n    }\n\n    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){\n        _result = false;\n        require(!gameOver);\n      \n        require( loseNum == _betNum || _betNum == winNum || _betNum == sameNum);\n        require(msg.sender != currentBanker);\n\n        require(now < betLastTime);\n\t\t\n\t\trequire(_betAmount >= gameMinBetAmount);\n        if (_betAmount > gameMaxBetAmount){\n            _betAmount = gameMaxBetAmount;\n        }\n\t\t\n\t\t_betAmount = _betAmount / 100 * 100;\n\t\t\n\t\tuint _odd = _seekOdd(_betNum, _betAmount);\n\t\t\n        require(userEtherOf[msg.sender] >= _betAmount);\n\n        betInfo memory bi= betInfo({\n            Odd :_odd,\n            Player :  msg.sender,\n            BetNum : _betNum,\n            BetAmount : _betAmount,\n\t\t\tBetTime : now,\n            IsReturnAward: false,\n\t\t\tResultNO: 9\n        });\n\n         playerBetInfoOf[playNo] = bi;\n        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(_betAmount); \n\t\tuserEtherOf[this] = userEtherOf[this].add(_betAmount);\n\t\t\n\t\tuint _maxpooling = _getMaxPooling();\n\t\tif(userEtherOf[this] < _maxpooling){\n\t\t\tuint BankerAmount = _maxpooling.sub(userEtherOf[this]);\n\t\t\trequire(userEtherOf[currentBanker] >= BankerAmount);\n\t\t\tuserEtherOf[currentBanker] = userEtherOf[currentBanker].sub(BankerAmount);\n\t\t\tuserEtherOf[this] = userEtherOf[this].add(BankerAmount);\n\t\t\tbankerAllDeposit = bankerAllDeposit.add(BankerAmount);\n\t\t}\n\t\t\n        emit OnPlay(gameID, playNo, msg.sender, gameName, _odd, team1, _betNum, _betAmount, now, getEventId());\n\n        playNo = playNo.add(1);\n        _result = true;\n    }\n\t\n\tfunction _seekOdd(uint _betNum, uint _betAmount) private returns (uint _odd){\n\t\tuint allAmount = 0;\n\t\tif(_betNum == 3){\n\t\t\tallAmount = _betAmount.mul(winOdd).div(100);\n\t\t\twinPooling = winPooling.add(allAmount);\n\t\t\t_odd  = winOdd;\n\t\t}else if(_betNum == 1){\n\t\t\tallAmount = _betAmount.mul(loseOdd).div(100);\n\t\t\tlosePooling = losePooling.add(allAmount);\n\t\t\t_odd = loseOdd;\n\t\t}else if(_betNum == 0){\n\t\t\tallAmount = _betAmount.mul(sameOdd).div(100);\n\t\t\tsamePooling = samePooling.add(allAmount);\n\t\t\t_odd = sameOdd;\n\t\t}\n    }\n\t\n\tfunction _getMaxPooling() private view returns(uint maxpooling){\n\t\tmaxpooling = winPooling;\n\t\tif(maxpooling < losePooling){\n\t\t\tmaxpooling = losePooling;\n\t\t}\n\t\tif(maxpooling < samePooling){\n\t\t\tmaxpooling = samePooling;\n\t\t}\n\t}\n\n\tevent OnOpenGameResult(uint indexed _gameID,uint indexed _palyNo, address _player, uint _gameResult, uint _eventTime, uint eventId);\n    function openGameLoop() public returns(bool _result){\n\t\tlock();\n        _result =  _openGameLoop();\n        unLock();\n    }\n\n    function _openGameLoop() private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor(uint i = 0; nextRewardPlayNo < playNo && i < currentRewardNum; i++ ){\n\t\t\tbetInfo storage p = playerBetInfoOf[nextRewardPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,nextRewardPlayNo);\n\t\t\t}\n\t\t\tnextRewardPlayNo = nextRewardPlayNo.add(1);\n\t\t}\n\t\t\n\t\t_setGameOver();\n\t\t\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNo(uint _playNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNo(_playNo);\n        unLock();\n    }\n\n    function _openGamePlayNo(uint _playNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_playNo >= gameBeginPlayNo && _playNo < playNo);\n\t\t_checkOpenGame();\n\t\t\n\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\trequire(!p.IsReturnAward);\n\t\t\n\t\tuint256 allAmount = 0;\n\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\n\t\t_setGameOver();\n\t\t\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNos(uint[] _playNos) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNos(_playNos);\n        unLock();\n    }\n\t\n    function _openGamePlayNos(uint[] _playNos) private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\t\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n\t\t\tuint _playNo = _playNos[_index];\n\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\t\t\tif(!p.IsReturnAward){\n\t\t\t\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_setGameOver();\n\t\t\n\t\t_result = true;\n    }\n\t\n\t\n\tfunction openGameRange(uint _beginPlayNo, uint _endPlayNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGameRange(_beginPlayNo, _endPlayNo);\n        unLock();\n    }\n\t\n    function _openGameRange(uint _beginPlayNo, uint _endPlayNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_beginPlayNo < _endPlayNo);\n\t\trequire(_beginPlayNo >= gameBeginPlayNo && _endPlayNo < playNo);\n\t\t\n\t\t_checkOpenGame();\n\t\t\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _indexPlayNo = _beginPlayNo; _indexPlayNo <= _endPlayNo; _indexPlayNo++) {\n\t\t\tbetInfo storage p = playerBetInfoOf[_indexPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,_indexPlayNo);\n\t\t\t}\n\t\t}\n\t\t_setGameOver();\n\t\t_result = true;\n    }\n\t\n\tfunction _checkOpenGame() private view{\n\t\trequire(!gameOver);\n\t\trequire( gameResult == loseNum || gameResult == winNum || gameResult == sameNum);\n\t\trequire(betLastTime + 90 minutes < now);\n\t}\n\t\n\tfunction _cashPrize(betInfo storage _p, uint256 _allAmount,uint _playNo) private{\n\t\tif(_p.BetNum == gameResult){\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\t\n\t\t\t_p.IsReturnAward = true;\n\t\t\t_p.ResultNO = gameResult;\n\t\t\tuserEtherOf[this] = userEtherOf[this].sub(_allAmount);\n\t\t\tunpayPooling = unpayPooling.sub(_allAmount);\n\t\t\tuserEtherOf[_p.Player] = userEtherOf[_p.Player].add(_allAmount);\n\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t\n\t\t\tif(_p.BetNum == 3){\n\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t}\n\t\t\t\n\t\t}else{\n\t\t\t_p.IsReturnAward = true;\n\t\t\t_p.ResultNO = gameResult;\n\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\tif(_p.BetNum == 3){\n\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction _setGameOver() private{\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserEtherOf[currentBanker] = userEtherOf[currentBanker].add(userEtherOf[this]);\n\t\t\tuserEtherOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t}\n\t\n\tfunction _canSetGameOver() private view returns(bool){\n\t\treturn winPooling<100 && losePooling<100 && samePooling<100;\n\t}\n\t\n\tfunction failUserRefund(uint[] _playNos) public returns (bool _result) {\n        _result = false;\n        require(!gameOver);\n\t\trequire(gameResult == 9);\n        require(betLastTime + 31 days < now);\n\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n\t\t\tuint _playNo = _playNos[_index];\n\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\t\t\tif(!p.IsReturnAward){\n\t\t\t\t\tp.IsReturnAward = true;\n\t\t\t\t\tuint256 ToUser = p.BetAmount;\n\t\t\t\t\tuserEtherOf[this] = userEtherOf[this].sub(ToUser);\n\t\t\t\t\tuserEtherOf[p.Player] =  userEtherOf[p.Player].add(ToUser);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(msg.sender == currentBanker && bankerAllDeposit>0){\n\t\t\tuserEtherOf[this] = userEtherOf[this].sub(bankerAllDeposit);\n\t\t\tuserEtherOf[currentBanker] =  userEtherOf[currentBanker].add(bankerAllDeposit);\n\t\t\tbankerAllDeposit = 0;\n\t\t}\n\t\tif(userEtherOf[this] == 0){\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\n\t\n\tevent OnRefund(uint indexed _gameId, address _to, uint _amount, bool _result, uint _eventTime, uint eventId);\n\tfunction _userRefund(address _to) internal  returns(bool _result){\n\t\trequire (_to != 0x0);\n\t\trequire(_to != currentBanker || gameOver);\n\t\tlock();\n\t\tuint256 amount = userEtherOf[_to];\n\t\tif(amount > 0){\n\t\t\tuserEtherOf[msg.sender] = 0;\n\t\t\t_to.transfer(amount);\n\t\t\t_result = true;\n\t\t}else{\n\t\t\t_result = false;\n\t\t}\n\t\t\n\t\temit OnRefund(gameID, _to, amount, _result, now, getEventId());\n\t\tunLock();                                                                            \n    }\n\t\n\tfunction playEtherOf() public payable {\n        if (msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);                  \n        }\n    }\n\t\n\tfunction () public payable {\n        if(msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n\t\t\t\n        }\n    }\n\n}", "debug": "calldata_SoccerBet_4 + calldata_SoccerBet_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_8: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/25/0xe2ef9698900e7deef586e335caa25b2d4f22af5b.sol", "function": "setOfficialGameUrl(string)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}, {"address": 17022, "code": "ner = msg.sender;\n    }\n\t\n\tuint public unpayPooling = 0;\n\tuint public losePooling = 0;\n\tuint public winPooling = 0;\n\tuint public samePooling = 0;\n\tuint public bankerAllDeposit = 0;\n\t\n\taddress public auction;\n\tfunction setAuction(address _newAuction) public onlyOwner{\n        auction = _newAuction;\n    }\n    modifier onlyAuction {\n\t    require(msg.sender == auction);\n        _;\n    }\n\t\n    modifier onlyBanker {\n        require(msg.sender == currentBanker);\n        require(bankerBeginTime <= now);\n        require(now < bankerEndTime);\n        _;\n    }    \n\t\n\tfunction canSetBanker() public view returns (bool _result){\n        _result =  false;\n\t\tif(now < bankerEndTime){\n\t\t\treturn;\n\t\t}\n\t\tif(userEtherOf[this] == 0){\n\t\t\t_result = true;\n\t\t}\n    }\n\t\n\tevent OnSetNewBanker(uint indexed _gameID, address _caller, address _banker, uint _beginTime, uint _endTime, uint _errInfo, uint _eventTime, uint eventId);\n\n    function setBanker(address _banker, uint _beginTime, uint _endTime) public onlyAuction returns(bool _result)\n    {\n        _result = false;\n        require(_banker != 0x0);\n\n        if(now < bankerEndTime){\n            emit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 1, now, getEventId());\n            return;\n        }\n\t\t\n\t\tif(userEtherOf[this] > 0){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 5, now, getEventId());\n\t\t\treturn;\n\t\t}\n        \n        if(_beginTime > now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 3, now, getEventId());\n            return;\n        }\n\n        if(_endTime <= now){\n\t\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 4, now, getEventId());\n            return;\n        }\n\n        currentBanker = _banker;\n        bankerBeginTime = _beginTime;\n        bankerEndTime =  _endTime;\n\t\t\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\t\t\n\t\tbankerAllDeposit = 0;\n\t\t\n\t\tgameResult = 9;\n\t\t\n\t\tgameOver = true;\n\n\t\temit OnSetNewBanker(gameID, msg.sender, _banker,  _beginTime,  _endTime, 0, now, getEventId());\n        _result = true;\n    }\n\t\n\tstring public team1;\n    string public team2;\n\t\n\tuint public constant loseNum = 1;\n    uint public constant winNum = 3;\n    uint public constant sameNum = 0;\n\n    uint public loseOdd;\n    uint public winOdd;\n    uint public sameOdd;\n\t\n\tuint public betLastTime;\n\t\n\tuint public playNo = 1;\n    uint public gameID = 0;\n\t\n\tuint public gameBeginPlayNo;\n\t\n\tuint public gameResult = 9;\n\t\n\tuint  public gameBeginTime;\n\n    uint256 public gameMaxBetAmount;\n    uint256 public gameMinBetAmount;\n    bool public gameOver = true;\n\t\n\tuint public nextRewardPlayNo=1;\n    uint public currentRewardNum = 100;\n\n\taddress public decider;\n\tfunction setDecider(address _decider) public onlyOwner{\t\n        decider = _decider;\n    }\n    modifier onlyDecider{\n        require(msg.sender == decider);\n        _;\n    }\n\tfunction setGameResult(uint _gameResult) public onlyDecider{\n\t\trequire(!gameOver);\n\t\trequire(betLastTime + 90 minutes < now);\n\t\trequire(now < betLastTime + 30 days);\n\t\trequire(gameResult == 9);\n\t\trequire( _gameResult == loseNum || _gameResult == winNum || _gameResult == sameNum);\n\t\tgameResult = _gameResult;\n\t\tif(gameResult == 3){\n\t\t\tunpayPooling = winPooling;\n\t\t}else if(gameResult == 1){\n\t\t\tunpayPooling = losePooling;\n\t\t}else if(gameResult == 0){\n\t\t\tunpayPooling = samePooling;\n\t\t}\n\t}\n\n    event OnNewGame(uint indexed _gameID, address _banker , uint _betLastTime, uint _gameBeginTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount, uint _eventTime, uint eventId);\n\tevent OnGameInfo(uint indexed _gameID, string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _eventTime, uint eventId);\n\t\n    function newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd,  uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) public onlyBanker payable returns(bool _result){\n        if (msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n        }\n\n        require(bytes(_team1).length < 100);\n\t\trequire(bytes(_team2).length < 100);\n\t\t\n\t\trequire(gameOver);\n        require(now > bankerBeginTime);\n        require(_gameMinBetAmount >= 100000000000000);\n        require(_gameMaxBetAmount >= _gameMinBetAmount);\n\t\trequire(now < _betLastTime);\n\t\trequire(_betLastTime+ 1 days < bankerEndTime);\n\t\t\t\n\t\t\n        _result = _newGame(_team1, _team2, _loseOdd, _winOdd, _sameOdd, _betLastTime, _gameMinBetAmount,  _gameMaxBetAmount);\n    }\n\n    function _newGame(string _team1, string _team2, uint _loseOdd, uint _winOdd, uint _sameOdd, uint _betLastTime, uint256 _gameMinBetAmount, uint256 _gameMaxBetAmount) private  returns(bool _result){\n        _result = false;\n\t\tgameID = gameID.add(1);\n\t\t\n\t\tteam1 = _team1;\n        team2 = _team2;\n\t\tloseOdd = _loseOdd;\n\t\twinOdd = _winOdd;\n\t\tsameOdd = _sameOdd;\n\t\temit OnGameInfo(gameID, team1, team2, loseOdd, winOdd, sameOdd, now, getEventId());\n\t\t\n\t\tbetLastTime = _betLastTime;\n        gameBeginTime = now;\n\t\tgameMinBetAmount = _gameMinBetAmount;\n        gameMaxBetAmount = _gameMaxBetAmount;\n\t\temit OnNewGame(gameID, msg.sender, betLastTime,  gameBeginTime, gameMinBetAmount,   gameMaxBetAmount, now, getEventId());\n\t\t\n        gameBeginPlayNo = playNo;\n        gameResult = 9;\n        gameOver = false;\n\t\tunpayPooling = 0;\n\t\tlosePooling = 0;\n\t\twinPooling = 0;\n\t\tsamePooling = 0;\n\t\t\n\t\tbankerAllDeposit = 0;\n\t\t\n        _result = true;\n    }\n\t\n    event OnSetOdd(uint indexed _gameID, uint _winOdd, uint _loseOdd, uint _sameOdd, uint _eventTime, uint eventId);\n\tfunction setOdd(uint _winOdd, uint _loseOdd, uint _sameOdd) onlyBanker public{\t\t\n\t\twinOdd = _winOdd;\n\t\tloseOdd = _loseOdd;\n\t\tsameOdd = _sameOdd;\t\n\t\temit OnSetOdd(gameID, winOdd, loseOdd, sameOdd, now, getEventId());\n\t}\n\n    struct betInfo\n    {\n        uint Odd;\n        address Player;\n        uint BetNum;\n        uint256 BetAmount;\n\t\tuint BetTime;\n        bool IsReturnAward;\n\t\tuint ResultNO;\n    }\n\n    mapping (uint => betInfo) public playerBetInfoOf;\n\n    event OnPlay( uint indexed _gameID, uint indexed _playNo, address indexed _player, string _gameName, uint odd, string _team1, uint _betNum, uint256 _betAmount,  uint _eventTime, uint eventId);\n    function play(uint _betNum, uint256 _betAmount) public payable  returns(bool _result){\n        if (msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n        }\n\t\t_result = _play(_betNum, _betAmount);\n    }\n\n    function _play(uint _betNum, uint256 _betAmount) private  returns(bool _result){\n        _result = false;\n        require(!gameOver);\n      \n        require( loseNum == _betNum || _betNum == winNum || _betNum == sameNum);\n        require(msg.sender != currentBanker);\n\n        require(now < betLastTime);\n\t\t\n\t\trequire(_betAmount >= gameMinBetAmount);\n        if (_betAmount > gameMaxBetAmount){\n            _betAmount = gameMaxBetAmount;\n        }\n\t\t\n\t\t_betAmount = _betAmount / 100 * 100;\n\t\t\n\t\tuint _odd = _seekOdd(_betNum, _betAmount);\n\t\t\n        require(userEtherOf[msg.sender] >= _betAmount);\n\n        betInfo memory bi= betInfo({\n            Odd :_odd,\n            Player :  msg.sender,\n            BetNum : _betNum,\n            BetAmount : _betAmount,\n\t\t\tBetTime : now,\n            IsReturnAward: false,\n\t\t\tResultNO: 9\n        });\n\n         playerBetInfoOf[playNo] = bi;\n        userEtherOf[msg.sender] = userEtherOf[msg.sender].sub(_betAmount); \n\t\tuserEtherOf[this] = userEtherOf[this].add(_betAmount);\n\t\t\n\t\tuint _maxpooling = _getMaxPooling();\n\t\tif(userEtherOf[this] < _maxpooling){\n\t\t\tuint BankerAmount = _maxpooling.sub(userEtherOf[this]);\n\t\t\trequire(userEtherOf[currentBanker] >= BankerAmount);\n\t\t\tuserEtherOf[currentBanker] = userEtherOf[currentBanker].sub(BankerAmount);\n\t\t\tuserEtherOf[this] = userEtherOf[this].add(BankerAmount);\n\t\t\tbankerAllDeposit = bankerAllDeposit.add(BankerAmount);\n\t\t}\n\t\t\n        emit OnPlay(gameID, playNo, msg.sender, gameName, _odd, team1, _betNum, _betAmount, now, getEventId());\n\n        playNo = playNo.add(1);\n        _result = true;\n    }\n\t\n\tfunction _seekOdd(uint _betNum, uint _betAmount) private returns (uint _odd){\n\t\tuint allAmount = 0;\n\t\tif(_betNum == 3){\n\t\t\tallAmount = _betAmount.mul(winOdd).div(100);\n\t\t\twinPooling = winPooling.add(allAmount);\n\t\t\t_odd  = winOdd;\n\t\t}else if(_betNum == 1){\n\t\t\tallAmount = _betAmount.mul(loseOdd).div(100);\n\t\t\tlosePooling = losePooling.add(allAmount);\n\t\t\t_odd = loseOdd;\n\t\t}else if(_betNum == 0){\n\t\t\tallAmount = _betAmount.mul(sameOdd).div(100);\n\t\t\tsamePooling = samePooling.add(allAmount);\n\t\t\t_odd = sameOdd;\n\t\t}\n    }\n\t\n\tfunction _getMaxPooling() private view returns(uint maxpooling){\n\t\tmaxpooling = winPooling;\n\t\tif(maxpooling < losePooling){\n\t\t\tmaxpooling = losePooling;\n\t\t}\n\t\tif(maxpooling < samePooling){\n\t\t\tmaxpooling = samePooling;\n\t\t}\n\t}\n\n\tevent OnOpenGameResult(uint indexed _gameID,uint indexed _palyNo, address _player, uint _gameResult, uint _eventTime, uint eventId);\n    function openGameLoop() public returns(bool _result){\n\t\tlock();\n        _result =  _openGameLoop();\n        unLock();\n    }\n\n    function _openGameLoop() private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\tuint256 allAmount = 0;\n\t\tfor(uint i = 0; nextRewardPlayNo < playNo && i < currentRewardNum; i++ ){\n\t\t\tbetInfo storage p = playerBetInfoOf[nextRewardPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,nextRewardPlayNo);\n\t\t\t}\n\t\t\tnextRewardPlayNo = nextRewardPlayNo.add(1);\n\t\t}\n\t\t\n\t\t_setGameOver();\n\t\t\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNo(uint _playNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNo(_playNo);\n        unLock();\n    }\n\n    function _openGamePlayNo(uint _playNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_playNo >= gameBeginPlayNo && _playNo < playNo);\n\t\t_checkOpenGame();\n\t\t\n\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\trequire(!p.IsReturnAward);\n\t\t\n\t\tuint256 allAmount = 0;\n\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\n\t\t_setGameOver();\n\t\t\n\t\t_result = true;\n    }\n\t\n\tfunction openGamePlayNos(uint[] _playNos) public returns(bool _result){\n\t\tlock();\n        _result =  _openGamePlayNos(_playNos);\n        unLock();\n    }\n\t\n    function _openGamePlayNos(uint[] _playNos) private returns(bool _result){\n        _result = false;\n        _checkOpenGame();\n\t\t\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n\t\t\tuint _playNo = _playNos[_index];\n\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\t\t\tif(!p.IsReturnAward){\n\t\t\t\t\t_cashPrize(p, allAmount,_playNo);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\t_setGameOver();\n\t\t\n\t\t_result = true;\n    }\n\t\n\t\n\tfunction openGameRange(uint _beginPlayNo, uint _endPlayNo) public returns(bool _result){\n\t\tlock();\n        _result =  _openGameRange(_beginPlayNo, _endPlayNo);\n        unLock();\n    }\n\t\n    function _openGameRange(uint _beginPlayNo, uint _endPlayNo) private returns(bool _result){\n        _result = false;\n\t\trequire(_beginPlayNo < _endPlayNo);\n\t\trequire(_beginPlayNo >= gameBeginPlayNo && _endPlayNo < playNo);\n\t\t\n\t\t_checkOpenGame();\n\t\t\n\t\tuint256 allAmount = 0;\n\t\tfor (uint _indexPlayNo = _beginPlayNo; _indexPlayNo <= _endPlayNo; _indexPlayNo++) {\n\t\t\tbetInfo storage p = playerBetInfoOf[_indexPlayNo];\n\t\t\tif(!p.IsReturnAward){\n\t\t\t\t_cashPrize(p, allAmount,_indexPlayNo);\n\t\t\t}\n\t\t}\n\t\t_setGameOver();\n\t\t_result = true;\n    }\n\t\n\tfunction _checkOpenGame() private view{\n\t\trequire(!gameOver);\n\t\trequire( gameResult == loseNum || gameResult == winNum || gameResult == sameNum);\n\t\trequire(betLastTime + 90 minutes < now);\n\t}\n\t\n\tfunction _cashPrize(betInfo storage _p, uint256 _allAmount,uint _playNo) private{\n\t\tif(_p.BetNum == gameResult){\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\t\n\t\t\t_p.IsReturnAward = true;\n\t\t\t_p.ResultNO = gameResult;\n\t\t\tuserEtherOf[this] = userEtherOf[this].sub(_allAmount);\n\t\t\tunpayPooling = unpayPooling.sub(_allAmount);\n\t\t\tuserEtherOf[_p.Player] = userEtherOf[_p.Player].add(_allAmount);\n\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t\n\t\t\tif(_p.BetNum == 3){\n\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t}\n\t\t\t\n\t\t}else{\n\t\t\t_p.IsReturnAward = true;\n\t\t\t_p.ResultNO = gameResult;\n\t\t\temit OnOpenGameResult(gameID,_playNo, msg.sender, gameResult, now, getEventId());\n\t\t\t\n\t\t\t_allAmount = _p.BetAmount.mul(_p.Odd).div(100);\n\t\t\tif(_p.BetNum == 3){\n\t\t\t\twinPooling = winPooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 1){\n\t\t\t\tlosePooling = losePooling.sub(_allAmount);\n\t\t\t}else if(_p.BetNum == 0){\n\t\t\t\tsamePooling = samePooling.sub(_allAmount);\n\t\t\t}\n\t\t}\n\t}\n\t\n\tfunction _setGameOver() private{\n\t\tif(unpayPooling == 0 && _canSetGameOver()){\n\t\t\tuserEtherOf[currentBanker] = userEtherOf[currentBanker].add(userEtherOf[this]);\n\t\t\tuserEtherOf[this] = 0;\n\t\t\tgameOver = true;\n\t\t}\n\t}\n\t\n\tfunction _canSetGameOver() private view returns(bool){\n\t\treturn winPooling<100 && losePooling<100 && samePooling<100;\n\t}\n\t\n\tfunction failUserRefund(uint[] _playNos) public returns (bool _result) {\n        _result = false;\n        require(!gameOver);\n\t\trequire(gameResult == 9);\n        require(betLastTime + 31 days < now);\n\t\tfor (uint _index = 0; _index < _playNos.length; _index++) {\n\t\t\tuint _playNo = _playNos[_index];\n\t\t\tif(_playNo >= gameBeginPlayNo && _playNo < playNo){\n\t\t\t\tbetInfo storage p = playerBetInfoOf[_playNo];\n\t\t\t\tif(!p.IsReturnAward){\n\t\t\t\t\tp.IsReturnAward = true;\n\t\t\t\t\tuint256 ToUser = p.BetAmount;\n\t\t\t\t\tuserEtherOf[this] = userEtherOf[this].sub(ToUser);\n\t\t\t\t\tuserEtherOf[p.Player] =  userEtherOf[p.Player].add(ToUser);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(msg.sender == currentBanker && bankerAllDeposit>0){\n\t\t\tuserEtherOf[this] = userEtherOf[this].sub(bankerAllDeposit);\n\t\t\tuserEtherOf[currentBanker] =  userEtherOf[currentBanker].add(bankerAllDeposit);\n\t\t\tbankerAllDeposit = 0;\n\t\t}\n\t\tif(userEtherOf[this] == 0){\n\t\t\tgameOver = true;\n\t\t}\n\t\t_result = true;\n    }\n\n\t\n\tevent OnRefund(uint indexed _gameId, address _to, uint _amount, bool _result, uint _eventTime, uint eventId);\n\tfunction _userRefund(address _to) internal  returns(bool _result){\n\t\trequire (_to != 0x0);\n\t\trequire(_to != currentBanker || gameOver);\n\t\tlock();\n\t\tuint256 amount = userEtherOf[_to];\n\t\tif(amount > 0){\n\t\t\tuserEtherOf[msg.sender] = 0;\n\t\t\t_to.transfer(amount);\n\t\t\t_result = true;\n\t\t}else{\n\t\t\t_result = false;\n\t\t}\n\t\t\n\t\temit OnRefund(gameID, _to, amount, _result, now, getEventId());\n\t\tunLock();                                                                            \n    }\n\t\n\tfunction playEtherOf() public payable {\n        if (msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);                  \n        }\n    }\n\t\n\tfunction () public payable {\n        if(msg.value > 0){\n            userEtherOf[msg.sender] = userEtherOf[msg.sender].add(msg.value);\n\t\t\t\n        }\n    }\n\n}", "debug": "calldata_SoccerBet_4 + calldata_SoccerBet_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_8: 0x0\ncaller: 0x0\ncalldata_SoccerBet_0: 0x26c4fa3d00000000000000000000000000000000000000000000000000000000\ncalldatasize_SoccerBet: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setOfficialGameUrl(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/25/0xe2ef9698900e7deef586e335caa25b2d4f22af5b.sol", "function": "setOfficialGameUrl(string)", "lineno": 115, "title": "Integer Overflow ", "type": "Warning"}], "success": true}