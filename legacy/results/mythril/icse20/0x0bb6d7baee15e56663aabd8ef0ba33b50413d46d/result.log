{"error": null, "issues": [{"address": 380, "code": "if name was actually given */\n        require(name.length != 0);\n        \n        /*check if approvals num equals or greater than given owners num*/\n        require(approvals <= owners.length);\n        \n        /* check if wallets with given name already exists */\n        bool found;\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\n            if (wallets[msg.sender][i].name == name){\n                found = true;\n            }\n        }\n        require (found == false);\n        \n        /*instantiate new wallet*/\n        uint currentLen = wallets[msg.sender].length++;\n        wallets[msg.sender][currentLen].name = name;\n        wallets[msg.sender][currentLen].creator = msg.sender;\n        wallets[msg.sender][currentLen].id = currentLen;\n        wallets[msg.sender][currentLen].allowance = msg.value;\n        wallets[msg.sender][currentLen].owners = owners;\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\n        emit WalletCreated(currentLen);\n    }\n\n    function topBalance(address creator, uint id) external payable {\n        require (msg.value > 0 wei);\n        wallets[creator]", "debug": "calldata_ibaMultisig_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_ibaMultisig_0: 0x2026069700000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A possible integer overflow exists in the function `createWallet(uint256,address[],bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "createWallet(uint256,address[],bytes32)", "lineno": 109, "title": "Integer Overflow ", "type": "Warning"}, {"address": 386, "code": "if name was actually given */\n        require(name.length != 0);\n        \n        /*check if approvals num equals or greater than given owners num*/\n        require(approvals <= owners.length);\n        \n        /* check if wallets with given name already exists */\n        bool found;\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\n            if (wallets[msg.sender][i].name == name){\n                found = true;\n            }\n        }\n        require (found == false);\n        \n        /*instantiate new wallet*/\n        uint currentLen = wallets[msg.sender].length++;\n        wallets[msg.sender][currentLen].name = name;\n        wallets[msg.sender][currentLen].creator = msg.sender;\n        wallets[msg.sender][currentLen].id = currentLen;\n        wallets[msg.sender][currentLen].allowance = msg.value;\n        wallets[msg.sender][currentLen].owners = owners;\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\n        emit WalletCreated(currentLen);\n    }\n\n    function topBalance(address creator, uint id) external payable {\n        require (msg.value > 0 wei);\n        wallets[creator]", "debug": "calldata_ibaMultisig_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_ibaMultisig_0: 0x2026069700000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A possible integer overflow exists in the function `createWallet(uint256,address[],bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "createWallet(uint256,address[],bytes32)", "lineno": 109, "title": "Integer Overflow ", "type": "Warning"}, {"address": 802, "code": "        return wallets[creator][id].owners;\n    }\n    \n    function getTxnNum(address creator, uint id) external view returns (uint", "debug": "storage_4 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6ab7127600000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getOwners(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getOwners(address,uint256)", "lineno": 82, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1132, "code": "ress, uint, bytes, TxnStatus, address[], address){\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint){\n      ", "debug": "The exception is triggered under the following conditions:\n\nstorage_5 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x800000000000000000000000000000000000000000000000000000000000000\nstorage_3 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x10\nstorage_4 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x8000\ncalldata_ibaMultisig_32 + 36: 0x0\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_6 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6b74c3d800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxn(address,uint256,uint256)", "lineno": 90, "title": "Exception state", "type": "Informational"}, {"address": 1323, "code": "ress, uint, bytes, TxnStatus, address[], address){\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint){\n      ", "debug": "storage_5 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_3 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               Concat(0,\n                      ~(~Extract(255,\n                                 1,\n                                 115792089237316195423570985008687907853269984665640564039457584007913129639935 +\n                                 256*\n                                 If(Extract(0,\n                                        0,\n                                        storage_3 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4) ==\n                                    0,\n                                    1,\n                                    0)) |\n                        ~Extract(255,\n                                 1,\n                                 storage_3 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4))))): 0x8000001f83a3f07c1000000000041ef7be4210842106f89b238211f2000a4100\nstorage_4 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_32 + 36: 0x0\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_6 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6b74c3d800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getTxn(address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxn(address,uint256,uint256)", "lineno": 90, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2011, "code": "*\n    * Methods\n    ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x1126210500000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getLog(address,uint256,uint256)", "lineno": 103, "title": "Exception state", "type": "Informational"}, {"address": 2041, "code": "*\n    * Methods\n    */\n    \n    ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\ncalldata_ibaMultisig_32 + 36: 0x0\nstorage_5 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x1126210500000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getLog(address,uint256,uint256)", "lineno": 103, "title": "Exception state", "type": "Informational"}, {"address": 3319, "code": "  * Constructor\n    */\n    function ibaMulti", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x353e65e900000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "_function_0x353e65e9", "lineno": 64, "title": "Exception state", "type": "Informational"}, {"address": 3484, "code": "ions.length;\n    }\n ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x3f13d33900000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxnNum(address,uint256)", "lineno": 87, "title": "Exception state", "type": "Informational"}, {"address": 3698, "code": "int id) external vie", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x6ab7127600000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getOwners(address,uint256)", "lineno": 85, "title": "Exception state", "type": "Informational"}, {"address": 3756, "code": "ator, uint id) external view retur", "debug": "storage_4 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6ab7127600000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getOwners(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getOwners(address,uint256)", "lineno": 85, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3758, "code": "ator, uint id) external view retur", "debug": "storage_4 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6ab7127600000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getOwners(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getOwners(address,uint256)", "lineno": 85, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3949, "code": "h;i++){\n            if (wa", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x6abf31eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "confirmTransaction(address,uint256,uint256)", "lineno": 40, "title": "Exception state", "type": "Informational"}, {"address": 4308, "code": ";i++){\n            if (tx", "debug": "The exception is triggered under the following conditions:\n\nstorage_4 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_32 + 4: 0x0\ncalldata_ibaMultisig_32 + 36: 0x0\nstorage_6 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncaller: 0x0\nstorage_keccac_4_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4 +\n0: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6abf31eb00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "confirmTransaction(address,uint256,uint256)", "lineno": 163, "title": "Exception state", "type": "Informational"}, {"address": 4818, "code": "value, txn.data, txn.statu", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x6b74c3d800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxn(address,uint256,uint256)", "lineno": 92, "title": "Exception state", "type": "Informational"}, {"address": 4848, "code": "value, txn.data, txn.status, txn.confirmed,", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\ncalldata_ibaMultisig_32 + 36: 0x0\nstorage_6 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6b74c3d800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxn(address,uint256,uint256)", "lineno": 92, "title": "Exception state", "type": "Informational"}, {"address": 5172, "code": "r);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint)", "debug": "storage_5 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x800001f0842ba1ef7be0000000007c5d201c7813e45f105c1c9364d54b80000\nstorage_3 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x20\ncalldata_ibaMultisig_32 + 36: 0x0\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_6 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6b74c3d800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getTxn(address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxn(address,uint256,uint256)", "lineno": 92, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5174, "code": "r);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint)", "debug": "storage_5 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3 +\n7*calldata_ibaMultisig_32 + 36 +\nkeccac_6_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x20\ncalldata_ibaMultisig_32 + 36: 0x0\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_6 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6b74c3d800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getTxn(address,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getTxn(address,uint256,uint256)", "lineno": 92, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5386, "code": ".length++;\n        w", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_0: 0x6dd35c7b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "topBalance(address,uint256)", "lineno": 140, "title": "Exception state", "type": "Informational"}, {"address": 5410, "code": ".length++;\n        wallets[creator][id].log", "debug": "callvalue: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\nstorage_3 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncalldata_ibaMultisig_0: 0x6dd35c7b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A possible integer overflow exists in the function `topBalance(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "topBalance(address,uint256)", "lineno": 140, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5517, "code": ".sender = msg.sender;\n        emit", "debug": "storage_5 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_0: 0x6dd35c7b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A possible integer overflow exists in the function `topBalance(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "topBalance(address,uint256)", "lineno": 142, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5634, "code": "ce(msg.value);\n    }\n    \n    fun", "debug": "The exception is triggered under the following conditions:\n\nstorage_5 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_5_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffe000000000\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_0: 0x6dd35c7b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "topBalance(address,uint256)", "lineno": 143, "title": "Exception state", "type": "Informational"}, {"address": 5977, "code": " logId) external vie", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x8bcddd5d00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "getLogsNum(address,uint256)", "lineno": 99, "title": "Exception state", "type": "Informational"}, {"address": 6318, "code": "h;i++){\n            if (wa", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 36: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0xcf8c9cc800000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "submitTransaction(address,address,uint256,uint256,bytes)", "lineno": 40, "title": "Exception state", "type": "Informational"}, {"address": 7613, "code": "h;i++){\n            if (wa", "debug": "The exception is triggered under the following conditions:\n\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0xe5583c5900000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "executeTxn(address,uint256,uint256)", "lineno": 40, "title": "Exception state", "type": "Informational"}, {"address": 8561, "code": "ontract ibaMultisig {\n\n    /*\n    * Types\n    */\n    struct Transaction {\n        uint id;\n        address destination;\n        uint value;\n        bytes data;\n        TxnStatus status;\n        address[] confirmed;\n        address creator;\n    }\n\n    struct Wallet {\n        bytes32 name;\n        address creator;\n        uint id;\n        uint allowance;\n        address[] owners;\n        Log[] logs;\n        Transaction[] transactions;\n        uint appovalsreq;\n    }\n    \n    struct Log {\n        uint amount;\n        address sender;\n    }\n    \n    enum TxnStatus { Unconfirmed, Pending, Executed }\n    \n    /*\n    * Modifiers\n    */\n    modifier onlyOwner ( address creator, uint walletId ) {\n        bool found;\n        for (uint i = 0;i<wallets[creator][walletId].owners.length;i++){\n            if (wallets[creator][walletId].owners[i] == msg.sender){\n                found = true;\n            }\n        }\n        if (found){\n            _;\n        }\n    }\n    \n    /*\n    * Events\n    */\n    event WalletCreated(uint id);\n    event TxnSumbitted(uint id);\n    event TxnConfirmed(uint id);\n    event topUpBalance(uint value);\n\n    /*\n    * Storage\n    */\n    mapping (address => Wallet[]) public wallets;\n    \n    /*\n    * Constructor\n    */\n    function ibaMultisig() public{\n\n    }\n\n    /*\n    * Getters\n    */\n    function getWalletId(address creator, bytes32 name) external view returns (uint, bool){\n        for (uint i = 0;i<wallets[creator].length;i++){\n            if (wallets[creator][i].name == name){\n                return (i, true);\n            }\n        }\n    }\n\n    function getOwners(address creator, uint id) external view returns (address[]){\n        return wallets[creator][id].owners;\n    }\n    \n    function getTxnNum(address creator, uint id) external view returns (uint){\n        require(wallets[creator][id].owners.length > 0);\n        return wallets[creator][id].transactions.length;\n    }\n    \n    function getTxn(address creator, uint walletId, uint id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint){\n        return wallets[creator][id].logs.length;\n    }\n    \n    function getLog(address creator, uint id, uint logId) external view returns (address, uint){\n        return(wallets[creator][id].logs[logId].sender, wallets[creator][id].logs[logId].amount);\n    }\n    \n    /*\n    * Methods\n    */\n    \n    function createWallet(uint approvals, address[] owners, bytes32 name) external payable{\n\n        /* check if name was actually given */\n        require(name.length != 0);\n        \n        /*check if approvals num equals or greater than given owners num*/\n        require(approvals <= owners.length);\n        \n        /* check if wallets with given name already exists */\n        bool found;\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\n            if (wallets[msg.sender][i].name == name){\n                found = true;\n            }\n        }\n        require (found == false);\n        \n        /*instantiate new wallet*/\n        uint currentLen = wallets[msg.sender].length++;\n        wallets[msg.sender][currentLen].name = name;\n        wallets[msg.sender][currentLen].creator = msg.sender;\n        wallets[msg.sender][currentLen].id = currentLen;\n        wallets[msg.sender][currentLen].allowance = msg.value;\n        wallets[msg.sender][currentLen].owners = owners;\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\n        emit WalletCreated(currentLen);\n    }\n\n    function topBalance(address creator, uint id) external payable {\n        require (msg.value > 0 wei);\n        wallets[creator][id].allowance += msg.value;\n        \n        /* create new log entry */\n        uint loglen = wallets[creator][id].logs.length++;\n        wallets[creator][id].logs[loglen].amount = msg.value;\n        wallets[creator][id].logs[loglen].sender = msg.sender;\n        emit topUpBalance(msg.value);\n    }\n    \n    function submitTransaction(address creator, address destination, uint walletId, uint value, bytes data) onlyOwner (creator,walletId) external returns (bool) {\n        uint newTxId = wallets[creator][walletId].transactions.length++;\n        wallets[creator][walletId].transactions[newTxId].id = newTxId;\n        wallets[creator][walletId].transactions[newTxId].destination = destination;\n        wallets[creator][walletId].transactions[newTxId].value = value;\n        wallets[creator][walletId].transactions[newTxId].data = data;\n        wallets[creator][walletId].transactions[newTxId].creator = msg.sender;\n        emit TxnSumbitted(newTxId);\n        return true;\n    }\n\n    function confirmTransaction(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        Transaction storage txn = wallet.transactions[txId];\n\n        //check whether this owner has already confirmed this txn\n        bool f;\n        for (uint8 i = 0; i<txn.confirmed.length;i++){\n            if (txn.confirmed[i] == msg.sender){\n                f = true;\n            }\n        }\n        //push sender address into confirmed array if haven't found\n        require(!f);\n        txn.confirmed.push(msg.sender);\n        \n        if (txn.confirmed.length == wallet.appovalsreq){\n            txn.status = TxnStatus.Pending;\n        }\n        \n        //fire event\n        emit TxnConfirmed(txId);\n        \n        return true;\n    }\n    \n    function executeTxn(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        \n        Transaction storage txn = wallet.transactions[txId];\n        \n        /* check txn status */\n        require(txn.status == TxnStatus.Pending);\n        \n        /* check whether wallet has sufficient balance to send this transaction */\n        require(wallet.allowance >= txn.value);\n        \n        /* send transaction */\n        address dest = txn.destination;\n        uint val = txn.value;\n        bytes memory dat = txn.data;\n        assert(dest.call.value(val)(dat));\n            \n        /* change transaction's status to executed */\n        txn.status = TxnStatus.Executed;\n\n        /* change wallet's balance */\n        wallet.allowance = wallet.allowance - txn.value;\n\n        return true;\n        \n    }\n}", "debug": "storage_4 +\n8*\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nkeccac_4_+\n8*\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_ibaMultisig_4 + calldata_ibaMultisig_32 + 4: 0x0\ncalldata_ibaMultisig_4: 0x0\ncalldata_ibaMultisig_0: 0x2026069700000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `createWallet(uint256,address[],bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "createWallet(uint256,address[],bytes32)", "lineno": 2, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8572, "code": "ontract ibaMultisig {\n\n    /*\n    * Types\n    */\n    struct Transaction {\n        uint id;\n        address destination;\n        uint value;\n        bytes data;\n        TxnStatus status;\n        address[] confirmed;\n        address creator;\n    }\n\n    struct Wallet {\n        bytes32 name;\n        address creator;\n        uint id;\n        uint allowance;\n        address[] owners;\n        Log[] logs;\n        Transaction[] transactions;\n        uint appovalsreq;\n    }\n    \n    struct Log {\n        uint amount;\n        address sender;\n    }\n    \n    enum TxnStatus { Unconfirmed, Pending, Executed }\n    \n    /*\n    * Modifiers\n    */\n    modifier onlyOwner ( address creator, uint walletId ) {\n        bool found;\n        for (uint i = 0;i<wallets[creator][walletId].owners.length;i++){\n            if (wallets[creator][walletId].owners[i] == msg.sender){\n                found = true;\n            }\n        }\n        if (found){\n            _;\n        }\n    }\n    \n    /*\n    * Events\n    */\n    event WalletCreated(uint id);\n    event TxnSumbitted(uint id);\n    event TxnConfirmed(uint id);\n    event topUpBalance(uint value);\n\n    /*\n    * Storage\n    */\n    mapping (address => Wallet[]) public wallets;\n    \n    /*\n    * Constructor\n    */\n    function ibaMultisig() public{\n\n    }\n\n    /*\n    * Getters\n    */\n    function getWalletId(address creator, bytes32 name) external view returns (uint, bool){\n        for (uint i = 0;i<wallets[creator].length;i++){\n            if (wallets[creator][i].name == name){\n                return (i, true);\n            }\n        }\n    }\n\n    function getOwners(address creator, uint id) external view returns (address[]){\n        return wallets[creator][id].owners;\n    }\n    \n    function getTxnNum(address creator, uint id) external view returns (uint){\n        require(wallets[creator][id].owners.length > 0);\n        return wallets[creator][id].transactions.length;\n    }\n    \n    function getTxn(address creator, uint walletId, uint id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint){\n        return wallets[creator][id].logs.length;\n    }\n    \n    function getLog(address creator, uint id, uint logId) external view returns (address, uint){\n        return(wallets[creator][id].logs[logId].sender, wallets[creator][id].logs[logId].amount);\n    }\n    \n    /*\n    * Methods\n    */\n    \n    function createWallet(uint approvals, address[] owners, bytes32 name) external payable{\n\n        /* check if name was actually given */\n        require(name.length != 0);\n        \n        /*check if approvals num equals or greater than given owners num*/\n        require(approvals <= owners.length);\n        \n        /* check if wallets with given name already exists */\n        bool found;\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\n            if (wallets[msg.sender][i].name == name){\n                found = true;\n            }\n        }\n        require (found == false);\n        \n        /*instantiate new wallet*/\n        uint currentLen = wallets[msg.sender].length++;\n        wallets[msg.sender][currentLen].name = name;\n        wallets[msg.sender][currentLen].creator = msg.sender;\n        wallets[msg.sender][currentLen].id = currentLen;\n        wallets[msg.sender][currentLen].allowance = msg.value;\n        wallets[msg.sender][currentLen].owners = owners;\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\n        emit WalletCreated(currentLen);\n    }\n\n    function topBalance(address creator, uint id) external payable {\n        require (msg.value > 0 wei);\n        wallets[creator][id].allowance += msg.value;\n        \n        /* create new log entry */\n        uint loglen = wallets[creator][id].logs.length++;\n        wallets[creator][id].logs[loglen].amount = msg.value;\n        wallets[creator][id].logs[loglen].sender = msg.sender;\n        emit topUpBalance(msg.value);\n    }\n    \n    function submitTransaction(address creator, address destination, uint walletId, uint value, bytes data) onlyOwner (creator,walletId) external returns (bool) {\n        uint newTxId = wallets[creator][walletId].transactions.length++;\n        wallets[creator][walletId].transactions[newTxId].id = newTxId;\n        wallets[creator][walletId].transactions[newTxId].destination = destination;\n        wallets[creator][walletId].transactions[newTxId].value = value;\n        wallets[creator][walletId].transactions[newTxId].data = data;\n        wallets[creator][walletId].transactions[newTxId].creator = msg.sender;\n        emit TxnSumbitted(newTxId);\n        return true;\n    }\n\n    function confirmTransaction(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        Transaction storage txn = wallet.transactions[txId];\n\n        //check whether this owner has already confirmed this txn\n        bool f;\n        for (uint8 i = 0; i<txn.confirmed.length;i++){\n            if (txn.confirmed[i] == msg.sender){\n                f = true;\n            }\n        }\n        //push sender address into confirmed array if haven't found\n        require(!f);\n        txn.confirmed.push(msg.sender);\n        \n        if (txn.confirmed.length == wallet.appovalsreq){\n            txn.status = TxnStatus.Pending;\n        }\n        \n        //fire event\n        emit TxnConfirmed(txId);\n        \n        return true;\n    }\n    \n    function executeTxn(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        \n        Transaction storage txn = wallet.transactions[txId];\n        \n        /* check txn status */\n        require(txn.status == TxnStatus.Pending);\n        \n        /* check whether wallet has sufficient balance to send this transaction */\n        require(wallet.allowance >= txn.value);\n        \n        /* send transaction */\n        address dest = txn.destination;\n        uint val = txn.value;\n        bytes memory dat = txn.data;\n        assert(dest.call.value(val)(dat));\n            \n        /* change transaction's status to executed */\n        txn.status = TxnStatus.Executed;\n\n        /* change wallet's balance */\n        wallet.allowance = wallet.allowance - txn.value;\n\n        return true;\n        \n    }\n}", "debug": "calldata_ibaMultisig_4 + calldata_ibaMultisig_32 + 4: 0x842100f10841c1f100060141c4210842000000000374837c000042022e8001f\ncalldata_ibaMultisig_4: 0x842100f10841c1f100060141c4210842000000000374837c000042022e8001f\ncalldata_ibaMultisig_0: 0x2026069700000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `createWallet(uint256,address[],bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "createWallet(uint256,address[],bytes32)", "lineno": 2, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8574, "code": "ontract ibaMultisig {\n\n    /*\n    * Types\n    */\n    struct Transaction {\n        uint id;\n        address destination;\n        uint value;\n        bytes data;\n        TxnStatus status;\n        address[] confirmed;\n        address creator;\n    }\n\n    struct Wallet {\n        bytes32 name;\n        address creator;\n        uint id;\n        uint allowance;\n        address[] owners;\n        Log[] logs;\n        Transaction[] transactions;\n        uint appovalsreq;\n    }\n    \n    struct Log {\n        uint amount;\n        address sender;\n    }\n    \n    enum TxnStatus { Unconfirmed, Pending, Executed }\n    \n    /*\n    * Modifiers\n    */\n    modifier onlyOwner ( address creator, uint walletId ) {\n        bool found;\n        for (uint i = 0;i<wallets[creator][walletId].owners.length;i++){\n            if (wallets[creator][walletId].owners[i] == msg.sender){\n                found = true;\n            }\n        }\n        if (found){\n            _;\n        }\n    }\n    \n    /*\n    * Events\n    */\n    event WalletCreated(uint id);\n    event TxnSumbitted(uint id);\n    event TxnConfirmed(uint id);\n    event topUpBalance(uint value);\n\n    /*\n    * Storage\n    */\n    mapping (address => Wallet[]) public wallets;\n    \n    /*\n    * Constructor\n    */\n    function ibaMultisig() public{\n\n    }\n\n    /*\n    * Getters\n    */\n    function getWalletId(address creator, bytes32 name) external view returns (uint, bool){\n        for (uint i = 0;i<wallets[creator].length;i++){\n            if (wallets[creator][i].name == name){\n                return (i, true);\n            }\n        }\n    }\n\n    function getOwners(address creator, uint id) external view returns (address[]){\n        return wallets[creator][id].owners;\n    }\n    \n    function getTxnNum(address creator, uint id) external view returns (uint){\n        require(wallets[creator][id].owners.length > 0);\n        return wallets[creator][id].transactions.length;\n    }\n    \n    function getTxn(address creator, uint walletId, uint id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint){\n        return wallets[creator][id].logs.length;\n    }\n    \n    function getLog(address creator, uint id, uint logId) external view returns (address, uint){\n        return(wallets[creator][id].logs[logId].sender, wallets[creator][id].logs[logId].amount);\n    }\n    \n    /*\n    * Methods\n    */\n    \n    function createWallet(uint approvals, address[] owners, bytes32 name) external payable{\n\n        /* check if name was actually given */\n        require(name.length != 0);\n        \n        /*check if approvals num equals or greater than given owners num*/\n        require(approvals <= owners.length);\n        \n        /* check if wallets with given name already exists */\n        bool found;\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\n            if (wallets[msg.sender][i].name == name){\n                found = true;\n            }\n        }\n        require (found == false);\n        \n        /*instantiate new wallet*/\n        uint currentLen = wallets[msg.sender].length++;\n        wallets[msg.sender][currentLen].name = name;\n        wallets[msg.sender][currentLen].creator = msg.sender;\n        wallets[msg.sender][currentLen].id = currentLen;\n        wallets[msg.sender][currentLen].allowance = msg.value;\n        wallets[msg.sender][currentLen].owners = owners;\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\n        emit WalletCreated(currentLen);\n    }\n\n    function topBalance(address creator, uint id) external payable {\n        require (msg.value > 0 wei);\n        wallets[creator][id].allowance += msg.value;\n        \n        /* create new log entry */\n        uint loglen = wallets[creator][id].logs.length++;\n        wallets[creator][id].logs[loglen].amount = msg.value;\n        wallets[creator][id].logs[loglen].sender = msg.sender;\n        emit topUpBalance(msg.value);\n    }\n    \n    function submitTransaction(address creator, address destination, uint walletId, uint value, bytes data) onlyOwner (creator,walletId) external returns (bool) {\n        uint newTxId = wallets[creator][walletId].transactions.length++;\n        wallets[creator][walletId].transactions[newTxId].id = newTxId;\n        wallets[creator][walletId].transactions[newTxId].destination = destination;\n        wallets[creator][walletId].transactions[newTxId].value = value;\n        wallets[creator][walletId].transactions[newTxId].data = data;\n        wallets[creator][walletId].transactions[newTxId].creator = msg.sender;\n        emit TxnSumbitted(newTxId);\n        return true;\n    }\n\n    function confirmTransaction(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        Transaction storage txn = wallet.transactions[txId];\n\n        //check whether this owner has already confirmed this txn\n        bool f;\n        for (uint8 i = 0; i<txn.confirmed.length;i++){\n            if (txn.confirmed[i] == msg.sender){\n                f = true;\n            }\n        }\n        //push sender address into confirmed array if haven't found\n        require(!f);\n        txn.confirmed.push(msg.sender);\n        \n        if (txn.confirmed.length == wallet.appovalsreq){\n            txn.status = TxnStatus.Pending;\n        }\n        \n        //fire event\n        emit TxnConfirmed(txId);\n        \n        return true;\n    }\n    \n    function executeTxn(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        \n        Transaction storage txn = wallet.transactions[txId];\n        \n        /* check txn status */\n        require(txn.status == TxnStatus.Pending);\n        \n        /* check whether wallet has sufficient balance to send this transaction */\n        require(wallet.allowance >= txn.value);\n        \n        /* send transaction */\n        address dest = txn.destination;\n        uint val = txn.value;\n        bytes memory dat = txn.data;\n        assert(dest.call.value(val)(dat));\n            \n        /* change transaction's status to executed */\n        txn.status = TxnStatus.Executed;\n\n        /* change wallet's balance */\n        wallet.allowance = wallet.allowance - txn.value;\n\n        return true;\n        \n    }\n}", "debug": "calldata_ibaMultisig_4 + calldata_ibaMultisig_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_32 + 4: 0x40ffffffffffffffffffffffffffffe0\ncalldata_ibaMultisig_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_0: 0x2026069700000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `createWallet(uint256,address[],bytes32)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "createWallet(uint256,address[],bytes32)", "lineno": 2, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8735, "code": "ontract ibaMultisig {\n\n    /*\n    * Types\n    */\n    struct Transaction {\n        uint id;\n        address destination;\n        uint value;\n        bytes data;\n        TxnStatus status;\n        address[] confirmed;\n        address creator;\n    }\n\n    struct Wallet {\n        bytes32 name;\n        address creator;\n        uint id;\n        uint allowance;\n        address[] owners;\n        Log[] logs;\n        Transaction[] transactions;\n        uint appovalsreq;\n    }\n    \n    struct Log {\n        uint amount;\n        address sender;\n    }\n    \n    enum TxnStatus { Unconfirmed, Pending, Executed }\n    \n    /*\n    * Modifiers\n    */\n    modifier onlyOwner ( address creator, uint walletId ) {\n        bool found;\n        for (uint i = 0;i<wallets[creator][walletId].owners.length;i++){\n            if (wallets[creator][walletId].owners[i] == msg.sender){\n                found = true;\n            }\n        }\n        if (found){\n            _;\n        }\n    }\n    \n    /*\n    * Events\n    */\n    event WalletCreated(uint id);\n    event TxnSumbitted(uint id);\n    event TxnConfirmed(uint id);\n    event topUpBalance(uint value);\n\n    /*\n    * Storage\n    */\n    mapping (address => Wallet[]) public wallets;\n    \n    /*\n    * Constructor\n    */\n    function ibaMultisig() public{\n\n    }\n\n    /*\n    * Getters\n    */\n    function getWalletId(address creator, bytes32 name) external view returns (uint, bool){\n        for (uint i = 0;i<wallets[creator].length;i++){\n            if (wallets[creator][i].name == name){\n                return (i, true);\n            }\n        }\n    }\n\n    function getOwners(address creator, uint id) external view returns (address[]){\n        return wallets[creator][id].owners;\n    }\n    \n    function getTxnNum(address creator, uint id) external view returns (uint){\n        require(wallets[creator][id].owners.length > 0);\n        return wallets[creator][id].transactions.length;\n    }\n    \n    function getTxn(address creator, uint walletId, uint id) external view returns (uint, address, uint, bytes, TxnStatus, address[], address){\n        Transaction storage txn = wallets[creator][walletId].transactions[id];\n        return (txn.id, txn.destination, txn.value, txn.data, txn.status, txn.confirmed, txn.creator);\n    }\n    \n    function getLogsNum(address creator, uint id) external view returns (uint){\n        return wallets[creator][id].logs.length;\n    }\n    \n    function getLog(address creator, uint id, uint logId) external view returns (address, uint){\n        return(wallets[creator][id].logs[logId].sender, wallets[creator][id].logs[logId].amount);\n    }\n    \n    /*\n    * Methods\n    */\n    \n    function createWallet(uint approvals, address[] owners, bytes32 name) external payable{\n\n        /* check if name was actually given */\n        require(name.length != 0);\n        \n        /*check if approvals num equals or greater than given owners num*/\n        require(approvals <= owners.length);\n        \n        /* check if wallets with given name already exists */\n        bool found;\n        for (uint i = 0; i<wallets[msg.sender].length;i++){\n            if (wallets[msg.sender][i].name == name){\n                found = true;\n            }\n        }\n        require (found == false);\n        \n        /*instantiate new wallet*/\n        uint currentLen = wallets[msg.sender].length++;\n        wallets[msg.sender][currentLen].name = name;\n        wallets[msg.sender][currentLen].creator = msg.sender;\n        wallets[msg.sender][currentLen].id = currentLen;\n        wallets[msg.sender][currentLen].allowance = msg.value;\n        wallets[msg.sender][currentLen].owners = owners;\n        wallets[msg.sender][currentLen].appovalsreq = approvals;\n        emit WalletCreated(currentLen);\n    }\n\n    function topBalance(address creator, uint id) external payable {\n        require (msg.value > 0 wei);\n        wallets[creator][id].allowance += msg.value;\n        \n        /* create new log entry */\n        uint loglen = wallets[creator][id].logs.length++;\n        wallets[creator][id].logs[loglen].amount = msg.value;\n        wallets[creator][id].logs[loglen].sender = msg.sender;\n        emit topUpBalance(msg.value);\n    }\n    \n    function submitTransaction(address creator, address destination, uint walletId, uint value, bytes data) onlyOwner (creator,walletId) external returns (bool) {\n        uint newTxId = wallets[creator][walletId].transactions.length++;\n        wallets[creator][walletId].transactions[newTxId].id = newTxId;\n        wallets[creator][walletId].transactions[newTxId].destination = destination;\n        wallets[creator][walletId].transactions[newTxId].value = value;\n        wallets[creator][walletId].transactions[newTxId].data = data;\n        wallets[creator][walletId].transactions[newTxId].creator = msg.sender;\n        emit TxnSumbitted(newTxId);\n        return true;\n    }\n\n    function confirmTransaction(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        Transaction storage txn = wallet.transactions[txId];\n\n        //check whether this owner has already confirmed this txn\n        bool f;\n        for (uint8 i = 0; i<txn.confirmed.length;i++){\n            if (txn.confirmed[i] == msg.sender){\n                f = true;\n            }\n        }\n        //push sender address into confirmed array if haven't found\n        require(!f);\n        txn.confirmed.push(msg.sender);\n        \n        if (txn.confirmed.length == wallet.appovalsreq){\n            txn.status = TxnStatus.Pending;\n        }\n        \n        //fire event\n        emit TxnConfirmed(txId);\n        \n        return true;\n    }\n    \n    function executeTxn(address creator, uint walletId, uint txId) onlyOwner(creator, walletId) external returns (bool){\n        Wallet storage wallet = wallets[creator][walletId];\n        \n        Transaction storage txn = wallet.transactions[txId];\n        \n        /* check txn status */\n        require(txn.status == TxnStatus.Pending);\n        \n        /* check whether wallet has sufficient balance to send this transaction */\n        require(wallet.allowance >= txn.value);\n        \n        /* send transaction */\n        address dest = txn.destination;\n        uint val = txn.value;\n        bytes memory dat = txn.data;\n        assert(dest.call.value(val)(dat));\n            \n        /* change transaction's status to executed */\n        txn.status = TxnStatus.Executed;\n\n        /* change wallet's balance */\n        wallet.allowance = wallet.allowance - txn.value;\n\n        return true;\n        \n    }\n}", "debug": "storage_5 +\n8*calldata_ibaMultisig_32 + 4 +\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nkeccac_5_+\n8*calldata_ibaMultisig_32_+_4_+\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x545491e000000000000000000000000000000000000000000000000000000000\ncalldata_ibaMultisig_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ibaMultisig_4: 0x1\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ibaMultisig_0: 0x6dd35c7b00000000000000000000000000000000000000000000000000000000\ncalldatasize_ibaMultisig: 0x4\n", "description": "A possible integer overflow exists in the function `topBalance(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/16/0x0bb6d7baee15e56663aabd8ef0ba33b50413d46d.sol", "function": "topBalance(address,uint256)", "lineno": 2, "title": "Integer Overflow ", "type": "Warning"}], "success": true}