{"error": null, "issues": [{"address": 1385, "debug": "SOLVER OUTPUT:\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Ethraffle_v1b_0: 0x41c0e1b500000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\ncallvalue: 0x0\n", "description": "The function `kill()` executes the SUICIDE instruction. The remaining Ether is sent to a stored address.\n\nThere is a check on storage index 0. This storage index can be written to by calling the function `Ethraffle()`.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "kill()", "lineno": 158, "title": "Unchecked SUICIDE", "type": "Warning"}, {"address": 1827, "code": ";\n\ncontract Ethraf", "debug": "storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_24465873643947496235832446106509767096567058095563226156125564318740882468607: 0x0\ncaller: 0x0\ncalldata_Ethraffle_v1b_0: 0xb2d5ae4400000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\nstorage_24465873643947496235832446106509767096567058095563226156125564318740882468608: 0x0\nstorage_1: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getRefund()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "getRefund()", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2722, "code": "(0), address(0), address(0), 0, 0);\n        ", "debug": "", "description": "A possible transaction order independence vulnerability exists in function endRaffle(). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "endRaffle()", "lineno": 140, "title": "Transaction order dependence", "type": "Warning"}, {"address": 3725, "code": "ecause buy", "debug": "storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0xb3c46e91a28000\nstorage_0: 0x0\ncalldata_Ethraffle_v1b_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\nstorage_2: 0x32\n", "description": "A possible integer overflow exists in the function `buyTickets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 103, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3794, "code": " the raffle occurs\n    functio", "debug": "", "description": "In the function `buyTickets()` the following predictable state variables are used to determine Ether recipient:\n- block.coinbase\n", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 111, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 3794, "code": " the raffle occurs\n    functio", "debug": "SOLVER OUTPUT:\ncallvalue: 0xb3c46e91a28000\nstorage_0: 0x0\ncalldata_Ethraffle_v1b_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\nstorage_2: 0x32\n", "description": "In the function `buyTickets()` a non-zero amount of Ether is sent to an address taken from storage slot 0.\nThere is a check on storage index 0. This storage slot can be written to by calling the function `Ethraffle()`.\n\nThere is a check on storage index 0. This storage slot can be written to by calling the function `Ethraffle()`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 111, "title": "Ether send", "type": "Warning"}, {"address": 3794, "code": " the raffle occurs\n    functio", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1214\nCall at address: 3905\n", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 111, "title": "Multiple Calls", "type": "Information"}, {"address": 3794, "code": " the raffle occurs\n    functio", "debug": "", "description": "A possible transaction order independence vulnerability exists in function buyTickets(). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 111, "title": "Transaction order dependence", "type": "Warning"}, {"address": 3905, "code": "() public {\n        uint", "debug": "SOLVER OUTPUT:\nretval_3794: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncallvalue: 0xb3c46e91a28000\nstorage_0: 0x0\ncalldata_Ethraffle_v1b_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\nstorage_2: 0x32\n", "description": "In the function `buyTickets()` a non-zero amount of Ether is sent to an address taken from storage slot 0.\nThere is a check on storage index 0. This storage slot can be written to by calling the function `Ethraffle()`.\n\nThere is a check on storage index 0. This storage slot can be written to by calling the function `Ethraffle()`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.\nThere is a check on storage index 2. This storage slot can be written to by calling the function `fallback`.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 112, "title": "Ether send", "type": "Warning"}, {"address": 3905, "code": "() public {\n        uint", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 1214\n", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 112, "title": "Multiple Calls", "type": "Information"}, {"address": 3905, "code": "() public {\n        uint", "debug": "", "description": "A possible transaction order independence vulnerability exists in function buyTickets(). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 112, "title": "Transaction order dependence", "type": "Warning"}, {"address": 3962, "code": "ntract Ethraffle_v1b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint indexed raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}", "debug": "storage_4: 0x7ffffffffffffffffffffffffffffffffffffffffffffffffffff9001c942e61\nstorage_2: 0x31\ncallvalue: 0xb3c46e91a28000\nstorage_0: 0x0\ncalldata_Ethraffle_v1b_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\n", "description": "A possible integer overflow exists in the function `buyTickets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3964, "code": "ntract Ethraffle_v1b {\n    struct Contestant {\n        address addr;\n        uint raffleId;\n    }\n\n    event RaffleResult(\n        uint indexed raffleId,\n        uint winningNumber,\n        address winningAddress,\n        address seed1,\n        address seed2,\n        uint seed3,\n        bytes32 randHash\n    );\n\n    event TicketPurchase(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    event TicketRefund(\n        uint indexed raffleId,\n        address contestant,\n        uint number\n    );\n\n    // Constants\n    uint public constant prize = 2.5 ether;\n    uint public constant fee = 0.03 ether;\n    uint public constant totalTickets = 50;\n    uint public constant pricePerTicket = (prize + fee) / totalTickets; // Make sure this divides evenly\n    address feeAddress;\n\n    // Other internal variables\n    bool public paused = false;\n    uint public raffleId = 1;\n    uint nextTicket = 0;\n    mapping (uint => Contestant) contestants;\n    uint[] gaps;\n\n    // Initialization\n    function Ethraffle() public {\n        feeAddress = msg.sender;\n    }\n\n    // Call buyTickets() when receiving Ether outside a function\n    function () payable public {\n        buyTickets();\n    }\n\n    function buyTickets() payable public {\n        if (paused) {\n            msg.sender.transfer(msg.value);\n            return;\n        }\n\n        uint moneySent = msg.value;\n\n        while (moneySent >= pricePerTicket && nextTicket < totalTickets) {\n            uint currTicket = 0;\n            if (gaps.length > 0) {\n                currTicket = gaps[gaps.length-1];\n                gaps.length--;\n            } else {\n                currTicket = nextTicket++;\n            }\n\n            contestants[currTicket] = Contestant(msg.sender, raffleId);\n            TicketPurchase(raffleId, msg.sender, currTicket);\n            moneySent -= pricePerTicket;\n        }\n\n        // Choose winner if we sold all the tickets\n        if (nextTicket == totalTickets) {\n            chooseWinner();\n        }\n\n        // Send back leftover money\n        if (moneySent > 0) {\n            msg.sender.transfer(moneySent);\n        }\n    }\n\n    function chooseWinner() private {\n        address seed1 = contestants[uint(block.coinbase) % totalTickets].addr;\n        address seed2 = contestants[uint(msg.sender) % totalTickets].addr;\n        uint seed3 = block.difficulty;\n        bytes32 randHash = keccak256(seed1, seed2, seed3);\n\n        uint winningNumber = uint(randHash) % totalTickets;\n        address winningAddress = contestants[winningNumber].addr;\n        RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash);\n\n        // Start next raffle\n        raffleId++;\n        nextTicket = 0;\n\n        // gaps.length = 0 isn't necessary here,\n        // because buyTickets() eventually clears\n        // the gaps array in the loop itself.\n\n        // Distribute prize and fee\n        winningAddress.transfer(prize);\n        feeAddress.transfer(fee);\n    }\n\n    // Get your money back before the raffle occurs\n    function getRefund() public {\n        uint refund = 0;\n        for (uint i = 0; i < totalTickets; i++) {\n            if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) {\n                refund += pricePerTicket;\n                contestants[i] = Contestant(address(0), 0);\n                gaps.push(i);\n                TicketRefund(raffleId, msg.sender, i);\n            }\n        }\n\n        if (refund > 0) {\n            msg.sender.transfer(refund);\n        }\n    }\n\n    // Refund everyone's money, start a new raffle, then pause it\n    function endRaffle() public {\n        if (msg.sender == feeAddress) {\n            paused = true;\n\n            for (uint i = 0; i < totalTickets; i++) {\n                if (raffleId == contestants[i].raffleId) {\n                    TicketRefund(raffleId, contestants[i].addr, i);\n                    contestants[i].addr.transfer(pricePerTicket);\n                }\n            }\n\n            RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0);\n            raffleId++;\n            nextTicket = 0;\n            gaps.length = 0;\n        }\n    }\n\n    function togglePause() public {\n        if (msg.sender == feeAddress) {\n            paused = !paused;\n        }\n    }\n\n    function kill() public {\n        if (msg.sender == feeAddress) {\n            selfdestruct(feeAddress);\n        }\n    }\n}", "debug": "storage_4: 0x7ffffffffffff7dffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_2: 0x31\ncallvalue: 0xb3c46e91a28000\nstorage_0: 0x0\ncalldata_Ethraffle_v1b_0: 0xc819982600000000000000000000000000000000000000000000000000000000\ncalldatasize_Ethraffle_v1b: 0x4\n", "description": "A possible integer overflow exists in the function `buyTickets()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/24/0xaafd4fc990ffa78ced015d77f04cc65842a3e78a.sol", "function": "buyTickets()", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}