{"error": null, "issues": [{"address": 1288, "code": "node].add(msg.value);\n    ETHtoP3Dbymasternode[masternode] = 0;\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n    p3dContract.buy.value(amt)(masternode);\n    }\n    // Sac dep\n    modifier isValidOffer()\n    {\n        require(msg.value == OFFER_SIZE);\n        _;\n    }\n    \n    modifier canPayFromVault()\n    {\n        require(playerVault[msg.sender] >= OF", "debug": "calldata_Slaughter3D_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Slaughter3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "changevanity(string,address)", "lineno": 193, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2983, "code": "de) public \n    {\n    uint256 amt = ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "contractownsthismanyP3D()", "lineno": 149, "title": "Message call to external contract", "type": "Informational"}, {"address": 3669, "code": "256)\n    {\n        return s", "debug": "", "description": "In the function `withdraw()` the following predictable state variables are used to determine Ether recipient:\n- block.number\n- block.number\n", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "withdraw()", "lineno": 294, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 4093, "code": "ontract \n            uint256 dividends", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "Expand(address)", "lineno": 160, "title": "Message call to external contract", "type": "Informational"}, {"address": 4380, "code": "      stages[num", "debug": "storage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 + keccac_storage_14_-_1: 0x200\ncalldata_Slaughter3D_0: 0x680478b100000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\ncallvalue: 0x16345785d8a0000\n", "description": "A possible integer overflow exists in the function `offerAsSacrifice(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "offerAsSacrifice(address)", "lineno": 236, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5499, "code": "  SPASM_.disburse.value(base)", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "_function_0x820776de", "lineno": 165, "title": "Message call to external contract", "type": "Informational"}, {"address": 6391, "code": "e is not ready to be finalized\n        if(stageTo", "debug": "The exception is triggered under the following conditions:\n\nstorage_14: 0x0\nstorage_13: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Slaughter3D_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "withdraw()", "lineno": 334, "title": "Exception state", "type": "Informational"}, {"address": 6458, "code": ".blocknumber) {\n            //bloc", "debug": "The exception is triggered under the following conditions:\n\nstorage_13: 0x0\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffe\nstorage_2 + keccac_storage_13: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Slaughter3D_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "withdraw()", "lineno": 340, "title": "Exception state", "type": "Informational"}, {"address": 6512, "code": "              \n            //determine s", "debug": "The exception is triggered under the following conditions:\n\nstorage_13: 0x0\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffe\nstorage_0 + keccac_storage_13: 0x200\nstorage_2 + keccac_storage_13: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Slaughter3D_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\nstorage_1 + keccac_storage_13: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "withdraw()", "lineno": 343, "title": "Exception state", "type": "Informational"}, {"address": 6523, "code": "ze.blocknumber)) %", "debug": "storage_13: 0x0\nstorage_14: 0xffffffffffffffffffffffffffffffffffffffffffffffffffeffffffffffffe\nblock_number: 0xff\nstorage_1 + keccac_storage_13: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_0 + keccac_storage_13: 0x200\nstorage_2 + keccac_storage_13: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Slaughter3D_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `withdraw()`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "withdraw()", "lineno": 345, "title": "Integer Underflow", "type": "Warning"}, {"address": 9087, "debug": "callvalue: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\nstorage_0: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\ncalldata_Slaughter3D_0: 0x4c2a0ae00000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\n", "description": "A possible integer overflow exists in the function `_function_0x04c2a0ae`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "_function_0x04c2a0ae", "lineno": 439, "title": "Integer Overflow ", "type": "Warning"}, {"address": 9173, "code": "] = true;\n        currentStage.setMN[currentStage.numberOfPl", "debug": "The exception is triggered under the following conditions:\n\nstorage_0 + keccac_1_+_storage_14_-_1: 0x200\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\nstorage_0 + keccac_storage_14_-_1: 0x200\ncalldata_Slaughter3D_0: 0x680478b100000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\ncallvalue: 0x16345785d8a0000\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "offerAsSacrifice(address)", "lineno": 311, "title": "Exception state", "type": "Informational"}, {"address": 10174, "code": " payable external;\n    function d", "debug": "storage_13: 0x0\nstorage_1 + keccac_storage_13: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_14: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_keccac_0,_256): 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffff60000\nblock_number: 0x8000000000000000000000000000000000000000000000000000000000000101\nstorage_0 + keccac_storage_13: 0x200\nstorage_2 + keccac_storage_13: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Slaughter3D_0: 0x3ccfd60b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `withdraw()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "withdraw()", "lineno": 416, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10268, "code": "r3D {\n    using SafeMath for uint;\n    struct Stage {\n        uint8 numberOfPlayers;\n        uint256 blocknumber;\n        bool finalized;\n        mapping (uint8 => address) slotXplayer;\n        mapping (address => bool) players;\n        mapping (uint8 => address) setMN;\n        \n    }\n    \n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\n    uint256 constant private P3D_SHARE = 0.005 ether;\n    \n    uint8 constant public MAX_PLAYERS_PER_STAGE = 2;\n    uint256 constant public OFFER_SIZE = 0.1 ether;\n    uint256 public Refundpot;\n    uint256 public Jackpot;// 1% of P3D divs to be allocated to the Jackpot\n    uint256 public SPASMfee;//1% of P3D divs to be shared with SPASM holders\n    mapping(address => uint256) public ETHtoP3Dbymasternode; //eth to buy P3D masternode\n    \n    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\n    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \n    uint256 public winningsPerRound = 0.185 ether;\n    \n    mapping(address => string) public Vanity;\n    mapping(address => uint256) private playerVault;\n    mapping(uint256 => Stage) public stages;\n    mapping(uint256 => address) public RefundWaitingLine;\n    mapping(uint256 => address) public Loser;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 private numberOfFinalizedStages;\n    \n    uint256 public numberOfStages;\n    \n    event JackpotWon(address indexed winner, uint256 SizeOfJackpot);\n    event SacrificeOffered(address indexed player);\n    event SacrificeChosen(address indexed sarifice);\n    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\n    event StageInvalidated(uint256 indexed stage);\n    // UI view functions\n    \n    \n    function previousstageloser()\n        public\n        view\n        returns(address)\n    {\n        return (Loser[numberOfFinalizedStages]);\n    }\n    function previousstageplayer1()\n        public\n        view\n        returns(address)\n    {\n        return (stages[numberOfFinalizedStages].slotXplayer[0]);\n    }\n    function previousstageplayer2()\n        public\n        view\n        returns(address)\n    {\n        return (stages[numberOfFinalizedStages].slotXplayer[2]);\n    }\n    function currentstageplayer1()\n        public\n        view\n        returns( address )\n    {\n        return (stages[numberOfStages].slotXplayer[0]);\n    }\n    function currentstageplayer2()\n        public\n        view\n        returns( address )\n    {\n        return (stages[numberOfStages].slotXplayer[1]);\n    }\n    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function jackpotinfo()\n        public\n        view\n        returns(uint256 SizeOfJackpot )\n    {\n        return (Jackpot);\n    }\n    function checkstatus()// true = ready to vallidate\n        public\n        view\n        returns(bool  )\n    {\n        bool check;\n        if(numberOfStages >= numberOfFinalizedStages)\n        {\n            if(!stages[numberOfFinalizedStages].finalized && stages[numberOfFinalizedStages].numberOfPlayers < MAX_PLAYERS_PER_STAGE && stages[numberOfFinalizedStages].blocknumber != 0)\n            {\n                check = true;\n            }\n        }\n        return (check);\n    }\n    \n    function nextonetogetpaid()\n        public\n        view\n        returns(address)\n    {\n        \n        return (RefundWaitingLine[NextInLine]);\n    }\n   function contractownsthismanyP3D()\n        public\n        view\n        returns(uint256)\n    {\n        \n        return (p3dContract.balanceOf(address(this)));\n    }\n    // expansion functions\n    \n    // Buy P3D by masternode \n    function Expand(address masternode) public \n    {\n    uint256 amt = ETHtoP3Dbymasternode[masternode];\n    ETHtoP3Dbymasternode[masternode] = 0;\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n    p3dContract.buy.value(amt)(masternode);\n    \n    }\n    //fetch P3D divs\n    function DivsToRefundpot ()public\n    {\n        //allocate p3d dividends to contract \n            uint256 dividends = p3dContract.myDividends(true);\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            p3dContract.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n            Refundpot = Refundpot.add(base.mul(94));\n            Jackpot = Jackpot.add(base.mul(5)); // allocation to jackpot\n            //\n    }\n    //Donate to losers\n    function DonateToLosers ()public payable\n    {\n            require(msg.value > 0);\n            Refundpot = Refundpot.add(msg.value);\n\n    }\n    // next loser payout\n    function Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n    //changevanity\n    function changevanity(string van , address masternode) public payable\n    {\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    uint256 amt = ETHtoP3Dbymasternode[masternode].add(msg.value);\n    ETHtoP3Dbymasternode[masternode] = 0;\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n    p3dContract.buy.value(amt)(masternode);\n    }\n    // Sac dep\n    modifier isValidOffer()\n    {\n        require(msg.value == OFFER_SIZE);\n        _;\n    }\n    \n    modifier canPayFromVault()\n    {\n        require(playerVault[msg.sender] >= OFFER_SIZE);\n        _;\n    }\n    \n    modifier hasEarnings()\n    {\n        require(playerVault[msg.sender] > 0);\n        _;\n    }\n    \n    modifier prepareStage()\n    {\n        //create a new stage if current has reached max amount of players\n        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n           stages[numberOfStages] = Stage(0, 0, false );\n           numberOfStages++;\n        }\n        _;\n    }\n    \n    modifier isNewToStage()\n    {\n        require(stages[numberOfStages - 1].players[msg.sender] == false);\n        _;\n    }\n    \n    constructor()\n        public\n    {\n        stages[numberOfStages] = Stage(0, 0, false);\n        numberOfStages++;\n    }\n    \n    function() external payable {}\n    \n    function offerAsSacrifice(address MN)\n        external\n        payable\n        isValidOffer\n        prepareStage\n        isNewToStage\n    {\n        acceptOffer(MN);\n        \n        //try to choose a sacrifice in an already full stage (finalize a stage)\n        tryFinalizeStage();\n    }\n    \n    function offerAsSacrificeFromVault(address MN)\n        external\n        canPayFromVault\n        prepareStage\n        isNewToStage\n    {\n        playerVault[msg.sender] -= OFFER_SIZE;\n        \n        acceptOffer(MN);\n        \n        tryFinalizeStage();\n    }\n    \n    function withdraw()\n        external\n        hasEarnings\n    {\n        tryFinalizeStage();\n        \n        uint256 amount = playerVault[msg.sender];\n        playerVault[msg.sender] = 0;\n        \n        emit EarningsWithdrawn(msg.sender, amount); \n        \n        msg.sender.transfer(amount);\n    }\n    \n    function myEarnings()\n        external\n        view\n        hasEarnings\n        returns(uint256)\n    {\n        return playerVault[msg.sender];\n    }\n    \n    function currentPlayers()\n        external\n        view\n        returns(uint256)\n    {\n        return stages[numberOfStages - 1].numberOfPlayers;\n    }\n    \n    function acceptOffer(address MN)\n        private\n    {\n        Stage storage currentStage = stages[numberOfStages - 1];\n        \n        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\n        \n        address player = msg.sender;\n        \n        //add player to current stage\n        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\n        currentStage.numberOfPlayers++;\n        currentStage.players[player] = true;\n        currentStage.setMN[currentStage.numberOfPlayers] = MN;\n        emit SacrificeOffered(player);\n        \n        //add blocknumber to current stage when the last player is added\n        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n            currentStage.blocknumber = block.number;\n        }\n        \n    }\n    \n    function tryFinalizeStage()\n        public\n    {\n        assert(numberOfStages >= numberOfFinalizedStages);\n        \n        //there are no stages to finalize\n        if(numberOfStages == numberOfFinalizedStages) {return;}\n        \n        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\n        \n        assert(!stageToFinalize.finalized);\n        \n        //stage is not ready to be finalized\n        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\n        \n        assert(stageToFinalize.blocknumber != 0);\n        \n        //check if blockhash can be determined\n        if(block.number - 256 <= stageToFinalize.blocknumber) {\n            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\n            if(block.number == stageToFinalize.blocknumber) {return;}\n                \n            //determine sacrifice\n            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\n            uint256 jackpot = uint256(blockhash(stageToFinalize.blocknumber)) % 1000;\n            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\n            Loser[numberOfFinalizedStages] = sacrifice;\n            emit SacrificeChosen(sacrifice);\n            \n            //allocate winnings to survivors\n            allocateSurvivorWinnings(sacrifice);\n            \n            //check jackpot win\n            if(jackpot == 777){\n                sacrifice.transfer(Jackpot);\n                emit JackpotWon ( sacrifice, Jackpot);\n                Jackpot = 0;\n            }\n            \n            \n            //add sacrifice to refund waiting line\n            RefundWaitingLine[NextAtLineEnd] = sacrifice;\n            NextAtLineEnd++;\n            \n            //set eth to MN for buying P3D deprecated\n            //ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[1]].add(0.005 ether);\n            //ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[2]].add(0.005 ether);\n            \n            //add 0.005 ether to Refundpot\n            Refundpot = Refundpot.add(0.005 ether);\n            //purchase p3d (using ref) \n            p3dContract.buy.value(0.005 ether)(stageToFinalize.setMN[1]);\n            p3dContract.buy.value(0.005 ether)(stageToFinalize.setMN[2]);\n            \n        } else {\n            invalidateStage(numberOfFinalizedStages);\n            \n            emit StageInvalidated(numberOfFinalizedStages);\n        }\n        //finalize stage\n        stageToFinalize.finalized = true;\n        numberOfFinalizedStages++;\n    }\n    \n    function allocateSurvivorWinnings(address sacrifice)\n        private\n    {\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\n            if(survivor != sacrifice) {\n                playerVault[survivor] += winningsPerRound;\n            }\n        }\n    }\n    \n    function invalidateStage(uint256 stageIndex)\n        private\n    {\n        Stage storage stageToInvalidate = stages[stageIndex];\n        \n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n            address player = stageToInvalidate.slotXplayer[i];\n            playerVault[player] += OFFER_SIZE;\n        }\n    }\n}\n\ninterface HourglassInterface {\n    function buy(address _playerAddress) payable external returns(uint256);\n    function withdraw() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function balanceOf(address _playerAddress) external view returns(uint256);\n}\ninterface SPASMInterface  {\n    function() payable external;\n    function disburse() external  pa", "debug": "calldata_Slaughter3D_4 + calldata_Slaughter3D_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x38d7ea4c68000\ncalldata_Slaughter3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "changevanity(string,address)", "lineno": 18, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10282, "code": "r3D {\n    using SafeMath for uint;\n    struct Stage {\n        uint8 numberOfPlayers;\n        uint256 blocknumber;\n        bool finalized;\n        mapping (uint8 => address) slotXplayer;\n        mapping (address => bool) players;\n        mapping (uint8 => address) setMN;\n        \n    }\n    \n    HourglassInterface constant p3dContract = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\n    SPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);//spielley's profit sharing payout\n    //a small part of every winners share of the sacrificed players offer is used to purchase p3d instead\n    uint256 constant private P3D_SHARE = 0.005 ether;\n    \n    uint8 constant public MAX_PLAYERS_PER_STAGE = 2;\n    uint256 constant public OFFER_SIZE = 0.1 ether;\n    uint256 public Refundpot;\n    uint256 public Jackpot;// 1% of P3D divs to be allocated to the Jackpot\n    uint256 public SPASMfee;//1% of P3D divs to be shared with SPASM holders\n    mapping(address => uint256) public ETHtoP3Dbymasternode; //eth to buy P3D masternode\n    \n    uint256 private p3dPerStage = P3D_SHARE * (MAX_PLAYERS_PER_STAGE - 1);\n    //not sacrificed players receive their offer back and also a share of the sacrificed players offer \n    uint256 public winningsPerRound = 0.185 ether;\n    \n    mapping(address => string) public Vanity;\n    mapping(address => uint256) private playerVault;\n    mapping(uint256 => Stage) public stages;\n    mapping(uint256 => address) public RefundWaitingLine;\n    mapping(uint256 => address) public Loser;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 private numberOfFinalizedStages;\n    \n    uint256 public numberOfStages;\n    \n    event JackpotWon(address indexed winner, uint256 SizeOfJackpot);\n    event SacrificeOffered(address indexed player);\n    event SacrificeChosen(address indexed sarifice);\n    event EarningsWithdrawn(address indexed player, uint256 indexed amount);\n    event StageInvalidated(uint256 indexed stage);\n    // UI view functions\n    \n    \n    function previousstageloser()\n        public\n        view\n        returns(address)\n    {\n        return (Loser[numberOfFinalizedStages]);\n    }\n    function previousstageplayer1()\n        public\n        view\n        returns(address)\n    {\n        return (stages[numberOfFinalizedStages].slotXplayer[0]);\n    }\n    function previousstageplayer2()\n        public\n        view\n        returns(address)\n    {\n        return (stages[numberOfFinalizedStages].slotXplayer[2]);\n    }\n    function currentstageplayer1()\n        public\n        view\n        returns( address )\n    {\n        return (stages[numberOfStages].slotXplayer[0]);\n    }\n    function currentstageplayer2()\n        public\n        view\n        returns( address )\n    {\n        return (stages[numberOfStages].slotXplayer[1]);\n    }\n    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function jackpotinfo()\n        public\n        view\n        returns(uint256 SizeOfJackpot )\n    {\n        return (Jackpot);\n    }\n    function checkstatus()// true = ready to vallidate\n        public\n        view\n        returns(bool  )\n    {\n        bool check;\n        if(numberOfStages >= numberOfFinalizedStages)\n        {\n            if(!stages[numberOfFinalizedStages].finalized && stages[numberOfFinalizedStages].numberOfPlayers < MAX_PLAYERS_PER_STAGE && stages[numberOfFinalizedStages].blocknumber != 0)\n            {\n                check = true;\n            }\n        }\n        return (check);\n    }\n    \n    function nextonetogetpaid()\n        public\n        view\n        returns(address)\n    {\n        \n        return (RefundWaitingLine[NextInLine]);\n    }\n   function contractownsthismanyP3D()\n        public\n        view\n        returns(uint256)\n    {\n        \n        return (p3dContract.balanceOf(address(this)));\n    }\n    // expansion functions\n    \n    // Buy P3D by masternode \n    function Expand(address masternode) public \n    {\n    uint256 amt = ETHtoP3Dbymasternode[masternode];\n    ETHtoP3Dbymasternode[masternode] = 0;\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n    p3dContract.buy.value(amt)(masternode);\n    \n    }\n    //fetch P3D divs\n    function DivsToRefundpot ()public\n    {\n        //allocate p3d dividends to contract \n            uint256 dividends = p3dContract.myDividends(true);\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            p3dContract.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n            Refundpot = Refundpot.add(base.mul(94));\n            Jackpot = Jackpot.add(base.mul(5)); // allocation to jackpot\n            //\n    }\n    //Donate to losers\n    function DonateToLosers ()public payable\n    {\n            require(msg.value > 0);\n            Refundpot = Refundpot.add(msg.value);\n\n    }\n    // next loser payout\n    function Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n    //changevanity\n    function changevanity(string van , address masternode) public payable\n    {\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    uint256 amt = ETHtoP3Dbymasternode[masternode].add(msg.value);\n    ETHtoP3Dbymasternode[masternode] = 0;\n    if(masternode == 0x0){masternode = 0x989eB9629225B8C06997eF0577CC08535fD789F9;}// raffle3d's address\n    p3dContract.buy.value(amt)(masternode);\n    }\n    // Sac dep\n    modifier isValidOffer()\n    {\n        require(msg.value == OFFER_SIZE);\n        _;\n    }\n    \n    modifier canPayFromVault()\n    {\n        require(playerVault[msg.sender] >= OFFER_SIZE);\n        _;\n    }\n    \n    modifier hasEarnings()\n    {\n        require(playerVault[msg.sender] > 0);\n        _;\n    }\n    \n    modifier prepareStage()\n    {\n        //create a new stage if current has reached max amount of players\n        if(stages[numberOfStages - 1].numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n           stages[numberOfStages] = Stage(0, 0, false );\n           numberOfStages++;\n        }\n        _;\n    }\n    \n    modifier isNewToStage()\n    {\n        require(stages[numberOfStages - 1].players[msg.sender] == false);\n        _;\n    }\n    \n    constructor()\n        public\n    {\n        stages[numberOfStages] = Stage(0, 0, false);\n        numberOfStages++;\n    }\n    \n    function() external payable {}\n    \n    function offerAsSacrifice(address MN)\n        external\n        payable\n        isValidOffer\n        prepareStage\n        isNewToStage\n    {\n        acceptOffer(MN);\n        \n        //try to choose a sacrifice in an already full stage (finalize a stage)\n        tryFinalizeStage();\n    }\n    \n    function offerAsSacrificeFromVault(address MN)\n        external\n        canPayFromVault\n        prepareStage\n        isNewToStage\n    {\n        playerVault[msg.sender] -= OFFER_SIZE;\n        \n        acceptOffer(MN);\n        \n        tryFinalizeStage();\n    }\n    \n    function withdraw()\n        external\n        hasEarnings\n    {\n        tryFinalizeStage();\n        \n        uint256 amount = playerVault[msg.sender];\n        playerVault[msg.sender] = 0;\n        \n        emit EarningsWithdrawn(msg.sender, amount); \n        \n        msg.sender.transfer(amount);\n    }\n    \n    function myEarnings()\n        external\n        view\n        hasEarnings\n        returns(uint256)\n    {\n        return playerVault[msg.sender];\n    }\n    \n    function currentPlayers()\n        external\n        view\n        returns(uint256)\n    {\n        return stages[numberOfStages - 1].numberOfPlayers;\n    }\n    \n    function acceptOffer(address MN)\n        private\n    {\n        Stage storage currentStage = stages[numberOfStages - 1];\n        \n        assert(currentStage.numberOfPlayers < MAX_PLAYERS_PER_STAGE);\n        \n        address player = msg.sender;\n        \n        //add player to current stage\n        currentStage.slotXplayer[currentStage.numberOfPlayers] = player;\n        currentStage.numberOfPlayers++;\n        currentStage.players[player] = true;\n        currentStage.setMN[currentStage.numberOfPlayers] = MN;\n        emit SacrificeOffered(player);\n        \n        //add blocknumber to current stage when the last player is added\n        if(currentStage.numberOfPlayers == MAX_PLAYERS_PER_STAGE) {\n            currentStage.blocknumber = block.number;\n        }\n        \n    }\n    \n    function tryFinalizeStage()\n        public\n    {\n        assert(numberOfStages >= numberOfFinalizedStages);\n        \n        //there are no stages to finalize\n        if(numberOfStages == numberOfFinalizedStages) {return;}\n        \n        Stage storage stageToFinalize = stages[numberOfFinalizedStages];\n        \n        assert(!stageToFinalize.finalized);\n        \n        //stage is not ready to be finalized\n        if(stageToFinalize.numberOfPlayers < MAX_PLAYERS_PER_STAGE) {return;}\n        \n        assert(stageToFinalize.blocknumber != 0);\n        \n        //check if blockhash can be determined\n        if(block.number - 256 <= stageToFinalize.blocknumber) {\n            //blocknumber of stage can not be equal to current block number -> blockhash() won't work\n            if(block.number == stageToFinalize.blocknumber) {return;}\n                \n            //determine sacrifice\n            uint8 sacrificeSlot = uint8(blockhash(stageToFinalize.blocknumber)) % MAX_PLAYERS_PER_STAGE;\n            uint256 jackpot = uint256(blockhash(stageToFinalize.blocknumber)) % 1000;\n            address sacrifice = stageToFinalize.slotXplayer[sacrificeSlot];\n            Loser[numberOfFinalizedStages] = sacrifice;\n            emit SacrificeChosen(sacrifice);\n            \n            //allocate winnings to survivors\n            allocateSurvivorWinnings(sacrifice);\n            \n            //check jackpot win\n            if(jackpot == 777){\n                sacrifice.transfer(Jackpot);\n                emit JackpotWon ( sacrifice, Jackpot);\n                Jackpot = 0;\n            }\n            \n            \n            //add sacrifice to refund waiting line\n            RefundWaitingLine[NextAtLineEnd] = sacrifice;\n            NextAtLineEnd++;\n            \n            //set eth to MN for buying P3D deprecated\n            //ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[1]].add(0.005 ether);\n            //ETHtoP3Dbymasternode[stageToFinalize.setMN[1]] = ETHtoP3Dbymasternode[stageToFinalize.setMN[2]].add(0.005 ether);\n            \n            //add 0.005 ether to Refundpot\n            Refundpot = Refundpot.add(0.005 ether);\n            //purchase p3d (using ref) \n            p3dContract.buy.value(0.005 ether)(stageToFinalize.setMN[1]);\n            p3dContract.buy.value(0.005 ether)(stageToFinalize.setMN[2]);\n            \n        } else {\n            invalidateStage(numberOfFinalizedStages);\n            \n            emit StageInvalidated(numberOfFinalizedStages);\n        }\n        //finalize stage\n        stageToFinalize.finalized = true;\n        numberOfFinalizedStages++;\n    }\n    \n    function allocateSurvivorWinnings(address sacrifice)\n        private\n    {\n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n            address survivor = stages[numberOfFinalizedStages].slotXplayer[i];\n            if(survivor != sacrifice) {\n                playerVault[survivor] += winningsPerRound;\n            }\n        }\n    }\n    \n    function invalidateStage(uint256 stageIndex)\n        private\n    {\n        Stage storage stageToInvalidate = stages[stageIndex];\n        \n        for (uint8 i = 0; i < MAX_PLAYERS_PER_STAGE; i++) {\n            address player = stageToInvalidate.slotXplayer[i];\n            playerVault[player] += OFFER_SIZE;\n        }\n    }\n}\n\ninterface HourglassInterface {\n    function buy(address _playerAddress) payable external returns(uint256);\n    function withdraw() external;\n    function myDividends(bool _includeReferralBonus) external view returns(uint256);\n    function balanceOf(address _playerAddress) external view returns(uint256);\n}\ninterface SPASMInterface  {\n    function() payable external;\n    function disburse() external  pa", "debug": "calldata_Slaughter3D_4 + calldata_Slaughter3D_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncallvalue: 0x38d7ea4c68000\ncalldata_Slaughter3D_0: 0x6b3ffb9100000000000000000000000000000000000000000000000000000000\ncalldatasize_Slaughter3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/5/0xa76daa02c1a6411c6c368f3a59f4f2257a460006.sol", "function": "changevanity(string,address)", "lineno": 18, "title": "Integer Overflow ", "type": "Warning"}], "success": true}