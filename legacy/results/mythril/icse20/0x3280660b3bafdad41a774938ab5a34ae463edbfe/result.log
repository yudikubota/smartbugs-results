{"error": null, "issues": [{"address": 526, "code": "der] = msg.value;\n      accou", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xcc79d62f75d9ec2863e911c1fd2530fbf1b6684401c3446176bdf70304dd188e\ncallvalue: 0x9979a34445a589cd7339193862b41cd6018580000b230ee1742bf32ba0d93b24\ntimestamp: 0x0\nstorage_4: 0x1\ncalldata_Auction_0: 0x5b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Auction: 0x4\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "fallback", "lineno": 65, "title": "Integer Overflow ", "type": "Warning"}, {"address": 616, "code": ";\n\n// Deploying ve", "debug": "storage_9: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ntimestamp: 0x0\nstorage_4: 0x1\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Auction_0: 0x15b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Auction: 0x4\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "fallback", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1204, "code": "creaseTimeBy;\n    }\n\n    initialPrice = f", "debug": "storage_4: 0x4000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000000000000000040000000000000000000000000000000\ncallvalue: 0xffff7fffffffffffffffffffffffffffbfffffffffffffffffffffffffffffff\nstorage_10: 0x4000000000000000000000000000000000000000000000000000000000000001\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0xff00\ntimestamp: 0x3fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_Auction: 0x3\n", "description": "A possible integer underflow exists in the function `fallback`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "fallback", "lineno": 76, "title": "Integer Underflow", "type": "Warning"}, {"address": 1216, "code": ".sender];\n    winner", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x3c979fd8f99f3477fff7ffe75fffbbddefffffddf77ffffffffffffffeffffff\ntimestamp: 0xf74ba970d8ea25b7d7fdf6ddf6d7ffc784bcbf9d3776cbcf75dad7a734bd96b9\ncallvalue: 0xc378e5ef1774cbe90008201da0ab65261990c2a228a000000000000000000000\nstorage_11: 0x778e25dc91c8e586027900d106d5801c413a3e16a7710e0805e297d406b11445\nstorage_4: 0xf74ba970d8ea25b7d7fdf6ddf6d7ffc784bcbf9d3776cbcf75dad7a734bd96ba\nstorage_10: 0x2\nstorage_2: 0x1085c8111400610000200500ab21040990c280201ffffffffffffffeffffff\nstorage_3: 0xff00\ncalldatasize_Auction: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "fallback", "lineno": 80, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2255, "code": "cription) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _", "debug": "calldata_Auction_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Auction_0: 0x90c3f38f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Auction: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setDescription(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "setDescription(string)", "lineno": 36, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3069, "code": "ender] = 0;\n  }\n\n}", "debug": "", "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "fallback", "lineno": 106, "title": "Unchecked CALL return value", "type": "Informational"}, {"address": 4246, "code": "loop it is skipped\n    ", "debug": "", "description": "In the function `finalize()` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "finalize()", "lineno": 92, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 4246, "code": "loop it is skipped\n    ", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4727\nCall at address: 4727\n", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "finalize()", "lineno": 92, "title": "Multiple Calls", "type": "Information"}, {"address": 4246, "code": "loop it is skipped\n    ", "debug": "", "description": "A possible transaction order independence vulnerability exists in function finalize(). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "finalize()", "lineno": 92, "title": "Transaction order dependence", "type": "Warning"}, {"address": 4246, "code": "loop it is skipped\n    ", "debug": "", "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "finalize()", "lineno": 92, "title": "Unchecked CALL return value", "type": "Informational"}, {"address": 4727, "code": "um.stackexchange.com/a/38642/2524\n        bid", "debug": "", "description": "In the function `finalize()` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "finalize()", "lineno": 95, "title": "Dependence on predictable environment variable", "type": "Warning"}, {"address": 4727, "code": "um.stackexchange.com/a/38642/2524\n        bid", "debug": "", "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "finalize()", "lineno": 95, "title": "Unchecked CALL return value", "type": "Informational"}, {"address": 5370, "code": "ountsList; // so we can itera", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Auction_4: 0x0\nstorage_9: 0x0\ncalldata_Auction_0: 0xcf9b3c8d00000000000000000000000000000000000000000000000000000000\ncalldatasize_Auction: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "_function_0xcf9b3c8d", "lineno": 21, "title": "Exception state", "type": "Informational"}, {"address": 5868, "code": "t Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n\n    msg.sender.send( bids[msg.sender] );\n    emit Refund(msg.sender, bids[msg.sender], now);\n    bids[msg.sender] = 0;\n  }\n\n}", "debug": "calldata_Auction_4 + calldata_Auction_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncaller: 0x0\nstorage_6: 0x0\ncalldata_Auction_0: 0x90c3f38f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Auction: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setDescription(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "setDescription(string)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5882, "code": "t Auction {\n  \n  string public description;\n  string public instructions; // will be used for delivery address or email\n  uint public price;\n  bool public initialPrice = true; // at first asking price is OK, then +25% required\n  uint public timestampEnd;\n  address public beneficiary;\n  bool public finalized = false;\n\n  address public owner;\n  address public winner;\n  mapping(address => uint) public bids;\n  address[] public accountsList; // so we can iterate: https://ethereum.stackexchange.com/questions/13167/are-there-well-solved-and-simple-storage-patterns-for-solidity\n\n  // THINK: should be (an optional) constructor parameter?\n  // For now if you want to change - simply modify the code\n  uint public increaseTimeIfBidBeforeEnd = 24 * 60 * 60; // Naming things: https://www.instagram.com/p/BSa_O5zjh8X/\n  uint public increaseTimeBy = 24 * 60 * 60;\n  \n\n  event Bid(address indexed winner, uint indexed price, uint indexed timestamp);\n  event Refund(address indexed sender, uint indexed amount, uint indexed timestamp);\n  \n  modifier onlyOwner { require(owner == msg.sender, \"only owner\"); _; }\n  modifier onlyWinner { require(winner == msg.sender, \"only winner\"); _; }\n  modifier ended { require(now > timestampEnd, \"not ended yet\"); _; }\n\n  function setDescription(string _description) public onlyOwner() {\n    description = _description;\n  }\n\n  function setInstructions(string _instructions) public ended() onlyWinner()  {\n    instructions = _instructions;\n  }\n\n  constructor(uint _price, string _description, uint _timestampEnd, address _beneficiary) public {\n    require(_timestampEnd > now, \"end of the auction must be in the future\");\n    owner = msg.sender;\n    price = _price;\n    description = _description;\n    timestampEnd = _timestampEnd;\n    beneficiary = _beneficiary;\n  }\n\n  function() public payable {\n\n    if (msg.value == 0) { // when sending `0` it acts as if it was `withdraw`\n      refund();\n      return;\n    }\n\n    require(now < timestampEnd, \"auction has ended\"); // sending ether only allowed before the end\n\n    if (bids[msg.sender] > 0) { // First we add the bid to an existing bid\n      bids[msg.sender] += msg.value;\n    } else {\n      bids[msg.sender] = msg.value;\n      accountsList.push(msg.sender); // this is out first bid, therefore adding \n    }\n\n    if (initialPrice) {\n      require(bids[msg.sender] >= price, \"bid too low, minimum is the initial price\");\n    } else {\n      require(bids[msg.sender] >= (price * 5 / 4), \"bid too low, minimum 25% increment\");\n    }\n    \n    if (now > timestampEnd - increaseTimeIfBidBeforeEnd) {\n      timestampEnd = now + increaseTimeBy;\n    }\n\n    initialPrice = false;\n    price = bids[msg.sender];\n    winner = msg.sender;\n    emit Bid(winner, price, now);\n  }\n\n  function finalize() public ended() onlyOwner() {\n    require(finalized == false, \"can withdraw only once\");\n    require(initialPrice == false, \"can withdraw only if there were bids\");\n\n    finalized = true; // THINK: DAO hack reentrancy - does it matter which order? (just in case setting it first)\n    beneficiary.send(price);\n\n    bids[winner] = 0; // setting it to zero that in the refund loop it is skipped\n    for (uint i = 0; i < accountsList.length;  i++) {\n      if (bids[accountsList[i]] > 0) {\n        accountsList[i].send( bids[accountsList[i]] ); // send? transfer? tell me baby: https://ethereum.stackexchange.com/a/38642/2524\n        bids[accountsList[i]] = 0; // in case someone calls `refund` again\n      }\n    }     \n  }\n\n  function refund() public {\n    require(msg.sender != winner, \"winner cannot refund\");\n\n    msg.sender.send( bids[msg.sender] );\n    emit Refund(msg.sender, bids[msg.sender], now);\n    bids[msg.sender] = 0;\n  }\n\n}", "debug": "calldata_Auction_4 + calldata_Auction_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncaller: 0x0\nstorage_6: 0x0\ncalldata_Auction_0: 0x90c3f38f00000000000000000000000000000000000000000000000000000000\ncalldatasize_Auction: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setDescription(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/46/0x3280660b3bafdad41a774938ab5a34ae463edbfe.sol", "function": "setDescription(string)", "lineno": 8, "title": "Integer Overflow ", "type": "Warning"}], "success": true}