{
  "contract": "0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8",
  "tool": "mythril",
  "start": 1563564301.2221398,
  "end": 1563564436.2530937,
  "duration": 135.03095388412476,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 883,
        "code": "*\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBala",
        "debug": "calldata_Solethium_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 393,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 889,
        "code": "*\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBala",
        "debug": "calldata_Solethium_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffdc\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 393,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 3366,
        "code": " private nextPrice",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Solethium_32 + 4: 0x0\nstorage_1: 0x0\ncalldata_Solethium_0: 0x95ea7b300000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "approve(address,uint256)",
        "lineno": 226,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3930,
        "code": "ce);\n            \n",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Solethium_4: 0x0\nstorage_1: 0x0\ncalldata_Solethium_0: 0x24c2362b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "buyCrySolObject(uint256)",
        "lineno": 345,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 4163,
        "code": ".sub(returnParentObjectCut(_",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0xffff\nstorage_3 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n4*calldata_Solethium_4: 0xffff00\ncallvalue: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffff0000\nstorage_1 +\n80084422859880547211683076133703299733277748156566366325829078699459944778998 +\n4*calldata_Solethium_4: 0x0\ncalldata_Solethium_4: 0xfffe\ncalldata_Solethium_0: 0x24c2362b00000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "buyCrySolObject(uint256)",
        "lineno": 353,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5247,
        "code": "ferHelper(msg.send",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Solethium_4: 0x0\nstorage_1: 0x0\ncalldata_Solethium_0: 0x6352211e00000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "ownerOf(uint256)",
        "lineno": 467,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5867,
        "code": "    function get",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0xffff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Solethium_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Solethium_0: 0x7491471000000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\nstorage_1: 0x0\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "getCrySolObjectsByOwner(address)",
        "lineno": 285,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10659,
        "code": " string name);\n    event EventSolethiumObjectBought(address oldOwner, address newOwner, uint price);\n\n    // @dev use SafeMath for the following uints\n    using SafeMath for uint256; // 1,15792E+77\n    using SafeMath for uint32; // 4294967296\n    using SafeMath for uint16; // 65536\n\n    //  @dev an object - CrySolObject ( dev expression for Solethium Object)- contains relevant attributes only\n    struct CrySolObject {\n        string name;\n        uint256 price;\n        uint256 id;\n        uint16 parentID;\n        uint16 percentWhenParent;\n        address owner;\n        uint8 specialPropertyType; // 0=NONE, 1=PARENT_UP\n        uint8 specialPropertyValue; // example: 5 meaning 0,5 %\n    }\n    \n\n    //  @dev an array of all CrySolObject objects in the game\n    CrySolObject[] public crySolObjects;\n    //  @dev integer - total number of CrySol Objects\n    uint16 public numberOfCrySolObjects;\n    //  @dev Total number of CrySol ETH worth in the game\n    uint256 public ETHOfCrySolObjects;\n\n    mapping (address => uint) public ownerCrySolObjectsCount; // for owner address, track number on tokens owned\n    mapping (address => uint) public ownerAddPercentToParent; // adding additional percents to owners of some Objects when they have PARENT objects\n    mapping (address => string) public ownerToNickname; // for owner address, track his nickname\n\n\n    /**\n    ** @dev MODIFIERS\n    **/\n    modifier onlyOwnerOf(uint _id) {\n        require(msg.sender == crySolObjects[_id].owner);\n        _;\n    } \n\n    /**\n    ** @dev NEXT PRICE CALCULATIONS\n    **/\n\n    uint256 private nextPriceTreshold1 = 0.05 ether;\n    uint256 private nextPriceTreshold2 = 0.3 ether;\n    uint256 private nextPriceTreshold3 = 1.0 ether;\n    uint256 private nextPriceTreshold4 = 5.0 ether;\n    uint256 private nextPriceTreshold5 = 10.0 ether;\n\n    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n        if (_price <= nextPriceTreshold1) {\n            return _price.mul(200).div(100);\n        } else if (_price <= nextPriceTreshold2) {\n            return _price.mul(170).div(100);\n        } else if (_price <= nextPriceTreshold3) {\n            return _price.mul(150).div(100);\n        } else if (_price <= nextPriceTreshold4) {\n            return _price.mul(140).div(100);\n        } else if (_price <= nextPriceTreshold5) {\n            return _price.mul(130).div(100);\n        } else {\n            return _price.mul(120).div(100);\n        }\n    }\n\n\n\n    /**\n    ** @dev this method is used to create CrySol Object\n    **/\n    function createCrySolObject(string _name, uint _price, uint16 _parentID, uint16 _percentWhenParent, uint8 _specialPropertyType, uint8 _specialPropertyValue) external onlyOwner() {\n        uint256 _id = crySolObjects.length;\n        crySolObjects.push(CrySolObject(_name, _price, _id, _parentID, _percentWhenParent, msg.sender, _specialPropertyType, _specialPropertyValue)) ; //insert into array\n        ownerCrySolObjectsCount[msg.sender] = ownerCrySolObjectsCount[msg.sender].add(1); // increase count for OWNER\n        numberOfCrySolObjects = (uint16)(numberOfCrySolObjects.add(1)); // increase count for Total number\n        ETHOfCrySolObjects = ETHOfCrySolObjects.add(_price); // increase total ETH worth of all tokens\n        EventSolethiumObjectCreated(_id, _name);\n\n    }\n\n    /**\n    ** @dev this method is used to GET CrySol Objects from one OWNER\n    **/\n    function getCrySolObjectsByOwner(address _owner) external view returns(uint[]) {\n        uint256 tokenCount = ownerCrySolObjectsCount[_owner];\n        if (tokenCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint[] memory result = new uint[](tokenCount);\n            uint counter = 0;\n            for (uint i = 0; i < numberOfCrySolObjects; i++) {\n            if (crySolObjects[i].owner == _owner) {\n                    result[counter] = i;\n                    counter++;\n                }\n            }\n            return result;\n        }\n    }\n\n\n    /**\n    ** @dev this method is used to GET ALL CrySol Objects in the game\n    **/\n    function getAllCrySolObjects() external view returns(uint[]) {\n        uint[] memory result = new uint[](numberOfCrySolObjects);\n        uint counter = 0;\n        for (uint i = 0; i < numberOfCrySolObjects; i++) {\n                result[counter] = i;\n                counter++;\n        }\n        return result;\n    }\n    \n    /**\n    ** @dev this method is used to calculate Developer's Cut in the game\n    **/\n    function returnDevelopersCut(uint256 _price) private view returns(uint) {\n            return _price.mul(devCutPromille).div(1000);\n    }\n\n    /**\n    ** @dev this method is used to calculate Parent Object's Owner Cut in the game\n    ** owner of PARENT objects will get : percentWhenParent % from his Objects + any additional bonuses he may have from SPECIAL trade objects\n    ** that are increasing PARENT percentage\n    **/\n    function returnParentObjectCut( CrySolObject storage _obj, uint256 _price ) private view returns(uint) {\n        uint256 _percentWhenParent = crySolObjects[_obj.parentID].percentWhenParent + (ownerAddPercentToParent[crySolObjects[_obj.parentID].owner]).div(10);\n        return _price.mul(_percentWhenParent).div(100); //_parentCut\n    }\n\n    \n     /**\n    ** @dev this method is used to TRANSFER OWNERSHIP of the CrySol Objects in the game on the BUY event\n    **/\n    function _transferOwnershipOnBuy(address _oldOwner, uint _id, address _newOwner) private {\n            // decrease count for original OWNER\n            ownerCrySolObjectsCount[_oldOwner] = ownerCrySolObjectsCount[_oldOwner].sub(1); \n\n            // new owner gets ownership\n            crySolObjects[_id].owner = _newOwner;  \n            ownerCrySolObjectsCount[_newOwner] = ownerCrySolObjectsCount[_newOwner].add(1); // increase count for the new OWNER\n\n            ETHOfCrySolObjects = ETHOfCrySolObjects.sub(crySolObjects[_id].price);\n            crySolObjects[_id].price = calculateNextPrice(crySolObjects[_id].price); // now, calculate and update next price\n            ETHOfCrySolObjects = ETHOfCrySolObjects.add(crySolObjects[_id].price);\n    }\n    \n\n\n\n    /**\n    ** @dev this method is used to BUY CrySol Objects in the game, defining what will happen with the next price\n    **/\n    function buyCrySolObject(uint _id) external payable {\n\n            CrySolObject storage _obj = crySolObjects[_id];\n            uint256 price = _obj.price;\n            address oldOwner = _obj.owner; // seller\n            address newOwner = msg.sender; // buyer\n\n            require(msg.value >= price);\n            require(msg.sender != _obj.owner); // can't buy again the same thing!\n\n            uint256 excess = msg.value.sub(price);\n            \n            // calculate if percentage will go to parent Object owner \n            crySolObjects[_obj.parentID].owner.transfer(returnParentObjectCut(_obj, price));\n\n            // Transfer payment to old owner minus the developer's cut, parent owner's cut and any special Object's cut.\n             uint256 _oldOwnerCut = 0;\n            _oldOwnerCut = price.sub(returnDevelopersCut(price));\n            _oldOwnerCut = _oldOwnerCut.sub(returnParentObjectCut(_obj, price));\n            oldOwner.transfer(_oldOwnerCut);\n\n            // if there was excess in payment, return that to newOwner buying Object!\n            if (excess > 0) {\n                newOwner.transfer(excess);\n            }\n\n            //if the sell object has special property, we have to update ownerAddPercentToParent for owners addresses\n            // 0=NONE, 1=PARENT_UP\n            if (_obj.specialPropertyType == 1) {\n                if (oldOwner != ownerAddress) {\n                    ownerAddPercentToParent[oldOwner] = ownerAddPercentToParent[oldOwner].sub(_obj.specialPropertyValue);\n                }\n                ownerAddPercentToParent[newOwner] = ownerAddPercentToParent[newOwner].add(_obj.specialPropertyValue);\n            } \n\n            _transferOwnershipOnBuy(oldOwner, _id, newOwner);\n            \n            // fire event\n            EventSolethiumObjectBought(oldOwner, newOwner, price);\n\n    }\n\n\n    /**\n    ** @dev this method is used to SET user's nickname\n    **/\n    function setOwnerNickName(address _owner, string _nickName) external {\n        require(msg.sender == _owner);\n        ownerToNickname[_owner] = _nickName; // set nickname\n    }\n\n    /**\n    ** @dev this method is used to GET user's nickname\n    **/\n    function getOwnerNickName(address _owner) external view returns(string) {\n        return ownerToNickname[_owner];\n    }\n\n    /**\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBalance() external view returns(uint) {\n        return this.balance;\n    }\n    function getNumberOfCrySolObjects() external view returns(uint16) {\n        return numberOfCrySolObjects;\n    }\n\n\n    /*\n        @dev Withdraw All or part of contract balance to Contract Owner address\n    */\n    function withdrawAll() onlyOwner() public {\n        ownerAddress.transfer(this.balance);\n    }\n    function withdrawAmount(uint256 _amount) onlyOwner() public {\n        ownerAddress.transfer(_amount);\n    }\n\n\n    /**\n    ** @dev this method is used to modify parentID if needed later;\n    **      For this game it is very important to keep intended hierarchy; you never know WHEN exactly transaction will be confirmed in the blockchain\n    **      Every Object creation is transaction; if by some accident Objects get \"wrong\" ID in the crySolObjects array, this is the method where we can adjust parentId\n    **      for objects orbiting it (we don't want for Moon to end up orbiting Mars :) )\n    **/\n    function setParentID (uint _crySolObjectID, uint16 _parentID) external onlyOwner() {\n        crySolObjects[_crySolObjectID].parentID = _parentID;\n    }\n\n\n   /**\n   **  @dev ERC-721 compliant methods;\n   ** Another contracts can simply talk to us without needing to know anything about our internal contract implementation \n   **/\n\n     mapping (uint => address) crySolObjectsApprovals;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _id);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _id);\n\n    function name() public pure returns (string _name) {\n        return \"Solethium\";\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return \"SOL\";\n    }\n\n    function totalSupply() public view returns (uint256 _totalSupply) {\n        return crySolObjects.length;\n    } \n\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\n        return ownerCrySolObjectsCount[_owner];\n    }\n\n    function ownerOf(uint256 _id) public view returns (address _owner) {\n        return crySolObjects[_id].owner;\n    }\n\n    function _transferHelper(address _from, address _to, uint256 _id) private {\n        ownerCrySolObjectsCount[_to] = ownerCrySolObjectsCount[_to].add(1);\n        ownerCrySolObjectsCount[_from] = ownerCrySolObjectsCount[_from].sub(1);\n        crySolObjects[_id].owner = _to;\n        Transfer(_from, _to, _id); // fire event\n    }\n\n      function transfer(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        _transferHelper(msg.sender, _to, _id);\n    }\n\n    function approve(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        require(msg.sender != _to);\n        crySolObjectsApprovals[_id] = _to;\n        Approval(msg.sender, _to, _id); // fire event\n    }\n\n    function takeOwnership(uint256 _id) public {\n        require(crySolObjectsApprovals[_id] == msg.sender);\n        _transferHelper(ownerOf(_id), msg.sender, _id);\n    }\n\n   \n\n\n}",
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Solethium_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Solethium_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_Solethium_4: 0x0\ncaller: 0x0\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 179,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10688,
        "code": " string name);\n    event EventSolethiumObjectBought(address oldOwner, address newOwner, uint price);\n\n    // @dev use SafeMath for the following uints\n    using SafeMath for uint256; // 1,15792E+77\n    using SafeMath for uint32; // 4294967296\n    using SafeMath for uint16; // 65536\n\n    //  @dev an object - CrySolObject ( dev expression for Solethium Object)- contains relevant attributes only\n    struct CrySolObject {\n        string name;\n        uint256 price;\n        uint256 id;\n        uint16 parentID;\n        uint16 percentWhenParent;\n        address owner;\n        uint8 specialPropertyType; // 0=NONE, 1=PARENT_UP\n        uint8 specialPropertyValue; // example: 5 meaning 0,5 %\n    }\n    \n\n    //  @dev an array of all CrySolObject objects in the game\n    CrySolObject[] public crySolObjects;\n    //  @dev integer - total number of CrySol Objects\n    uint16 public numberOfCrySolObjects;\n    //  @dev Total number of CrySol ETH worth in the game\n    uint256 public ETHOfCrySolObjects;\n\n    mapping (address => uint) public ownerCrySolObjectsCount; // for owner address, track number on tokens owned\n    mapping (address => uint) public ownerAddPercentToParent; // adding additional percents to owners of some Objects when they have PARENT objects\n    mapping (address => string) public ownerToNickname; // for owner address, track his nickname\n\n\n    /**\n    ** @dev MODIFIERS\n    **/\n    modifier onlyOwnerOf(uint _id) {\n        require(msg.sender == crySolObjects[_id].owner);\n        _;\n    } \n\n    /**\n    ** @dev NEXT PRICE CALCULATIONS\n    **/\n\n    uint256 private nextPriceTreshold1 = 0.05 ether;\n    uint256 private nextPriceTreshold2 = 0.3 ether;\n    uint256 private nextPriceTreshold3 = 1.0 ether;\n    uint256 private nextPriceTreshold4 = 5.0 ether;\n    uint256 private nextPriceTreshold5 = 10.0 ether;\n\n    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n        if (_price <= nextPriceTreshold1) {\n            return _price.mul(200).div(100);\n        } else if (_price <= nextPriceTreshold2) {\n            return _price.mul(170).div(100);\n        } else if (_price <= nextPriceTreshold3) {\n            return _price.mul(150).div(100);\n        } else if (_price <= nextPriceTreshold4) {\n            return _price.mul(140).div(100);\n        } else if (_price <= nextPriceTreshold5) {\n            return _price.mul(130).div(100);\n        } else {\n            return _price.mul(120).div(100);\n        }\n    }\n\n\n\n    /**\n    ** @dev this method is used to create CrySol Object\n    **/\n    function createCrySolObject(string _name, uint _price, uint16 _parentID, uint16 _percentWhenParent, uint8 _specialPropertyType, uint8 _specialPropertyValue) external onlyOwner() {\n        uint256 _id = crySolObjects.length;\n        crySolObjects.push(CrySolObject(_name, _price, _id, _parentID, _percentWhenParent, msg.sender, _specialPropertyType, _specialPropertyValue)) ; //insert into array\n        ownerCrySolObjectsCount[msg.sender] = ownerCrySolObjectsCount[msg.sender].add(1); // increase count for OWNER\n        numberOfCrySolObjects = (uint16)(numberOfCrySolObjects.add(1)); // increase count for Total number\n        ETHOfCrySolObjects = ETHOfCrySolObjects.add(_price); // increase total ETH worth of all tokens\n        EventSolethiumObjectCreated(_id, _name);\n\n    }\n\n    /**\n    ** @dev this method is used to GET CrySol Objects from one OWNER\n    **/\n    function getCrySolObjectsByOwner(address _owner) external view returns(uint[]) {\n        uint256 tokenCount = ownerCrySolObjectsCount[_owner];\n        if (tokenCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint[] memory result = new uint[](tokenCount);\n            uint counter = 0;\n            for (uint i = 0; i < numberOfCrySolObjects; i++) {\n            if (crySolObjects[i].owner == _owner) {\n                    result[counter] = i;\n                    counter++;\n                }\n            }\n            return result;\n        }\n    }\n\n\n    /**\n    ** @dev this method is used to GET ALL CrySol Objects in the game\n    **/\n    function getAllCrySolObjects() external view returns(uint[]) {\n        uint[] memory result = new uint[](numberOfCrySolObjects);\n        uint counter = 0;\n        for (uint i = 0; i < numberOfCrySolObjects; i++) {\n                result[counter] = i;\n                counter++;\n        }\n        return result;\n    }\n    \n    /**\n    ** @dev this method is used to calculate Developer's Cut in the game\n    **/\n    function returnDevelopersCut(uint256 _price) private view returns(uint) {\n            return _price.mul(devCutPromille).div(1000);\n    }\n\n    /**\n    ** @dev this method is used to calculate Parent Object's Owner Cut in the game\n    ** owner of PARENT objects will get : percentWhenParent % from his Objects + any additional bonuses he may have from SPECIAL trade objects\n    ** that are increasing PARENT percentage\n    **/\n    function returnParentObjectCut( CrySolObject storage _obj, uint256 _price ) private view returns(uint) {\n        uint256 _percentWhenParent = crySolObjects[_obj.parentID].percentWhenParent + (ownerAddPercentToParent[crySolObjects[_obj.parentID].owner]).div(10);\n        return _price.mul(_percentWhenParent).div(100); //_parentCut\n    }\n\n    \n     /**\n    ** @dev this method is used to TRANSFER OWNERSHIP of the CrySol Objects in the game on the BUY event\n    **/\n    function _transferOwnershipOnBuy(address _oldOwner, uint _id, address _newOwner) private {\n            // decrease count for original OWNER\n            ownerCrySolObjectsCount[_oldOwner] = ownerCrySolObjectsCount[_oldOwner].sub(1); \n\n            // new owner gets ownership\n            crySolObjects[_id].owner = _newOwner;  \n            ownerCrySolObjectsCount[_newOwner] = ownerCrySolObjectsCount[_newOwner].add(1); // increase count for the new OWNER\n\n            ETHOfCrySolObjects = ETHOfCrySolObjects.sub(crySolObjects[_id].price);\n            crySolObjects[_id].price = calculateNextPrice(crySolObjects[_id].price); // now, calculate and update next price\n            ETHOfCrySolObjects = ETHOfCrySolObjects.add(crySolObjects[_id].price);\n    }\n    \n\n\n\n    /**\n    ** @dev this method is used to BUY CrySol Objects in the game, defining what will happen with the next price\n    **/\n    function buyCrySolObject(uint _id) external payable {\n\n            CrySolObject storage _obj = crySolObjects[_id];\n            uint256 price = _obj.price;\n            address oldOwner = _obj.owner; // seller\n            address newOwner = msg.sender; // buyer\n\n            require(msg.value >= price);\n            require(msg.sender != _obj.owner); // can't buy again the same thing!\n\n            uint256 excess = msg.value.sub(price);\n            \n            // calculate if percentage will go to parent Object owner \n            crySolObjects[_obj.parentID].owner.transfer(returnParentObjectCut(_obj, price));\n\n            // Transfer payment to old owner minus the developer's cut, parent owner's cut and any special Object's cut.\n             uint256 _oldOwnerCut = 0;\n            _oldOwnerCut = price.sub(returnDevelopersCut(price));\n            _oldOwnerCut = _oldOwnerCut.sub(returnParentObjectCut(_obj, price));\n            oldOwner.transfer(_oldOwnerCut);\n\n            // if there was excess in payment, return that to newOwner buying Object!\n            if (excess > 0) {\n                newOwner.transfer(excess);\n            }\n\n            //if the sell object has special property, we have to update ownerAddPercentToParent for owners addresses\n            // 0=NONE, 1=PARENT_UP\n            if (_obj.specialPropertyType == 1) {\n                if (oldOwner != ownerAddress) {\n                    ownerAddPercentToParent[oldOwner] = ownerAddPercentToParent[oldOwner].sub(_obj.specialPropertyValue);\n                }\n                ownerAddPercentToParent[newOwner] = ownerAddPercentToParent[newOwner].add(_obj.specialPropertyValue);\n            } \n\n            _transferOwnershipOnBuy(oldOwner, _id, newOwner);\n            \n            // fire event\n            EventSolethiumObjectBought(oldOwner, newOwner, price);\n\n    }\n\n\n    /**\n    ** @dev this method is used to SET user's nickname\n    **/\n    function setOwnerNickName(address _owner, string _nickName) external {\n        require(msg.sender == _owner);\n        ownerToNickname[_owner] = _nickName; // set nickname\n    }\n\n    /**\n    ** @dev this method is used to GET user's nickname\n    **/\n    function getOwnerNickName(address _owner) external view returns(string) {\n        return ownerToNickname[_owner];\n    }\n\n    /**\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBalance() external view returns(uint) {\n        return this.balance;\n    }\n    function getNumberOfCrySolObjects() external view returns(uint16) {\n        return numberOfCrySolObjects;\n    }\n\n\n    /*\n        @dev Withdraw All or part of contract balance to Contract Owner address\n    */\n    function withdrawAll() onlyOwner() public {\n        ownerAddress.transfer(this.balance);\n    }\n    function withdrawAmount(uint256 _amount) onlyOwner() public {\n        ownerAddress.transfer(_amount);\n    }\n\n\n    /**\n    ** @dev this method is used to modify parentID if needed later;\n    **      For this game it is very important to keep intended hierarchy; you never know WHEN exactly transaction will be confirmed in the blockchain\n    **      Every Object creation is transaction; if by some accident Objects get \"wrong\" ID in the crySolObjects array, this is the method where we can adjust parentId\n    **      for objects orbiting it (we don't want for Moon to end up orbiting Mars :) )\n    **/\n    function setParentID (uint _crySolObjectID, uint16 _parentID) external onlyOwner() {\n        crySolObjects[_crySolObjectID].parentID = _parentID;\n    }\n\n\n   /**\n   **  @dev ERC-721 compliant methods;\n   ** Another contracts can simply talk to us without needing to know anything about our internal contract implementation \n   **/\n\n     mapping (uint => address) crySolObjectsApprovals;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _id);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _id);\n\n    function name() public pure returns (string _name) {\n        return \"Solethium\";\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return \"SOL\";\n    }\n\n    function totalSupply() public view returns (uint256 _totalSupply) {\n        return crySolObjects.length;\n    } \n\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\n        return ownerCrySolObjectsCount[_owner];\n    }\n\n    function ownerOf(uint256 _id) public view returns (address _owner) {\n        return crySolObjects[_id].owner;\n    }\n\n    function _transferHelper(address _from, address _to, uint256 _id) private {\n        ownerCrySolObjectsCount[_to] = ownerCrySolObjectsCount[_to].add(1);\n        ownerCrySolObjectsCount[_from] = ownerCrySolObjectsCount[_from].sub(1);\n        crySolObjects[_id].owner = _to;\n        Transfer(_from, _to, _id); // fire event\n    }\n\n      function transfer(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        _transferHelper(msg.sender, _to, _id);\n    }\n\n    function approve(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        require(msg.sender != _to);\n        crySolObjectsApprovals[_id] = _to;\n        Approval(msg.sender, _to, _id); // fire event\n    }\n\n    function takeOwnership(uint256 _id) public {\n        require(crySolObjectsApprovals[_id] == msg.sender);\n        _transferHelper(ownerOf(_id), msg.sender, _id);\n    }\n\n   \n\n\n}",
        "debug": "calldata_Solethium_4 + calldata_Solethium_32 + 4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_Solethium_4: 0x0\ncaller: 0x0\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 179,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10702,
        "code": " string name);\n    event EventSolethiumObjectBought(address oldOwner, address newOwner, uint price);\n\n    // @dev use SafeMath for the following uints\n    using SafeMath for uint256; // 1,15792E+77\n    using SafeMath for uint32; // 4294967296\n    using SafeMath for uint16; // 65536\n\n    //  @dev an object - CrySolObject ( dev expression for Solethium Object)- contains relevant attributes only\n    struct CrySolObject {\n        string name;\n        uint256 price;\n        uint256 id;\n        uint16 parentID;\n        uint16 percentWhenParent;\n        address owner;\n        uint8 specialPropertyType; // 0=NONE, 1=PARENT_UP\n        uint8 specialPropertyValue; // example: 5 meaning 0,5 %\n    }\n    \n\n    //  @dev an array of all CrySolObject objects in the game\n    CrySolObject[] public crySolObjects;\n    //  @dev integer - total number of CrySol Objects\n    uint16 public numberOfCrySolObjects;\n    //  @dev Total number of CrySol ETH worth in the game\n    uint256 public ETHOfCrySolObjects;\n\n    mapping (address => uint) public ownerCrySolObjectsCount; // for owner address, track number on tokens owned\n    mapping (address => uint) public ownerAddPercentToParent; // adding additional percents to owners of some Objects when they have PARENT objects\n    mapping (address => string) public ownerToNickname; // for owner address, track his nickname\n\n\n    /**\n    ** @dev MODIFIERS\n    **/\n    modifier onlyOwnerOf(uint _id) {\n        require(msg.sender == crySolObjects[_id].owner);\n        _;\n    } \n\n    /**\n    ** @dev NEXT PRICE CALCULATIONS\n    **/\n\n    uint256 private nextPriceTreshold1 = 0.05 ether;\n    uint256 private nextPriceTreshold2 = 0.3 ether;\n    uint256 private nextPriceTreshold3 = 1.0 ether;\n    uint256 private nextPriceTreshold4 = 5.0 ether;\n    uint256 private nextPriceTreshold5 = 10.0 ether;\n\n    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n        if (_price <= nextPriceTreshold1) {\n            return _price.mul(200).div(100);\n        } else if (_price <= nextPriceTreshold2) {\n            return _price.mul(170).div(100);\n        } else if (_price <= nextPriceTreshold3) {\n            return _price.mul(150).div(100);\n        } else if (_price <= nextPriceTreshold4) {\n            return _price.mul(140).div(100);\n        } else if (_price <= nextPriceTreshold5) {\n            return _price.mul(130).div(100);\n        } else {\n            return _price.mul(120).div(100);\n        }\n    }\n\n\n\n    /**\n    ** @dev this method is used to create CrySol Object\n    **/\n    function createCrySolObject(string _name, uint _price, uint16 _parentID, uint16 _percentWhenParent, uint8 _specialPropertyType, uint8 _specialPropertyValue) external onlyOwner() {\n        uint256 _id = crySolObjects.length;\n        crySolObjects.push(CrySolObject(_name, _price, _id, _parentID, _percentWhenParent, msg.sender, _specialPropertyType, _specialPropertyValue)) ; //insert into array\n        ownerCrySolObjectsCount[msg.sender] = ownerCrySolObjectsCount[msg.sender].add(1); // increase count for OWNER\n        numberOfCrySolObjects = (uint16)(numberOfCrySolObjects.add(1)); // increase count for Total number\n        ETHOfCrySolObjects = ETHOfCrySolObjects.add(_price); // increase total ETH worth of all tokens\n        EventSolethiumObjectCreated(_id, _name);\n\n    }\n\n    /**\n    ** @dev this method is used to GET CrySol Objects from one OWNER\n    **/\n    function getCrySolObjectsByOwner(address _owner) external view returns(uint[]) {\n        uint256 tokenCount = ownerCrySolObjectsCount[_owner];\n        if (tokenCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint[] memory result = new uint[](tokenCount);\n            uint counter = 0;\n            for (uint i = 0; i < numberOfCrySolObjects; i++) {\n            if (crySolObjects[i].owner == _owner) {\n                    result[counter] = i;\n                    counter++;\n                }\n            }\n            return result;\n        }\n    }\n\n\n    /**\n    ** @dev this method is used to GET ALL CrySol Objects in the game\n    **/\n    function getAllCrySolObjects() external view returns(uint[]) {\n        uint[] memory result = new uint[](numberOfCrySolObjects);\n        uint counter = 0;\n        for (uint i = 0; i < numberOfCrySolObjects; i++) {\n                result[counter] = i;\n                counter++;\n        }\n        return result;\n    }\n    \n    /**\n    ** @dev this method is used to calculate Developer's Cut in the game\n    **/\n    function returnDevelopersCut(uint256 _price) private view returns(uint) {\n            return _price.mul(devCutPromille).div(1000);\n    }\n\n    /**\n    ** @dev this method is used to calculate Parent Object's Owner Cut in the game\n    ** owner of PARENT objects will get : percentWhenParent % from his Objects + any additional bonuses he may have from SPECIAL trade objects\n    ** that are increasing PARENT percentage\n    **/\n    function returnParentObjectCut( CrySolObject storage _obj, uint256 _price ) private view returns(uint) {\n        uint256 _percentWhenParent = crySolObjects[_obj.parentID].percentWhenParent + (ownerAddPercentToParent[crySolObjects[_obj.parentID].owner]).div(10);\n        return _price.mul(_percentWhenParent).div(100); //_parentCut\n    }\n\n    \n     /**\n    ** @dev this method is used to TRANSFER OWNERSHIP of the CrySol Objects in the game on the BUY event\n    **/\n    function _transferOwnershipOnBuy(address _oldOwner, uint _id, address _newOwner) private {\n            // decrease count for original OWNER\n            ownerCrySolObjectsCount[_oldOwner] = ownerCrySolObjectsCount[_oldOwner].sub(1); \n\n            // new owner gets ownership\n            crySolObjects[_id].owner = _newOwner;  \n            ownerCrySolObjectsCount[_newOwner] = ownerCrySolObjectsCount[_newOwner].add(1); // increase count for the new OWNER\n\n            ETHOfCrySolObjects = ETHOfCrySolObjects.sub(crySolObjects[_id].price);\n            crySolObjects[_id].price = calculateNextPrice(crySolObjects[_id].price); // now, calculate and update next price\n            ETHOfCrySolObjects = ETHOfCrySolObjects.add(crySolObjects[_id].price);\n    }\n    \n\n\n\n    /**\n    ** @dev this method is used to BUY CrySol Objects in the game, defining what will happen with the next price\n    **/\n    function buyCrySolObject(uint _id) external payable {\n\n            CrySolObject storage _obj = crySolObjects[_id];\n            uint256 price = _obj.price;\n            address oldOwner = _obj.owner; // seller\n            address newOwner = msg.sender; // buyer\n\n            require(msg.value >= price);\n            require(msg.sender != _obj.owner); // can't buy again the same thing!\n\n            uint256 excess = msg.value.sub(price);\n            \n            // calculate if percentage will go to parent Object owner \n            crySolObjects[_obj.parentID].owner.transfer(returnParentObjectCut(_obj, price));\n\n            // Transfer payment to old owner minus the developer's cut, parent owner's cut and any special Object's cut.\n             uint256 _oldOwnerCut = 0;\n            _oldOwnerCut = price.sub(returnDevelopersCut(price));\n            _oldOwnerCut = _oldOwnerCut.sub(returnParentObjectCut(_obj, price));\n            oldOwner.transfer(_oldOwnerCut);\n\n            // if there was excess in payment, return that to newOwner buying Object!\n            if (excess > 0) {\n                newOwner.transfer(excess);\n            }\n\n            //if the sell object has special property, we have to update ownerAddPercentToParent for owners addresses\n            // 0=NONE, 1=PARENT_UP\n            if (_obj.specialPropertyType == 1) {\n                if (oldOwner != ownerAddress) {\n                    ownerAddPercentToParent[oldOwner] = ownerAddPercentToParent[oldOwner].sub(_obj.specialPropertyValue);\n                }\n                ownerAddPercentToParent[newOwner] = ownerAddPercentToParent[newOwner].add(_obj.specialPropertyValue);\n            } \n\n            _transferOwnershipOnBuy(oldOwner, _id, newOwner);\n            \n            // fire event\n            EventSolethiumObjectBought(oldOwner, newOwner, price);\n\n    }\n\n\n    /**\n    ** @dev this method is used to SET user's nickname\n    **/\n    function setOwnerNickName(address _owner, string _nickName) external {\n        require(msg.sender == _owner);\n        ownerToNickname[_owner] = _nickName; // set nickname\n    }\n\n    /**\n    ** @dev this method is used to GET user's nickname\n    **/\n    function getOwnerNickName(address _owner) external view returns(string) {\n        return ownerToNickname[_owner];\n    }\n\n    /**\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBalance() external view returns(uint) {\n        return this.balance;\n    }\n    function getNumberOfCrySolObjects() external view returns(uint16) {\n        return numberOfCrySolObjects;\n    }\n\n\n    /*\n        @dev Withdraw All or part of contract balance to Contract Owner address\n    */\n    function withdrawAll() onlyOwner() public {\n        ownerAddress.transfer(this.balance);\n    }\n    function withdrawAmount(uint256 _amount) onlyOwner() public {\n        ownerAddress.transfer(_amount);\n    }\n\n\n    /**\n    ** @dev this method is used to modify parentID if needed later;\n    **      For this game it is very important to keep intended hierarchy; you never know WHEN exactly transaction will be confirmed in the blockchain\n    **      Every Object creation is transaction; if by some accident Objects get \"wrong\" ID in the crySolObjects array, this is the method where we can adjust parentId\n    **      for objects orbiting it (we don't want for Moon to end up orbiting Mars :) )\n    **/\n    function setParentID (uint _crySolObjectID, uint16 _parentID) external onlyOwner() {\n        crySolObjects[_crySolObjectID].parentID = _parentID;\n    }\n\n\n   /**\n   **  @dev ERC-721 compliant methods;\n   ** Another contracts can simply talk to us without needing to know anything about our internal contract implementation \n   **/\n\n     mapping (uint => address) crySolObjectsApprovals;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _id);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _id);\n\n    function name() public pure returns (string _name) {\n        return \"Solethium\";\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return \"SOL\";\n    }\n\n    function totalSupply() public view returns (uint256 _totalSupply) {\n        return crySolObjects.length;\n    } \n\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\n        return ownerCrySolObjectsCount[_owner];\n    }\n\n    function ownerOf(uint256 _id) public view returns (address _owner) {\n        return crySolObjects[_id].owner;\n    }\n\n    function _transferHelper(address _from, address _to, uint256 _id) private {\n        ownerCrySolObjectsCount[_to] = ownerCrySolObjectsCount[_to].add(1);\n        ownerCrySolObjectsCount[_from] = ownerCrySolObjectsCount[_from].sub(1);\n        crySolObjects[_id].owner = _to;\n        Transfer(_from, _to, _id); // fire event\n    }\n\n      function transfer(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        _transferHelper(msg.sender, _to, _id);\n    }\n\n    function approve(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        require(msg.sender != _to);\n        crySolObjectsApprovals[_id] = _to;\n        Approval(msg.sender, _to, _id); // fire event\n    }\n\n    function takeOwnership(uint256 _id) public {\n        require(crySolObjectsApprovals[_id] == msg.sender);\n        _transferHelper(ownerOf(_id), msg.sender, _id);\n    }\n\n   \n\n\n}",
        "debug": "calldata_Solethium_4 + calldata_Solethium_32 + 4: 0x98b80124e0c0001a297fffffffffffffffffffffffffffffffffffffffffffc4\ncalldata_Solethium_32 + 4: 0xda439b2041c8c00602000000000000000000000000000000000000000000001a\ncalldata_Solethium_4: 0x0\ncaller: 0x0\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 179,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10719,
        "code": " string name);\n    event EventSolethiumObjectBought(address oldOwner, address newOwner, uint price);\n\n    // @dev use SafeMath for the following uints\n    using SafeMath for uint256; // 1,15792E+77\n    using SafeMath for uint32; // 4294967296\n    using SafeMath for uint16; // 65536\n\n    //  @dev an object - CrySolObject ( dev expression for Solethium Object)- contains relevant attributes only\n    struct CrySolObject {\n        string name;\n        uint256 price;\n        uint256 id;\n        uint16 parentID;\n        uint16 percentWhenParent;\n        address owner;\n        uint8 specialPropertyType; // 0=NONE, 1=PARENT_UP\n        uint8 specialPropertyValue; // example: 5 meaning 0,5 %\n    }\n    \n\n    //  @dev an array of all CrySolObject objects in the game\n    CrySolObject[] public crySolObjects;\n    //  @dev integer - total number of CrySol Objects\n    uint16 public numberOfCrySolObjects;\n    //  @dev Total number of CrySol ETH worth in the game\n    uint256 public ETHOfCrySolObjects;\n\n    mapping (address => uint) public ownerCrySolObjectsCount; // for owner address, track number on tokens owned\n    mapping (address => uint) public ownerAddPercentToParent; // adding additional percents to owners of some Objects when they have PARENT objects\n    mapping (address => string) public ownerToNickname; // for owner address, track his nickname\n\n\n    /**\n    ** @dev MODIFIERS\n    **/\n    modifier onlyOwnerOf(uint _id) {\n        require(msg.sender == crySolObjects[_id].owner);\n        _;\n    } \n\n    /**\n    ** @dev NEXT PRICE CALCULATIONS\n    **/\n\n    uint256 private nextPriceTreshold1 = 0.05 ether;\n    uint256 private nextPriceTreshold2 = 0.3 ether;\n    uint256 private nextPriceTreshold3 = 1.0 ether;\n    uint256 private nextPriceTreshold4 = 5.0 ether;\n    uint256 private nextPriceTreshold5 = 10.0 ether;\n\n    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n        if (_price <= nextPriceTreshold1) {\n            return _price.mul(200).div(100);\n        } else if (_price <= nextPriceTreshold2) {\n            return _price.mul(170).div(100);\n        } else if (_price <= nextPriceTreshold3) {\n            return _price.mul(150).div(100);\n        } else if (_price <= nextPriceTreshold4) {\n            return _price.mul(140).div(100);\n        } else if (_price <= nextPriceTreshold5) {\n            return _price.mul(130).div(100);\n        } else {\n            return _price.mul(120).div(100);\n        }\n    }\n\n\n\n    /**\n    ** @dev this method is used to create CrySol Object\n    **/\n    function createCrySolObject(string _name, uint _price, uint16 _parentID, uint16 _percentWhenParent, uint8 _specialPropertyType, uint8 _specialPropertyValue) external onlyOwner() {\n        uint256 _id = crySolObjects.length;\n        crySolObjects.push(CrySolObject(_name, _price, _id, _parentID, _percentWhenParent, msg.sender, _specialPropertyType, _specialPropertyValue)) ; //insert into array\n        ownerCrySolObjectsCount[msg.sender] = ownerCrySolObjectsCount[msg.sender].add(1); // increase count for OWNER\n        numberOfCrySolObjects = (uint16)(numberOfCrySolObjects.add(1)); // increase count for Total number\n        ETHOfCrySolObjects = ETHOfCrySolObjects.add(_price); // increase total ETH worth of all tokens\n        EventSolethiumObjectCreated(_id, _name);\n\n    }\n\n    /**\n    ** @dev this method is used to GET CrySol Objects from one OWNER\n    **/\n    function getCrySolObjectsByOwner(address _owner) external view returns(uint[]) {\n        uint256 tokenCount = ownerCrySolObjectsCount[_owner];\n        if (tokenCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint[] memory result = new uint[](tokenCount);\n            uint counter = 0;\n            for (uint i = 0; i < numberOfCrySolObjects; i++) {\n            if (crySolObjects[i].owner == _owner) {\n                    result[counter] = i;\n                    counter++;\n                }\n            }\n            return result;\n        }\n    }\n\n\n    /**\n    ** @dev this method is used to GET ALL CrySol Objects in the game\n    **/\n    function getAllCrySolObjects() external view returns(uint[]) {\n        uint[] memory result = new uint[](numberOfCrySolObjects);\n        uint counter = 0;\n        for (uint i = 0; i < numberOfCrySolObjects; i++) {\n                result[counter] = i;\n                counter++;\n        }\n        return result;\n    }\n    \n    /**\n    ** @dev this method is used to calculate Developer's Cut in the game\n    **/\n    function returnDevelopersCut(uint256 _price) private view returns(uint) {\n            return _price.mul(devCutPromille).div(1000);\n    }\n\n    /**\n    ** @dev this method is used to calculate Parent Object's Owner Cut in the game\n    ** owner of PARENT objects will get : percentWhenParent % from his Objects + any additional bonuses he may have from SPECIAL trade objects\n    ** that are increasing PARENT percentage\n    **/\n    function returnParentObjectCut( CrySolObject storage _obj, uint256 _price ) private view returns(uint) {\n        uint256 _percentWhenParent = crySolObjects[_obj.parentID].percentWhenParent + (ownerAddPercentToParent[crySolObjects[_obj.parentID].owner]).div(10);\n        return _price.mul(_percentWhenParent).div(100); //_parentCut\n    }\n\n    \n     /**\n    ** @dev this method is used to TRANSFER OWNERSHIP of the CrySol Objects in the game on the BUY event\n    **/\n    function _transferOwnershipOnBuy(address _oldOwner, uint _id, address _newOwner) private {\n            // decrease count for original OWNER\n            ownerCrySolObjectsCount[_oldOwner] = ownerCrySolObjectsCount[_oldOwner].sub(1); \n\n            // new owner gets ownership\n            crySolObjects[_id].owner = _newOwner;  \n            ownerCrySolObjectsCount[_newOwner] = ownerCrySolObjectsCount[_newOwner].add(1); // increase count for the new OWNER\n\n            ETHOfCrySolObjects = ETHOfCrySolObjects.sub(crySolObjects[_id].price);\n            crySolObjects[_id].price = calculateNextPrice(crySolObjects[_id].price); // now, calculate and update next price\n            ETHOfCrySolObjects = ETHOfCrySolObjects.add(crySolObjects[_id].price);\n    }\n    \n\n\n\n    /**\n    ** @dev this method is used to BUY CrySol Objects in the game, defining what will happen with the next price\n    **/\n    function buyCrySolObject(uint _id) external payable {\n\n            CrySolObject storage _obj = crySolObjects[_id];\n            uint256 price = _obj.price;\n            address oldOwner = _obj.owner; // seller\n            address newOwner = msg.sender; // buyer\n\n            require(msg.value >= price);\n            require(msg.sender != _obj.owner); // can't buy again the same thing!\n\n            uint256 excess = msg.value.sub(price);\n            \n            // calculate if percentage will go to parent Object owner \n            crySolObjects[_obj.parentID].owner.transfer(returnParentObjectCut(_obj, price));\n\n            // Transfer payment to old owner minus the developer's cut, parent owner's cut and any special Object's cut.\n             uint256 _oldOwnerCut = 0;\n            _oldOwnerCut = price.sub(returnDevelopersCut(price));\n            _oldOwnerCut = _oldOwnerCut.sub(returnParentObjectCut(_obj, price));\n            oldOwner.transfer(_oldOwnerCut);\n\n            // if there was excess in payment, return that to newOwner buying Object!\n            if (excess > 0) {\n                newOwner.transfer(excess);\n            }\n\n            //if the sell object has special property, we have to update ownerAddPercentToParent for owners addresses\n            // 0=NONE, 1=PARENT_UP\n            if (_obj.specialPropertyType == 1) {\n                if (oldOwner != ownerAddress) {\n                    ownerAddPercentToParent[oldOwner] = ownerAddPercentToParent[oldOwner].sub(_obj.specialPropertyValue);\n                }\n                ownerAddPercentToParent[newOwner] = ownerAddPercentToParent[newOwner].add(_obj.specialPropertyValue);\n            } \n\n            _transferOwnershipOnBuy(oldOwner, _id, newOwner);\n            \n            // fire event\n            EventSolethiumObjectBought(oldOwner, newOwner, price);\n\n    }\n\n\n    /**\n    ** @dev this method is used to SET user's nickname\n    **/\n    function setOwnerNickName(address _owner, string _nickName) external {\n        require(msg.sender == _owner);\n        ownerToNickname[_owner] = _nickName; // set nickname\n    }\n\n    /**\n    ** @dev this method is used to GET user's nickname\n    **/\n    function getOwnerNickName(address _owner) external view returns(string) {\n        return ownerToNickname[_owner];\n    }\n\n    /**\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBalance() external view returns(uint) {\n        return this.balance;\n    }\n    function getNumberOfCrySolObjects() external view returns(uint16) {\n        return numberOfCrySolObjects;\n    }\n\n\n    /*\n        @dev Withdraw All or part of contract balance to Contract Owner address\n    */\n    function withdrawAll() onlyOwner() public {\n        ownerAddress.transfer(this.balance);\n    }\n    function withdrawAmount(uint256 _amount) onlyOwner() public {\n        ownerAddress.transfer(_amount);\n    }\n\n\n    /**\n    ** @dev this method is used to modify parentID if needed later;\n    **      For this game it is very important to keep intended hierarchy; you never know WHEN exactly transaction will be confirmed in the blockchain\n    **      Every Object creation is transaction; if by some accident Objects get \"wrong\" ID in the crySolObjects array, this is the method where we can adjust parentId\n    **      for objects orbiting it (we don't want for Moon to end up orbiting Mars :) )\n    **/\n    function setParentID (uint _crySolObjectID, uint16 _parentID) external onlyOwner() {\n        crySolObjects[_crySolObjectID].parentID = _parentID;\n    }\n\n\n   /**\n   **  @dev ERC-721 compliant methods;\n   ** Another contracts can simply talk to us without needing to know anything about our internal contract implementation \n   **/\n\n     mapping (uint => address) crySolObjectsApprovals;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _id);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _id);\n\n    function name() public pure returns (string _name) {\n        return \"Solethium\";\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return \"SOL\";\n    }\n\n    function totalSupply() public view returns (uint256 _totalSupply) {\n        return crySolObjects.length;\n    } \n\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\n        return ownerCrySolObjectsCount[_owner];\n    }\n\n    function ownerOf(uint256 _id) public view returns (address _owner) {\n        return crySolObjects[_id].owner;\n    }\n\n    function _transferHelper(address _from, address _to, uint256 _id) private {\n        ownerCrySolObjectsCount[_to] = ownerCrySolObjectsCount[_to].add(1);\n        ownerCrySolObjectsCount[_from] = ownerCrySolObjectsCount[_from].sub(1);\n        crySolObjects[_id].owner = _to;\n        Transfer(_from, _to, _id); // fire event\n    }\n\n      function transfer(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        _transferHelper(msg.sender, _to, _id);\n    }\n\n    function approve(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        require(msg.sender != _to);\n        crySolObjectsApprovals[_id] = _to;\n        Approval(msg.sender, _to, _id); // fire event\n    }\n\n    function takeOwnership(uint256 _id) public {\n        require(crySolObjectsApprovals[_id] == msg.sender);\n        _transferHelper(ownerOf(_id), msg.sender, _id);\n    }\n\n   \n\n\n}",
        "debug": "calldata_Solethium_4 + calldata_Solethium_32 + 4: 0x21\ncalldata_Solethium_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff9c\ncalldata_Solethium_4: 0x0\ncaller: 0x0\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 179,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 10724,
        "code": " string name);\n    event EventSolethiumObjectBought(address oldOwner, address newOwner, uint price);\n\n    // @dev use SafeMath for the following uints\n    using SafeMath for uint256; // 1,15792E+77\n    using SafeMath for uint32; // 4294967296\n    using SafeMath for uint16; // 65536\n\n    //  @dev an object - CrySolObject ( dev expression for Solethium Object)- contains relevant attributes only\n    struct CrySolObject {\n        string name;\n        uint256 price;\n        uint256 id;\n        uint16 parentID;\n        uint16 percentWhenParent;\n        address owner;\n        uint8 specialPropertyType; // 0=NONE, 1=PARENT_UP\n        uint8 specialPropertyValue; // example: 5 meaning 0,5 %\n    }\n    \n\n    //  @dev an array of all CrySolObject objects in the game\n    CrySolObject[] public crySolObjects;\n    //  @dev integer - total number of CrySol Objects\n    uint16 public numberOfCrySolObjects;\n    //  @dev Total number of CrySol ETH worth in the game\n    uint256 public ETHOfCrySolObjects;\n\n    mapping (address => uint) public ownerCrySolObjectsCount; // for owner address, track number on tokens owned\n    mapping (address => uint) public ownerAddPercentToParent; // adding additional percents to owners of some Objects when they have PARENT objects\n    mapping (address => string) public ownerToNickname; // for owner address, track his nickname\n\n\n    /**\n    ** @dev MODIFIERS\n    **/\n    modifier onlyOwnerOf(uint _id) {\n        require(msg.sender == crySolObjects[_id].owner);\n        _;\n    } \n\n    /**\n    ** @dev NEXT PRICE CALCULATIONS\n    **/\n\n    uint256 private nextPriceTreshold1 = 0.05 ether;\n    uint256 private nextPriceTreshold2 = 0.3 ether;\n    uint256 private nextPriceTreshold3 = 1.0 ether;\n    uint256 private nextPriceTreshold4 = 5.0 ether;\n    uint256 private nextPriceTreshold5 = 10.0 ether;\n\n    function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) {\n        if (_price <= nextPriceTreshold1) {\n            return _price.mul(200).div(100);\n        } else if (_price <= nextPriceTreshold2) {\n            return _price.mul(170).div(100);\n        } else if (_price <= nextPriceTreshold3) {\n            return _price.mul(150).div(100);\n        } else if (_price <= nextPriceTreshold4) {\n            return _price.mul(140).div(100);\n        } else if (_price <= nextPriceTreshold5) {\n            return _price.mul(130).div(100);\n        } else {\n            return _price.mul(120).div(100);\n        }\n    }\n\n\n\n    /**\n    ** @dev this method is used to create CrySol Object\n    **/\n    function createCrySolObject(string _name, uint _price, uint16 _parentID, uint16 _percentWhenParent, uint8 _specialPropertyType, uint8 _specialPropertyValue) external onlyOwner() {\n        uint256 _id = crySolObjects.length;\n        crySolObjects.push(CrySolObject(_name, _price, _id, _parentID, _percentWhenParent, msg.sender, _specialPropertyType, _specialPropertyValue)) ; //insert into array\n        ownerCrySolObjectsCount[msg.sender] = ownerCrySolObjectsCount[msg.sender].add(1); // increase count for OWNER\n        numberOfCrySolObjects = (uint16)(numberOfCrySolObjects.add(1)); // increase count for Total number\n        ETHOfCrySolObjects = ETHOfCrySolObjects.add(_price); // increase total ETH worth of all tokens\n        EventSolethiumObjectCreated(_id, _name);\n\n    }\n\n    /**\n    ** @dev this method is used to GET CrySol Objects from one OWNER\n    **/\n    function getCrySolObjectsByOwner(address _owner) external view returns(uint[]) {\n        uint256 tokenCount = ownerCrySolObjectsCount[_owner];\n        if (tokenCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint[] memory result = new uint[](tokenCount);\n            uint counter = 0;\n            for (uint i = 0; i < numberOfCrySolObjects; i++) {\n            if (crySolObjects[i].owner == _owner) {\n                    result[counter] = i;\n                    counter++;\n                }\n            }\n            return result;\n        }\n    }\n\n\n    /**\n    ** @dev this method is used to GET ALL CrySol Objects in the game\n    **/\n    function getAllCrySolObjects() external view returns(uint[]) {\n        uint[] memory result = new uint[](numberOfCrySolObjects);\n        uint counter = 0;\n        for (uint i = 0; i < numberOfCrySolObjects; i++) {\n                result[counter] = i;\n                counter++;\n        }\n        return result;\n    }\n    \n    /**\n    ** @dev this method is used to calculate Developer's Cut in the game\n    **/\n    function returnDevelopersCut(uint256 _price) private view returns(uint) {\n            return _price.mul(devCutPromille).div(1000);\n    }\n\n    /**\n    ** @dev this method is used to calculate Parent Object's Owner Cut in the game\n    ** owner of PARENT objects will get : percentWhenParent % from his Objects + any additional bonuses he may have from SPECIAL trade objects\n    ** that are increasing PARENT percentage\n    **/\n    function returnParentObjectCut( CrySolObject storage _obj, uint256 _price ) private view returns(uint) {\n        uint256 _percentWhenParent = crySolObjects[_obj.parentID].percentWhenParent + (ownerAddPercentToParent[crySolObjects[_obj.parentID].owner]).div(10);\n        return _price.mul(_percentWhenParent).div(100); //_parentCut\n    }\n\n    \n     /**\n    ** @dev this method is used to TRANSFER OWNERSHIP of the CrySol Objects in the game on the BUY event\n    **/\n    function _transferOwnershipOnBuy(address _oldOwner, uint _id, address _newOwner) private {\n            // decrease count for original OWNER\n            ownerCrySolObjectsCount[_oldOwner] = ownerCrySolObjectsCount[_oldOwner].sub(1); \n\n            // new owner gets ownership\n            crySolObjects[_id].owner = _newOwner;  \n            ownerCrySolObjectsCount[_newOwner] = ownerCrySolObjectsCount[_newOwner].add(1); // increase count for the new OWNER\n\n            ETHOfCrySolObjects = ETHOfCrySolObjects.sub(crySolObjects[_id].price);\n            crySolObjects[_id].price = calculateNextPrice(crySolObjects[_id].price); // now, calculate and update next price\n            ETHOfCrySolObjects = ETHOfCrySolObjects.add(crySolObjects[_id].price);\n    }\n    \n\n\n\n    /**\n    ** @dev this method is used to BUY CrySol Objects in the game, defining what will happen with the next price\n    **/\n    function buyCrySolObject(uint _id) external payable {\n\n            CrySolObject storage _obj = crySolObjects[_id];\n            uint256 price = _obj.price;\n            address oldOwner = _obj.owner; // seller\n            address newOwner = msg.sender; // buyer\n\n            require(msg.value >= price);\n            require(msg.sender != _obj.owner); // can't buy again the same thing!\n\n            uint256 excess = msg.value.sub(price);\n            \n            // calculate if percentage will go to parent Object owner \n            crySolObjects[_obj.parentID].owner.transfer(returnParentObjectCut(_obj, price));\n\n            // Transfer payment to old owner minus the developer's cut, parent owner's cut and any special Object's cut.\n             uint256 _oldOwnerCut = 0;\n            _oldOwnerCut = price.sub(returnDevelopersCut(price));\n            _oldOwnerCut = _oldOwnerCut.sub(returnParentObjectCut(_obj, price));\n            oldOwner.transfer(_oldOwnerCut);\n\n            // if there was excess in payment, return that to newOwner buying Object!\n            if (excess > 0) {\n                newOwner.transfer(excess);\n            }\n\n            //if the sell object has special property, we have to update ownerAddPercentToParent for owners addresses\n            // 0=NONE, 1=PARENT_UP\n            if (_obj.specialPropertyType == 1) {\n                if (oldOwner != ownerAddress) {\n                    ownerAddPercentToParent[oldOwner] = ownerAddPercentToParent[oldOwner].sub(_obj.specialPropertyValue);\n                }\n                ownerAddPercentToParent[newOwner] = ownerAddPercentToParent[newOwner].add(_obj.specialPropertyValue);\n            } \n\n            _transferOwnershipOnBuy(oldOwner, _id, newOwner);\n            \n            // fire event\n            EventSolethiumObjectBought(oldOwner, newOwner, price);\n\n    }\n\n\n    /**\n    ** @dev this method is used to SET user's nickname\n    **/\n    function setOwnerNickName(address _owner, string _nickName) external {\n        require(msg.sender == _owner);\n        ownerToNickname[_owner] = _nickName; // set nickname\n    }\n\n    /**\n    ** @dev this method is used to GET user's nickname\n    **/\n    function getOwnerNickName(address _owner) external view returns(string) {\n        return ownerToNickname[_owner];\n    }\n\n    /**\n    ** @dev some helper / info getter functions\n    **/\n    function getContractOwner() external view returns(address) {\n        return ownerAddress; \n    }\n    function getBalance() external view returns(uint) {\n        return this.balance;\n    }\n    function getNumberOfCrySolObjects() external view returns(uint16) {\n        return numberOfCrySolObjects;\n    }\n\n\n    /*\n        @dev Withdraw All or part of contract balance to Contract Owner address\n    */\n    function withdrawAll() onlyOwner() public {\n        ownerAddress.transfer(this.balance);\n    }\n    function withdrawAmount(uint256 _amount) onlyOwner() public {\n        ownerAddress.transfer(_amount);\n    }\n\n\n    /**\n    ** @dev this method is used to modify parentID if needed later;\n    **      For this game it is very important to keep intended hierarchy; you never know WHEN exactly transaction will be confirmed in the blockchain\n    **      Every Object creation is transaction; if by some accident Objects get \"wrong\" ID in the crySolObjects array, this is the method where we can adjust parentId\n    **      for objects orbiting it (we don't want for Moon to end up orbiting Mars :) )\n    **/\n    function setParentID (uint _crySolObjectID, uint16 _parentID) external onlyOwner() {\n        crySolObjects[_crySolObjectID].parentID = _parentID;\n    }\n\n\n   /**\n   **  @dev ERC-721 compliant methods;\n   ** Another contracts can simply talk to us without needing to know anything about our internal contract implementation \n   **/\n\n     mapping (uint => address) crySolObjectsApprovals;\n\n    event Transfer(address indexed _from, address indexed _to, uint256 _id);\n    event Approval(address indexed _owner, address indexed _approved, uint256 _id);\n\n    function name() public pure returns (string _name) {\n        return \"Solethium\";\n    }\n\n    function symbol() public pure returns (string _symbol) {\n        return \"SOL\";\n    }\n\n    function totalSupply() public view returns (uint256 _totalSupply) {\n        return crySolObjects.length;\n    } \n\n    function balanceOf(address _owner) public view returns (uint256 _balance) {\n        return ownerCrySolObjectsCount[_owner];\n    }\n\n    function ownerOf(uint256 _id) public view returns (address _owner) {\n        return crySolObjects[_id].owner;\n    }\n\n    function _transferHelper(address _from, address _to, uint256 _id) private {\n        ownerCrySolObjectsCount[_to] = ownerCrySolObjectsCount[_to].add(1);\n        ownerCrySolObjectsCount[_from] = ownerCrySolObjectsCount[_from].sub(1);\n        crySolObjects[_id].owner = _to;\n        Transfer(_from, _to, _id); // fire event\n    }\n\n      function transfer(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        _transferHelper(msg.sender, _to, _id);\n    }\n\n    function approve(address _to, uint256 _id) public onlyOwnerOf(_id) {\n        require(msg.sender != _to);\n        crySolObjectsApprovals[_id] = _to;\n        Approval(msg.sender, _to, _id); // fire event\n    }\n\n    function takeOwnership(uint256 _id) public {\n        require(crySolObjectsApprovals[_id] == msg.sender);\n        _transferHelper(ownerOf(_id), msg.sender, _id);\n    }\n\n   \n\n\n}",
        "debug": "calldata_Solethium_4 + calldata_Solethium_32 + 4: 0x987c2551f8080d0a0016240787c0618800000000002903c3e006100b780cc80d\ncalldata_Solethium_32 + 4: 0x8638cebc3ef479b69080227bf800000000000006ebdfb9c10e3eff4826476bf\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Solethium_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Solethium_4: 0x0\ncaller: 0x0\ncalldata_Solethium_0: 0x1dc3ac2200000000000000000000000000000000000000000000000000000000\ncalldatasize_Solethium: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `setOwnerNickName(address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0xbc34b85205affe0c941c784f6d76d1d6fbf2caa8.sol",
        "function": "setOwnerNickName(address,string)",
        "lineno": 179,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}