{
  "contract": "0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8",
  "tool": "mythril",
  "start": 1563609232.7881663,
  "end": 1563609754.2467995,
  "duration": 521.458633184433,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 2637,
        "code": "on[] public tokenListArray;\n    //token address -> tok",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_T1WinTokenConfig_4: 0x0\nstorage_1: 0x0\ncalldata_T1WinTokenConfig_0: 0x7b90a58200000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "_function_0x7b90a582",
        "lineno": 29,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 3368,
        "code": "re(adminAddress == ms",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 38,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 3487,
        "code": "        require(adminAddress == ms",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 38,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3683,
        "code": "i < tokenListArray.length; i++) {\n",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 101,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3719,
        "code": "i < tokenListArray.length; i++) {\n",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 101,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 3739,
        "code": "i < tokenListArray.length; i++) {\n",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 101,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 4358,
        "code": "re(adminAddress == ms",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 38,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 4477,
        "code": "        require(adminAddress == ms",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 38,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 4857,
        "code": "cimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addTo",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 89,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 4874,
        "code": "cimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addTo",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)) +\n32: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4: 0x0\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)): 0x0\nreturndatasize: 0x20\nretval_4358: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_T1WinTokenConfig_0: 0xb4c642ff00000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addNewTokenByAdmin(address,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 89,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5599,
        "code": "e,tokenListArray[",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_T1WinTokenConfig_4: 0x0\nstorage_1: 0x0\ncalldata_T1WinTokenConfig_0: 0xe4b50cb800000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "getToken(uint256)",
        "lineno": 59,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6484,
        "code": "ntract T1WinTokenConfig {\n    /*=====================================\n    =            EVENT               =\n    =====================================*/\n    event addConfigUser(\n    address indexed userAddress,\n    uint ethereumReinvested\n    );\n     event addToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n     event removeToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n    /*=====================================\n    =            CONSTANTS               =\n    =====================================*/\n    T1WinAdmin constant private t1WinAdmin = T1WinAdmin(0xcc258f29443d849efd5dccf233bfe29533b042bc);\n\n    uint constant internal  configEthSpent       = 1   ether;\n\n    \n    address[] configUserList; \n\n    T1Wdatasets.TokenConfiguration[] public tokenListArray;\n    //token address -> token object map \n    mapping (address => T1Wdatasets.TokenConfiguration) public tokenListMap;\n    //address -> add config user map  \n    mapping (address => T1Wdatasets.AddConfigurationUser) public configurationUserMap;\n    mapping (address => uint256) public configurationUserCheck;\n   address private adminAddress;\n    modifier onlyAuthorizedAdmin {\n        adminAddress=t1WinAdmin.getAdmin();\n        require(adminAddress == msg.sender);\n        _;\n    }\n    modifier isWithinETHLimits(uint256 _eth) {\n        // add a configuration need 1 ETH\n        require(_eth == 1000000000000000000);\n        _;    \n    }\n    //get token array lenght\n    function getTokenArrayLength() \n        public\n        view\n        returns(uint) \n    {\n        return tokenListArray.length;\n    }    \n    //get token from array\n    function getToken(uint n)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        return (tokenListArray[n].tokenAddress, tokenListArray[n].tokenName,tokenListArray[n].tokenDecimals,tokenListArray[n].used);\n    }  \n    function getTokenByAddress(address a)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n        return (token.tokenAddress, token.tokenName,token.tokenDecimals,token.used);\n    } \n    function getTokenNameByAddress(address a)\n        public \n        view\n        returns (string ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenName);\n        }\n      function getTokenDecimalsByAddress(address a)\n        public \n        view\n        returns (uint8 ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenDecimals);\n        }   \n     //add new token by admin\n    function addNewTokenByAdmin(address _tokenAddress, string _tokenName,uint8 decimal)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //check the token address already exist or not exit\n             require(!tokenListMap[_tokenAddress].used);\n             tokenListMap[_tokenAddress]= T1Wdatasets.TokenConfiguration(_tokenAddress, _tokenName,decimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addToken(_tokenAddress, _tokenName);\n        }\n     //remove token by admin    \n    function removeNewTokenByAdmin(address _tokenAddress)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //remove from map\n            delete tokenListMap[_tokenAddress];\n            //remove from array \n            for (uint i = 0; i < tokenListArray.length; i++) {\n                if (tokenListArray[i].tokenAddress == _tokenAddress) {\n                    tokenListArray[i] = tokenListArray[tokenListArray.length - 1];\n                    tokenListArray.length -= 1;\n                    break;\n                }\n            }\n          \n        }\n    function addNewToken(address _tokenAddress, bytes32 _tokenName)\n            isWithinETHLimits(msg.value)\n            public\n            payable\n        {\n          uint256 checkUserStatu = configurationUserCheck[msg.sender];\n            //1 . chcke if the address already existin the config address array\n            \n            if(checkUserStatu == 0){\n                //this is new user, change the user statu to 1.\n                configurationUserCheck[msg.sender]=1;\n                // inital a  new configuration user\n                T1Wdatasets.AddConfigurationUser memory configurationUser ; \n                configurationUser.addr = msg.sender;\n                configurationUser.ethTotalAmount += msg.value;\n                configurationUserMap[msg.sender] = configurationUser;\n                emit addConfigUser(msg.sender , msg.value);\n               \n            }\n    \n            //2. add new Token\n            \n              \n        }\n\n}\n\n/*================================\n=            Interface            =\n================================*/\n\ninterface T1WinAdmin {\n  ",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 3,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 6517,
        "code": "ntract T1WinTokenConfig {\n    /*=====================================\n    =            EVENT               =\n    =====================================*/\n    event addConfigUser(\n    address indexed userAddress,\n    uint ethereumReinvested\n    );\n     event addToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n     event removeToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n    /*=====================================\n    =            CONSTANTS               =\n    =====================================*/\n    T1WinAdmin constant private t1WinAdmin = T1WinAdmin(0xcc258f29443d849efd5dccf233bfe29533b042bc);\n\n    uint constant internal  configEthSpent       = 1   ether;\n\n    \n    address[] configUserList; \n\n    T1Wdatasets.TokenConfiguration[] public tokenListArray;\n    //token address -> token object map \n    mapping (address => T1Wdatasets.TokenConfiguration) public tokenListMap;\n    //address -> add config user map  \n    mapping (address => T1Wdatasets.AddConfigurationUser) public configurationUserMap;\n    mapping (address => uint256) public configurationUserCheck;\n   address private adminAddress;\n    modifier onlyAuthorizedAdmin {\n        adminAddress=t1WinAdmin.getAdmin();\n        require(adminAddress == msg.sender);\n        _;\n    }\n    modifier isWithinETHLimits(uint256 _eth) {\n        // add a configuration need 1 ETH\n        require(_eth == 1000000000000000000);\n        _;    \n    }\n    //get token array lenght\n    function getTokenArrayLength() \n        public\n        view\n        returns(uint) \n    {\n        return tokenListArray.length;\n    }    \n    //get token from array\n    function getToken(uint n)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        return (tokenListArray[n].tokenAddress, tokenListArray[n].tokenName,tokenListArray[n].tokenDecimals,tokenListArray[n].used);\n    }  \n    function getTokenByAddress(address a)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n        return (token.tokenAddress, token.tokenName,token.tokenDecimals,token.used);\n    } \n    function getTokenNameByAddress(address a)\n        public \n        view\n        returns (string ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenName);\n        }\n      function getTokenDecimalsByAddress(address a)\n        public \n        view\n        returns (uint8 ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenDecimals);\n        }   \n     //add new token by admin\n    function addNewTokenByAdmin(address _tokenAddress, string _tokenName,uint8 decimal)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //check the token address already exist or not exit\n             require(!tokenListMap[_tokenAddress].used);\n             tokenListMap[_tokenAddress]= T1Wdatasets.TokenConfiguration(_tokenAddress, _tokenName,decimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addToken(_tokenAddress, _tokenName);\n        }\n     //remove token by admin    \n    function removeNewTokenByAdmin(address _tokenAddress)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //remove from map\n            delete tokenListMap[_tokenAddress];\n            //remove from array \n            for (uint i = 0; i < tokenListArray.length; i++) {\n                if (tokenListArray[i].tokenAddress == _tokenAddress) {\n                    tokenListArray[i] = tokenListArray[tokenListArray.length - 1];\n                    tokenListArray.length -= 1;\n                    break;\n                }\n            }\n          \n        }\n    function addNewToken(address _tokenAddress, bytes32 _tokenName)\n            isWithinETHLimits(msg.value)\n            public\n            payable\n        {\n          uint256 checkUserStatu = configurationUserCheck[msg.sender];\n            //1 . chcke if the address already existin the config address array\n            \n            if(checkUserStatu == 0){\n                //this is new user, change the user statu to 1.\n                configurationUserCheck[msg.sender]=1;\n                // inital a  new configuration user\n                T1Wdatasets.AddConfigurationUser memory configurationUser ; \n                configurationUser.addr = msg.sender;\n                configurationUser.ethTotalAmount += msg.value;\n                configurationUserMap[msg.sender] = configurationUser;\n                emit addConfigUser(msg.sender , msg.value);\n               \n            }\n    \n            //2. add new Token\n            \n              \n        }\n\n}\n\n/*================================\n=            Interface            =\n================================*/\n\ninterface T1WinAdmin {\n  ",
        "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4_+\n1: 0xfedf99ff7ffff7ffcfffffffffefffbffe7fffffff5f3fffffc069feffffc800\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4 +\n1: 0xbe806f1fb9a91febe830a18c9b68af7fd7defe83d2ebeeebc7db7ebfffffffc1\ncaller: 0x0\nreturndatasize: 0x20\nretval_3368: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_T1WinTokenConfig_0: 0xa1c182d600000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeNewTokenByAdmin(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "removeNewTokenByAdmin(address)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6756,
        "code": "ntract T1WinTokenConfig {\n    /*=====================================\n    =            EVENT               =\n    =====================================*/\n    event addConfigUser(\n    address indexed userAddress,\n    uint ethereumReinvested\n    );\n     event addToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n     event removeToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n    /*=====================================\n    =            CONSTANTS               =\n    =====================================*/\n    T1WinAdmin constant private t1WinAdmin = T1WinAdmin(0xcc258f29443d849efd5dccf233bfe29533b042bc);\n\n    uint constant internal  configEthSpent       = 1   ether;\n\n    \n    address[] configUserList; \n\n    T1Wdatasets.TokenConfiguration[] public tokenListArray;\n    //token address -> token object map \n    mapping (address => T1Wdatasets.TokenConfiguration) public tokenListMap;\n    //address -> add config user map  \n    mapping (address => T1Wdatasets.AddConfigurationUser) public configurationUserMap;\n    mapping (address => uint256) public configurationUserCheck;\n   address private adminAddress;\n    modifier onlyAuthorizedAdmin {\n        adminAddress=t1WinAdmin.getAdmin();\n        require(adminAddress == msg.sender);\n        _;\n    }\n    modifier isWithinETHLimits(uint256 _eth) {\n        // add a configuration need 1 ETH\n        require(_eth == 1000000000000000000);\n        _;    \n    }\n    //get token array lenght\n    function getTokenArrayLength() \n        public\n        view\n        returns(uint) \n    {\n        return tokenListArray.length;\n    }    \n    //get token from array\n    function getToken(uint n)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        return (tokenListArray[n].tokenAddress, tokenListArray[n].tokenName,tokenListArray[n].tokenDecimals,tokenListArray[n].used);\n    }  \n    function getTokenByAddress(address a)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n        return (token.tokenAddress, token.tokenName,token.tokenDecimals,token.used);\n    } \n    function getTokenNameByAddress(address a)\n        public \n        view\n        returns (string ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenName);\n        }\n      function getTokenDecimalsByAddress(address a)\n        public \n        view\n        returns (uint8 ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenDecimals);\n        }   \n     //add new token by admin\n    function addNewTokenByAdmin(address _tokenAddress, string _tokenName,uint8 decimal)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //check the token address already exist or not exit\n             require(!tokenListMap[_tokenAddress].used);\n             tokenListMap[_tokenAddress]= T1Wdatasets.TokenConfiguration(_tokenAddress, _tokenName,decimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addToken(_tokenAddress, _tokenName);\n        }\n     //remove token by admin    \n    function removeNewTokenByAdmin(address _tokenAddress)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //remove from map\n            delete tokenListMap[_tokenAddress];\n            //remove from array \n            for (uint i = 0; i < tokenListArray.length; i++) {\n                if (tokenListArray[i].tokenAddress == _tokenAddress) {\n                    tokenListArray[i] = tokenListArray[tokenListArray.length - 1];\n                    tokenListArray.length -= 1;\n                    break;\n                }\n            }\n          \n        }\n    function addNewToken(address _tokenAddress, bytes32 _tokenName)\n            isWithinETHLimits(msg.value)\n            public\n            payable\n        {\n          uint256 checkUserStatu = configurationUserCheck[msg.sender];\n            //1 . chcke if the address already existin the config address array\n            \n            if(checkUserStatu == 0){\n                //this is new user, change the user statu to 1.\n                configurationUserCheck[msg.sender]=1;\n                // inital a  new configuration user\n                T1Wdatasets.AddConfigurationUser memory configurationUser ; \n                configurationUser.addr = msg.sender;\n                configurationUser.ethTotalAmount += msg.value;\n                configurationUserMap[msg.sender] = configurationUser;\n                emit addConfigUser(msg.sender , msg.value);\n               \n            }\n    \n            //2. add new Token\n            \n              \n        }\n\n}\n\n/*================================\n=            Interface            =\n================================*/\n\ninterface T1WinAdmin {\n  ",
        "debug": "storage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_1_+\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4: 0x0\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)): 0x0\nreturndatasize: 0x20\nretval_4358: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_T1WinTokenConfig_0: 0xb4c642ff00000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addNewTokenByAdmin(address,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6785,
        "code": "ntract T1WinTokenConfig {\n    /*=====================================\n    =            EVENT               =\n    =====================================*/\n    event addConfigUser(\n    address indexed userAddress,\n    uint ethereumReinvested\n    );\n     event addToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n     event removeToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n    /*=====================================\n    =            CONSTANTS               =\n    =====================================*/\n    T1WinAdmin constant private t1WinAdmin = T1WinAdmin(0xcc258f29443d849efd5dccf233bfe29533b042bc);\n\n    uint constant internal  configEthSpent       = 1   ether;\n\n    \n    address[] configUserList; \n\n    T1Wdatasets.TokenConfiguration[] public tokenListArray;\n    //token address -> token object map \n    mapping (address => T1Wdatasets.TokenConfiguration) public tokenListMap;\n    //address -> add config user map  \n    mapping (address => T1Wdatasets.AddConfigurationUser) public configurationUserMap;\n    mapping (address => uint256) public configurationUserCheck;\n   address private adminAddress;\n    modifier onlyAuthorizedAdmin {\n        adminAddress=t1WinAdmin.getAdmin();\n        require(adminAddress == msg.sender);\n        _;\n    }\n    modifier isWithinETHLimits(uint256 _eth) {\n        // add a configuration need 1 ETH\n        require(_eth == 1000000000000000000);\n        _;    \n    }\n    //get token array lenght\n    function getTokenArrayLength() \n        public\n        view\n        returns(uint) \n    {\n        return tokenListArray.length;\n    }    \n    //get token from array\n    function getToken(uint n)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        return (tokenListArray[n].tokenAddress, tokenListArray[n].tokenName,tokenListArray[n].tokenDecimals,tokenListArray[n].used);\n    }  \n    function getTokenByAddress(address a)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n        return (token.tokenAddress, token.tokenName,token.tokenDecimals,token.used);\n    } \n    function getTokenNameByAddress(address a)\n        public \n        view\n        returns (string ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenName);\n        }\n      function getTokenDecimalsByAddress(address a)\n        public \n        view\n        returns (uint8 ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenDecimals);\n        }   \n     //add new token by admin\n    function addNewTokenByAdmin(address _tokenAddress, string _tokenName,uint8 decimal)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //check the token address already exist or not exit\n             require(!tokenListMap[_tokenAddress].used);\n             tokenListMap[_tokenAddress]= T1Wdatasets.TokenConfiguration(_tokenAddress, _tokenName,decimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addToken(_tokenAddress, _tokenName);\n        }\n     //remove token by admin    \n    function removeNewTokenByAdmin(address _tokenAddress)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //remove from map\n            delete tokenListMap[_tokenAddress];\n            //remove from array \n            for (uint i = 0; i < tokenListArray.length; i++) {\n                if (tokenListArray[i].tokenAddress == _tokenAddress) {\n                    tokenListArray[i] = tokenListArray[tokenListArray.length - 1];\n                    tokenListArray.length -= 1;\n                    break;\n                }\n            }\n          \n        }\n    function addNewToken(address _tokenAddress, bytes32 _tokenName)\n            isWithinETHLimits(msg.value)\n            public\n            payable\n        {\n          uint256 checkUserStatu = configurationUserCheck[msg.sender];\n            //1 . chcke if the address already existin the config address array\n            \n            if(checkUserStatu == 0){\n                //this is new user, change the user statu to 1.\n                configurationUserCheck[msg.sender]=1;\n                // inital a  new configuration user\n                T1Wdatasets.AddConfigurationUser memory configurationUser ; \n                configurationUser.addr = msg.sender;\n                configurationUser.ethTotalAmount += msg.value;\n                configurationUserMap[msg.sender] = configurationUser;\n                emit addConfigUser(msg.sender , msg.value);\n               \n            }\n    \n            //2. add new Token\n            \n              \n        }\n\n}\n\n/*================================\n=            Interface            =\n================================*/\n\ninterface T1WinAdmin {\n  ",
        "debug": "mem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)) +\n32: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4: 0x0\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)): 0x0\nreturndatasize: 0x20\nretval_4358: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_T1WinTokenConfig_0: 0xb4c642ff00000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addNewTokenByAdmin(address,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6790,
        "code": "ntract T1WinTokenConfig {\n    /*=====================================\n    =            EVENT               =\n    =====================================*/\n    event addConfigUser(\n    address indexed userAddress,\n    uint ethereumReinvested\n    );\n     event addToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n     event removeToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n    /*=====================================\n    =            CONSTANTS               =\n    =====================================*/\n    T1WinAdmin constant private t1WinAdmin = T1WinAdmin(0xcc258f29443d849efd5dccf233bfe29533b042bc);\n\n    uint constant internal  configEthSpent       = 1   ether;\n\n    \n    address[] configUserList; \n\n    T1Wdatasets.TokenConfiguration[] public tokenListArray;\n    //token address -> token object map \n    mapping (address => T1Wdatasets.TokenConfiguration) public tokenListMap;\n    //address -> add config user map  \n    mapping (address => T1Wdatasets.AddConfigurationUser) public configurationUserMap;\n    mapping (address => uint256) public configurationUserCheck;\n   address private adminAddress;\n    modifier onlyAuthorizedAdmin {\n        adminAddress=t1WinAdmin.getAdmin();\n        require(adminAddress == msg.sender);\n        _;\n    }\n    modifier isWithinETHLimits(uint256 _eth) {\n        // add a configuration need 1 ETH\n        require(_eth == 1000000000000000000);\n        _;    \n    }\n    //get token array lenght\n    function getTokenArrayLength() \n        public\n        view\n        returns(uint) \n    {\n        return tokenListArray.length;\n    }    \n    //get token from array\n    function getToken(uint n)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        return (tokenListArray[n].tokenAddress, tokenListArray[n].tokenName,tokenListArray[n].tokenDecimals,tokenListArray[n].used);\n    }  \n    function getTokenByAddress(address a)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n        return (token.tokenAddress, token.tokenName,token.tokenDecimals,token.used);\n    } \n    function getTokenNameByAddress(address a)\n        public \n        view\n        returns (string ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenName);\n        }\n      function getTokenDecimalsByAddress(address a)\n        public \n        view\n        returns (uint8 ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenDecimals);\n        }   \n     //add new token by admin\n    function addNewTokenByAdmin(address _tokenAddress, string _tokenName,uint8 decimal)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //check the token address already exist or not exit\n             require(!tokenListMap[_tokenAddress].used);\n             tokenListMap[_tokenAddress]= T1Wdatasets.TokenConfiguration(_tokenAddress, _tokenName,decimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addToken(_tokenAddress, _tokenName);\n        }\n     //remove token by admin    \n    function removeNewTokenByAdmin(address _tokenAddress)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //remove from map\n            delete tokenListMap[_tokenAddress];\n            //remove from array \n            for (uint i = 0; i < tokenListArray.length; i++) {\n                if (tokenListArray[i].tokenAddress == _tokenAddress) {\n                    tokenListArray[i] = tokenListArray[tokenListArray.length - 1];\n                    tokenListArray.length -= 1;\n                    break;\n                }\n            }\n          \n        }\n    function addNewToken(address _tokenAddress, bytes32 _tokenName)\n            isWithinETHLimits(msg.value)\n            public\n            payable\n        {\n          uint256 checkUserStatu = configurationUserCheck[msg.sender];\n            //1 . chcke if the address already existin the config address array\n            \n            if(checkUserStatu == 0){\n                //this is new user, change the user statu to 1.\n                configurationUserCheck[msg.sender]=1;\n                // inital a  new configuration user\n                T1Wdatasets.AddConfigurationUser memory configurationUser ; \n                configurationUser.addr = msg.sender;\n                configurationUser.ethTotalAmount += msg.value;\n                configurationUserMap[msg.sender] = configurationUser;\n                emit addConfigUser(msg.sender , msg.value);\n               \n            }\n    \n            //2. add new Token\n            \n              \n        }\n\n}\n\n/*================================\n=            Interface            =\n================================*/\n\ninterface T1WinAdmin {\n  ",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 3,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 6799,
        "code": "ntract T1WinTokenConfig {\n    /*=====================================\n    =            EVENT               =\n    =====================================*/\n    event addConfigUser(\n    address indexed userAddress,\n    uint ethereumReinvested\n    );\n     event addToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n     event removeToken(\n    address indexed tokenAddress,\n    string tokenName\n    );\n    /*=====================================\n    =            CONSTANTS               =\n    =====================================*/\n    T1WinAdmin constant private t1WinAdmin = T1WinAdmin(0xcc258f29443d849efd5dccf233bfe29533b042bc);\n\n    uint constant internal  configEthSpent       = 1   ether;\n\n    \n    address[] configUserList; \n\n    T1Wdatasets.TokenConfiguration[] public tokenListArray;\n    //token address -> token object map \n    mapping (address => T1Wdatasets.TokenConfiguration) public tokenListMap;\n    //address -> add config user map  \n    mapping (address => T1Wdatasets.AddConfigurationUser) public configurationUserMap;\n    mapping (address => uint256) public configurationUserCheck;\n   address private adminAddress;\n    modifier onlyAuthorizedAdmin {\n        adminAddress=t1WinAdmin.getAdmin();\n        require(adminAddress == msg.sender);\n        _;\n    }\n    modifier isWithinETHLimits(uint256 _eth) {\n        // add a configuration need 1 ETH\n        require(_eth == 1000000000000000000);\n        _;    \n    }\n    //get token array lenght\n    function getTokenArrayLength() \n        public\n        view\n        returns(uint) \n    {\n        return tokenListArray.length;\n    }    \n    //get token from array\n    function getToken(uint n)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        return (tokenListArray[n].tokenAddress, tokenListArray[n].tokenName,tokenListArray[n].tokenDecimals,tokenListArray[n].used);\n    }  \n    function getTokenByAddress(address a)\n        public \n        view\n        returns (address, string,uint8,bool ) {\n        T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n        return (token.tokenAddress, token.tokenName,token.tokenDecimals,token.used);\n    } \n    function getTokenNameByAddress(address a)\n        public \n        view\n        returns (string ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenName);\n        }\n      function getTokenDecimalsByAddress(address a)\n        public \n        view\n        returns (uint8 ) {\n             T1Wdatasets.TokenConfiguration token = tokenListMap[a];\n             return(token.tokenDecimals);\n        }   \n     //add new token by admin\n    function addNewTokenByAdmin(address _tokenAddress, string _tokenName,uint8 decimal)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //check the token address already exist or not exit\n             require(!tokenListMap[_tokenAddress].used);\n             tokenListMap[_tokenAddress]= T1Wdatasets.TokenConfiguration(_tokenAddress, _tokenName,decimal,true);\n             tokenListArray.push(tokenListMap[_tokenAddress]);\n             emit addToken(_tokenAddress, _tokenName);\n        }\n     //remove token by admin    \n    function removeNewTokenByAdmin(address _tokenAddress)\n            onlyAuthorizedAdmin()\n            public\n        {\n            //remove from map\n            delete tokenListMap[_tokenAddress];\n            //remove from array \n            for (uint i = 0; i < tokenListArray.length; i++) {\n                if (tokenListArray[i].tokenAddress == _tokenAddress) {\n                    tokenListArray[i] = tokenListArray[tokenListArray.length - 1];\n                    tokenListArray.length -= 1;\n                    break;\n                }\n            }\n          \n        }\n    function addNewToken(address _tokenAddress, bytes32 _tokenName)\n            isWithinETHLimits(msg.value)\n            public\n            payable\n        {\n          uint256 checkUserStatu = configurationUserCheck[msg.sender];\n            //1 . chcke if the address already existin the config address array\n            \n            if(checkUserStatu == 0){\n                //this is new user, change the user statu to 1.\n                configurationUserCheck[msg.sender]=1;\n                // inital a  new configuration user\n                T1Wdatasets.AddConfigurationUser memory configurationUser ; \n                configurationUser.addr = msg.sender;\n                configurationUser.ethTotalAmount += msg.value;\n                configurationUserMap[msg.sender] = configurationUser;\n                emit addConfigUser(msg.sender , msg.value);\n               \n            }\n    \n            //2. add new Token\n            \n              \n        }\n\n}\n\n/*================================\n=            Interface            =\n================================*/\n\ninterface T1WinAdmin {\n  ",
        "debug": "mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)) +\n32: 0xc48c04261444f7ce9c1a66f6c355debe3fffffffffffffffffffffffffffffed\nmem_mem_160 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)) +\n32: 0xe9ed542651000003d76906f7c018193fbfffffffffffffffffffffffffffffcb\nstorage_2 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_T1WinTokenConfig_4: 0x0\ncaller: 0x0\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_T1WinTokenConfig_4 + calldata_T1WinTokenConfig_32 + 4)): 0x0\nreturndatasize: 0x20\nretval_4358: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nextcodesize: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_T1WinTokenConfig_0: 0xb4c642ff00000000000000000000000000000000000000000000000000000000\ncalldatasize_T1WinTokenConfig: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addNewTokenByAdmin(address,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x3ede53a1bc8cf5bb1fcc101d1a08c8992bacf5a8.sol",
        "function": "addNewTokenByAdmin(address,string,uint8)",
        "lineno": 3,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}