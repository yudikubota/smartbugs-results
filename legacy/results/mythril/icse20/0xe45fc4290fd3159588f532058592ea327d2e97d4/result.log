{"error": null, "issues": [{"address": 1091, "code": "ng\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[_to];\n\n    uint256 lockAmountNow;\n    uint256 lockLimit;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n        if (lockLimit == 0 || lockLimit > temp.end", "debug": "calldata_TokenLockUp_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenLockUp_0: 0x3a03ce8700000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `lockBatch(address[],uint256[],uint256[],uint256[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "lockBatch(address[],uint256[],uint256[],uint256[])", "lineno": 404, "title": "Integer Overflow ", "type": "Warning"}, {"address": 10995, "code": "dev Adds two num", "debug": "The exception is triggered under the following conditions:\n\ncalldata_TokenLockUp_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenLockUp_0: 0x42966c6800000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "burn(uint256)", "lineno": 60, "title": "Exception state", "type": "Informational"}, {"address": 11012, "code": "ppelin-", "debug": "storage_1: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_TokenLockUp_32 + 4: 0x57f25cd000000000000000000000000000000000000000000000000000000000\ncalldata_TokenLockUp_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0x0\nstorage_3: 0x0\ncaller: 0x0\ncalldata_TokenLockUp_0: 0x40c10f1900000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `mint(address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "mint(address,uint256)", "lineno": 69, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11025, "code": "y/contracts/tok", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x1\ncalldata_TokenLockUp_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_TokenLockUp_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0x0\nstorage_3: 0x0\ncaller: 0x0\ncalldata_TokenLockUp_0: 0x40c10f1900000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "mint(address,uint256)", "lineno": 69, "title": "Exception state", "type": "Informational"}, {"address": 11732, "code": " address indexed to, uint256 amount, uint256 startTime, uint256 endTime);\n\n  constructor (uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n    require(_initialSupply >= 0);\n    require(_decimals >= 0);\n\n    totalSupply_ = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n    owner = msg.sender;\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n    emit Transfer(address(0), msg.sender, _initialSupply);\n  }\n\n  modifier checkLock (uint _amount) {\n    require(_amount >= 0);\n\n    // mapping\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[msg.sender];\n\n    uint256 lockAmountNow;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n      }\n    }\n\n    // \u73fe\u5728\u6642\u9593\u304cLOCK UP\u671f\u9593\u304b\u5224\u65ad\n    if (lockAmountNow == 0) {\n      // \u671f\u9593\u5916 => \u6240\u6709\u91cf\u3068\u6bd4\u8f03\n      require(balances[msg.sender] >= _amount);\n    } else {\n      // \u671f\u9593\u5185 => \u6240\u6709\u91cf - LOCK UP\u91cf \u3068\u6bd4\u8f03\n      require(balances[msg.sender].sub(lockAmountNow) >= _amount);\n    }\n    _;\n  }\n\n  function lockUp(address _to, uint256 _amount, uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\n    require(_to != address(0));\n    require(_amount >= 0);\n    require(_endTime >= 0);\n    require(_startTime < _endTime);\n\n    LockUp memory temp;\n    temp.lockamount = _amount;\n    temp.startTime = block.timestamp.add(_startTime);\n    temp.endTime = block.timestamp.add(_endTime);\n    addressLock[_to].push(temp);\n    emit Lock(msg.sender, _to, _amount, temp.startTime, temp.endTime);\n    return true;\n  }\n\n  function lockBatch(address[] _addresses, uint256[] _amounts, uint256[] _startTimes, uint256[] _endTimes) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length && _amounts.length == _startTimes.length && _startTimes.length == _endTimes.length);\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      lockUp(_addresses[i], _amounts[i], _startTimes[i], _endTimes[i]);\n    }\n    return true;\n  }\n\n  function getLockTime(address _to) public view returns (uint256, uint256) {\n    // mapping\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[_to];\n\n    uint256 lockAmountNow;\n    uint256 lockLimit;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n        if (lockLimit == 0 || lockLimit > temp.endTime) {\n          lockLimit = temp.endTime;\n        }\n      }\n    }\n    return (lockAmountNow, lockLimit);\n  }\n\n  function deleteLockTime(address _to) public onlyOwner returns (bool) {\n    require(_to != address(0));\n    \n    delete addressLock[_to];\n    return true;\n  }\n\n  function transfer(address _to, uint256 _value) public checkLock(_value) returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferBatch(address[] _addresses, uint256[] _amounts) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length);\n    uint256 sum;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      sum = sum + _amounts[i];\n    }\n    require(sum <= balances[msg.sender]);\n    for (uint256 j = 0; j < _amounts.length; j++) {\n      transfer(_addresses[j], _amounts[j]);\n    }\n    return true;\n  }\n\n  function transferWithLock(address _to, uint256 _value, uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n\n    lockUp(_to, _value, _startTime, _endTime);\n    return true;\n  }\n\n  function transferWithLockBatch(address[] _addresses, uint256[] _amounts, uint256[] _startTimes, uint256[] _endTimes) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length && _amounts.length == _startTimes.length && _startTimes.length == _endTimes.length);\n    uint256 sum;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      sum = sum + _amounts[i];\n    }\n    require(sum <= balances[msg.sender]);\n    for (uint256 j = 0; j < _amounts.length; j++) {\n      transferWithLock(_addresses[j], _amounts[j], _startTimes[j], _endTimes[j]);\n    }\n    return true;\n  }\n\n  /*** Mintable ***/\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n    require(_to != address(0));\n\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  function finishMinting() public onlyOwner canMint returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n\n  /*** Burnable ***/\n  event Burn(address indexed burner, uint256 value);\n\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenLockUp_4: 0xfefeeefeeeffffffffffffffffcc5ffe000001ee94fecc37e3ef3fdfff0000aa\ncalldata_TokenLockUp_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_TokenLockUp_0: 0x133311b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `deleteLockTime(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "deleteLockTime(address)", "lineno": 338, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11744, "code": " address indexed to, uint256 amount, uint256 startTime, uint256 endTime);\n\n  constructor (uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n    require(_initialSupply >= 0);\n    require(_decimals >= 0);\n\n    totalSupply_ = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n    owner = msg.sender;\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n    emit Transfer(address(0), msg.sender, _initialSupply);\n  }\n\n  modifier checkLock (uint _amount) {\n    require(_amount >= 0);\n\n    // mapping\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[msg.sender];\n\n    uint256 lockAmountNow;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n      }\n    }\n\n    // \u73fe\u5728\u6642\u9593\u304cLOCK UP\u671f\u9593\u304b\u5224\u65ad\n    if (lockAmountNow == 0) {\n      // \u671f\u9593\u5916 => \u6240\u6709\u91cf\u3068\u6bd4\u8f03\n      require(balances[msg.sender] >= _amount);\n    } else {\n      // \u671f\u9593\u5185 => \u6240\u6709\u91cf - LOCK UP\u91cf \u3068\u6bd4\u8f03\n      require(balances[msg.sender].sub(lockAmountNow) >= _amount);\n    }\n    _;\n  }\n\n  function lockUp(address _to, uint256 _amount, uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\n    require(_to != address(0));\n    require(_amount >= 0);\n    require(_endTime >= 0);\n    require(_startTime < _endTime);\n\n    LockUp memory temp;\n    temp.lockamount = _amount;\n    temp.startTime = block.timestamp.add(_startTime);\n    temp.endTime = block.timestamp.add(_endTime);\n    addressLock[_to].push(temp);\n    emit Lock(msg.sender, _to, _amount, temp.startTime, temp.endTime);\n    return true;\n  }\n\n  function lockBatch(address[] _addresses, uint256[] _amounts, uint256[] _startTimes, uint256[] _endTimes) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length && _amounts.length == _startTimes.length && _startTimes.length == _endTimes.length);\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      lockUp(_addresses[i], _amounts[i], _startTimes[i], _endTimes[i]);\n    }\n    return true;\n  }\n\n  function getLockTime(address _to) public view returns (uint256, uint256) {\n    // mapping\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[_to];\n\n    uint256 lockAmountNow;\n    uint256 lockLimit;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n        if (lockLimit == 0 || lockLimit > temp.endTime) {\n          lockLimit = temp.endTime;\n        }\n      }\n    }\n    return (lockAmountNow, lockLimit);\n  }\n\n  function deleteLockTime(address _to) public onlyOwner returns (bool) {\n    require(_to != address(0));\n    \n    delete addressLock[_to];\n    return true;\n  }\n\n  function transfer(address _to, uint256 _value) public checkLock(_value) returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferBatch(address[] _addresses, uint256[] _amounts) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length);\n    uint256 sum;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      sum = sum + _amounts[i];\n    }\n    require(sum <= balances[msg.sender]);\n    for (uint256 j = 0; j < _amounts.length; j++) {\n      transfer(_addresses[j], _amounts[j]);\n    }\n    return true;\n  }\n\n  function transferWithLock(address _to, uint256 _value, uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n\n    lockUp(_to, _value, _startTime, _endTime);\n    return true;\n  }\n\n  function transferWithLockBatch(address[] _addresses, uint256[] _amounts, uint256[] _startTimes, uint256[] _endTimes) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length && _amounts.length == _startTimes.length && _startTimes.length == _endTimes.length);\n    uint256 sum;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      sum = sum + _amounts[i];\n    }\n    require(sum <= balances[msg.sender]);\n    for (uint256 j = 0; j < _amounts.length; j++) {\n      transferWithLock(_addresses[j], _amounts[j], _startTimes[j], _endTimes[j]);\n    }\n    return true;\n  }\n\n  /*** Mintable ***/\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n    require(_to != address(0));\n\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  function finishMinting() public onlyOwner canMint returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n\n  /*** Burnable ***/\n  event Burn(address indexed burner, uint256 value);\n\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}", "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenLockUp_4: 0x510ca602c5308502644fa567c86c9b0ee05d7ba00178817e01147c6db0eb488e\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenLockUp_4: 0x4739d129bcd2b479cc8fc21cc7d8ee30aa138095240e41d5210928710ee4250f\ncalldata_TokenLockUp_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_TokenLockUp_0: 0x133311b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `deleteLockTime(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "deleteLockTime(address)", "lineno": 338, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11835, "code": " address indexed to, uint256 amount, uint256 startTime, uint256 endTime);\n\n  constructor (uint _initialSupply, string _name, string _symbol, uint _decimals) public {\n    require(_initialSupply >= 0);\n    require(_decimals >= 0);\n\n    totalSupply_ = _initialSupply;\n    balances[msg.sender] = _initialSupply;\n    owner = msg.sender;\n    name = _name;\n    symbol = _symbol;\n    decimals = _decimals;\n    emit Transfer(address(0), msg.sender, _initialSupply);\n  }\n\n  modifier checkLock (uint _amount) {\n    require(_amount >= 0);\n\n    // mapping\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[msg.sender];\n\n    uint256 lockAmountNow;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n      }\n    }\n\n    // \u73fe\u5728\u6642\u9593\u304cLOCK UP\u671f\u9593\u304b\u5224\u65ad\n    if (lockAmountNow == 0) {\n      // \u671f\u9593\u5916 => \u6240\u6709\u91cf\u3068\u6bd4\u8f03\n      require(balances[msg.sender] >= _amount);\n    } else {\n      // \u671f\u9593\u5185 => \u6240\u6709\u91cf - LOCK UP\u91cf \u3068\u6bd4\u8f03\n      require(balances[msg.sender].sub(lockAmountNow) >= _amount);\n    }\n    _;\n  }\n\n  function lockUp(address _to, uint256 _amount, uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\n    require(_to != address(0));\n    require(_amount >= 0);\n    require(_endTime >= 0);\n    require(_startTime < _endTime);\n\n    LockUp memory temp;\n    temp.lockamount = _amount;\n    temp.startTime = block.timestamp.add(_startTime);\n    temp.endTime = block.timestamp.add(_endTime);\n    addressLock[_to].push(temp);\n    emit Lock(msg.sender, _to, _amount, temp.startTime, temp.endTime);\n    return true;\n  }\n\n  function lockBatch(address[] _addresses, uint256[] _amounts, uint256[] _startTimes, uint256[] _endTimes) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length && _amounts.length == _startTimes.length && _startTimes.length == _endTimes.length);\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      lockUp(_addresses[i], _amounts[i], _startTimes[i], _endTimes[i]);\n    }\n    return true;\n  }\n\n  function getLockTime(address _to) public view returns (uint256, uint256) {\n    // mapping\u3092\u53d6\u5f97\n    LockUp[] storage lockData = addressLock[_to];\n\n    uint256 lockAmountNow;\n    uint256 lockLimit;\n    for (uint256 i = 0; i < lockData.length; i++) {\n      LockUp memory temp = lockData[i];\n\n      // \u30ed\u30c3\u30af\u671f\u9593\u5185\u3067\u6700\u5927\u306e\u30ed\u30c3\u30af\u91cf\u3092\u3082\u3064\u30ed\u30c3\u30af\u30c7\u30fc\u30bf\u3092\u53d6\u5f97\u3059\u308b\n      if (block.timestamp >= temp.startTime && block.timestamp < temp.endTime) {\n        lockAmountNow = lockAmountNow.add(temp.lockamount);\n        if (lockLimit == 0 || lockLimit > temp.endTime) {\n          lockLimit = temp.endTime;\n        }\n      }\n    }\n    return (lockAmountNow, lockLimit);\n  }\n\n  function deleteLockTime(address _to) public onlyOwner returns (bool) {\n    require(_to != address(0));\n    \n    delete addressLock[_to];\n    return true;\n  }\n\n  function transfer(address _to, uint256 _value) public checkLock(_value) returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n    return true;\n  }\n\n  function transferBatch(address[] _addresses, uint256[] _amounts) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length);\n    uint256 sum;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      sum = sum + _amounts[i];\n    }\n    require(sum <= balances[msg.sender]);\n    for (uint256 j = 0; j < _amounts.length; j++) {\n      transfer(_addresses[j], _amounts[j]);\n    }\n    return true;\n  }\n\n  function transferWithLock(address _to, uint256 _value, uint256 _startTime, uint256 _endTime) public onlyOwner returns (bool) {\n    require(_value <= balances[msg.sender]);\n    require(_to != address(0));\n\n    balances[msg.sender] = balances[msg.sender].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    emit Transfer(msg.sender, _to, _value);\n\n    lockUp(_to, _value, _startTime, _endTime);\n    return true;\n  }\n\n  function transferWithLockBatch(address[] _addresses, uint256[] _amounts, uint256[] _startTimes, uint256[] _endTimes) public onlyOwner returns (bool) {\n    require(_addresses.length == _amounts.length && _amounts.length == _startTimes.length && _startTimes.length == _endTimes.length);\n    uint256 sum;\n    for (uint256 i = 0; i < _amounts.length; i++) {\n      sum = sum + _amounts[i];\n    }\n    require(sum <= balances[msg.sender]);\n    for (uint256 j = 0; j < _amounts.length; j++) {\n      transferWithLock(_addresses[j], _amounts[j], _startTimes[j], _endTimes[j]);\n    }\n    return true;\n  }\n\n  /*** Mintable ***/\n  event Mint(address indexed to, uint256 amount);\n  event MintFinished();\n\n  bool public mintingFinished = false;\n\n  modifier canMint() {\n    require(!mintingFinished);\n    _;\n  }\n\n  function mint(address _to, uint256 _amount) public onlyOwner canMint returns (bool) {\n    require(_to != address(0));\n\n    totalSupply_ = totalSupply_.add(_amount);\n    balances[_to] = balances[_to].add(_amount);\n    emit Mint(_to, _amount);\n    emit Transfer(address(0), _to, _amount);\n    return true;\n  }\n\n  function finishMinting() public onlyOwner canMint returns (bool) {\n    mintingFinished = true;\n    emit MintFinished();\n    return true;\n  }\n\n  /*** Burnable ***/\n  event Burn(address indexed burner, uint256 value);\n\n  function burn(uint256 _value) public {\n    _burn(msg.sender, _value);\n  }\n\n  function _burn(address _who, uint256 _value) internal {\n    require(_value <= balances[_who]);\n\n    balances[_who] = balances[_who].sub(_value);\n    totalSupply_ = totalSupply_.sub(_value);\n    emit Burn(_who, _value);\n    emit Transfer(_who, address(0), _value);\n  }\n}", "debug": "keccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenLockUp_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenLockUp_4: 0xaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaab\ncalldata_TokenLockUp_4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_TokenLockUp_0: 0x133311b00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenLockUp: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `deleteLockTime(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/4/0xe45fc4290fd3159588f532058592ea327d2e97d4.sol", "function": "deleteLockTime(address)", "lineno": 338, "title": "Integer Overflow ", "type": "Warning"}], "success": true}