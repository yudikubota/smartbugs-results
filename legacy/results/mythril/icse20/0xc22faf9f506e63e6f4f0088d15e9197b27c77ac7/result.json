{
  "contract": "0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7",
  "tool": "mythril",
  "start": 1563486914.7087617,
  "end": 1563486956.9199247,
  "duration": 42.21116304397583,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 4729,
        "code": " * @param _name Name ot the token\n   * @param _startingPrice Price of item (in wei) at beginning of auction\n   * @param _endin",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/6/0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7.sol",
        "function": "createAuction(uint256,uint256,uint256,uint256)",
        "lineno": 447,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5461,
        "code": "ns (uint) {\n    return tokens.length;\n  }\n\n ",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function withdrawBalance(). The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/6/0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7.sol",
        "function": "withdrawBalance()",
        "lineno": 181,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 8954,
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ERC721_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_ERC721_4: 0x0\ncaller: 0x0\nstorage_keccac_calldata_ERC721_32_+_36: 0x0\ncalldata_ERC721_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncalldata_ERC721_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC721: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 615,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9170,
        "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_ERC721_4: 0x0\ncalldata_ERC721_4: 0xffffffffffffffffffffffffffffffffffffffff\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_calldata_ERC721_32_+_36: 0xffffffffffffffffffffffffffffffffffffffff00\ncalldata_ERC721_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncalldata_ERC721_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC721: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferFrom(address,address,uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/6/0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 615,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 9368,
        "code": ";\n\n\n/**\n * @title ",
        "debug": "storage_0: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_8: 0x383\nstorage_5: 0x0\ncaller: 0x0\ncalldata_ERC721_0: 0x5a9d27dc00000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC721: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createReleaseTokenAuction(string,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7.sol",
        "function": "createReleaseTokenAuction(string,uint256,uint256,uint256)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 9745,
        "code": "ress indexed owner,\n    uint256 indexed tokenId,\n    string name\n  );\n  event ContractUpgrade(address newContract);\n\n  struct Token {\n    string name;\n  }\n\n  // Name and symbol of ERC721 token\n  string public constant NAME = \"Curio\";\n  string public constant SYMBOL = \"CUR\";\n\n  // Array of token's data\n  Token[] tokens;\n\n  // A mapping from token IDs to the address that owns them\n  mapping (uint256 => address) public tokenIndexToOwner;\n\n  // A mapping from owner address to count of tokens that address owns\n  mapping (address => uint256) ownershipTokenCount;\n\n  // A mapping from token IDs to an address that has been approved\n  mapping (uint256 => address) public tokenIndexToApproved;\n\n  address public ownerAddress;\n  address public adminAddress;\n\n  bool public paused = false;\n\n  // The address of new contract when this contract was upgraded\n  address public newContractAddress;\n\n  // The address of CurioAuction contract that handles sales of tokens\n  CurioAuction public auction;\n\n  // Restriction on release of tokens\n  uint256 public constant TOTAL_SUPPLY_LIMIT = 900;\n\n  // Count of released tokens\n  uint256 public releaseCreatedCount;\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == ownerAddress);\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the admin.\n   */\n  modifier onlyAdmin() {\n    require(msg.sender == adminAddress);\n    _;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner or admin.\n   */\n  modifier onlyOwnerOrAdmin() {\n    require(\n      msg.sender == adminAddress ||\n      msg.sender == ownerAddress\n    );\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev Constructor function\n   */\n  constructor() public {\n    // Contract paused after start\n    paused = true;\n\n    // Set owner and admin addresses\n    ownerAddress = msg.sender;\n    adminAddress = msg.sender;\n  }\n\n\n  // -----------------------------------------\n  // External interface\n  // -----------------------------------------\n\n\n  /**\n   * @dev Check implementing ERC721 standard (needed in auction contract).\n   */\n  function implementsERC721() public pure returns (bool) {\n    return true;\n  }\n\n  /**\n   * @dev Default payable function rejects all Ether from being sent here, unless it's from auction contract.\n   */\n  function() external payable {\n    require(msg.sender == address(auction));\n  }\n\n  /**\n   * @dev Transfer all Ether from this contract to owner.\n   */\n  function withdrawBalance() external onlyOwner {\n    ownerAddress.transfer(address(this).balance);\n  }\n\n  /**\n   * @dev Returns the total number of tokens currently in existence.\n   */\n  function totalSupply() public view returns (uint) {\n    return tokens.length;\n  }\n\n  /**\n   * @dev Returns the number of tokens owned by a specific address.\n   * @param _owner The owner address to check\n   */\n  function balanceOf(address _owner) public view returns (uint256 count) {\n    return ownershipTokenCount[_owner];\n  }\n\n  /**\n   * @dev Returns the address currently assigned ownership of a given token.\n   * @param _tokenId The ID of the token\n   */\n  function ownerOf(uint256 _tokenId) external view returns (address owner) {\n    owner = tokenIndexToOwner[_tokenId];\n\n    require(owner != address(0));\n  }\n\n  /**\n   * @dev Returns information about token.\n   * @param _id The ID of the token\n   */\n  function getToken(uint256 _id) external view returns (string name) {\n    Token storage token = tokens[_id];\n\n    name = token.name;\n  }\n\n  /**\n   * @dev Set new owner address. Only available to the current owner.\n   * @param _newOwner The address of the new owner\n   */\n  function setOwner(address _newOwner) onlyOwner external {\n    require(_newOwner != address(0));\n\n    ownerAddress = _newOwner;\n  }\n\n  /**\n   * @dev Set new admin address. Only available to owner.\n   * @param _newAdmin The address of the new admin\n   */\n  function setAdmin(address _newAdmin) onlyOwner external {\n    require(_newAdmin != address(0));\n\n    adminAddress = _newAdmin;\n  }\n\n  /**\n   * @dev Set new auction price limit.\n   * @param _newAuctionPriceLimit Start and end price limit\n   */\n  function setAuctionPriceLimit(uint256 _newAuctionPriceLimit) onlyOwnerOrAdmin external {\n    auction.setAuctionPriceLimit(_newAuctionPriceLimit);\n  }\n\n  /**\n   * @dev Set the address of upgraded contract.\n   * @param _newContract Address of new contract\n   */\n  function setNewAddress(address _newContract) onlyOwner whenPaused external {\n    newContractAddress = _newContract;\n\n    emit ContractUpgrade(_newContract);\n  }\n\n  /**\n   * @dev Pause the contract. Called by owner or admin to pause the contract.\n   */\n  function pause() onlyOwnerOrAdmin whenNotPaused external {\n    paused = true;\n  }\n\n  /**\n   * @dev Unpause the contract. Can only be called by owner, since\n   *      one reason we may pause the contract is when admin account is\n   *      compromised. Requires auction contract addresses\n   *      to be set before contract can be unpaused. Also, we can't have\n   *      newContractAddress set either, because then the contract was upgraded.\n   */\n  function unpause() onlyOwner whenPaused public {\n    require(auction != address(0));\n    require(newContractAddress == address(0));\n\n    paused = false;\n  }\n\n  /**\n   * @dev Transfer a token to another address.\n   * @param _to The address of the recipient, can be a user or contract\n   * @param _tokenId The ID of the token to transfer\n   */\n  function transfer(\n    address _to,\n    uint256 _tokenId\n  )\n    whenNotPaused\n    external\n  {\n    // Safety check to prevent against an unexpected 0x0 default.\n    require(_to != address(0));\n\n    // Disallow transfers to this contract to prevent accidental misuse.\n    // The contract should never own any tokens (except very briefly\n    // after a release token is created and before it goes on auction).\n    require(_to != address(this));\n\n    // Disallow transfers to the auction contract to prevent accidental\n    // misuse. Auction contracts should only take ownership of tokens\n    // through the allow + transferFrom flow.\n    require(_to != address(auction));\n\n    // Check token ownership\n    require(_owns(msg.sender, _tokenId));\n\n    // Reassign ownership, clear pending approvals, emit Transfer event.\n    _transfer(msg.sender, _to, _tokenId);\n  }\n\n  /**\n   * @dev Grant another address the right to transfer a specific token via\n   *      transferFrom(). This is the preferred flow for transfering NFTs to contracts.\n   * @param _to The address to be granted transfer approval. Pass address(0) to\n   *            clear all approvals\n   * @param _tokenId The ID of the token that can be transferred if this call succeeds\n   */\n  function approve(\n    address _to,\n    uint256 _tokenId\n  )\n    whenNotPaused\n    external\n  {\n    // Only an owner can grant transfer approval.\n    require(_owns(msg.sender, _tokenId));\n\n    // Register the approval (replacing any previous approval).\n    _approve(_tokenId, _to);\n\n    // Emit approval event.\n    emit Approval(msg.sender, _to, _tokenId);\n  }\n\n  /**\n   * @dev Transfers a token owned by another address, for which the calling address\n   *      has previously been granted transfer approval by the owner.\n   * @param _from The address that owns the token to be transferred\n   * @param _to The address that should take ownership of the token. Can be any address,\n   *            including the caller\n   * @param _tokenId The ID of the token to be transferred\n   */\n  function transferFrom(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    whenNotPaused\n    external\n  {\n    // Safety check to prevent against an unexpected 0x0 default.\n    require(_to != address(0));\n\n    // Disallow transfers to this contract to prevent accidental misuse.\n    // The contract should never own any tokens (except very briefly\n    // after a release token is created and before it goes on auction).\n    require(_to != address(this));\n\n    // Check for approval and valid ownership\n    require(_approvedFor(msg.sender, _tokenId));\n    require(_owns(_from, _tokenId));\n\n    // Reassign ownership (also clears pending approvals and emits Transfer event).\n    _transfer(_from, _to, _tokenId);\n  }\n\n  /**\n   * @dev Returns a list of all tokens assigned to an address.\n   * @param _owner The owner whose tokens we are interested in\n   * @notice This method MUST NEVER be called by smart contract code. First, it's fairly\n   *         expensive (it walks the entire token array looking for tokens belonging to owner),\n   *         but it also returns a dynamic array, which is only supported for web3 calls, and\n   *         not contract-to-contract calls.\n   */\n  function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) {\n    uint256 tokenCount = balanceOf(_owner);\n\n    if (tokenCount == 0) {\n      // Return an empty array\n      return new uint256[](0);\n    } else {\n      uint256[] memory result = new uint256[](tokenCount);\n      uint256 totalTokens = totalSupply();\n      uint256 resultIndex = 0;\n\n      uint256 tokenId;\n\n      for (tokenId = 0; tokenId <= totalTokens; tokenId++) {\n        if (tokenIndexToOwner[tokenId] == _owner) {\n          result[resultIndex] = tokenId;\n          resultIndex++;\n        }\n      }\n\n      return result;\n    }\n  }\n\n  /**\n   * @dev Set the reference to the auction contract.\n   * @param _address Address of auction contract\n   */\n  function setAuctionAddress(address _address) onlyOwner external {\n    CurioAuction candidateContract = CurioAuction(_address);\n\n    require(candidateContract.isCurioAuction());\n\n    // Set the new contract address\n    auction = candidateContract;\n  }\n\n  /**\n   * @dev Put a token up for auction.\n   * @param _tokenId ID of token to auction, sender must be owner\n   * @param _startingPrice Price of item (in wei) at beginning of auction\n   * @param _endingPrice Price of item (in wei) at end of auction\n   * @param _duration Length of auction (in seconds)\n   */\n  function createAuction(\n    uint256 _tokenId,\n    uint256 _startingPrice,\n    uint256 _endingPrice,\n    uint256 _duration\n  )\n    whenNotPaused\n    external\n  {\n    // Auction contract checks input sizes\n    // If token is already on any auction, this will throw because it will be owned by the auction contract\n    require(_owns(msg.sender, _tokenId));\n\n    // Set auction contract as approved for token\n    _approve(_tokenId, auction);\n\n    // Sale auction throws if inputs are invalid\n    auction.createAuction(\n      _tokenId,\n      _startingPrice,\n      _endingPrice,\n      _duration,\n      msg.sender\n    );\n  }\n\n  /**\n   * @dev Transfers the balance of the auction contract to this contract by owner or admin.\n   */\n  function withdrawAuctionBalance() onlyOwnerOrAdmin external {\n    auction.withdrawBalance();\n  }\n\n  /**\n   * @dev Creates a new release token with the given name and creates an auction for it.\n   * @param _name Name ot the token\n   * @param _startingPrice Price of item (in wei) at beginning of auction\n   * @param _endingPrice Price of item (in wei) at end of auction\n   * @param _duration Length of auction (in seconds)\n   */\n  function createReleaseTokenAuction(\n    string _name,\n    uint256 _startingPrice,\n    uint256 _endingPrice,\n    uint256 _duration\n  )\n    onlyAdmin\n    external\n  {\n    // Check release tokens limit\n    require(releaseCreatedCount < TOTAL_SUPPLY_LIMIT);\n\n    // Create token and tranfer ownership to this contract\n    uint256 tokenId = _createToken(_name, address(this));\n\n    // Set auction address as approved for release token\n    _approve(tokenId, auction);\n\n    // Call createAuction in auction contract\n    auction.createAuction(\n      tokenId,\n      _startingPrice,\n      _endingPrice,\n      _duration,\n      address(this)\n    );\n\n    releaseCreatedCount++;\n  }\n\n  /**\n   * @dev Creates free token and transfer it to recipient.\n   * @param _name Name of the token\n   * @param _to The address of the recipient, can be a user or contract\n   */\n  function createFreeToken(\n    string _name,\n    address _to\n  )\n    onlyAdmin\n    external\n  {\n    require(_to != address(0));\n    require(_to != address(this));\n    require(_to != address(auction));\n\n    // Check release tokens limit\n    require(releaseCreatedCount < TOTAL_SUPPLY_LIMIT);\n\n    // Create token and transfer to owner\n    _createToken(_name, _to);\n\n    releaseCreatedCount++;\n  }\n\n\n  // -----------------------------------------\n  // Internal interface\n  // -----------------------------------------\n\n\n  /**\n   * @dev Create a new token and stores it.\n   * @param _name Token name\n   * @param _owner The initial owner of this token, must be non-zero\n   */\n  function _createToken(\n    string _name,\n    address _owner\n  )\n    internal\n    returns (uint)\n  {\n    Token memory _token = Token({\n      name: _name\n    });\n\n    uint256 newTokenId = tokens.push(_token) - 1;\n\n    // Check overflow newTokenId\n    require(newTokenId == uint256(uint32(newTokenId)));\n\n    emit Create(_owner, newTokenId, _name);\n\n    // This will assign ownership\n    _transfer(0, _owner, newTokenId);\n\n    return newTokenId;\n  }\n\n  /**\n   * @dev Check claimant address as token owner.\n   * @param _claimant The address we are validating against\n   * @param _tokenId Token id, only valid when > 0\n   */\n  function _owns(\n    address _claimant,\n    uint256 _tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    return tokenIndexToOwner[_tokenId] == _claimant;\n  }\n\n  /**\n   * @dev Check if a given address currently has transferApproval for a particular token.\n   * @param _claimant The address we are confirming token is approved for\n   * @param _tokenId Token id, only valid when > 0\n   */\n  function _approvedFor(\n    address _claimant,\n    uint256 _tokenId\n  )\n    internal\n    view\n    returns (bool)\n  {\n    return tokenIndexToApproved[_tokenId] == _claimant;\n  }\n\n  /**\n   * @dev Marks an address as being approved for transferFrom().\n   *      Setting _approved to address(0) clears all transfer approval.\n   *      NOTE: _approve() does NOT send the Approval event. This is intentional because\n   *      _approve() and transferFrom() are used together for putting tokens on auction, and\n   *      there is no value in spamming the log with Approval events in that case.\n   */\n  function _approve(\n    uint256 _tokenId,\n    address _approved\n  )\n    internal\n  {\n    tokenIndexToApproved[_tokenId] = _approved;\n  }\n\n  /**\n   * @dev Assigns ownership of a specific token to an address.\n   */\n  function _transfer(\n    address _from,\n    address _to,\n    uint256 _tokenId\n  )\n    internal\n  {\n    ownershipTokenCount[_to]++;\n\n    // Transfer ownership\n    tokenIndexToOwner[_tokenId] = _to;\n\n    // When creating new token _from is 0x0, but we can't account that address\n    if (_from != address(0)) {\n      ownershipTokenCount[_from]--;\n\n      // Clear any previously approved ownership exchange\n      delete tokenIndexToApproved[_tokenId];\n    }\n\n    emit Transfer(_from, _to, _tokenId);\n  }\n}",
        "debug": "mem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_ERC721_4 + calldata_ERC721_4)) +\n0: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_8: 0x383\nstorage_5: 0x0\ncaller: 0x0\ncalldata_ERC721_0: 0x5a9d27dc00000000000000000000000000000000000000000000000000000000\ncalldatasize_ERC721: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `createReleaseTokenAuction(string,uint256,uint256,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/6/0xc22faf9f506e63e6f4f0088d15e9197b27c77ac7.sol",
        "function": "createReleaseTokenAuction(string,uint256,uint256,uint256)",
        "lineno": 53,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}