{"error": null, "issues": [{"address": 4501, "code": "equest before.\n   */\n  function approveRem", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfd77ef6e00\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff06081c91\nstorage_23: 0xfa7f540e00\ntimestamp: 0x3800c00\ncalldata_TokenContract_0: 0x2a75cb7100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x2a75cb71`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x2a75cb71", "lineno": 481, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5928, "code": ";\n  }\n  \n  /**\n   * @", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x2e4bd18a", "lineno": 222, "title": "Message call to external contract", "type": "Informational"}, {"address": 5978, "code": "l finish minting request, can be cal", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x2e4bd18a", "lineno": 226, "title": "State change after external call", "type": "Warning"}, {"address": 6005, "code": " owner\n   * which crea", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x2e4bd18a", "lineno": 226, "title": "State change after external call", "type": "Warning"}, {"address": 6458, "code": "e call only by owner\n   * which don't cal", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfd77ef6e00\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff06081c91\nstorage_20: 0xfa7f540e00\ntimestamp: 0x3800c00\ncalldata_TokenContract_0: 0x3a253cee00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x3a253cee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x3a253cee", "lineno": 412, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8015, "code": "Execute);\n\n  ", "debug": "storage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_6: 0x0\nstorage_17: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_16,_256): 0x0\nstorage_1: 0x0\ntimestamp: 0x0\nstorage_16: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_TokenContract_0: 0x45448a2800000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenContract: 0x4\nstorage_18: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x45448a28`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x45448a28", "lineno": 381, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8633, "code": "dr);\n    setNewApproves.confirmators.push(m", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfd77ef6e00\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffff06081c91\nstorage_14: 0xfa7f540e00\ntimestamp: 0x3800c00\ncalldata_TokenContract_0: 0x4b1325ea00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x4b1325ea`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x4b1325ea", "lineno": 267, "title": "Integer Overflow ", "type": "Warning"}, {"address": 20027, "code": "tisig {\n  \n  /**\n   *@dev token contract variable, contains token address\n   *can use abstract contract functions\n  */\n  TokenContract public token;\n\n  //@dev Variable to check multisig functions life time.\n  //change it before deploy in main network\n  uint public lifeTime = 86400; // seconds;\n  \n  //@dev constructor\n  constructor (address _token, uint _needApprovesToConfirm, address[] _owners) public{\n    require (_needApprovesToConfirm > 1 && _needApprovesToConfirm <= _owners.length);\n    \n    //@dev setup GangTokenContract by contract address\n    token = TokenContract(_token);\n\n    addInitialOwners(_owners);\n\n    needApprovesToConfirm = _needApprovesToConfirm;\n\n    /**\n     *@dev Call function setupMultisig in token contract\n     *This function can be call once.\n    */\n    token.setupMultisig(address(this));\n    \n    ownersCount = _owners.length;\n  }\n\n  /**\n   *@dev internal function, called in constructor\n   *Add initial owners in mapping 'owners'\n  */\n  function addInitialOwners (address[] _owners) internal {\n    for (uint i = 0; i < _owners.length; i++){\n      //@dev check for duplicate owner addresses\n      require(!owners[_owners[i]]);\n      owners[_owners[i]] = true;\n    }\n  }\n\n  //@dev variable to check is minting finished;\n  bool public mintingFinished = false;\n\n  //@dev Mapping which contains all active owners.\n  mapping (address => bool) public owners;\n\n  //@dev Owner can add new proposal 1 time at each lifeTime cycle\n  mapping (address => uint32) public lastOwnersAction;\n  \n  modifier canCreate() { \n    require (lastOwnersAction[msg.sender] + lifeTime < now);\n    lastOwnersAction[msg.sender] = uint32(now);\n    _; \n  }\n  \n\n  //@dev Modifier to check is message sender contains in mapping 'owners'.\n  modifier onlyOwners() { \n    require (owners[msg.sender]); \n    _; \n  }\n\n  //@dev current owners count\n  uint public ownersCount;\n\n  //@dev current approves need to confirm for any function. Can't be less than 2. \n  uint public needApprovesToConfirm;\n\n  //Start Minting Tokens\n  struct SetNewMint {\n    address spender;\n    uint value;\n    uint8 confirms;\n    bool isExecute;\n    address initiator;\n    bool isCanceled;\n    uint32 creationTimestamp;\n    address[] confirmators;\n  }\n\n  //@dev Variable which contains all information about current SetNewMint request\n  SetNewMint public setNewMint;\n\n  event NewMintRequestSetup(address indexed initiator, address indexed spender, uint value);\n  event NewMintRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\n  event NewMintRequestCanceled();  \n\n  /**\n   * @dev Set new mint request, can be call only by owner\n   * @param _spender address The address which you want to mint to\n   * @param _value uint256 the amount of tokens to be minted\n   */\n  function setNewMintRequest (address _spender, uint _value) public onlyOwners canCreate {\n    require (setNewMint.creationTimestamp + lifeTime < uint32(now) || setNewMint.isExecute || setNewMint.isCanceled);\n\n    require (!mintingFinished);\n\n    address[] memory addr;\n\n    setNewMint = SetNewMint(_spender, _value, 1, false, msg.sender, false, uint32(now), addr);\n    setNewMint.confirmators.push(msg.sender);\n\n    emit NewMintRequestSetup(msg.sender, _spender, _value);\n  }\n\n  /**\n   * @dev Approve mint request, can be call only by owner\n   * which don't call this mint request before.\n   */\n  function approveNewMintRequest () public onlyOwners {\n    require (!setNewMint.isExecute && !setNewMint.isCanceled);\n    require (setNewMint.creationTimestamp + lifeTime >= uint32(now));\n\n    require (!mintingFinished);\n\n    for (uint i = 0; i < setNewMint.confirmators.length; i++){\n      require(setNewMint.confirmators[i] != msg.sender);\n    }\n      \n    setNewMint.confirms++;\n    setNewMint.confirmators.push(msg.sender);\n\n    if(setNewMint.confirms >= needApprovesToConfirm){\n      setNewMint.isExecute = true;\n\n      token.mint(setNewMint.spender, setNewMint.value); \n    }\n    emit NewMintRequestUpdate(msg.sender, setNewMint.confirms, setNewMint.isExecute);\n  }\n\n  /**\n   * @dev Cancel mint request, can be call only by owner\n   * which created this mint request.\n   */\n  function cancelMintRequest () public {\n    require (msg.sender == setNewMint.initiator);    \n    require (!setNewMint.isCanceled && !setNewMint.isExecute);\n\n    setNewMint.isCanceled = true;\n    emit NewMintRequestCanceled();\n  }\n  //Finish Minting Tokens\n\n  //Start finishMinting functions\n  struct FinishMintingStruct {\n    uint8 confirms;\n    bool isExecute;\n    address initiator;\n    bool isCanceled;\n    uint32 creationTimestamp;\n    address[] confirmators;\n  }\n\n  //@dev Variable which contains all information about current finishMintingStruct request\n  FinishMintingStruct public finishMintingStruct;\n\n  event FinishMintingRequestSetup(address indexed initiator);\n  event FinishMintingRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\n  event FinishMintingRequestCanceled();\n  event FinishMintingApproveCanceled(address owner);\n\n  /**\n   * @dev New finish minting request, can be call only by owner\n   */\n  function finishMintingRequestSetup () public onlyOwners canCreate{\n    require ((finishMintingStruct.creationTimestamp + lifeTime < uint32(now) || finishMintingStruct.isCanceled) && !finishMintingStruct.isExecute);\n    \n    require (!mintingFinished);\n\n    address[] memory addr;\n\n    finishMintingStruct = FinishMintingStruct(1, false, msg.sender, false, uint32(now), addr);\n    finishMintingStruct.confirmators.push(msg.sender);\n\n    emit FinishMintingRequestSetup(msg.sender);\n  }\n\n  /**\n   * @dev Approve finish minting request, can be call only by owner\n   * which don't call this finish minting request before.\n   */\n  function ApproveFinishMintingRequest () public onlyOwners {\n    require (!finishMintingStruct.isCanceled && !finishMintingStruct.isExecute);\n    require (finishMintingStruct.creationTimestamp + lifeTime >= uint32(now));\n\n    require (!mintingFinished);\n\n    for (uint i = 0; i < finishMintingStruct.confirmators.length; i++){\n      require(finishMintingStruct.confirmators[i] != msg.sender);\n    }\n\n    finishMintingStruct.confirmators.push(msg.sender);\n\n    finishMintingStruct.confirms++;\n\n    if(finishMintingStruct.confirms >= needApprovesToConfirm){\n      token.finishMinting();\n      finishMintingStruct.isExecute = true;\n      mintingFinished = true;\n    }\n    \n    emit FinishMintingRequestUpdate(msg.sender, finishMintingStruct.confirms, finishMintingStruct.isExecute);\n  }\n  \n  /**\n   * @dev Cancel finish minting request, can be call only by owner\n   * which created this finish minting request.\n   */\n  function cancelFinishMintingRequest () public {\n    require (msg.sender == finishMintingStruct.initiator);\n    require (!finishMintingStruct.isCanceled);\n\n    finishMintingStruct.isCanceled = true;\n    emit FinishMintingRequestCanceled();\n  }\n  //Finish finishMinting functions\n\n  //Start change approves count\n  struct SetNewApproves {\n    uint count;\n    uint8 confirms;\n    bool isExecute;\n    address initiator;\n    bool isCanceled;\n    uint32 creationTimestamp;\n    address[] confirmators;\n  }\n\n  //@dev Variable which contains all information about current setNewApproves request\n  SetNewApproves public setNewApproves;\n\n  event NewNeedApprovesToConfirmRequestSetup(address indexed initiator, uint count);\n  event NewNeedApprovesToConfirmRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\n  event NewNeedApprovesToConfirmRequestCanceled();\n\n  /**\n   * @dev Function to change 'needApprovesToConfirm' variable, can be call only by owner\n   * @param _count uint256 New need approves to confirm will needed\n   */\n  function setNewOwnersCountToApprove (uint _count) public onlyOwners canCreate {\n    require (setNewApproves.creationTimestamp + lifeTime < uint32(now) || setNewApproves.isExecute || setNewApproves.isCanceled);\n\n    require (_count > 1);\n\n    address[] memory addr;\n\n    setNewApproves = SetNewApproves(_count, 1, false, msg.sender,false, uint32(now), addr);\n    setNewApproves.confirmators.push(msg.sender);\n\n    emit NewNeedApprovesToConfirmRequestSetup(msg.sender, _count);\n  }\n\n  /**\n   * @dev Approve new owners count request, can be call only by owner\n   * which don't call this new owners count request before.\n   */\n  function approveNewOwnersCount () public onlyOwners {\n    require (setNewApproves.count <= ownersCount);\n    require (setNewApproves.creationTimestamp + lifeTime >= uint32(now));\n    \n    for (uint i = 0; i < setNewApproves.confirmators.length; i++){\n      require(setNewApproves.confirmators[i] != msg.sender);\n    }\n    \n    require (!setNewApproves.isExecute && !setNewApproves.isCanceled);\n    \n    setNewApproves.confirms++;\n    setNewApproves.confirmators.push(msg.sender);\n\n    if(setNewApproves.confirms >= needApprovesToConfirm){\n      setNewApproves.isExecute = true;\n\n      needApprovesToConfirm = setNewApproves.count;   \n    }\n    emit NewNeedApprovesToConfirmRequestUpdate(msg.sender, setNewApproves.confirms, setNewApproves.isExecute);\n  }\n\n  /**\n   * @dev Cancel new owners count request, can be call only by owner\n   * which created this owners count request.\n   */\n  function cancelNewOwnersCountRequest () public {\n    require (msg.sender == setNewApproves.initiator);    \n    require (!setNewApproves.isCanceled && !setNewApproves.isExecute);\n\n    setNewApproves.isCanceled = true;\n    emit NewNeedApprovesToConfirmRequestCanceled();\n  }\n  \n  //Finish change approves count\n\n  //Start add new owner\n  struct NewOwner {\n    address newOwner;\n    uint8 confirms;\n    bool isExecute;\n    address initiator;\n    bool isCanceled;\n    uint32 creationTimestamp;\n    address[] confirmators;\n  }\n\n  NewOwner public addOwner;\n  //@dev Variable which contains all information about current addOwner request\n\n  event AddOwnerRequestSetup(address indexed initiator, address newOwner);\n  event AddOwnerRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\n  event AddOwnerRequestCanceled();\n\n  /**\n   * @dev Function to add new owner in mapping 'owners', can be call only by owner\n   * @param _newOwner address new potentially owner\n   */\n  function setAddOwnerRequest (address _newOwner) public onlyOwners canCreate {\n    require (addOwner.creationTimestamp + lifeTime < uint32(now) || addOwner.isExecute || addOwner.isCanceled);\n    \n    address[] memory addr;\n\n    addOwner = NewOwner(_newOwner, 1, false, msg.sender, false, uint32(now), addr);\n    addOwner.confirmators.push(msg.sender);\n\n    emit AddOwnerRequestSetup(msg.sender, _newOwner);\n  }\n\n  /**\n   * @dev Approve new owner request, can be call only by owner\n   * which don't call this new owner request before.\n   */\n  function approveAddOwnerRequest () public onlyOwners {\n    require (!addOwner.isExecute && !addOwner.isCanceled);\n    require (addOwner.creationTimestamp + lifeTime >= uint32(now));\n\n    /**\n     *@dev new owner shoudn't be in owners mapping\n     */\n    require (!owners[addOwner.newOwner]);\n\n    for (uint i = 0; i < addOwner.confirmators.length; i++){\n      require(addOwner.confirmators[i] != msg.sender);\n    }\n    \n    addOwner.confirms++;\n    addOwner.confirmators.push(msg.sender);\n\n    if(addOwner.confirms >= needApprovesToConfirm){\n      addOwner.isExecute = true;\n\n      owners[addOwner.newOwner] = true;\n      ownersCount++;\n    }\n\n    emit AddOwnerRequestUpdate(msg.sender, addOwner.confirms, addOwner.isExecute);\n  }\n\n  /**\n   * @dev Cancel new owner request, can be call only by owner\n   * which created this add owner request.\n   */\n  function cancelAddOwnerRequest() public {\n    require (msg.sender == addOwner.initiator);\n    require (!addOwner.isCanceled && !addOwner.isExecute);\n\n    addOwner.isCanceled = true;\n    emit AddOwnerRequestCanceled();\n  }\n  //Finish add new owner\n\n  //Start remove owner\n  NewOwner public removeOwners;\n  //@dev Variable which contains all information about current removeOwners request\n\n  event RemoveOwnerRequestSetup(address indexed initiator, address newOwner);\n  event RemoveOwnerRequestUpdate(address indexed owner, uint8 indexed confirms, bool isExecute);\n  event RemoveOwnerRequestCanceled();\n\n  /**\n   * @dev Function to remove owner from mapping 'owners', can be call only by owner\n   * @param _removeOwner address potentially owner to remove\n   */\n  function removeOwnerRequest (address _removeOwner) public onlyOwners canCreate {\n    require (removeOwners.creationTimestamp + lifeTime < uint32(now) || removeOwners.isExecute || removeOwners.isCanceled);\n\n    address[] memory addr;\n    \n    removeOwners = NewOwner(_removeOwner, 1, false, msg.sender, false, uint32(now), addr);\n    removeOwners.confirmators.push(msg.sender);\n\n    emit RemoveOwnerRequestSetup(msg.sender, _removeOwner);\n  }\n\n  /**\n   * @dev Approve remove owner request, can be call only by owner\n   * which don't call this remove owner request before.\n   */\n  function approveRemoveOwnerRequest () public onlyOwners {\n    require (ownersCount - 1 >= needApprovesToConfirm && ownersCount > 2);\n\n    require (owners[removeOwners.newOwner]);\n    \n    require (!removeOwners.isExecute && !removeOwners.isCanceled);\n    require (removeOwners.creationTimestamp + lifeTime >= uint32(now));\n\n    for (uint i = 0; i < removeOwners.confirmators.length; i++){\n      require(removeOwners.confirmators[i] != msg.sender);\n    }\n    \n    removeOwners.confirms++;\n    removeOwners.confirmators.push(msg.sender);\n\n    if(removeOwners.confirms >= needApprovesToConfirm){\n      removeOwners.isExecute = true;\n\n      owners[removeOwners.newOwner] = false;\n      ownersCount--;\n\n      _removeOwnersAproves(removeOwners.newOwner);\n    }\n\n    emit RemoveOwnerRequestUpdate(msg.sender, removeOwners.confirms, removeOwners.isExecute);\n  }\n\n  \n  /**\n   * @dev Cancel remove owner request, can be call only by owner\n   * which created this remove owner request.\n   */\n  function cancelRemoveOwnerRequest () public {\n    require (msg.sender == removeOwners.initiator);    \n    require (!removeOwners.isCanceled && !removeOwners.isExecute);\n\n    removeOwners.isCanceled = true;\n    emit RemoveOwnerRequestCanceled();\n  }\n  //Finish remove owner\n\n  //Start remove 2nd owner\n  NewOwner public removeOwners2;\n  //@dev Variable which contains all information about current removeOwners request\n\n  event RemoveOwnerRequestSetup2(address indexed initiator, address newOwner);\n  event RemoveOwnerRequestUpdate2(address indexed owner, uint8 indexed confirms, bool isExecute);\n  event RemoveOwnerRequestCanceled2();\n\n  /**\n   * @dev Function to remove owner from mapping 'owners', can be call only by owner\n   * @param _removeOwner address potentially owner to remove\n   */\n  function removeOwnerRequest2 (address _removeOwner) public onlyOwners canCreate {\n    require (removeOwners2.creationTimestamp + lifeTime < uint32(now) || removeOwners2.isExecute || removeOwners2.isCanceled);\n\n    address[] memory addr;\n    \n    removeOwners2 = NewOwner(_removeOwner, 1, false, msg.sender, false, uint32(now), addr);\n    removeOwners2.confirmators.push(msg.sender);\n\n    emit RemoveOwnerRequestSetup2(msg.sender, _removeOwner);\n  }\n\n  /**\n   * @dev Approve remove owner request, can be call only by owner\n   * which don't call this remove owner request before.\n   */\n  function approveRemoveOwnerRequest2 () public onlyOwners {\n    require (ownersCount - 1 >= needApprovesToConfirm && ownersCount > 2);\n\n    require (owners[removeOwners2.newOwner]);\n    \n    require (!removeOwners2.isExecute && !removeOwners2.isCanceled);\n    require (removeOwners2.creationTimestamp + lifeTime >= uint32(now));\n\n    for (uint i = 0; i < removeOwners2.confirmators.length; i++){\n      require(removeOwners2.confirmators[i] != msg.sender);\n    }\n    \n    removeOwners2.confirms++;\n    removeOwners2.confirmators.push(msg.sender);\n\n    if(removeOwners2.confirms >= needApprovesToConfirm){\n      removeOwners2.isExecute = true;\n\n      owners[removeOwners2.newOwner] = false;\n      ownersCount--;\n\n      _removeOwnersAproves(removeOwners2.newOwner);\n    }\n\n    emit RemoveOwnerRequestUpdate2(msg.sender, removeOwners2.confirms, removeOwners2.isExecute);\n  }\n\n  /**\n   * @dev Cancel remove owner request, can be call only by owner\n   * which created this remove owner request.\n   */\n  function cancelRemoveOwnerRequest2 () public {\n    require (msg.sender == removeOwners2.initiator);    \n    require (!removeOwners2.isCanceled && !removeOwners2.isExecute);\n\n    removeOwners2.isCanceled = true;\n    emit RemoveOwnerRequestCanceled2();\n  }\n  //Finish remove 2nd owner\n\n  /**\n   * @dev internal function to check and revert all actions\n   * by removed owner in this contract.\n   * If _oldOwner created request then it will be canceled.\n   * If _oldOwner approved request then his approve will canceled.\n   */\n  function _removeOwnersAproves(address _oldOwner) internal{\n    //@dev check actions in setNewMint requests\n    //@dev check for empty struct\n    if (setNewMint.initiator != address(0)){\n      //@dev check, can this request be approved by someone, if no then no sense to change something\n      if (setNewMint.creationTimestamp + lifeTime >= uint32(now) && !setNewMint.isExecute && !setNewMint.isCanceled){\n        if(setNewMint.initiator == _oldOwner){\n          setNewMint.isCanceled = true;\n          emit NewMintRequestCanceled();\n        }else{\n          //@dev Trying to find _oldOwner in struct confirmators\n          for (uint i = 0; i < setNewMint.confirmators.length; i++){\n            if (setNewMint.confirmators[i] == _oldOwner){\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\n              setNewMint.confirmators[i] = address(0);\n              setNewMint.confirms--;\n\n              /**\n               *@dev Struct can be confirmed each owner just once\n               *so no sence to continue loop\n               */\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    /**@dev check actions in finishMintingStruct requests\n     * check for empty struct\n     */\n    if (finishMintingStruct.initiator != address(0)){\n      //@dev check, can this request be approved by someone, if no then no sense to change something\n      if (finishMintingStruct.creationTimestamp + lifeTime >= uint32(now) && !finishMintingStruct.isExecute && !finishMintingStruct.isCanceled){\n        if(finishMintingStruct.initiator == _oldOwner){\n          finishMintingStruct.isCanceled = true;\n          emit NewMintRequestCanceled();\n        }else{\n          //@dev Trying to find _oldOwner in struct confirmators\n          for (i = 0; i < finishMintingStruct.confirmators.length; i++){\n            if (finishMintingStruct.confirmators[i] == _oldOwner){\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\n              finishMintingStruct.confirmators[i] = address(0);\n              finishMintingStruct.confirms--;\n\n              /**\n               *@dev Struct can be confirmed each owner just once\n               *so no sence to continue loop\n               */\n              break;\n            }\n          }\n        }     \n      }\n    }\n\n    /**@dev check actions in setNewApproves requests\n     * check for empty struct\n     */\n    if (setNewApproves.initiator != address(0)){\n      //@dev check, can this request be approved by someone, if no then no sense to change something\n      if (setNewApproves.creationTimestamp + lifeTime >= uint32(now) && !setNewApproves.isExecute && !setNewApproves.isCanceled){\n        if(setNewApproves.initiator == _oldOwner){\n          setNewApproves.isCanceled = true;\n\n          emit NewNeedApprovesToConfirmRequestCanceled();\n        }else{\n          //@dev Trying to find _oldOwner in struct confirmators\n          for (i = 0; i < setNewApproves.confirmators.length; i++){\n            if (setNewApproves.confirmators[i] == _oldOwner){\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\n              setNewApproves.confirmators[i] = address(0);\n              setNewApproves.confirms--;\n\n              /**\n               *@dev Struct can be confirmed each owner just once\n               *so no sence to continue loop\n               */\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    /**\n     *@dev check actions in addOwner requests\n     *check for empty struct\n     */\n    if (addOwner.initiator != address(0)){\n      //@dev check, can this request be approved by someone, if no then no sense to change something\n      if (addOwner.creationTimestamp + lifeTime >= uint32(now) && !addOwner.isExecute && !addOwner.isCanceled){\n        if(addOwner.initiator == _oldOwner){\n          addOwner.isCanceled = true;\n          emit AddOwnerRequestCanceled();\n        }else{\n          //@dev Trying to find _oldOwner in struct confirmators\n          for (i = 0; i < addOwner.confirmators.length; i++){\n            if (addOwner.confirmators[i] == _oldOwner){\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\n              addOwner.confirmators[i] = address(0);\n              addOwner.confirms--;\n\n              /**\n               *@dev Struct can be confirmed each owner just once\n               *so no sence to continue loop\n               */\n              break;\n            }\n          }\n        }\n      }\n    }\n\n    /**@dev check actions in removeOwners requests\n     *@dev check for empty struct\n    */\n    if (removeOwners.initiator != address(0)){\n      //@dev check, can this request be approved by someone, if no then no sense to change something\n      if (removeOwners.creationTimestamp + lifeTime >= uint32(now) && !removeOwners.isExecute && !removeOwners.isCanceled){\n        if(removeOwners.initiator == _oldOwner){\n          removeOwners.isCanceled = true;\n          emit RemoveOwnerRequestCanceled();\n        }else{\n          //@dev Trying to find _oldOwner in struct confirmators\n          for (i = 0; i < removeOwners.confirmators.length; i++){\n            if (removeOwners.confirmators[i] == _oldOwner){\n              //@dev if _oldOwner confirmed this request he should be removed from confirmators\n              removeOwners.confirmators[i] = address(0);\n              removeOwners.confirms--;\n\n              /**\n               *@dev Struct can be confirmed each owner just once\n               *so no sence to continue loop\n               */\n              break;\n            }\n          }\n        }\n      }\n    }\n  }\n}", "debug": "storage_21: 0xffcfffff9fffffe84048a8020007c9001ff3fffffffffffffffffffffff9ffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xfbfffdff00\ntimestamp: 0x10000000000000000100000000\nstorage_20: 0xfbffffff00\nstorage_1: 0xc003ffffff\nstorage_19: 0x0\ncalldata_TokenContract_0: 0x3a253cee00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenContract: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x3a253cee`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/27/0x03e69cb57d951d9b123145f5e458153c19f57c88.sol", "function": "_function_0x3a253cee", "lineno": 17, "title": "Integer Overflow ", "type": "Warning"}], "success": true}