{
  "contract": "0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1",
  "tool": "mythril",
  "start": 1563587103.0765243,
  "end": 1563587377.5644646,
  "duration": 274.4879403114319,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 1062,
        "code": "wName)\n    public\n    onlyOwner {\n        giftTemplateStorageArry[templateId].giftPrice = _newPrice;\n        giftTemplateStorageArry[templateId].giftLimit = _newlimit;\n        giftTemplateStorageArry[templateId].giftImgUrl = _newUrl;\n        giftTemplateStorageArry[templateId].giftName = _newName;\n    }\n    \n    function getGiftSoldFromType(uint256 giftType)\n    public\n    constant\n    returns(uint256){\n        return giftTypeToSelledSum[giftType];\n    }\n\n    //@dev Retrieving gifts by template.\n    function getGiftsByTemplateId(uint",
        "debug": "calldata_VirtualGift_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_VirtualGift_0: 0x416608a900000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateTemplate(uint256,uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "updateTemplate(uint256,uint256,uint256,string,string)",
        "lineno": 229,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4926,
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "withdraw()",
        "lineno": 462,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 5043,
        "code": "eId].giftName = _newName;\n    }\n   ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_VirtualGift_4: 0x0\nstorage_8: 0x0\nstorage_4: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x416608a900000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "updateTemplate(uint256,uint256,uint256,string,string)",
        "lineno": 235,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5596,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "withdrawGTO()",
        "lineno": 462,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5596,
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 5788\n",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "withdrawGTO()",
        "lineno": 462,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 5788,
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "withdrawGTO()",
        "lineno": 462,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 7399,
        "code": "//Mint a virtual gift.\n       ",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_VirtualGift_4: 0x0\nstorage_8: 0x0\nstorage_4: 0x0\ncaller: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x0\ncalldata_VirtualGift_0: 0x5b1fe0cb00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "sendGift(uint256,address)",
        "lineno": 164,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 10584,
        "code": "to != address(0))",
        "debug": "storage_keccac_calldata_VirtualGift_32_+_36: 0x8000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VirtualGift_32_+_4: 0x1fffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VirtualGift_4: 0x0\ncalldata_VirtualGift_4: 0x80\ncalldata_VirtualGift_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_VirtualGift_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncalldata_VirtualGift_32 + 36: 0x1fffffffffffffffffffffffffffffffffffff\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `transferFrom(address,address,uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "transferFrom(address,address,uint256)",
        "lineno": 413,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 11568,
        "code": "name = \"VirtualGift\";             \n    uint8 public decimals = 0;                \n    string public symbol = \"VTG\";                 \n    string public version = \"1.0\";  \n\n    address private defaultGiftOwner;\n    \n    mapping(address => bool) allowPermission;\n\n    ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    event Creation(address indexed _owner, uint256 indexed tokenId);\n    //Gift token storage.\n    GiftToken[] giftStorageArry;\n    //Gift template storage.\n    GiftTemplateToken[] giftTemplateStorageArry;\n    //mapping address to it's gift sum\n    mapping(address => uint256) private balances;\n    //mapping gift id to owner\n    mapping(uint256 => address) private giftIndexToOwners;\n    //tells the gift is existed by gift id\n    mapping(uint256 => bool) private giftExists;\n    //mapping current owner to approved owners to gift\n    mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds;\n    //mapping gift template id to gift ids\n    mapping(uint256 => uint256[]) private giftTemplateIdToGiftids;\n    //Mapping gift type to gift limit.\n    mapping(uint256 => uint256) private giftTypeToGiftLimit;\n\n    \n    //mapping gift template to gift selled sum.\n    mapping(uint256 => uint256) private giftTypeToSelledSum;\n\n    //Gift template known as 0 generation gift\n    struct GiftTemplateToken {\n        uint256 giftPrice;\n        uint256 giftLimit;\n        //gift image url\n        string giftImgUrl;\n        //gift animation url\n        string giftName;\n    }\n    //virtual gift token\n    struct GiftToken {\n        uint256 giftPrice;\n        uint256 giftType;\n        //gift image url\n        string giftImgUrl;\n        //gift animation url\n        string giftName;\n    }     \n\n    modifier onlyHavePermission(){\n        require(allowPermission[msg.sender] == true || msg.sender == defaultGiftOwner);\n        _;\n    }\n\n    modifier onlyOwner(){\n         require(msg.sender == defaultGiftOwner);\n         _;\n    }\n\n    //@dev Constructor \n    function VirtualGift() public {\n\n        defaultGiftOwner = msg.sender;\n        \n        GiftToken memory newGift = GiftToken({\n            giftPrice: 0,\n            giftType: 0,\n            giftImgUrl: \"\",\n            giftName: \"\"\n        });\n\n         GiftTemplateToken memory newGiftTemplate = GiftTemplateToken({\n                giftPrice: 0,\n                giftLimit: 0,\n                giftImgUrl: \"\",\n                giftName: \"\"\n            });\n        \n        giftStorageArry.push(newGift); // id = 0\n        giftTemplateStorageArry.push(newGiftTemplate);\n       \n    }\n\n    function addPermission(address _addr) \n    public \n    onlyOwner{\n        allowPermission[_addr] = true;\n    }\n    \n    function removePermission(address _addr) \n    public \n    onlyOwner{\n        allowPermission[_addr] = false;\n    }\n\n\n     ///@dev Buy a gift while create a new gift based on gift template.\n     ///Make sure to call Gifto.approve() fist, before calling this function\n    function sendGift(uint256 _type, \n                      address recipient)\n                     public \n                     onlyHavePermission\n                     returns(uint256 _giftId)\n                     {\n        //Check if the created gifts sum <  gift Limit\n        require(giftTypeToSelledSum[_type] < giftTemplateStorageArry[_type].giftLimit);\n         //_type must be a valid value\n        require(_type > 0 && _type < giftTemplateStorageArry.length);\n        //Mint a virtual gift.\n        _giftId = _mintGift(_type, recipient);\n        giftTypeToSelledSum[_type]++;\n        return _giftId;\n    }\n\n    /// @dev Mint gift.\n    function _mintGift(uint256 _type, \n                       address recipient)\n                     internal returns (uint256) \n                     {\n\n        GiftToken memory newGift = GiftToken({\n            giftPrice: giftTemplateStorageArry[_type].giftPrice,\n            giftType: _type,\n            giftImgUrl: giftTemplateStorageArry[_type].giftImgUrl,\n            giftName: giftTemplateStorageArry[_type].giftName\n        });\n        \n        uint256 giftId = giftStorageArry.push(newGift) - 1;\n        //Add giftid to gift template mapping \n        giftTemplateIdToGiftids[_type].push(giftId);\n        giftExists[giftId] = true;\n        //Reassign Ownership for new owner\n        _transfer(0, recipient, giftId);\n        //Trigger Ethereum Event\n        Creation(msg.sender, giftId);\n        return giftId;\n    }\n\n    /// @dev Initiate gift template.\n    /// A gift template means a gift of \"0\" generation's\n    function createGiftTemplate(uint256 _price,\n                         uint256 _limit, \n                         string _imgUrl,\n                         string _giftName) \n                         public onlyHavePermission\n                         returns (uint256 giftTemplateId)\n                         {\n        //Check these variables\n        require(_price > 0);\n        bytes memory imgUrlStringTest = bytes(_imgUrl);\n        bytes memory giftNameStringTest = bytes(_giftName);\n        require(imgUrlStringTest.length > 0);\n        require(giftNameStringTest.length > 0);\n        require(_limit > 0);\n        require(msg.sender != address(0));\n        //Create GiftTemplateToken\n        GiftTemplateToken memory newGiftTemplate = GiftTemplateToken({\n                giftPrice: _price,\n                giftLimit: _limit,\n                giftImgUrl: _imgUrl,\n                giftName: _giftName\n        });\n        //Push GiftTemplate into storage.\n        giftTemplateId = giftTemplateStorageArry.push(newGiftTemplate) - 1;\n        giftTypeToGiftLimit[giftTemplateId] = _limit;\n        return giftTemplateId;\n        \n    }\n    \n    function updateTemplate(uint256 templateId, \n                            uint256 _newPrice, \n                            uint256 _newlimit, \n                            string _newUrl, \n                            string _newName)\n    public\n    onlyOwner {\n        giftTemplateStorageArry[templateId].giftPrice = _newPrice;\n        giftTemplateStorageArry[templateId].giftLimit = _newlimit;\n        giftTemplateStorageArry[templateId].giftImgUrl = _newUrl;\n        giftTemplateStorageArry[templateId].giftName = _newName;\n    }\n    \n    function getGiftSoldFromType(uint256 giftType)\n    public\n    constant\n    returns(uint256){\n        return giftTypeToSelledSum[giftType];\n    }\n\n    //@dev Retrieving gifts by template.\n    function getGiftsByTemplateId(uint256 templateId) \n    public \n    constant \n    returns(uint256[] giftsId) {\n        return giftTemplateIdToGiftids[templateId];\n    }\n \n    //@dev Retrievings all gift template ids\n    function getAllGiftTemplateIds() \n    public \n    constant \n    returns(uint256[]) {\n        \n        if (giftTemplateStorageArry.length > 1) {\n            uint256 theLength = giftTemplateStorageArry.length - 1;\n            uint256[] memory resultTempIds = new uint256[](theLength);\n            uint256 resultIndex = 0;\n           \n            for (uint256 i = 1; i <= theLength; i++) {\n                resultTempIds[resultIndex] = i;\n                resultIndex++;\n            }\n             return resultTempIds;\n        }\n        require(giftTemplateStorageArry.length > 1);\n       \n    }\n\n    //@dev Retrieving gift template by it's id\n    function getGiftTemplateById(uint256 templateId) \n                                public constant returns(\n                                uint256 _price,\n                                uint256 _limit,\n                                string _imgUrl,\n                                string _giftName\n                                ){\n        require(templateId > 0);\n        require(templateId < giftTemplateStorageArry.length);\n        GiftTemplateToken memory giftTemplate = giftTemplateStorageArry[templateId];\n        _price = giftTemplate.giftPrice;\n        _limit = giftTemplate.giftLimit;\n        _imgUrl = giftTemplate.giftImgUrl;\n        _giftName = giftTemplate.giftName;\n        return (_price, _limit, _imgUrl, _giftName);\n    }\n\n    /// @dev Retrieving gift info by gift id.\n    function getGift(uint256 _giftId) \n                    public constant returns (\n                    uint256 giftType,\n                    uint256 giftPrice,\n                    string imgUrl,\n                    string giftName\n                    ) {\n        require(_giftId < giftStorageArry.length);\n        GiftToken memory gToken = giftStorageArry[_giftId];\n        giftType = gToken.giftType;\n        giftPrice = gToken.giftPrice;\n        imgUrl = gToken.giftImgUrl;\n        giftName = gToken.giftName;\n        return (giftType, giftPrice, imgUrl, giftName);\n    }\n\n    /// @dev transfer gift to a new owner.\n    /// @param _to : \n    /// @param _giftId :\n    function transfer(address _to, uint256 _giftId) external returns (bool success){\n        require(giftExists[_giftId]);\n        require(_to != 0x0);\n        require(msg.sender != _to);\n        require(msg.sender == ownerOf(_giftId));\n        require(_to != address(this));\n        _transfer(msg.sender, _to, _giftId);\n        return true;\n    }\n\n    /// @dev change Gifto contract's address or another type of token, like Ether.\n    /// @param newAddress Gifto contract address\n    function setGiftoAddress(address newAddress) public onlyOwner {\n        Gifto = ERC20(newAddress);\n    }\n    \n    /// @dev Retrieving Gifto contract adress\n    function getGiftoAddress() public constant returns (address giftoAddress) {\n        return address(Gifto);\n    }\n\n    /// @dev returns total supply for this token\n    function totalSupply() public  constant returns (uint256){\n        return giftStorageArry.length - 1;\n    }\n    \n    //@dev \n    //@param _owner \n    //@return \n    function balanceOf(address _owner)  public  constant  returns (uint256 giftSum) {\n        return balances[_owner];\n    }\n    \n    /// @dev \n    /// @return owner\n    function ownerOf(uint256 _giftId) public constant returns (address _owner) {\n        require(giftExists[_giftId]);\n        return giftIndexToOwners[_giftId];\n    }\n    \n    /// @dev approved owner \n    /// @param _to :\n    function approve(address _to, uint256 _giftId) public {\n        require(msg.sender == ownerOf(_giftId));\n        require(msg.sender != _to);\n        \n        ownerToApprovedAddsToGifIds[msg.sender][_to] = _giftId;\n        //Ethereum Event\n        Approval(msg.sender, _to, _giftId);\n    }\n    \n    /// @dev \n    /// @param _owner : \n    /// @param _spender :\n    function allowance(address _owner, address _spender) public constant returns (uint256 giftId) {\n        return ownerToApprovedAddsToGifIds[_owner][_spender];\n    }\n    \n    /// @dev \n    /// @param _giftId :\n    function takeOwnership(uint256 _giftId) public {\n        //Check if exits\n        require(giftExists[_giftId]);\n        \n        address oldOwner = ownerOf(_giftId);\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        //New owner has to be approved by oldowner.\n        require(ownerToApprovedAddsToGifIds[oldOwner][newOwner] == _giftId);\n\n        //transfer gift for new owner\n        _transfer(oldOwner, newOwner, _giftId);\n        delete ownerToApprovedAddsToGifIds[oldOwner][newOwner];\n        //Ethereum Event\n        Transfer(oldOwner, newOwner, _giftId);\n    }\n    \n    /// @dev transfer gift for new owner \"_to\"\n    /// @param _from : \n    /// @param _to : \n    /// @param _giftId :\n    function _transfer(address _from, address _to, uint256 _giftId) internal {\n        require(balances[_to] + 1 > balances[_to]);\n        balances[_to]++;\n        giftIndexToOwners[_giftId] = _to;\n   \n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        \n        //Ethereum event.\n        Transfer(_from, _to, _giftId);\n    }\n    \n    /// @dev transfer Gift for new owner(_to) which is approved.\n    /// @param _from : address of owner of gift\n    /// @param _to : recipient address\n    /// @param _giftId : gift id\n    function transferFrom(address _from, address _to, uint256 _giftId) external {\n\n        require(_to != address(0));\n        require(_to != address(this));\n        //Check if this spender(_to) is approved to the gift.\n        require(ownerToApprovedAddsToGifIds[_from][_to] == _giftId);\n        require(_from == ownerOf(_giftId));\n\n        //@dev reassign ownership of the gift. \n        _transfer(_from, _to, _giftId);\n        //Delete approved spender\n        delete ownerToApprovedAddsToGifIds[_from][_to];\n    }\n    \n    /// @dev Retrieving gifts by address _owner\n    function giftsOfOwner(address _owner)  public view returns (uint256[] ownerGifts) {\n        \n        uint256 giftCount = balanceOf(_owner);\n        if (giftCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](giftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 giftId;\n            \n            for (giftId = 0; giftId <= total; giftId++) {\n                if (giftIndexToOwners[giftId] == _owner) {\n                    result[resultIndex] = giftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n     \n    /// @dev withdraw GTO and ETH in this contract \n    function withdrawGTO() \n    onlyOwner \n    public { \n        Gifto.transfer(defaultGiftOwner, Gifto.balanceOf(address(this))); \n    }\n    \n    function withdraw()\n    onlyOwner\n    public\n    returns (bool){\n        return defaultGiftOwner.send(this.balance);\n    }\n}",
        "debug": "storage_2 +\n110349606679412691172957834289542550319383271247755660854362242977991410020067 +\n4*calldata_VirtualGift_4: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_2_+\n110349606679412691172957834289542550319383271247755660854362242977991410020067_+\n4*calldata_VirtualGift_4: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncalldata_VirtualGift_4: 0x0\nstorage_8: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x416608a900000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateTemplate(uint256,uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "updateTemplate(uint256,uint256,uint256,string,string)",
        "lineno": 53,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11597,
        "code": "name = \"VirtualGift\";             \n    uint8 public decimals = 0;                \n    string public symbol = \"VTG\";                 \n    string public version = \"1.0\";  \n\n    address private defaultGiftOwner;\n    \n    mapping(address => bool) allowPermission;\n\n    ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    event Creation(address indexed _owner, uint256 indexed tokenId);\n    //Gift token storage.\n    GiftToken[] giftStorageArry;\n    //Gift template storage.\n    GiftTemplateToken[] giftTemplateStorageArry;\n    //mapping address to it's gift sum\n    mapping(address => uint256) private balances;\n    //mapping gift id to owner\n    mapping(uint256 => address) private giftIndexToOwners;\n    //tells the gift is existed by gift id\n    mapping(uint256 => bool) private giftExists;\n    //mapping current owner to approved owners to gift\n    mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds;\n    //mapping gift template id to gift ids\n    mapping(uint256 => uint256[]) private giftTemplateIdToGiftids;\n    //Mapping gift type to gift limit.\n    mapping(uint256 => uint256) private giftTypeToGiftLimit;\n\n    \n    //mapping gift template to gift selled sum.\n    mapping(uint256 => uint256) private giftTypeToSelledSum;\n\n    //Gift template known as 0 generation gift\n    struct GiftTemplateToken {\n        uint256 giftPrice;\n        uint256 giftLimit;\n        //gift image url\n        string giftImgUrl;\n        //gift animation url\n        string giftName;\n    }\n    //virtual gift token\n    struct GiftToken {\n        uint256 giftPrice;\n        uint256 giftType;\n        //gift image url\n        string giftImgUrl;\n        //gift animation url\n        string giftName;\n    }     \n\n    modifier onlyHavePermission(){\n        require(allowPermission[msg.sender] == true || msg.sender == defaultGiftOwner);\n        _;\n    }\n\n    modifier onlyOwner(){\n         require(msg.sender == defaultGiftOwner);\n         _;\n    }\n\n    //@dev Constructor \n    function VirtualGift() public {\n\n        defaultGiftOwner = msg.sender;\n        \n        GiftToken memory newGift = GiftToken({\n            giftPrice: 0,\n            giftType: 0,\n            giftImgUrl: \"\",\n            giftName: \"\"\n        });\n\n         GiftTemplateToken memory newGiftTemplate = GiftTemplateToken({\n                giftPrice: 0,\n                giftLimit: 0,\n                giftImgUrl: \"\",\n                giftName: \"\"\n            });\n        \n        giftStorageArry.push(newGift); // id = 0\n        giftTemplateStorageArry.push(newGiftTemplate);\n       \n    }\n\n    function addPermission(address _addr) \n    public \n    onlyOwner{\n        allowPermission[_addr] = true;\n    }\n    \n    function removePermission(address _addr) \n    public \n    onlyOwner{\n        allowPermission[_addr] = false;\n    }\n\n\n     ///@dev Buy a gift while create a new gift based on gift template.\n     ///Make sure to call Gifto.approve() fist, before calling this function\n    function sendGift(uint256 _type, \n                      address recipient)\n                     public \n                     onlyHavePermission\n                     returns(uint256 _giftId)\n                     {\n        //Check if the created gifts sum <  gift Limit\n        require(giftTypeToSelledSum[_type] < giftTemplateStorageArry[_type].giftLimit);\n         //_type must be a valid value\n        require(_type > 0 && _type < giftTemplateStorageArry.length);\n        //Mint a virtual gift.\n        _giftId = _mintGift(_type, recipient);\n        giftTypeToSelledSum[_type]++;\n        return _giftId;\n    }\n\n    /// @dev Mint gift.\n    function _mintGift(uint256 _type, \n                       address recipient)\n                     internal returns (uint256) \n                     {\n\n        GiftToken memory newGift = GiftToken({\n            giftPrice: giftTemplateStorageArry[_type].giftPrice,\n            giftType: _type,\n            giftImgUrl: giftTemplateStorageArry[_type].giftImgUrl,\n            giftName: giftTemplateStorageArry[_type].giftName\n        });\n        \n        uint256 giftId = giftStorageArry.push(newGift) - 1;\n        //Add giftid to gift template mapping \n        giftTemplateIdToGiftids[_type].push(giftId);\n        giftExists[giftId] = true;\n        //Reassign Ownership for new owner\n        _transfer(0, recipient, giftId);\n        //Trigger Ethereum Event\n        Creation(msg.sender, giftId);\n        return giftId;\n    }\n\n    /// @dev Initiate gift template.\n    /// A gift template means a gift of \"0\" generation's\n    function createGiftTemplate(uint256 _price,\n                         uint256 _limit, \n                         string _imgUrl,\n                         string _giftName) \n                         public onlyHavePermission\n                         returns (uint256 giftTemplateId)\n                         {\n        //Check these variables\n        require(_price > 0);\n        bytes memory imgUrlStringTest = bytes(_imgUrl);\n        bytes memory giftNameStringTest = bytes(_giftName);\n        require(imgUrlStringTest.length > 0);\n        require(giftNameStringTest.length > 0);\n        require(_limit > 0);\n        require(msg.sender != address(0));\n        //Create GiftTemplateToken\n        GiftTemplateToken memory newGiftTemplate = GiftTemplateToken({\n                giftPrice: _price,\n                giftLimit: _limit,\n                giftImgUrl: _imgUrl,\n                giftName: _giftName\n        });\n        //Push GiftTemplate into storage.\n        giftTemplateId = giftTemplateStorageArry.push(newGiftTemplate) - 1;\n        giftTypeToGiftLimit[giftTemplateId] = _limit;\n        return giftTemplateId;\n        \n    }\n    \n    function updateTemplate(uint256 templateId, \n                            uint256 _newPrice, \n                            uint256 _newlimit, \n                            string _newUrl, \n                            string _newName)\n    public\n    onlyOwner {\n        giftTemplateStorageArry[templateId].giftPrice = _newPrice;\n        giftTemplateStorageArry[templateId].giftLimit = _newlimit;\n        giftTemplateStorageArry[templateId].giftImgUrl = _newUrl;\n        giftTemplateStorageArry[templateId].giftName = _newName;\n    }\n    \n    function getGiftSoldFromType(uint256 giftType)\n    public\n    constant\n    returns(uint256){\n        return giftTypeToSelledSum[giftType];\n    }\n\n    //@dev Retrieving gifts by template.\n    function getGiftsByTemplateId(uint256 templateId) \n    public \n    constant \n    returns(uint256[] giftsId) {\n        return giftTemplateIdToGiftids[templateId];\n    }\n \n    //@dev Retrievings all gift template ids\n    function getAllGiftTemplateIds() \n    public \n    constant \n    returns(uint256[]) {\n        \n        if (giftTemplateStorageArry.length > 1) {\n            uint256 theLength = giftTemplateStorageArry.length - 1;\n            uint256[] memory resultTempIds = new uint256[](theLength);\n            uint256 resultIndex = 0;\n           \n            for (uint256 i = 1; i <= theLength; i++) {\n                resultTempIds[resultIndex] = i;\n                resultIndex++;\n            }\n             return resultTempIds;\n        }\n        require(giftTemplateStorageArry.length > 1);\n       \n    }\n\n    //@dev Retrieving gift template by it's id\n    function getGiftTemplateById(uint256 templateId) \n                                public constant returns(\n                                uint256 _price,\n                                uint256 _limit,\n                                string _imgUrl,\n                                string _giftName\n                                ){\n        require(templateId > 0);\n        require(templateId < giftTemplateStorageArry.length);\n        GiftTemplateToken memory giftTemplate = giftTemplateStorageArry[templateId];\n        _price = giftTemplate.giftPrice;\n        _limit = giftTemplate.giftLimit;\n        _imgUrl = giftTemplate.giftImgUrl;\n        _giftName = giftTemplate.giftName;\n        return (_price, _limit, _imgUrl, _giftName);\n    }\n\n    /// @dev Retrieving gift info by gift id.\n    function getGift(uint256 _giftId) \n                    public constant returns (\n                    uint256 giftType,\n                    uint256 giftPrice,\n                    string imgUrl,\n                    string giftName\n                    ) {\n        require(_giftId < giftStorageArry.length);\n        GiftToken memory gToken = giftStorageArry[_giftId];\n        giftType = gToken.giftType;\n        giftPrice = gToken.giftPrice;\n        imgUrl = gToken.giftImgUrl;\n        giftName = gToken.giftName;\n        return (giftType, giftPrice, imgUrl, giftName);\n    }\n\n    /// @dev transfer gift to a new owner.\n    /// @param _to : \n    /// @param _giftId :\n    function transfer(address _to, uint256 _giftId) external returns (bool success){\n        require(giftExists[_giftId]);\n        require(_to != 0x0);\n        require(msg.sender != _to);\n        require(msg.sender == ownerOf(_giftId));\n        require(_to != address(this));\n        _transfer(msg.sender, _to, _giftId);\n        return true;\n    }\n\n    /// @dev change Gifto contract's address or another type of token, like Ether.\n    /// @param newAddress Gifto contract address\n    function setGiftoAddress(address newAddress) public onlyOwner {\n        Gifto = ERC20(newAddress);\n    }\n    \n    /// @dev Retrieving Gifto contract adress\n    function getGiftoAddress() public constant returns (address giftoAddress) {\n        return address(Gifto);\n    }\n\n    /// @dev returns total supply for this token\n    function totalSupply() public  constant returns (uint256){\n        return giftStorageArry.length - 1;\n    }\n    \n    //@dev \n    //@param _owner \n    //@return \n    function balanceOf(address _owner)  public  constant  returns (uint256 giftSum) {\n        return balances[_owner];\n    }\n    \n    /// @dev \n    /// @return owner\n    function ownerOf(uint256 _giftId) public constant returns (address _owner) {\n        require(giftExists[_giftId]);\n        return giftIndexToOwners[_giftId];\n    }\n    \n    /// @dev approved owner \n    /// @param _to :\n    function approve(address _to, uint256 _giftId) public {\n        require(msg.sender == ownerOf(_giftId));\n        require(msg.sender != _to);\n        \n        ownerToApprovedAddsToGifIds[msg.sender][_to] = _giftId;\n        //Ethereum Event\n        Approval(msg.sender, _to, _giftId);\n    }\n    \n    /// @dev \n    /// @param _owner : \n    /// @param _spender :\n    function allowance(address _owner, address _spender) public constant returns (uint256 giftId) {\n        return ownerToApprovedAddsToGifIds[_owner][_spender];\n    }\n    \n    /// @dev \n    /// @param _giftId :\n    function takeOwnership(uint256 _giftId) public {\n        //Check if exits\n        require(giftExists[_giftId]);\n        \n        address oldOwner = ownerOf(_giftId);\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        //New owner has to be approved by oldowner.\n        require(ownerToApprovedAddsToGifIds[oldOwner][newOwner] == _giftId);\n\n        //transfer gift for new owner\n        _transfer(oldOwner, newOwner, _giftId);\n        delete ownerToApprovedAddsToGifIds[oldOwner][newOwner];\n        //Ethereum Event\n        Transfer(oldOwner, newOwner, _giftId);\n    }\n    \n    /// @dev transfer gift for new owner \"_to\"\n    /// @param _from : \n    /// @param _to : \n    /// @param _giftId :\n    function _transfer(address _from, address _to, uint256 _giftId) internal {\n        require(balances[_to] + 1 > balances[_to]);\n        balances[_to]++;\n        giftIndexToOwners[_giftId] = _to;\n   \n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        \n        //Ethereum event.\n        Transfer(_from, _to, _giftId);\n    }\n    \n    /// @dev transfer Gift for new owner(_to) which is approved.\n    /// @param _from : address of owner of gift\n    /// @param _to : recipient address\n    /// @param _giftId : gift id\n    function transferFrom(address _from, address _to, uint256 _giftId) external {\n\n        require(_to != address(0));\n        require(_to != address(this));\n        //Check if this spender(_to) is approved to the gift.\n        require(ownerToApprovedAddsToGifIds[_from][_to] == _giftId);\n        require(_from == ownerOf(_giftId));\n\n        //@dev reassign ownership of the gift. \n        _transfer(_from, _to, _giftId);\n        //Delete approved spender\n        delete ownerToApprovedAddsToGifIds[_from][_to];\n    }\n    \n    /// @dev Retrieving gifts by address _owner\n    function giftsOfOwner(address _owner)  public view returns (uint256[] ownerGifts) {\n        \n        uint256 giftCount = balanceOf(_owner);\n        if (giftCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](giftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 giftId;\n            \n            for (giftId = 0; giftId <= total; giftId++) {\n                if (giftIndexToOwners[giftId] == _owner) {\n                    result[resultIndex] = giftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n     \n    /// @dev withdraw GTO and ETH in this contract \n    function withdrawGTO() \n    onlyOwner \n    public { \n        Gifto.transfer(defaultGiftOwner, Gifto.balanceOf(address(this))); \n    }\n    \n    function withdraw()\n    onlyOwner\n    public\n    returns (bool){\n        return defaultGiftOwner.send(this.balance);\n    }\n}",
        "debug": "calldata_VirtualGift_4 + calldata_VirtualGift_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_VirtualGift_4: 0x0\nstorage_8: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x416608a900000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateTemplate(uint256,uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "updateTemplate(uint256,uint256,uint256,string,string)",
        "lineno": 53,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 11611,
        "code": "name = \"VirtualGift\";             \n    uint8 public decimals = 0;                \n    string public symbol = \"VTG\";                 \n    string public version = \"1.0\";  \n\n    address private defaultGiftOwner;\n    \n    mapping(address => bool) allowPermission;\n\n    ERC20 private Gifto = ERC20(0x00C5bBaE50781Be1669306b9e001EFF57a2957b09d);\n    \n    event Creation(address indexed _owner, uint256 indexed tokenId);\n    //Gift token storage.\n    GiftToken[] giftStorageArry;\n    //Gift template storage.\n    GiftTemplateToken[] giftTemplateStorageArry;\n    //mapping address to it's gift sum\n    mapping(address => uint256) private balances;\n    //mapping gift id to owner\n    mapping(uint256 => address) private giftIndexToOwners;\n    //tells the gift is existed by gift id\n    mapping(uint256 => bool) private giftExists;\n    //mapping current owner to approved owners to gift\n    mapping(address => mapping (address => uint256)) private ownerToApprovedAddsToGifIds;\n    //mapping gift template id to gift ids\n    mapping(uint256 => uint256[]) private giftTemplateIdToGiftids;\n    //Mapping gift type to gift limit.\n    mapping(uint256 => uint256) private giftTypeToGiftLimit;\n\n    \n    //mapping gift template to gift selled sum.\n    mapping(uint256 => uint256) private giftTypeToSelledSum;\n\n    //Gift template known as 0 generation gift\n    struct GiftTemplateToken {\n        uint256 giftPrice;\n        uint256 giftLimit;\n        //gift image url\n        string giftImgUrl;\n        //gift animation url\n        string giftName;\n    }\n    //virtual gift token\n    struct GiftToken {\n        uint256 giftPrice;\n        uint256 giftType;\n        //gift image url\n        string giftImgUrl;\n        //gift animation url\n        string giftName;\n    }     \n\n    modifier onlyHavePermission(){\n        require(allowPermission[msg.sender] == true || msg.sender == defaultGiftOwner);\n        _;\n    }\n\n    modifier onlyOwner(){\n         require(msg.sender == defaultGiftOwner);\n         _;\n    }\n\n    //@dev Constructor \n    function VirtualGift() public {\n\n        defaultGiftOwner = msg.sender;\n        \n        GiftToken memory newGift = GiftToken({\n            giftPrice: 0,\n            giftType: 0,\n            giftImgUrl: \"\",\n            giftName: \"\"\n        });\n\n         GiftTemplateToken memory newGiftTemplate = GiftTemplateToken({\n                giftPrice: 0,\n                giftLimit: 0,\n                giftImgUrl: \"\",\n                giftName: \"\"\n            });\n        \n        giftStorageArry.push(newGift); // id = 0\n        giftTemplateStorageArry.push(newGiftTemplate);\n       \n    }\n\n    function addPermission(address _addr) \n    public \n    onlyOwner{\n        allowPermission[_addr] = true;\n    }\n    \n    function removePermission(address _addr) \n    public \n    onlyOwner{\n        allowPermission[_addr] = false;\n    }\n\n\n     ///@dev Buy a gift while create a new gift based on gift template.\n     ///Make sure to call Gifto.approve() fist, before calling this function\n    function sendGift(uint256 _type, \n                      address recipient)\n                     public \n                     onlyHavePermission\n                     returns(uint256 _giftId)\n                     {\n        //Check if the created gifts sum <  gift Limit\n        require(giftTypeToSelledSum[_type] < giftTemplateStorageArry[_type].giftLimit);\n         //_type must be a valid value\n        require(_type > 0 && _type < giftTemplateStorageArry.length);\n        //Mint a virtual gift.\n        _giftId = _mintGift(_type, recipient);\n        giftTypeToSelledSum[_type]++;\n        return _giftId;\n    }\n\n    /// @dev Mint gift.\n    function _mintGift(uint256 _type, \n                       address recipient)\n                     internal returns (uint256) \n                     {\n\n        GiftToken memory newGift = GiftToken({\n            giftPrice: giftTemplateStorageArry[_type].giftPrice,\n            giftType: _type,\n            giftImgUrl: giftTemplateStorageArry[_type].giftImgUrl,\n            giftName: giftTemplateStorageArry[_type].giftName\n        });\n        \n        uint256 giftId = giftStorageArry.push(newGift) - 1;\n        //Add giftid to gift template mapping \n        giftTemplateIdToGiftids[_type].push(giftId);\n        giftExists[giftId] = true;\n        //Reassign Ownership for new owner\n        _transfer(0, recipient, giftId);\n        //Trigger Ethereum Event\n        Creation(msg.sender, giftId);\n        return giftId;\n    }\n\n    /// @dev Initiate gift template.\n    /// A gift template means a gift of \"0\" generation's\n    function createGiftTemplate(uint256 _price,\n                         uint256 _limit, \n                         string _imgUrl,\n                         string _giftName) \n                         public onlyHavePermission\n                         returns (uint256 giftTemplateId)\n                         {\n        //Check these variables\n        require(_price > 0);\n        bytes memory imgUrlStringTest = bytes(_imgUrl);\n        bytes memory giftNameStringTest = bytes(_giftName);\n        require(imgUrlStringTest.length > 0);\n        require(giftNameStringTest.length > 0);\n        require(_limit > 0);\n        require(msg.sender != address(0));\n        //Create GiftTemplateToken\n        GiftTemplateToken memory newGiftTemplate = GiftTemplateToken({\n                giftPrice: _price,\n                giftLimit: _limit,\n                giftImgUrl: _imgUrl,\n                giftName: _giftName\n        });\n        //Push GiftTemplate into storage.\n        giftTemplateId = giftTemplateStorageArry.push(newGiftTemplate) - 1;\n        giftTypeToGiftLimit[giftTemplateId] = _limit;\n        return giftTemplateId;\n        \n    }\n    \n    function updateTemplate(uint256 templateId, \n                            uint256 _newPrice, \n                            uint256 _newlimit, \n                            string _newUrl, \n                            string _newName)\n    public\n    onlyOwner {\n        giftTemplateStorageArry[templateId].giftPrice = _newPrice;\n        giftTemplateStorageArry[templateId].giftLimit = _newlimit;\n        giftTemplateStorageArry[templateId].giftImgUrl = _newUrl;\n        giftTemplateStorageArry[templateId].giftName = _newName;\n    }\n    \n    function getGiftSoldFromType(uint256 giftType)\n    public\n    constant\n    returns(uint256){\n        return giftTypeToSelledSum[giftType];\n    }\n\n    //@dev Retrieving gifts by template.\n    function getGiftsByTemplateId(uint256 templateId) \n    public \n    constant \n    returns(uint256[] giftsId) {\n        return giftTemplateIdToGiftids[templateId];\n    }\n \n    //@dev Retrievings all gift template ids\n    function getAllGiftTemplateIds() \n    public \n    constant \n    returns(uint256[]) {\n        \n        if (giftTemplateStorageArry.length > 1) {\n            uint256 theLength = giftTemplateStorageArry.length - 1;\n            uint256[] memory resultTempIds = new uint256[](theLength);\n            uint256 resultIndex = 0;\n           \n            for (uint256 i = 1; i <= theLength; i++) {\n                resultTempIds[resultIndex] = i;\n                resultIndex++;\n            }\n             return resultTempIds;\n        }\n        require(giftTemplateStorageArry.length > 1);\n       \n    }\n\n    //@dev Retrieving gift template by it's id\n    function getGiftTemplateById(uint256 templateId) \n                                public constant returns(\n                                uint256 _price,\n                                uint256 _limit,\n                                string _imgUrl,\n                                string _giftName\n                                ){\n        require(templateId > 0);\n        require(templateId < giftTemplateStorageArry.length);\n        GiftTemplateToken memory giftTemplate = giftTemplateStorageArry[templateId];\n        _price = giftTemplate.giftPrice;\n        _limit = giftTemplate.giftLimit;\n        _imgUrl = giftTemplate.giftImgUrl;\n        _giftName = giftTemplate.giftName;\n        return (_price, _limit, _imgUrl, _giftName);\n    }\n\n    /// @dev Retrieving gift info by gift id.\n    function getGift(uint256 _giftId) \n                    public constant returns (\n                    uint256 giftType,\n                    uint256 giftPrice,\n                    string imgUrl,\n                    string giftName\n                    ) {\n        require(_giftId < giftStorageArry.length);\n        GiftToken memory gToken = giftStorageArry[_giftId];\n        giftType = gToken.giftType;\n        giftPrice = gToken.giftPrice;\n        imgUrl = gToken.giftImgUrl;\n        giftName = gToken.giftName;\n        return (giftType, giftPrice, imgUrl, giftName);\n    }\n\n    /// @dev transfer gift to a new owner.\n    /// @param _to : \n    /// @param _giftId :\n    function transfer(address _to, uint256 _giftId) external returns (bool success){\n        require(giftExists[_giftId]);\n        require(_to != 0x0);\n        require(msg.sender != _to);\n        require(msg.sender == ownerOf(_giftId));\n        require(_to != address(this));\n        _transfer(msg.sender, _to, _giftId);\n        return true;\n    }\n\n    /// @dev change Gifto contract's address or another type of token, like Ether.\n    /// @param newAddress Gifto contract address\n    function setGiftoAddress(address newAddress) public onlyOwner {\n        Gifto = ERC20(newAddress);\n    }\n    \n    /// @dev Retrieving Gifto contract adress\n    function getGiftoAddress() public constant returns (address giftoAddress) {\n        return address(Gifto);\n    }\n\n    /// @dev returns total supply for this token\n    function totalSupply() public  constant returns (uint256){\n        return giftStorageArry.length - 1;\n    }\n    \n    //@dev \n    //@param _owner \n    //@return \n    function balanceOf(address _owner)  public  constant  returns (uint256 giftSum) {\n        return balances[_owner];\n    }\n    \n    /// @dev \n    /// @return owner\n    function ownerOf(uint256 _giftId) public constant returns (address _owner) {\n        require(giftExists[_giftId]);\n        return giftIndexToOwners[_giftId];\n    }\n    \n    /// @dev approved owner \n    /// @param _to :\n    function approve(address _to, uint256 _giftId) public {\n        require(msg.sender == ownerOf(_giftId));\n        require(msg.sender != _to);\n        \n        ownerToApprovedAddsToGifIds[msg.sender][_to] = _giftId;\n        //Ethereum Event\n        Approval(msg.sender, _to, _giftId);\n    }\n    \n    /// @dev \n    /// @param _owner : \n    /// @param _spender :\n    function allowance(address _owner, address _spender) public constant returns (uint256 giftId) {\n        return ownerToApprovedAddsToGifIds[_owner][_spender];\n    }\n    \n    /// @dev \n    /// @param _giftId :\n    function takeOwnership(uint256 _giftId) public {\n        //Check if exits\n        require(giftExists[_giftId]);\n        \n        address oldOwner = ownerOf(_giftId);\n        address newOwner = msg.sender;\n        \n        require(newOwner != oldOwner);\n        //New owner has to be approved by oldowner.\n        require(ownerToApprovedAddsToGifIds[oldOwner][newOwner] == _giftId);\n\n        //transfer gift for new owner\n        _transfer(oldOwner, newOwner, _giftId);\n        delete ownerToApprovedAddsToGifIds[oldOwner][newOwner];\n        //Ethereum Event\n        Transfer(oldOwner, newOwner, _giftId);\n    }\n    \n    /// @dev transfer gift for new owner \"_to\"\n    /// @param _from : \n    /// @param _to : \n    /// @param _giftId :\n    function _transfer(address _from, address _to, uint256 _giftId) internal {\n        require(balances[_to] + 1 > balances[_to]);\n        balances[_to]++;\n        giftIndexToOwners[_giftId] = _to;\n   \n        if (_from != address(0)) {\n            balances[_from]--;\n        }\n        \n        //Ethereum event.\n        Transfer(_from, _to, _giftId);\n    }\n    \n    /// @dev transfer Gift for new owner(_to) which is approved.\n    /// @param _from : address of owner of gift\n    /// @param _to : recipient address\n    /// @param _giftId : gift id\n    function transferFrom(address _from, address _to, uint256 _giftId) external {\n\n        require(_to != address(0));\n        require(_to != address(this));\n        //Check if this spender(_to) is approved to the gift.\n        require(ownerToApprovedAddsToGifIds[_from][_to] == _giftId);\n        require(_from == ownerOf(_giftId));\n\n        //@dev reassign ownership of the gift. \n        _transfer(_from, _to, _giftId);\n        //Delete approved spender\n        delete ownerToApprovedAddsToGifIds[_from][_to];\n    }\n    \n    /// @dev Retrieving gifts by address _owner\n    function giftsOfOwner(address _owner)  public view returns (uint256[] ownerGifts) {\n        \n        uint256 giftCount = balanceOf(_owner);\n        if (giftCount == 0) {\n            return new uint256[](0);\n        } else {\n            uint256[] memory result = new uint256[](giftCount);\n            uint256 total = totalSupply();\n            uint256 resultIndex = 0;\n\n            uint256 giftId;\n            \n            for (giftId = 0; giftId <= total; giftId++) {\n                if (giftIndexToOwners[giftId] == _owner) {\n                    result[resultIndex] = giftId;\n                    resultIndex++;\n                }\n            }\n\n            return result;\n        }\n    }\n     \n    /// @dev withdraw GTO and ETH in this contract \n    function withdrawGTO() \n    onlyOwner \n    public { \n        Gifto.transfer(defaultGiftOwner, Gifto.balanceOf(address(this))); \n    }\n    \n    function withdraw()\n    onlyOwner\n    public\n    returns (bool){\n        return defaultGiftOwner.send(this.balance);\n    }\n}",
        "debug": "calldata_VirtualGift_4 + calldata_VirtualGift_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncalldata_VirtualGift_4: 0x0\nstorage_8: 0x1\nstorage_4: 0x0\ncaller: 0x0\ncalldata_VirtualGift_0: 0x416608a900000000000000000000000000000000000000000000000000000000\ncalldatasize_VirtualGift: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updateTemplate(uint256,uint256,uint256,string,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/21/0xcffd73396e6f4dae2fd43da7eeb2536b50b695a1.sol",
        "function": "updateTemplate(uint256,uint256,uint256,string,string)",
        "lineno": 53,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}