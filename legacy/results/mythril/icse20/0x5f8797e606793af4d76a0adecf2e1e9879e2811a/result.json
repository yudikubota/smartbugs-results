{
  "contract": "0x5f8797e606793af4d76a0adecf2e1e9879e2811a",
  "tool": "mythril",
  "start": 1563572953.068418,
  "end": 1563573097.0349615,
  "duration": 143.96654343605042,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 5032,
        "code": "              expects[j] = dep.expect;\n     ",
        "debug": "",
        "description": "In the function `fallback` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 304,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 5032,
        "code": "              expects[j] = dep.expect;\n     ",
        "debug": "",
        "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 304,
        "title": "Message call to external contract",
        "type": "Informational"
      },
      {
        "address": 5032,
        "code": "              expects[j] = dep.expect;\n     ",
        "debug": "",
        "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 5208\n",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 304,
        "title": "Multiple Calls",
        "type": "Information"
      },
      {
        "address": 5032,
        "code": "              expects[j] = dep.expect;\n     ",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 304,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 5032,
        "code": "              expects[j] = dep.expect;\n     ",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 304,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 5110,
        "code": " }\n    }\n\n    //Get current ",
        "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0x0\nstorage_1: 0x3fffffffffffffffffffffffffffff\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x0\ngas: 0x3d090\nstorage_4: 0x1\ntimestamp: 0x80000000000000000000000000000706\nstorage_3: 0x7ffffffffffffffffffffffffffffffe00\ncalldatasize_Multipliers: 0x3\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 308,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 5208,
        "code": " }\n    }\n\n    //Get current queue size\n    functio",
        "debug": "",
        "description": "In the function `fallback` the following predictable state variables are used to determine Ether recipient:\n- block.timestamp\n",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 308,
        "title": "Dependence on predictable environment variable",
        "type": "Warning"
      },
      {
        "address": 5208,
        "code": " }\n    }\n\n    //Get current queue size\n    functio",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 308,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 5208,
        "code": " }\n    }\n\n    //Get current queue size\n    functio",
        "debug": "",
        "description": "The return value of an external call is not checked. Note that execution continue even if the called contract throws.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 308,
        "title": "Unchecked CALL return value",
        "type": "Informational"
      },
      {
        "address": 5221,
        "code": "gth() public vi",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 312,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 5231,
        "code": "eturn que",
        "debug": "storage_2: 0x8000008000940200000038000\nstorage_1: 0x1000000000000001400404000010004004007c\nstorage_5: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x0\ngas: 0x3d090\nstorage_4: 0x1\ntimestamp: 0xfffffff7fcc003faf9400fff3ff37e82\nstorage_3: 0xfffffff7fcc003faf9400fff3ff3777a00\ncalldatasize_Multipliers: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 313,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 5255,
        "debug": "callvalue: 0x800000000000000\ntimestamp: 0xef0f\ngas: 0x35b60\ncaller: 0x83205ddd0c80a3b331b64c4403bea1736ee2e327\ncalldatasize_Multipliers: 0x3\n",
        "description": "A possible integer underflow exists in the function `fallback`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 342,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 6219,
        "code": "itsMade[de",
        "debug": "The exception is triggered under the following conditions:\n\ncalldata_Multipliers_4: 0x0\nstorage_1: 0x0\ncalldata_Multipliers_0: 0x9f9fb96800000000000000000000000000000000000000000000000000000000\ncalldatasize_Multipliers: 0x4\ncallvalue: 0x0\n",
        "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "getDeposit(uint256)",
        "lineno": 318,
        "title": "Exception state",
        "type": "Informational"
      },
      {
        "address": 6978,
        "code": "ex\n    //You c",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 272,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 7000,
        "code": "tion getDeposit(uint idx",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 274,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 7039,
        "code": "ew returns (address de",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 274,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 7074,
        "code": "ew returns (address de",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 274,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 7086,
        "code": " deposit structure holds all the info about the deposit made\n    struct Deposit {\n        address depositor; //The depositor address\n        uint128 deposit;   //The deposit amount\n        uint128 expect;    //How much we should pay out (initially it is 111%-141% of deposit)\n    }\n\n    struct DepositCount {\n        int128 stage;\n        uint128 count;\n    }\n\n    struct LastDepositInfo {\n        uint128 index;\n        uint128 time;\n    }\n\n    Deposit[] private queue;  //The queue\n    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\n    LastDepositInfo public lastDepositInfo; //The time last deposit made at\n\n    uint public prizeAmount = 0; //Prize amount accumulated for the last depositor\n    int public stage = 0; //Number of contract runs\n    mapping(address => DepositCount) public depositsMade; //The number of deposits of different depositors\n\n    //This function receives all the deposits\n    //stores them and make immediate payouts\n    function () public payable {\n        //If money are from first multiplier, just add them to the balance\n        //All these money will be distributed to current investors\n        if(msg.value > 0 && msg.sender != FATHER){\n            require(gasleft() >= 220000, \"We require more gas!\"); //We need gas to process queue\n            require(msg.value <= MAX_INVESTMENT, \"The investment is too much!\"); //Do not allow too big investments to stabilize payouts\n\n            checkAndUpdateStage();\n\n            addDeposit(msg.sender, msg.value);\n\n            //Pay to first investors in line\n            pay();\n        }else if(msg.value == 0){\n            withdrawPrize();\n        }\n    }\n\n    //Used to pay to current investors\n    //Each new transaction processes 1 - 4+ investors in the head of queue\n    //depending on balance and gas left\n    function pay() private {\n        //Try to send all the money on contract to the first investors in line\n        uint balance = address(this).balance;\n        uint128 money = 0;\n        if(balance > prizeAmount) //The opposite is impossible, however the check will not do any harm\n            money = uint128(balance - prizeAmount);\n\n        //We will do cycle on the queue\n        for(uint i=currentReceiverIndex; i<queue.length; i++){\n\n            Deposit storage dep = queue[i]; //get the info of the first investor\n\n            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\n                dep.depositor.send(dep.expect); //Send money to him\n                money -= dep.expect;            //update money left\n\n                //this investor is fully paid, so remove him\n                delete queue[i];\n            }else{\n                //Here we don't have enough money so partially pay to investor\n                dep.depositor.send(money); //Send to him everything we have\n                dep.expect -= money;       //Update the expected amount\n                break;                     //Exit cycle\n            }\n\n            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\n                break;                     //The next investor will process the line further\n        }\n\n        currentReceiverIndex = i; //Update the index of the current first investor\n    }\n\n    function addDeposit(address depositor, uint value) private {\n        //Count the number of the deposit at this stage\n        DepositCount storage c = depositsMade[depositor];\n        if(c.stage != stage){\n            c.stage = int128(stage);\n            c.count = 0;\n        }\n\n        //If you are applying for the prize you should invest more than minimal amount\n        //Otherwize it doesn't count\n        if(value >= MIN_INVESTMENT_FOR_PRIZE)\n            lastDepositInfo = LastDepositInfo(uint128(queue.length), uint128(now));\n\n        //Compute the multiplier percent for this depositor\n        uint multiplier = getDepositorMultiplier(depositor);\n        //Add the investor into the queue. Mark that he expects to receive 111%-141% of deposit back\n        queue.push(Deposit(depositor, uint128(value), uint128(value*multiplier/100)));\n\n        //Increment number of deposits the depositors made this round\n        c.count++;\n\n        //Save money for prize and father multiplier\n        prizeAmount += value*(FATHER_PERCENT + PRIZE_PERCENT)/100;\n\n        //Send small part to tech support\n        uint support = value*TECH_PERCENT/100;\n        TECH.send(support);\n        uint adv = value*PROMO_PERCENT/100;\n        PROMO.send(adv);\n\n    }\n\n    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n    function proceedToNewStage(int _stage) private {\n        //Clean queue info\n        //The prize amount on the balance is left the same if not withdrawn\n        stage = _stage;\n        delete queue;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n    function withdrawPrize() private {\n        //You can withdraw prize only if the last deposit was more than MAX_IDLE_TIME ago\n        require(lastDepositInfo.time > 0 && lastDepositInfo.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\n        //Last depositor will receive prize only if it has not been fully paid\n        require(currentReceiverIndex <= lastDepositInfo.index, \"The last depositor should still be in queue\");\n\n        uint balance = address(this).balance;\n        if(prizeAmount > balance) //Impossible but better check it\n            prizeAmount = balance;\n\n        //Send donation to the first multiplier for it to spin faster\n        //It already contains all the sum, so we must split for father and last depositor only\n        //If the .call fails then ether will just stay on the contract to be distributed to\n        //the queue at the next stage\n        uint donation = prizeAmount*FATHER_PERCENT/(FATHER_PERCENT + PRIZE_PERCENT);\n        require(gasleft() >= 250000, \"We need gas for the father contract\");\n        FATHER.call.value(donation).gas(gasleft())();\n\n        uint prize = prizeAmount - donation;\n        queue[lastDepositInfo.index].depositor.send(prize);\n\n        prizeAmount = 0;\n        proceedToNewStage(stage + 1);\n    }\n\n    //Get the deposit info by its index\n    //You can get deposit index from\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n    //Get the count of deposits of specific investor\n    function getDepositsCount(address depositor) public view returns (uint) {\n        uint c = 0;\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n            if(queue[i].depositor == depositor)\n                c++;\n        }\n        return c;\n    }\n\n    //Get all deposits (index, deposit, expect) of a specific investor\n    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\n        uint c = getDepositsCount(depositor);\n\n        idxs = new uint[](c);\n        deposits = new uint128[](c);\n        expects = new uint128[](c);\n\n        if(c > 0) {\n            uint j = 0;\n            for(uint i=currentReceiverIndex; i<queue.length; ++i){\n                Deposit storage dep = queue[i];\n                if(dep.depositor == depositor){\n                    idxs[j] = i;\n                    deposits[j] = dep.deposit;\n                    expects[j] = dep.expect;\n                    j++;\n                }\n            }\n        }\n    }\n\n    //Get current queue size\n    function getQueueLength() public view returns (uint) {\n        return queue.length - currentReceiverIndex;\n    }\n\n    //Get current depositors multiplier percent at this stage\n    function getDepositorMultiplier(address depositor) public view returns (uint) {\n        DepositCount storage c = depositsMade[depositor];\n        uint count = 0;\n        if(c.stage == getCurrentStageByTime())\n            count = c.count;\n        if(count < MULTIPLIERS.length)\n            return MULTIPLIERS[count];\n\n        return MULTIPLIERS[MULTIPLIERS.length - 1];\n    }\n\n    function getCurrentStageByTime() public view returns (int) {\n        return int(now - 17 hours) / 1 days - 17836; //Start is 01/11/2018 20:00 GMT+3\n    }\n\n    function getStageStartTime(int _stage) public pure returns (int) {\n        return 17 hours + (_stage + 17836)*1 days;\n    }\n\n    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\n        Deposit storage d = queue[lastDepositInfo.index];\n        addr = d.depositor;\n        timeLeft = int(lastDepositInfo.time + MAX_IDLE_TIME) - int(now);\n    }\n\n}",
        "debug": "",
        "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 116,
        "title": "State change after external call",
        "type": "Warning"
      },
      {
        "address": 7089,
        "code": " deposit structure holds all the info about the deposit made\n    struct Deposit {\n        address depositor; //The depositor address\n        uint128 deposit;   //The deposit amount\n        uint128 expect;    //How much we should pay out (initially it is 111%-141% of deposit)\n    }\n\n    struct DepositCount {\n        int128 stage;\n        uint128 count;\n    }\n\n    struct LastDepositInfo {\n        uint128 index;\n        uint128 time;\n    }\n\n    Deposit[] private queue;  //The queue\n    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\n    LastDepositInfo public lastDepositInfo; //The time last deposit made at\n\n    uint public prizeAmount = 0; //Prize amount accumulated for the last depositor\n    int public stage = 0; //Number of contract runs\n    mapping(address => DepositCount) public depositsMade; //The number of deposits of different depositors\n\n    //This function receives all the deposits\n    //stores them and make immediate payouts\n    function () public payable {\n        //If money are from first multiplier, just add them to the balance\n        //All these money will be distributed to current investors\n        if(msg.value > 0 && msg.sender != FATHER){\n            require(gasleft() >= 220000, \"We require more gas!\"); //We need gas to process queue\n            require(msg.value <= MAX_INVESTMENT, \"The investment is too much!\"); //Do not allow too big investments to stabilize payouts\n\n            checkAndUpdateStage();\n\n            addDeposit(msg.sender, msg.value);\n\n            //Pay to first investors in line\n            pay();\n        }else if(msg.value == 0){\n            withdrawPrize();\n        }\n    }\n\n    //Used to pay to current investors\n    //Each new transaction processes 1 - 4+ investors in the head of queue\n    //depending on balance and gas left\n    function pay() private {\n        //Try to send all the money on contract to the first investors in line\n        uint balance = address(this).balance;\n        uint128 money = 0;\n        if(balance > prizeAmount) //The opposite is impossible, however the check will not do any harm\n            money = uint128(balance - prizeAmount);\n\n        //We will do cycle on the queue\n        for(uint i=currentReceiverIndex; i<queue.length; i++){\n\n            Deposit storage dep = queue[i]; //get the info of the first investor\n\n            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\n                dep.depositor.send(dep.expect); //Send money to him\n                money -= dep.expect;            //update money left\n\n                //this investor is fully paid, so remove him\n                delete queue[i];\n            }else{\n                //Here we don't have enough money so partially pay to investor\n                dep.depositor.send(money); //Send to him everything we have\n                dep.expect -= money;       //Update the expected amount\n                break;                     //Exit cycle\n            }\n\n            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\n                break;                     //The next investor will process the line further\n        }\n\n        currentReceiverIndex = i; //Update the index of the current first investor\n    }\n\n    function addDeposit(address depositor, uint value) private {\n        //Count the number of the deposit at this stage\n        DepositCount storage c = depositsMade[depositor];\n        if(c.stage != stage){\n            c.stage = int128(stage);\n            c.count = 0;\n        }\n\n        //If you are applying for the prize you should invest more than minimal amount\n        //Otherwize it doesn't count\n        if(value >= MIN_INVESTMENT_FOR_PRIZE)\n            lastDepositInfo = LastDepositInfo(uint128(queue.length), uint128(now));\n\n        //Compute the multiplier percent for this depositor\n        uint multiplier = getDepositorMultiplier(depositor);\n        //Add the investor into the queue. Mark that he expects to receive 111%-141% of deposit back\n        queue.push(Deposit(depositor, uint128(value), uint128(value*multiplier/100)));\n\n        //Increment number of deposits the depositors made this round\n        c.count++;\n\n        //Save money for prize and father multiplier\n        prizeAmount += value*(FATHER_PERCENT + PRIZE_PERCENT)/100;\n\n        //Send small part to tech support\n        uint support = value*TECH_PERCENT/100;\n        TECH.send(support);\n        uint adv = value*PROMO_PERCENT/100;\n        PROMO.send(adv);\n\n    }\n\n    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n    function proceedToNewStage(int _stage) private {\n        //Clean queue info\n        //The prize amount on the balance is left the same if not withdrawn\n        stage = _stage;\n        delete queue;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n    function withdrawPrize() private {\n        //You can withdraw prize only if the last deposit was more than MAX_IDLE_TIME ago\n        require(lastDepositInfo.time > 0 && lastDepositInfo.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\n        //Last depositor will receive prize only if it has not been fully paid\n        require(currentReceiverIndex <= lastDepositInfo.index, \"The last depositor should still be in queue\");\n\n        uint balance = address(this).balance;\n        if(prizeAmount > balance) //Impossible but better check it\n            prizeAmount = balance;\n\n        //Send donation to the first multiplier for it to spin faster\n        //It already contains all the sum, so we must split for father and last depositor only\n        //If the .call fails then ether will just stay on the contract to be distributed to\n        //the queue at the next stage\n        uint donation = prizeAmount*FATHER_PERCENT/(FATHER_PERCENT + PRIZE_PERCENT);\n        require(gasleft() >= 250000, \"We need gas for the father contract\");\n        FATHER.call.value(donation).gas(gasleft())();\n\n        uint prize = prizeAmount - donation;\n        queue[lastDepositInfo.index].depositor.send(prize);\n\n        prizeAmount = 0;\n        proceedToNewStage(stage + 1);\n    }\n\n    //Get the deposit info by its index\n    //You can get deposit index from\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n    //Get the count of deposits of specific investor\n    function getDepositsCount(address depositor) public view returns (uint) {\n        uint c = 0;\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n            if(queue[i].depositor == depositor)\n                c++;\n        }\n        return c;\n    }\n\n    //Get all deposits (index, deposit, expect) of a specific investor\n    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\n        uint c = getDepositsCount(depositor);\n\n        idxs = new uint[](c);\n        deposits = new uint128[](c);\n        expects = new uint128[](c);\n\n        if(c > 0) {\n            uint j = 0;\n            for(uint i=currentReceiverIndex; i<queue.length; ++i){\n                Deposit storage dep = queue[i];\n                if(dep.depositor == depositor){\n                    idxs[j] = i;\n                    deposits[j] = dep.deposit;\n                    expects[j] = dep.expect;\n                    j++;\n                }\n            }\n        }\n    }\n\n    //Get current queue size\n    function getQueueLength() public view returns (uint) {\n        return queue.length - currentReceiverIndex;\n    }\n\n    //Get current depositors multiplier percent at this stage\n    function getDepositorMultiplier(address depositor) public view returns (uint) {\n        DepositCount storage c = depositsMade[depositor];\n        uint count = 0;\n        if(c.stage == getCurrentStageByTime())\n            count = c.count;\n        if(count < MULTIPLIERS.length)\n            return MULTIPLIERS[count];\n\n        return MULTIPLIERS[MULTIPLIERS.length - 1];\n    }\n\n    function getCurrentStageByTime() public view returns (int) {\n        return int(now - 17 hours) / 1 days - 17836; //Start is 01/11/2018 20:00 GMT+3\n    }\n\n    function getStageStartTime(int _stage) public pure returns (int) {\n        return 17 hours + (_stage + 17836)*1 days;\n    }\n\n    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\n        Deposit storage d = queue[lastDepositInfo.index];\n        addr = d.depositor;\n        timeLeft = int(lastDepositInfo.time + MAX_IDLE_TIME) - int(now);\n    }\n\n}",
        "debug": "storage_2: 0x0\nstorage_1: 0x8000000000000000000000000000000000000000000000000000000000000003\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x0\ngas: 0x3d090\nstorage_4: 0x1\ntimestamp: 0x70a\nstorage_3: 0x200\ncalldatasize_Multipliers: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 116,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7101,
        "code": " deposit structure holds all the info about the deposit made\n    struct Deposit {\n        address depositor; //The depositor address\n        uint128 deposit;   //The deposit amount\n        uint128 expect;    //How much we should pay out (initially it is 111%-141% of deposit)\n    }\n\n    struct DepositCount {\n        int128 stage;\n        uint128 count;\n    }\n\n    struct LastDepositInfo {\n        uint128 index;\n        uint128 time;\n    }\n\n    Deposit[] private queue;  //The queue\n    uint public currentReceiverIndex = 0; //The index of the first depositor in the queue. The receiver of investments!\n    LastDepositInfo public lastDepositInfo; //The time last deposit made at\n\n    uint public prizeAmount = 0; //Prize amount accumulated for the last depositor\n    int public stage = 0; //Number of contract runs\n    mapping(address => DepositCount) public depositsMade; //The number of deposits of different depositors\n\n    //This function receives all the deposits\n    //stores them and make immediate payouts\n    function () public payable {\n        //If money are from first multiplier, just add them to the balance\n        //All these money will be distributed to current investors\n        if(msg.value > 0 && msg.sender != FATHER){\n            require(gasleft() >= 220000, \"We require more gas!\"); //We need gas to process queue\n            require(msg.value <= MAX_INVESTMENT, \"The investment is too much!\"); //Do not allow too big investments to stabilize payouts\n\n            checkAndUpdateStage();\n\n            addDeposit(msg.sender, msg.value);\n\n            //Pay to first investors in line\n            pay();\n        }else if(msg.value == 0){\n            withdrawPrize();\n        }\n    }\n\n    //Used to pay to current investors\n    //Each new transaction processes 1 - 4+ investors in the head of queue\n    //depending on balance and gas left\n    function pay() private {\n        //Try to send all the money on contract to the first investors in line\n        uint balance = address(this).balance;\n        uint128 money = 0;\n        if(balance > prizeAmount) //The opposite is impossible, however the check will not do any harm\n            money = uint128(balance - prizeAmount);\n\n        //We will do cycle on the queue\n        for(uint i=currentReceiverIndex; i<queue.length; i++){\n\n            Deposit storage dep = queue[i]; //get the info of the first investor\n\n            if(money >= dep.expect){  //If we have enough money on the contract to fully pay to investor\n                dep.depositor.send(dep.expect); //Send money to him\n                money -= dep.expect;            //update money left\n\n                //this investor is fully paid, so remove him\n                delete queue[i];\n            }else{\n                //Here we don't have enough money so partially pay to investor\n                dep.depositor.send(money); //Send to him everything we have\n                dep.expect -= money;       //Update the expected amount\n                break;                     //Exit cycle\n            }\n\n            if(gasleft() <= 50000)         //Check the gas left. If it is low, exit the cycle\n                break;                     //The next investor will process the line further\n        }\n\n        currentReceiverIndex = i; //Update the index of the current first investor\n    }\n\n    function addDeposit(address depositor, uint value) private {\n        //Count the number of the deposit at this stage\n        DepositCount storage c = depositsMade[depositor];\n        if(c.stage != stage){\n            c.stage = int128(stage);\n            c.count = 0;\n        }\n\n        //If you are applying for the prize you should invest more than minimal amount\n        //Otherwize it doesn't count\n        if(value >= MIN_INVESTMENT_FOR_PRIZE)\n            lastDepositInfo = LastDepositInfo(uint128(queue.length), uint128(now));\n\n        //Compute the multiplier percent for this depositor\n        uint multiplier = getDepositorMultiplier(depositor);\n        //Add the investor into the queue. Mark that he expects to receive 111%-141% of deposit back\n        queue.push(Deposit(depositor, uint128(value), uint128(value*multiplier/100)));\n\n        //Increment number of deposits the depositors made this round\n        c.count++;\n\n        //Save money for prize and father multiplier\n        prizeAmount += value*(FATHER_PERCENT + PRIZE_PERCENT)/100;\n\n        //Send small part to tech support\n        uint support = value*TECH_PERCENT/100;\n        TECH.send(support);\n        uint adv = value*PROMO_PERCENT/100;\n        PROMO.send(adv);\n\n    }\n\n    function checkAndUpdateStage() private{\n        int _stage = getCurrentStageByTime();\n\n        require(_stage >= stage, \"We should only go forward in time\");\n\n        if(_stage != stage){\n            proceedToNewStage(_stage);\n        }\n    }\n\n    function proceedToNewStage(int _stage) private {\n        //Clean queue info\n        //The prize amount on the balance is left the same if not withdrawn\n        stage = _stage;\n        delete queue;\n        currentReceiverIndex = 0;\n        delete lastDepositInfo;\n    }\n\n    function withdrawPrize() private {\n        //You can withdraw prize only if the last deposit was more than MAX_IDLE_TIME ago\n        require(lastDepositInfo.time > 0 && lastDepositInfo.time <= now - MAX_IDLE_TIME, \"The last depositor is not confirmed yet\");\n        //Last depositor will receive prize only if it has not been fully paid\n        require(currentReceiverIndex <= lastDepositInfo.index, \"The last depositor should still be in queue\");\n\n        uint balance = address(this).balance;\n        if(prizeAmount > balance) //Impossible but better check it\n            prizeAmount = balance;\n\n        //Send donation to the first multiplier for it to spin faster\n        //It already contains all the sum, so we must split for father and last depositor only\n        //If the .call fails then ether will just stay on the contract to be distributed to\n        //the queue at the next stage\n        uint donation = prizeAmount*FATHER_PERCENT/(FATHER_PERCENT + PRIZE_PERCENT);\n        require(gasleft() >= 250000, \"We need gas for the father contract\");\n        FATHER.call.value(donation).gas(gasleft())();\n\n        uint prize = prizeAmount - donation;\n        queue[lastDepositInfo.index].depositor.send(prize);\n\n        prizeAmount = 0;\n        proceedToNewStage(stage + 1);\n    }\n\n    //Get the deposit info by its index\n    //You can get deposit index from\n    function getDeposit(uint idx) public view returns (address depositor, uint deposit, uint expect){\n        Deposit storage dep = queue[idx];\n        return (dep.depositor, dep.deposit, dep.expect);\n    }\n\n    //Get the count of deposits of specific investor\n    function getDepositsCount(address depositor) public view returns (uint) {\n        uint c = 0;\n        for(uint i=currentReceiverIndex; i<queue.length; ++i){\n            if(queue[i].depositor == depositor)\n                c++;\n        }\n        return c;\n    }\n\n    //Get all deposits (index, deposit, expect) of a specific investor\n    function getDeposits(address depositor) public view returns (uint[] idxs, uint128[] deposits, uint128[] expects) {\n        uint c = getDepositsCount(depositor);\n\n        idxs = new uint[](c);\n        deposits = new uint128[](c);\n        expects = new uint128[](c);\n\n        if(c > 0) {\n            uint j = 0;\n            for(uint i=currentReceiverIndex; i<queue.length; ++i){\n                Deposit storage dep = queue[i];\n                if(dep.depositor == depositor){\n                    idxs[j] = i;\n                    deposits[j] = dep.deposit;\n                    expects[j] = dep.expect;\n                    j++;\n                }\n            }\n        }\n    }\n\n    //Get current queue size\n    function getQueueLength() public view returns (uint) {\n        return queue.length - currentReceiverIndex;\n    }\n\n    //Get current depositors multiplier percent at this stage\n    function getDepositorMultiplier(address depositor) public view returns (uint) {\n        DepositCount storage c = depositsMade[depositor];\n        uint count = 0;\n        if(c.stage == getCurrentStageByTime())\n            count = c.count;\n        if(count < MULTIPLIERS.length)\n            return MULTIPLIERS[count];\n\n        return MULTIPLIERS[MULTIPLIERS.length - 1];\n    }\n\n    function getCurrentStageByTime() public view returns (int) {\n        return int(now - 17 hours) / 1 days - 17836; //Start is 01/11/2018 20:00 GMT+3\n    }\n\n    function getStageStartTime(int _stage) public pure returns (int) {\n        return 17 hours + (_stage + 17836)*1 days;\n    }\n\n    function getCurrentCandidateForPrize() public view returns (address addr, int timeLeft){\n        Deposit storage d = queue[lastDepositInfo.index];\n        addr = d.depositor;\n        timeLeft = int(lastDepositInfo.time + MAX_IDLE_TIME) - int(now);\n    }\n\n}",
        "debug": "storage_2: 0x926de0eac2f43530675700400030003\nstorage_1: 0x400038aaf2837e000782e1003ba141e99201ea6e813e070248601e0046000203\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x0\ngas: 0x3d090\nstorage_4: 0x1\ntimestamp: 0x142b7d4e983f06a60e6ad80402020712\nstorage_3: 0x142b7d4e983f06a60e6ad8040202000a00\ncalldatasize_Multipliers: 0x3\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/12/0x5f8797e606793af4d76a0adecf2e1e9879e2811a.sol",
        "function": "fallback",
        "lineno": 116,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}