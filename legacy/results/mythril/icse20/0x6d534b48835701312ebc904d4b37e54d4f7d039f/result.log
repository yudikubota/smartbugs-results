{"error": null, "issues": [{"address": 1202, "code": "PASM_.disburse.value(base)();// to dev fee sharing contract\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\n}\n\n// bugtest selfdestruct f", "debug": "calldata_Snip3D_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "changevanity(string)", "lineno": 378, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3116, "code": "}\n\n    \n}\ninterface Hou", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "P3DDivstocontract()", "lineno": 385, "title": "Message call to external contract", "type": "Informational"}, {"address": 3116, "code": "}\n\n    \n}\ninterface Hou", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3303\n", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "P3DDivstocontract()", "lineno": 385, "title": "Multiple Calls", "type": "Information"}, {"address": 3303, "code": "ble external returns(uint256)", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "P3DDivstocontract()", "lineno": 391, "title": "Message call to external contract", "type": "Informational"}, {"address": 3429, "code": "turn (number);\n    }\n    function ", "debug": "block_number: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Snip3D_4: 0x1\ncalldata_Snip3D_0: 0x182a7f7200000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `blocksTillSemiShoot(address)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "blocksTillSemiShoot(address)", "lineno": 165, "title": "Integer Underflow", "type": "Warning"}, {"address": 6065, "code": "{\n        \n        return (RefundWaitin", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "harvestabledivs()", "lineno": 146, "title": "Message call to external contract", "type": "Informational"}, {"address": 6065, "code": "{\n        \n        return (RefundWaitin", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3303\nCall at address: 3116\n", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "P3DDivstocontract()", "lineno": 146, "title": "Multiple Calls", "type": "Information"}, {"address": 6295, "code": "aimedDividends.sub(owing);\n    \n    account.transfer(owin", "debug": "The exception is triggered under the following conditions:\n\nstorage_18: 0x0\nstorage_1 +\nkeccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Snip3D_4: 0x0\ncalldata_Snip3D_0: 0x358fcee900000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\nstorage_14: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "fetchdivs(address)", "lineno": 199, "title": "Exception state", "type": "Informational"}, {"address": 11558, "code": "ing(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 200;\n    uint256 public blocksBeforeTargetShoot = 800;\n    \n    // events\n    event death(address indexed player);\n    event semiShot(address indexed player);\n    event targetShot(address indexed player);\n    \n    //constructor\n    constructor()\n        public\n    {\n        \n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( P3Dcontract_.dividendsOf(address(this)))  ;\n    }\n    function nextonetogetpaid()\n        public\n        view\n        returns(address)\n    {\n        \n        return (RefundWaitingLine[NextInLine]);\n    }\n    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function blocksTillSemiShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\n        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\n    function blocksTillTargetShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\n        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    account.transfer(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 finney)(masternode);\n    // check excess of payed \n     if(value > 100 finney){Refundpot += value - 100 finney;}\n    // progress refundline\n    Refundpot += 5 finney;\n    // send SPASM cut\n    SPASM_.disburse.value(2 finney)();\n\n}\nfunction sendInSoldierReferal(address masternode, address referal) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 finney)(masternode);\n    // check excess of payed \n    if(value > 100 finney){Refundpot += value - 100 finney;}\n    // progress refundline\n    Refundpot += 5 finney;\n    // send SPASM cut\n    SPASM_.disburse.value(1 finney)();\n    // send referal cut\n    referal.transfer(1 finney);\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    // update divs loser\n    fetchdivs(killed);\n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    \n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit semiShot(sender);\n    emit death(killed);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target <= nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    if(target == nextFormation){target = 0;}\n    address killed = formation[target];\n    \n    // update divs loser\n    fetchdivs(killed);\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // fetch contracts divs\n    //allocate p3d dividends to contract \n            uint256 dividends =  harvestabledivs();\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    uint256 amt2 = dividends.sub(base);\n    Refundpot = Refundpot.add(amt2);\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit targetShot(sender);\n    emit death(killed);\n}\n\nfunction Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\n}\n\n// bugtest selfdestruct function - deactivate on live\n//  function die () public onlyOwner {\n//      selfdestruct(msg.sender);\n//  }\n\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function dividendsOf(address _playerAddress) external view returns(uint256);\n    function ", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xbac1c3147749165dd7d1977fffffffffffffffffffffffffffffffffffffffc5\nkeccac_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff13e6a7459ae5a4c49c419171c3f89100a371508000000000129200000219e2\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "changevanity(string)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11587, "code": "ing(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 200;\n    uint256 public blocksBeforeTargetShoot = 800;\n    \n    // events\n    event death(address indexed player);\n    event semiShot(address indexed player);\n    event targetShot(address indexed player);\n    \n    //constructor\n    constructor()\n        public\n    {\n        \n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( P3Dcontract_.dividendsOf(address(this)))  ;\n    }\n    function nextonetogetpaid()\n        public\n        view\n        returns(address)\n    {\n        \n        return (RefundWaitingLine[NextInLine]);\n    }\n    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function blocksTillSemiShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\n        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\n    function blocksTillTargetShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\n        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    account.transfer(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 finney)(masternode);\n    // check excess of payed \n     if(value > 100 finney){Refundpot += value - 100 finney;}\n    // progress refundline\n    Refundpot += 5 finney;\n    // send SPASM cut\n    SPASM_.disburse.value(2 finney)();\n\n}\nfunction sendInSoldierReferal(address masternode, address referal) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 finney)(masternode);\n    // check excess of payed \n    if(value > 100 finney){Refundpot += value - 100 finney;}\n    // progress refundline\n    Refundpot += 5 finney;\n    // send SPASM cut\n    SPASM_.disburse.value(1 finney)();\n    // send referal cut\n    referal.transfer(1 finney);\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    // update divs loser\n    fetchdivs(killed);\n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    \n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit semiShot(sender);\n    emit death(killed);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target <= nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    if(target == nextFormation){target = 0;}\n    address killed = formation[target];\n    \n    // update divs loser\n    fetchdivs(killed);\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // fetch contracts divs\n    //allocate p3d dividends to contract \n            uint256 dividends =  harvestabledivs();\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    uint256 amt2 = dividends.sub(base);\n    Refundpot = Refundpot.add(amt2);\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit targetShot(sender);\n    emit death(killed);\n}\n\nfunction Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\n}\n\n// bugtest selfdestruct function - deactivate on live\n//  function die () public onlyOwner {\n//      selfdestruct(msg.sender);\n//  }\n\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function dividendsOf(address _playerAddress) external view returns(uint256);\n    function ", "debug": "calldata_Snip3D_4 + calldata_Snip3D_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "changevanity(string)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11601, "code": "ing(address => uint256)public  balances;// soldiers on field\n    mapping(address => uint256)public  bullets;// amount of bullets Owned\n    mapping(uint256 => address)public  formation;// the playing field\n    uint256 public nextFormation;// next spot in formation\n    mapping(address => uint256)public lastMove;//blocknumber lastMove\n    mapping(uint256 => address) public RefundWaitingLine;\n    uint256 public  NextInLine;//next person to be refunded\n    uint256 public  NextAtLineEnd;//next spot to add loser\n    uint256 public Refundpot;\n    uint256 public blocksBeforeSemiRandomShoot = 200;\n    uint256 public blocksBeforeTargetShoot = 800;\n    \n    // events\n    event death(address indexed player);\n    event semiShot(address indexed player);\n    event targetShot(address indexed player);\n    \n    //constructor\n    constructor()\n        public\n    {\n        \n        \n    }\n    //mods\n    modifier isAlive()\n    {\n        require(balances[msg.sender] > 0);\n        _;\n    }\n    // divfunctions\nHourglassInterface constant P3Dcontract_ = HourglassInterface(0xB3775fB83F7D12A36E0475aBdD1FCA35c091efBe);\nSPASMInterface constant SPASM_ = SPASMInterface(0xfaAe60F2CE6491886C9f7C9356bd92F688cA66a1);\n// view functions\nfunction harvestabledivs()\n        view\n        public\n        returns(uint256)\n    {\n        return ( P3Dcontract_.dividendsOf(address(this)))  ;\n    }\n    function nextonetogetpaid()\n        public\n        view\n        returns(address)\n    {\n        \n        return (RefundWaitingLine[NextInLine]);\n    }\n    function playervanity(address theplayer)\n        public\n        view\n        returns( string )\n    {\n        return (Vanity[theplayer]);\n    }\n    function blocksTillSemiShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeSemiRandomShoot)\n        {number = blocksBeforeSemiRandomShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\n    function blocksTillTargetShoot(address theplayer)\n        public\n        view\n        returns( uint256 )\n    {\n        uint256 number;\n        if(block.number - lastMove[theplayer] < blocksBeforeTargetShoot)\n        {number = blocksBeforeTargetShoot -(block.number - lastMove[theplayer]);}\n        return (number);\n    }\nfunction amountofp3d() external view returns(uint256){\n    return ( P3Dcontract_.balanceOf(address(this)))  ;\n}\n    //divsection\nuint256 public pointMultiplier = 10e18;\nstruct Account {\n  uint balance;\n  uint lastDividendPoints;\n}\nmapping(address=>Account) accounts;\nmapping(address => string) public Vanity;\nuint public ethtotalSupply;\nuint public totalDividendPoints;\nuint public unclaimedDividends;\n\nfunction dividendsOwing(address account) public view returns(uint256) {\n  uint256 newDividendPoints = totalDividendPoints.sub(accounts[account].lastDividendPoints);\n  return (balances[account] * newDividendPoints) / pointMultiplier;\n}\nmodifier updateAccount(address account) {\n  uint256 owing = dividendsOwing(account);\n  if(owing > 0) {\n    unclaimedDividends = unclaimedDividends.sub(owing);\n    \n    account.transfer(owing);\n  }\n  accounts[account].lastDividendPoints = totalDividendPoints;\n  _;\n}\nfunction () external payable{}\nfunction fetchdivs(address toupdate) public updateAccount(toupdate){}\n// Gamefunctions\nfunction sendInSoldier(address masternode) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 finney)(masternode);\n    // check excess of payed \n     if(value > 100 finney){Refundpot += value - 100 finney;}\n    // progress refundline\n    Refundpot += 5 finney;\n    // send SPASM cut\n    SPASM_.disburse.value(2 finney)();\n\n}\nfunction sendInSoldierReferal(address masternode, address referal) public updateAccount(msg.sender)  payable{\n    uint256 value = msg.value;\n    require(value >= 100 finney);// sending in sol costs 0.1 eth\n    address sender = msg.sender;\n    // add life\n    balances[sender]++;\n    // update totalSupply\n    _totalSupply++;\n    // add bullet \n    bullets[sender]++;\n    // add to playing field\n    formation[nextFormation] = sender;\n    nextFormation++;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    // buy P3D\n    P3Dcontract_.buy.value(5 finney)(masternode);\n    // check excess of payed \n    if(value > 100 finney){Refundpot += value - 100 finney;}\n    // progress refundline\n    Refundpot += 5 finney;\n    // send SPASM cut\n    SPASM_.disburse.value(1 finney)();\n    // send referal cut\n    referal.transfer(1 finney);\n\n}\nfunction shootSemiRandom() public isAlive() {\n    address sender = msg.sender;\n    require(block.number > lastMove[sender] + blocksBeforeSemiRandomShoot);\n    require(bullets[sender] > 0);\n    uint256 semiRNG = (block.number.sub(lastMove[sender])) % 200;\n    \n    uint256 shot = uint256 (blockhash(block.number.sub(semiRNG))) % nextFormation;\n    address killed = formation[shot];\n    // solo soldiers self kill prevention - shoots next in line instead\n    if(sender == killed)\n    {\n        shot = uint256 (blockhash(block.number.sub(semiRNG).add(1))) % nextFormation;\n        killed = formation[shot];\n    }\n    // update divs loser\n    fetchdivs(killed);\n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[shot] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    \n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit semiShot(sender);\n    emit death(killed);\n\n}\nfunction shootTarget(uint256 target) public isAlive() {\n    address sender = msg.sender;\n    require(target <= nextFormation && target > 0);\n    require(block.number > lastMove[sender] + blocksBeforeTargetShoot);\n    require(bullets[sender] > 0);\n    if(target == nextFormation){target = 0;}\n    address killed = formation[target];\n    \n    // update divs loser\n    fetchdivs(killed);\n    \n    // remove life\n    balances[killed]--;\n    // update totalSupply\n    _totalSupply--;\n    // remove bullet \n    bullets[sender]--;\n    // remove from playing field\n    uint256 lastEntry = nextFormation.sub(1);\n    formation[target] = formation[lastEntry];\n    nextFormation--;\n    // reset lastMove to prevent people from adding bullets and start shooting\n    lastMove[sender] = block.number;\n    \n    // add loser to refundline\n    RefundWaitingLine[NextAtLineEnd] = killed;\n    NextAtLineEnd++;\n    // fetch contracts divs\n    //allocate p3d dividends to contract \n            uint256 dividends =  harvestabledivs();\n            require(dividends > 0);\n            uint256 base = dividends.div(100);\n            P3Dcontract_.withdraw();\n            SPASM_.disburse.value(base)();// to dev fee sharing contract SPASM\n    // disburse eth to survivors\n    uint256 amount = 88 finney;\n    uint256 amt2 = dividends.sub(base);\n    Refundpot = Refundpot.add(amt2);\n    totalDividendPoints = totalDividendPoints.add(amount.mul(pointMultiplier).div(_totalSupply));\n    unclaimedDividends = unclaimedDividends.add(amount);\n    emit targetShot(sender);\n    emit death(killed);\n}\n\nfunction Payoutnextrefund ()public\n    {\n        //allocate p3d dividends to sacrifice if existing\n            uint256 Pot = Refundpot;\n            require(Pot > 0.1 ether);\n            Refundpot -= 0.1 ether;\n            RefundWaitingLine[NextInLine].transfer(0.1 ether);\n            NextInLine++;\n            //\n    }\n\nfunction disburse() public  payable {\n    uint256 amount = msg.value;\n    uint256 base = amount.div(100);\n    uint256 amt2 = amount.sub(base);\n  totalDividendPoints = totalDividendPoints.add(amt2.mul(pointMultiplier).div(_totalSupply));\n unclaimedDividends = unclaimedDividends.add(amt2);\n \n}\nfunction changevanity(string van) public payable{\n    require(msg.value >= 1  finney);\n    Vanity[msg.sender] = van;\n    Refundpot += msg.value;\n}\nfunction P3DDivstocontract() public{\n    uint256 divs = harvestabledivs();\n    require(divs > 0);\n \nP3Dcontract_.withdraw();\n    //1% to owner\n    uint256 base = divs.div(100);\n    uint256 amt2 = divs.sub(base);\n    SPASM_.disburse.value(base)();// to dev fee sharing contract\n   Refundpot = Refundpot.add(amt2);// add divs to refund line\n}\n\n// bugtest selfdestruct function - deactivate on live\n//  function die () public onlyOwner {\n//      selfdestruct(msg.sender);\n//  }\n\n    \n}\ninterface HourglassInterface  {\n    function() payable external;\n    function buy(address _playerAddress) payable external returns(uint256);\n    function sell(uint256 _amountOfTokens) external;\n    function reinvest() external;\n    function withdraw() external;\n    function exit() external;\n    function dividendsOf(address _playerAddress) external view returns(uint256);\n    function ", "debug": "calldata_Snip3D_4 + calldata_Snip3D_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\ncallvalue: 0x38d7ea4c68000\ncalldata_Snip3D_0: 0x61df829800000000000000000000000000000000000000000000000000000000\ncalldatasize_Snip3D: 0x4\n", "description": "A possible integer overflow exists in the function `changevanity(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/3/0x6d534b48835701312ebc904d4b37e54d4f7d039f.sol", "function": "changevanity(string)", "lineno": 101, "title": "Integer Overflow ", "type": "Warning"}], "success": true}