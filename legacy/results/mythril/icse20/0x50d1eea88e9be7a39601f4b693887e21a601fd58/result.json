{
  "contract": "0x50d1eea88e9be7a39601f4b693887e21a601fd58",
  "tool": "mythril",
  "start": 1563609802.053132,
  "end": 1563609965.1381605,
  "duration": 163.08502840995789,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 638,
        "code": "zenFunds(addresses[i], freeze);\n\t\t\t\n\t\t\tif (isContract(addresses[i])) {\n\t\t\t\ttransferToContract(addresses[i], _value);\n\t\t\t} \n\t\t\telse {\n\t\t\t\ttransferToAddress(addresses[i], _value);\n\t\t\t}\n\t\t}\n\t}\n}",
        "debug": "calldata_TokenRHT_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenRHT_0: 0x153737f500000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenRHT: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `OWN_DistributeTokenAdmin_Multi(address[],uint256,bool)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol",
        "function": "OWN_DistributeTokenAdmin_Multi(address[],uint256,bool)",
        "lineno": 258,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1353,
        "code": "ock smart contract\n    function OWN_contractlocked(bool _locked) onlyOwner public {\n        SC_locked = _locked;\n    }\n\t\n\t// Destroy tokens amount from another accoun",
        "debug": "calldata_TokenRHT_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_TokenRHT_0: 0x8839515c00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenRHT: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `OWN_ChangeToken(string,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol",
        "function": "OWN_ChangeToken(string,string,uint8)",
        "lineno": 203,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 4154,
        "code": "   //aggiungo i decim",
        "debug": "calldata_TokenRHT_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_TokenRHT_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_5: 0x0\ncaller: 0x0\ncalldata_TokenRHT_0: 0x75fcc6f100000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenRHT: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer underflow exists in the function `OWN_burnToken(address,uint256)`.\nThe subtraction may result in a value < 0.",
        "filename": "/unique_chucks/20/0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol",
        "function": "OWN_burnToken(address,uint256)",
        "lineno": 219,
        "title": "Integer Underflow",
        "type": "Warning"
      },
      {
        "address": 6339,
        "code": " string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n    bool public SC_locked = true;\n    bool public tokenCreated = false;\n\tuint public DateCreateToken;\n\n    mapping(address => uint256) balances;\n    mapping(address => bool) public frozenAccount;\n\tmapping(address => bool) public SmartContract_Allowed;\n\n    // Initialize\n    // Constructor is called only once and can not be called again (Ethereum Solidity specification)\n    function TokenRHT() public {\n        // Security check in case EVM has future flaw or exploit to call constructor multiple times\n        require(tokenCreated == false);\n\n        owner = msg.sender;\n        \n\t\tname = \"REALTHIUM\";\n        symbol = \"RHT\";\n        decimals = 5;\n        totalSupply = 500000000 * 10 ** uint256(decimals);\n        balances[owner] = totalSupply;\n        emit Transfer(owner, owner, totalSupply);\n\t\t\n        tokenCreated = true;\n\n        // Final sanity check to ensure owner balance is greater than zero\n        require(balances[owner] > 0);\n\n\t\t// Date Deploy Contract\n\t\tDateCreateToken = now;\n    }\n\t\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\t// Function to create date token.\n    function DateCreateToken() public view returns (uint256 _DateCreateToken) {\n\t\treturn DateCreateToken;\n\t}\n   \t\n    // Function to access name of token .\n    function name() view public returns (string _name) {\n\t\treturn name;\n\t}\n\t\n    // Function to access symbol of token .\n    function symbol() public view returns (string _symbol) {\n\t\treturn symbol;\n    }\n\n    // Function to access decimals of token .\n    function decimals() public view returns (uint8 _decimals) {\t\n\t\treturn decimals;\n    }\n\n    // Function to access total supply of tokens .\n    function totalSupply() public view returns (uint256 _totalSupply) {\n\t\treturn totalSupply;\n\t}\n\t\n\t// Get balance of the address provided\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n\t// Get Smart Contract of the address approved\n    function SmartContract_Allowed(address _target) constant public returns (bool _sc_address_allowed) {\n        return SmartContract_Allowed[_target];\n    }\n\n    // Added due to backwards compatibility reasons .\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        // Only allow transfer once Locked\n        require(!SC_locked);\n\t\trequire(!frozenAccount[msg.sender]);\n\t\trequire(!frozenAccount[_to]);\n\n        //standard function transfer similar to ERC20 transfer with no _data\n        if (isContract(_to)) {\n            return transferToContract(_to, _value);\n        } \n        else {\n            return transferToAddress(_to, _value);\n        }\n    }\n\n\t// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n    function isContract(address _addr) private view returns (bool is_contract) {\n        uint length;\n        assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        return (length > 0);\n    }\n\n    // function that is called when transaction target is an address\n    function transferToAddress(address _to, uint256 _value) private returns (bool success) {\n        if (balanceOf(msg.sender) < _value) revert();\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n        balances[_to] = safeAdd(balanceOf(_to), _value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    // function that is called when transaction target is a contract\n    function transferToContract(address _to, uint256 _value) private returns (bool success) {\n        require(SmartContract_Allowed[_to]);\n\t\t\n\t\tif (balanceOf(msg.sender) < _value) revert();\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n        balances[_to] = safeAdd(balanceOf(_to), _value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n\t// Function to activate Ether reception in the smart Contract address only by the Owner\n    function () public payable { \n\t\tif(msg.sender != owner) { revert(); }\n    }\n\n\t// Creator/Owner change name and symbol\n    function OWN_ChangeToken(string _name, string _symbol, uint8 _decimals) onlyOwner public {\n\t\tname = _name;\n        symbol = _symbol;\n\t\tdecimals = _decimals;\n    }\n\n\t// Creator/Owner can Locked/Unlock smart contract\n    function OWN_contractlocked(bool _locked) onlyOwner public {\n        SC_locked = _locked;\n    }\n\t\n\t// Destroy tokens amount from another account (Caution!!! the operation is destructive and you can not go back)\n    function OWN_burnToken(address _from, uint256 _value)  onlyOwner public returns (bool success) {\n        require(balances[_from] >= _value);\n        balances[_from] -= _value;\n        totalSupply -= _value;\n        emit Burn(_from, _value);\n        return true;\n    }\n\t\n\t//Generate other tokens after starting the program\n    function OWN_mintToken(uint256 mintedAmount) onlyOwner public {\n        //aggiungo i decimali al valore che imposto\n        balances[owner] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(0, this, mintedAmount);\n        emit Transfer(this, owner, mintedAmount);\n    }\n\t\n\t// Block / Unlock address handling tokens\n    function OWN_freezeAddress(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\t\t\n\t// Function to destroy the smart contract\n    function OWN_kill() onlyOwner public { \n\t\tselfdestruct(owner); \n    }\n\t\n\t// Function Change Owner\n\tfunction OWN_transferOwnership(address newOwner) onlyOwner public {\n        // function allowed only if the address is not smart contract\n        if (!isContract(newOwner)) {\t\n\t\t\towner = newOwner;\n\t\t}\n    }\n\t\n\t// Smart Contract approved\n    function OWN_SmartContract_Allowed(address target, bool _allowed) onlyOwner public {\n\t\t// function allowed only for smart contract\n        if (isContract(target)) {\n\t\t\tSmartContract_Allowed[target] = _allowed;\n\t\t}\n    }\n\n\t// Distribution Token from Admin\n\tfunction OWN_DistributeTokenAdmin_Multi(address[] addresses, uint256 _value, bool freeze) onlyOwner public {\n\t\tfor (uint i = 0; i < addresses.length; i++) {\n\t\t\t//Block / Unlock address handling tokens\n\t\t\tfrozenAccount[addresses[i]] = freeze;\n\t\t\temit FrozenFunds(addresses[i], freeze);\n\t\t\t\n\t\t\tif (isContract(addresses[i])) {\n\t\t\t\ttransferToContract(addresses[i], _value);\n\t\t\t} \n\t\t\telse {\n\t\t\t\ttransferToAddress(addresses[i], _value);\n\t\t\t}\n\t\t}\n\t}\n}",
        "debug": "calldata_TokenRHT_4 + calldata_TokenRHT_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_5: 0x0\ncaller: 0x0\ncalldata_TokenRHT_0: 0x8839515c00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenRHT: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `OWN_ChangeToken(string,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol",
        "function": "OWN_ChangeToken(string,string,uint8)",
        "lineno": 69,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 6353,
        "code": " string public symbol;\n    uint8 public decimals;\n    uint256 public totalSupply;\n    address public owner;\n    bool public SC_locked = true;\n    bool public tokenCreated = false;\n\tuint public DateCreateToken;\n\n    mapping(address => uint256) balances;\n    mapping(address => bool) public frozenAccount;\n\tmapping(address => bool) public SmartContract_Allowed;\n\n    // Initialize\n    // Constructor is called only once and can not be called again (Ethereum Solidity specification)\n    function TokenRHT() public {\n        // Security check in case EVM has future flaw or exploit to call constructor multiple times\n        require(tokenCreated == false);\n\n        owner = msg.sender;\n        \n\t\tname = \"REALTHIUM\";\n        symbol = \"RHT\";\n        decimals = 5;\n        totalSupply = 500000000 * 10 ** uint256(decimals);\n        balances[owner] = totalSupply;\n        emit Transfer(owner, owner, totalSupply);\n\t\t\n        tokenCreated = true;\n\n        // Final sanity check to ensure owner balance is greater than zero\n        require(balances[owner] > 0);\n\n\t\t// Date Deploy Contract\n\t\tDateCreateToken = now;\n    }\n\t\n    modifier onlyOwner() {\n        require(msg.sender == owner);\n        _;\n    }\n\n\t// Function to create date token.\n    function DateCreateToken() public view returns (uint256 _DateCreateToken) {\n\t\treturn DateCreateToken;\n\t}\n   \t\n    // Function to access name of token .\n    function name() view public returns (string _name) {\n\t\treturn name;\n\t}\n\t\n    // Function to access symbol of token .\n    function symbol() public view returns (string _symbol) {\n\t\treturn symbol;\n    }\n\n    // Function to access decimals of token .\n    function decimals() public view returns (uint8 _decimals) {\t\n\t\treturn decimals;\n    }\n\n    // Function to access total supply of tokens .\n    function totalSupply() public view returns (uint256 _totalSupply) {\n\t\treturn totalSupply;\n\t}\n\t\n\t// Get balance of the address provided\n    function balanceOf(address _owner) constant public returns (uint256 balance) {\n        return balances[_owner];\n    }\n\n\t// Get Smart Contract of the address approved\n    function SmartContract_Allowed(address _target) constant public returns (bool _sc_address_allowed) {\n        return SmartContract_Allowed[_target];\n    }\n\n    // Added due to backwards compatibility reasons .\n    function transfer(address _to, uint256 _value) public returns (bool success) {\n        // Only allow transfer once Locked\n        require(!SC_locked);\n\t\trequire(!frozenAccount[msg.sender]);\n\t\trequire(!frozenAccount[_to]);\n\n        //standard function transfer similar to ERC20 transfer with no _data\n        if (isContract(_to)) {\n            return transferToContract(_to, _value);\n        } \n        else {\n            return transferToAddress(_to, _value);\n        }\n    }\n\n\t// assemble the given address bytecode. If bytecode exists then the _addr is a contract.\n    function isContract(address _addr) private view returns (bool is_contract) {\n        uint length;\n        assembly {\n            //retrieve the size of the code on target address, this needs assembly\n            length := extcodesize(_addr)\n        }\n        return (length > 0);\n    }\n\n    // function that is called when transaction target is an address\n    function transferToAddress(address _to, uint256 _value) private returns (bool success) {\n        if (balanceOf(msg.sender) < _value) revert();\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n        balances[_to] = safeAdd(balanceOf(_to), _value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n    // function that is called when transaction target is a contract\n    function transferToContract(address _to, uint256 _value) private returns (bool success) {\n        require(SmartContract_Allowed[_to]);\n\t\t\n\t\tif (balanceOf(msg.sender) < _value) revert();\n        balances[msg.sender] = safeSub(balanceOf(msg.sender), _value);\n        balances[_to] = safeAdd(balanceOf(_to), _value);\n        emit Transfer(msg.sender, _to, _value);\n        return true;\n    }\n\n\t// Function to activate Ether reception in the smart Contract address only by the Owner\n    function () public payable { \n\t\tif(msg.sender != owner) { revert(); }\n    }\n\n\t// Creator/Owner change name and symbol\n    function OWN_ChangeToken(string _name, string _symbol, uint8 _decimals) onlyOwner public {\n\t\tname = _name;\n        symbol = _symbol;\n\t\tdecimals = _decimals;\n    }\n\n\t// Creator/Owner can Locked/Unlock smart contract\n    function OWN_contractlocked(bool _locked) onlyOwner public {\n        SC_locked = _locked;\n    }\n\t\n\t// Destroy tokens amount from another account (Caution!!! the operation is destructive and you can not go back)\n    function OWN_burnToken(address _from, uint256 _value)  onlyOwner public returns (bool success) {\n        require(balances[_from] >= _value);\n        balances[_from] -= _value;\n        totalSupply -= _value;\n        emit Burn(_from, _value);\n        return true;\n    }\n\t\n\t//Generate other tokens after starting the program\n    function OWN_mintToken(uint256 mintedAmount) onlyOwner public {\n        //aggiungo i decimali al valore che imposto\n        balances[owner] += mintedAmount;\n        totalSupply += mintedAmount;\n        emit Transfer(0, this, mintedAmount);\n        emit Transfer(this, owner, mintedAmount);\n    }\n\t\n\t// Block / Unlock address handling tokens\n    function OWN_freezeAddress(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        emit FrozenFunds(target, freeze);\n    }\n\t\t\n\t// Function to destroy the smart contract\n    function OWN_kill() onlyOwner public { \n\t\tselfdestruct(owner); \n    }\n\t\n\t// Function Change Owner\n\tfunction OWN_transferOwnership(address newOwner) onlyOwner public {\n        // function allowed only if the address is not smart contract\n        if (!isContract(newOwner)) {\t\n\t\t\towner = newOwner;\n\t\t}\n    }\n\t\n\t// Smart Contract approved\n    function OWN_SmartContract_Allowed(address target, bool _allowed) onlyOwner public {\n\t\t// function allowed only for smart contract\n        if (isContract(target)) {\n\t\t\tSmartContract_Allowed[target] = _allowed;\n\t\t}\n    }\n\n\t// Distribution Token from Admin\n\tfunction OWN_DistributeTokenAdmin_Multi(address[] addresses, uint256 _value, bool freeze) onlyOwner public {\n\t\tfor (uint i = 0; i < addresses.length; i++) {\n\t\t\t//Block / Unlock address handling tokens\n\t\t\tfrozenAccount[addresses[i]] = freeze;\n\t\t\temit FrozenFunds(addresses[i], freeze);\n\t\t\t\n\t\t\tif (isContract(addresses[i])) {\n\t\t\t\ttransferToContract(addresses[i], _value);\n\t\t\t} \n\t\t\telse {\n\t\t\t\ttransferToAddress(addresses[i], _value);\n\t\t\t}\n\t\t}\n\t}\n}",
        "debug": "calldata_TokenRHT_4 + calldata_TokenRHT_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_5: 0x0\ncaller: 0x0\ncalldata_TokenRHT_0: 0x8839515c00000000000000000000000000000000000000000000000000000000\ncalldatasize_TokenRHT: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `OWN_ChangeToken(string,string,uint8)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/20/0x50d1eea88e9be7a39601f4b693887e21a601fd58.sol",
        "function": "OWN_ChangeToken(string,string,uint8)",
        "lineno": 69,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}