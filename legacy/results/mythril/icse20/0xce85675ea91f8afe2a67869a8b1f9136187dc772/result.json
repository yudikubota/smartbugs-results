{
  "contract": "0xce85675ea91f8afe2a67869a8b1f9136187dc772",
  "tool": "mythril",
  "start": 1563558664.6454706,
  "end": 1563559188.8070164,
  "duration": 524.161545753479,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 619,
        "code": " UniverseName;\n      min_donation = ",
        "debug": "",
        "description": "A possible transaction order independence vulnerability exists in function fallback. The value or direction of the call statement is determined from a tainted storage location",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "fallback",
        "lineno": 237,
        "title": "Transaction order dependence",
        "type": "Warning"
      },
      {
        "address": 1124,
        "debug": "calldata_PlanetToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 424,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1136,
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 424,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1145,
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 424,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 1151,
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 424,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2148,
        "code": "].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;",
        "debug": "calldata_PlanetToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 416,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2160,
        "code": "].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;",
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 416,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2169,
        "code": "].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;",
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 416,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 2175,
        "code": "].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;",
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 416,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 7999,
        "code": "t y, uint z) public \n  {\n    require(msg.se",
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff21\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 376,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8045,
        "code": "t y, uint z) public \n  {\n    require(msg.se",
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff01\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 376,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8091,
        "code": "t y, uint z) public \n  {\n    require(msg.se",
        "debug": "calldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffee1\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 376,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8186,
        "code": "t y, uint z) public \n  {\n    require(msg.se",
        "debug": "storage_19: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\ncalldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 376,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8210,
        "code": "t y, uint z) public \n  {\n    require(msg.se",
        "debug": "storage_19: 0xfffffffffeb6cf6dd76fd127f7faf2ff7ffdffffdffebe7df2f36e11ffffff01\ncalldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec1\ncalldata_PlanetToken_0: 0x3b69eed400000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetName(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetName(uint256,uint256,uint256,string)",
        "lineno": 376,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16683,
        "code": " public cordY;\n  mapping (uint => uint) public cordZ;\n  mapping (uint => uint) public lifeD;\n  mapping (uint => uint) public lifeN;\n  mapping (uint => uint) public lifeA;    \n  mapping (uint => uint) public latestPing;\n    \n  struct planet\n  {\n    uint x;\n    uint y;\n    uint z;\n    string name;\n    address owner;\n    string liason;\n    string url;\n    uint cost;\n    uint index;\n  }\n    \n  struct _donations\n  {\n      uint start;\n      uint genesis;\n      uint interval;\n      uint ppp;\n      uint amount;\n      uint checkpoint;\n  }\n\n  mapping(uint => planet) planets;\n  mapping(address => _donations) donations;\n  \n  string private universe;\n  uint private min_donation;\n  address private donation_address;\n  uint private coordinate_limit;\n\n  event TokenPing(uint tokenId);\n\n  function () public payable \n  {\n      donation_address.transfer(msg.value);\n  }\n    \n  function PlanetToken(string UniverseName, uint CoordinateLimit, address DonationAddress, uint StartingWeiDonation, uint BlockIntervals, uint WeiPerPlanet) public\n  {\n      universe = UniverseName;\n      min_donation = StartingWeiDonation;\n      coordinate_limit = CoordinateLimit;\n      donation_address = DonationAddress;\n      donations[donation_address].start = min_donation;\n      donations[donation_address].genesis = block.number;\n      donations[donation_address].checkpoint = block.number;\n      donations[donation_address].interval = BlockIntervals;\n      donations[donation_address].ppp = WeiPerPlanet;\n      donations[donation_address].amount = min_donation;\n  }\n\n  function assignNewPlanet(address beneficiary, uint x, uint y, uint z, string _planetName, string liason, string url) public payable \n  {  \n    // Check current fee\n    uint MinimumDonation = donations[donation_address].amount;\n      \n    // Check required paramters\n    require(tokenOwner[buildTokenId(x, y, z)] == 0);\n    require(msg.value >= MinimumDonation);\n    require(x <= coordinate_limit);\n    require(y <= coordinate_limit);\n    require(z <= coordinate_limit);\n     \n    // Update token records\n    latestPing[buildTokenId(x, y, z)] = now;\n    _addTokenTo(beneficiary, buildTokenId(x, y, z));\n    totalTokens++;\n    tokenMetadata[buildTokenId(x, y, z)] = _planetName;\n\n    // Update galactic records\n    cordX[buildTokenId(x, y, z)] = x;\n    cordY[buildTokenId(x, y, z)] = y;\n    cordZ[buildTokenId(x, y, z)] = z;\n\n    // Update DNA records\n    lifeD[buildTokenId(x, y, z)] = uint256(keccak256(x, '|x|', msg.sender, '|', universe));\n    lifeN[buildTokenId(x, y, z)] = uint256(keccak256(y, '|y|', msg.sender, '|', universe));\n    lifeA[buildTokenId(x, y, z)] = uint256(keccak256(z, '|z|', msg.sender, '|', universe));\n      \n    // Map the planet object too ...\n    planets[buildTokenId(x, y, z)].x = x;\n    planets[buildTokenId(x, y, z)].x = y;\n    planets[buildTokenId(x, y, z)].x = z;\n    planets[buildTokenId(x, y, z)].name = _planetName;\n    planets[buildTokenId(x, y, z)].owner = beneficiary;\n    planets[buildTokenId(x, y, z)].liason = liason;\n    planets[buildTokenId(x, y, z)].url = url;\n    planets[buildTokenId(x, y, z)].index = totalTokens - 1;\n    planets[buildTokenId(x, y, z)].cost = msg.value;\n\n    // Finalize process\n    TokenCreated(buildTokenId(x, y, z), beneficiary, _planetName);  \n    donation_address.transfer(msg.value);\n      \n    // Update donation info\n    uint this_block = block.number;\n    uint new_checkpoint = donations[donation_address].checkpoint + donations[donation_address].interval; \n    if(this_block > new_checkpoint)\n    {\n        donations[donation_address].checkpoint = this_block;\n        donations[donation_address].amount = donations[donation_address].ppp * totalTokens;\n    }\n  }\n    \n  function MinimumDonation() public view returns(uint)\n  {\n      return donations[donation_address].amount;\n  }\n    \n  function BlocksToGo() public view returns(uint)\n  {\n      uint this_block = block.number;\n      uint next_block = donations[donation_address].checkpoint + donations[donation_address].interval;\n      if(this_block < next_block)\n      {\n          return next_block - this_block;\n      }\n      else\n      {\n          return 0;\n      }\n  }\n    \n  function GetLiasonName(uint x, uint y, uint z) public view returns(string)\n  {\n      return planets[buildTokenId(x, y, z)].liason;\n  }\n\n  function GetLiasonURL(uint x, uint y, uint z) public view returns(string)\n  {\n      return planets[buildTokenId(x, y, z)].url;\n  }\n    \n  function GetIndex(uint x, uint y, uint z) public view returns(uint)\n  {\n      return planets[buildTokenId(x, y, z)].index;\n  }\n    \n  function GetCost(uint x, uint y, uint z) public view returns(uint)\n  {\n      return planets[buildTokenId(x, y, z)].cost;\n  }\n    \n  function UpdatedDonationAddress(address NewAddress) onlyOwner public\n  {\n      address OldAddress = donation_address;\n      donation_address = NewAddress;\n      donations[donation_address].start = donations[OldAddress].start;\n      donations[donation_address].genesis = donations[OldAddress].genesis;\n      donations[donation_address].checkpoint = donations[OldAddress].checkpoint;\n      donations[donation_address].interval = donations[OldAddress].interval;\n      donations[donation_address].ppp = donations[OldAddress].ppp;\n      donations[donation_address].amount = donations[OldAddress].amount;\n      \n  }\n\n  function ping(uint tokenId) public \n  {\n    require(msg.sender == tokenOwner[tokenId]);\n    latestPing[tokenId] = now;\n    TokenPing(tokenId);\n  }\n\n  function buildTokenId(uint x, uint y, uint z) public view returns (uint256) \n  {\n    return uint256(keccak256(x, '|', y, '|', z, '|', universe));\n  }\n\n  function exists(uint x, uint y, uint z) public constant returns (bool) \n  {\n    return ownerOfPlanet(x, y, z) != 0;\n  }\n\n  function ownerOfPlanet(uint x, uint y, uint z) public constant returns (address) \n  {\n    return tokenOwner[buildTokenId(x, y, z)];\n  }\n\n  function transferPlanet(address to, uint x, uint y, uint z) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].owner = to;\n  }\n\n  function planetName(uint x, uint y, uint z) constant public returns (string) \n  {\n    return tokenMetadata[buildTokenId(x, y, z)];\n  }\n    \n  function planetCordinates(uint tokenId) public constant returns (uint[]) \n  {\n    uint[] memory data = new uint[](3);\n    data[0] = cordX[tokenId];\n    data[1] = cordY[tokenId];\n    data[2] = cordZ[tokenId];\n    return data;\n  }\n    \n  function planetLife(uint x, uint y, uint z) constant public returns (uint[]) \n  {\n    uint[] memory dna = new uint[](3);\n    dna[0] = lifeD[buildTokenId(x, y, z)];\n    dna[1] = lifeN[buildTokenId(x, y, z)];\n    dna[2] = lifeA[buildTokenId(x, y, z)];\n    return dna;\n  }\n\n  function updatePlanetName(uint x, uint y, uint z, string _planetName) public \n  {\n    if(updateTokenMetadata(buildTokenId(x, y, z), _planetName))\n    {\n        planets[buildTokenId(x, y, z)].name = _planetName;\n    }\n  }\n  \n  function updatePlanetLiason(uint x, uint y, uint z, string LiasonName) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;\n  }\n}",
        "debug": "storage_19: 0x0\nkeccac_5_+\nkeccac_UDiv(KECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_PlanetToken_4_+_calldata_PlanetToken_32_+_68))),\n_____1): 0xff1b2f77e8dfedf7dfc0c2add3b0019922428288182d36f2fcd8fffa6b263461\nstorage_5 +\nkeccac_UDiv(KECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_PlanetToken_4_+_calldata_PlanetToken_32_+_68))),\n_____1): 0xecf2ddf987c47607c730abb83fa26addddaecaa0742fbdffffffffffffffffe1\nstorage_keccac_UDiv(KECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_PlanetToken_4_+_calldata_PlanetToken_32_+_68))),\n_____1): 0x0\ncaller: 0x0\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 190,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16712,
        "code": " public cordY;\n  mapping (uint => uint) public cordZ;\n  mapping (uint => uint) public lifeD;\n  mapping (uint => uint) public lifeN;\n  mapping (uint => uint) public lifeA;    \n  mapping (uint => uint) public latestPing;\n    \n  struct planet\n  {\n    uint x;\n    uint y;\n    uint z;\n    string name;\n    address owner;\n    string liason;\n    string url;\n    uint cost;\n    uint index;\n  }\n    \n  struct _donations\n  {\n      uint start;\n      uint genesis;\n      uint interval;\n      uint ppp;\n      uint amount;\n      uint checkpoint;\n  }\n\n  mapping(uint => planet) planets;\n  mapping(address => _donations) donations;\n  \n  string private universe;\n  uint private min_donation;\n  address private donation_address;\n  uint private coordinate_limit;\n\n  event TokenPing(uint tokenId);\n\n  function () public payable \n  {\n      donation_address.transfer(msg.value);\n  }\n    \n  function PlanetToken(string UniverseName, uint CoordinateLimit, address DonationAddress, uint StartingWeiDonation, uint BlockIntervals, uint WeiPerPlanet) public\n  {\n      universe = UniverseName;\n      min_donation = StartingWeiDonation;\n      coordinate_limit = CoordinateLimit;\n      donation_address = DonationAddress;\n      donations[donation_address].start = min_donation;\n      donations[donation_address].genesis = block.number;\n      donations[donation_address].checkpoint = block.number;\n      donations[donation_address].interval = BlockIntervals;\n      donations[donation_address].ppp = WeiPerPlanet;\n      donations[donation_address].amount = min_donation;\n  }\n\n  function assignNewPlanet(address beneficiary, uint x, uint y, uint z, string _planetName, string liason, string url) public payable \n  {  \n    // Check current fee\n    uint MinimumDonation = donations[donation_address].amount;\n      \n    // Check required paramters\n    require(tokenOwner[buildTokenId(x, y, z)] == 0);\n    require(msg.value >= MinimumDonation);\n    require(x <= coordinate_limit);\n    require(y <= coordinate_limit);\n    require(z <= coordinate_limit);\n     \n    // Update token records\n    latestPing[buildTokenId(x, y, z)] = now;\n    _addTokenTo(beneficiary, buildTokenId(x, y, z));\n    totalTokens++;\n    tokenMetadata[buildTokenId(x, y, z)] = _planetName;\n\n    // Update galactic records\n    cordX[buildTokenId(x, y, z)] = x;\n    cordY[buildTokenId(x, y, z)] = y;\n    cordZ[buildTokenId(x, y, z)] = z;\n\n    // Update DNA records\n    lifeD[buildTokenId(x, y, z)] = uint256(keccak256(x, '|x|', msg.sender, '|', universe));\n    lifeN[buildTokenId(x, y, z)] = uint256(keccak256(y, '|y|', msg.sender, '|', universe));\n    lifeA[buildTokenId(x, y, z)] = uint256(keccak256(z, '|z|', msg.sender, '|', universe));\n      \n    // Map the planet object too ...\n    planets[buildTokenId(x, y, z)].x = x;\n    planets[buildTokenId(x, y, z)].x = y;\n    planets[buildTokenId(x, y, z)].x = z;\n    planets[buildTokenId(x, y, z)].name = _planetName;\n    planets[buildTokenId(x, y, z)].owner = beneficiary;\n    planets[buildTokenId(x, y, z)].liason = liason;\n    planets[buildTokenId(x, y, z)].url = url;\n    planets[buildTokenId(x, y, z)].index = totalTokens - 1;\n    planets[buildTokenId(x, y, z)].cost = msg.value;\n\n    // Finalize process\n    TokenCreated(buildTokenId(x, y, z), beneficiary, _planetName);  \n    donation_address.transfer(msg.value);\n      \n    // Update donation info\n    uint this_block = block.number;\n    uint new_checkpoint = donations[donation_address].checkpoint + donations[donation_address].interval; \n    if(this_block > new_checkpoint)\n    {\n        donations[donation_address].checkpoint = this_block;\n        donations[donation_address].amount = donations[donation_address].ppp * totalTokens;\n    }\n  }\n    \n  function MinimumDonation() public view returns(uint)\n  {\n      return donations[donation_address].amount;\n  }\n    \n  function BlocksToGo() public view returns(uint)\n  {\n      uint this_block = block.number;\n      uint next_block = donations[donation_address].checkpoint + donations[donation_address].interval;\n      if(this_block < next_block)\n      {\n          return next_block - this_block;\n      }\n      else\n      {\n          return 0;\n      }\n  }\n    \n  function GetLiasonName(uint x, uint y, uint z) public view returns(string)\n  {\n      return planets[buildTokenId(x, y, z)].liason;\n  }\n\n  function GetLiasonURL(uint x, uint y, uint z) public view returns(string)\n  {\n      return planets[buildTokenId(x, y, z)].url;\n  }\n    \n  function GetIndex(uint x, uint y, uint z) public view returns(uint)\n  {\n      return planets[buildTokenId(x, y, z)].index;\n  }\n    \n  function GetCost(uint x, uint y, uint z) public view returns(uint)\n  {\n      return planets[buildTokenId(x, y, z)].cost;\n  }\n    \n  function UpdatedDonationAddress(address NewAddress) onlyOwner public\n  {\n      address OldAddress = donation_address;\n      donation_address = NewAddress;\n      donations[donation_address].start = donations[OldAddress].start;\n      donations[donation_address].genesis = donations[OldAddress].genesis;\n      donations[donation_address].checkpoint = donations[OldAddress].checkpoint;\n      donations[donation_address].interval = donations[OldAddress].interval;\n      donations[donation_address].ppp = donations[OldAddress].ppp;\n      donations[donation_address].amount = donations[OldAddress].amount;\n      \n  }\n\n  function ping(uint tokenId) public \n  {\n    require(msg.sender == tokenOwner[tokenId]);\n    latestPing[tokenId] = now;\n    TokenPing(tokenId);\n  }\n\n  function buildTokenId(uint x, uint y, uint z) public view returns (uint256) \n  {\n    return uint256(keccak256(x, '|', y, '|', z, '|', universe));\n  }\n\n  function exists(uint x, uint y, uint z) public constant returns (bool) \n  {\n    return ownerOfPlanet(x, y, z) != 0;\n  }\n\n  function ownerOfPlanet(uint x, uint y, uint z) public constant returns (address) \n  {\n    return tokenOwner[buildTokenId(x, y, z)];\n  }\n\n  function transferPlanet(address to, uint x, uint y, uint z) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].owner = to;\n  }\n\n  function planetName(uint x, uint y, uint z) constant public returns (string) \n  {\n    return tokenMetadata[buildTokenId(x, y, z)];\n  }\n    \n  function planetCordinates(uint tokenId) public constant returns (uint[]) \n  {\n    uint[] memory data = new uint[](3);\n    data[0] = cordX[tokenId];\n    data[1] = cordY[tokenId];\n    data[2] = cordZ[tokenId];\n    return data;\n  }\n    \n  function planetLife(uint x, uint y, uint z) constant public returns (uint[]) \n  {\n    uint[] memory dna = new uint[](3);\n    dna[0] = lifeD[buildTokenId(x, y, z)];\n    dna[1] = lifeN[buildTokenId(x, y, z)];\n    dna[2] = lifeA[buildTokenId(x, y, z)];\n    return dna;\n  }\n\n  function updatePlanetName(uint x, uint y, uint z, string _planetName) public \n  {\n    if(updateTokenMetadata(buildTokenId(x, y, z), _planetName))\n    {\n        planets[buildTokenId(x, y, z)].name = _planetName;\n    }\n  }\n  \n  function updatePlanetLiason(uint x, uint y, uint z, string LiasonName) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;\n  }\n}",
        "debug": "storage_19: 0x20\ncalldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_UDiv(KECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_PlanetToken_4_+_calldata_PlanetToken_32_+_68))),\n_____1): 0x0\ncaller: 0x0\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 190,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 16726,
        "code": " public cordY;\n  mapping (uint => uint) public cordZ;\n  mapping (uint => uint) public lifeD;\n  mapping (uint => uint) public lifeN;\n  mapping (uint => uint) public lifeA;    \n  mapping (uint => uint) public latestPing;\n    \n  struct planet\n  {\n    uint x;\n    uint y;\n    uint z;\n    string name;\n    address owner;\n    string liason;\n    string url;\n    uint cost;\n    uint index;\n  }\n    \n  struct _donations\n  {\n      uint start;\n      uint genesis;\n      uint interval;\n      uint ppp;\n      uint amount;\n      uint checkpoint;\n  }\n\n  mapping(uint => planet) planets;\n  mapping(address => _donations) donations;\n  \n  string private universe;\n  uint private min_donation;\n  address private donation_address;\n  uint private coordinate_limit;\n\n  event TokenPing(uint tokenId);\n\n  function () public payable \n  {\n      donation_address.transfer(msg.value);\n  }\n    \n  function PlanetToken(string UniverseName, uint CoordinateLimit, address DonationAddress, uint StartingWeiDonation, uint BlockIntervals, uint WeiPerPlanet) public\n  {\n      universe = UniverseName;\n      min_donation = StartingWeiDonation;\n      coordinate_limit = CoordinateLimit;\n      donation_address = DonationAddress;\n      donations[donation_address].start = min_donation;\n      donations[donation_address].genesis = block.number;\n      donations[donation_address].checkpoint = block.number;\n      donations[donation_address].interval = BlockIntervals;\n      donations[donation_address].ppp = WeiPerPlanet;\n      donations[donation_address].amount = min_donation;\n  }\n\n  function assignNewPlanet(address beneficiary, uint x, uint y, uint z, string _planetName, string liason, string url) public payable \n  {  \n    // Check current fee\n    uint MinimumDonation = donations[donation_address].amount;\n      \n    // Check required paramters\n    require(tokenOwner[buildTokenId(x, y, z)] == 0);\n    require(msg.value >= MinimumDonation);\n    require(x <= coordinate_limit);\n    require(y <= coordinate_limit);\n    require(z <= coordinate_limit);\n     \n    // Update token records\n    latestPing[buildTokenId(x, y, z)] = now;\n    _addTokenTo(beneficiary, buildTokenId(x, y, z));\n    totalTokens++;\n    tokenMetadata[buildTokenId(x, y, z)] = _planetName;\n\n    // Update galactic records\n    cordX[buildTokenId(x, y, z)] = x;\n    cordY[buildTokenId(x, y, z)] = y;\n    cordZ[buildTokenId(x, y, z)] = z;\n\n    // Update DNA records\n    lifeD[buildTokenId(x, y, z)] = uint256(keccak256(x, '|x|', msg.sender, '|', universe));\n    lifeN[buildTokenId(x, y, z)] = uint256(keccak256(y, '|y|', msg.sender, '|', universe));\n    lifeA[buildTokenId(x, y, z)] = uint256(keccak256(z, '|z|', msg.sender, '|', universe));\n      \n    // Map the planet object too ...\n    planets[buildTokenId(x, y, z)].x = x;\n    planets[buildTokenId(x, y, z)].x = y;\n    planets[buildTokenId(x, y, z)].x = z;\n    planets[buildTokenId(x, y, z)].name = _planetName;\n    planets[buildTokenId(x, y, z)].owner = beneficiary;\n    planets[buildTokenId(x, y, z)].liason = liason;\n    planets[buildTokenId(x, y, z)].url = url;\n    planets[buildTokenId(x, y, z)].index = totalTokens - 1;\n    planets[buildTokenId(x, y, z)].cost = msg.value;\n\n    // Finalize process\n    TokenCreated(buildTokenId(x, y, z), beneficiary, _planetName);  \n    donation_address.transfer(msg.value);\n      \n    // Update donation info\n    uint this_block = block.number;\n    uint new_checkpoint = donations[donation_address].checkpoint + donations[donation_address].interval; \n    if(this_block > new_checkpoint)\n    {\n        donations[donation_address].checkpoint = this_block;\n        donations[donation_address].amount = donations[donation_address].ppp * totalTokens;\n    }\n  }\n    \n  function MinimumDonation() public view returns(uint)\n  {\n      return donations[donation_address].amount;\n  }\n    \n  function BlocksToGo() public view returns(uint)\n  {\n      uint this_block = block.number;\n      uint next_block = donations[donation_address].checkpoint + donations[donation_address].interval;\n      if(this_block < next_block)\n      {\n          return next_block - this_block;\n      }\n      else\n      {\n          return 0;\n      }\n  }\n    \n  function GetLiasonName(uint x, uint y, uint z) public view returns(string)\n  {\n      return planets[buildTokenId(x, y, z)].liason;\n  }\n\n  function GetLiasonURL(uint x, uint y, uint z) public view returns(string)\n  {\n      return planets[buildTokenId(x, y, z)].url;\n  }\n    \n  function GetIndex(uint x, uint y, uint z) public view returns(uint)\n  {\n      return planets[buildTokenId(x, y, z)].index;\n  }\n    \n  function GetCost(uint x, uint y, uint z) public view returns(uint)\n  {\n      return planets[buildTokenId(x, y, z)].cost;\n  }\n    \n  function UpdatedDonationAddress(address NewAddress) onlyOwner public\n  {\n      address OldAddress = donation_address;\n      donation_address = NewAddress;\n      donations[donation_address].start = donations[OldAddress].start;\n      donations[donation_address].genesis = donations[OldAddress].genesis;\n      donations[donation_address].checkpoint = donations[OldAddress].checkpoint;\n      donations[donation_address].interval = donations[OldAddress].interval;\n      donations[donation_address].ppp = donations[OldAddress].ppp;\n      donations[donation_address].amount = donations[OldAddress].amount;\n      \n  }\n\n  function ping(uint tokenId) public \n  {\n    require(msg.sender == tokenOwner[tokenId]);\n    latestPing[tokenId] = now;\n    TokenPing(tokenId);\n  }\n\n  function buildTokenId(uint x, uint y, uint z) public view returns (uint256) \n  {\n    return uint256(keccak256(x, '|', y, '|', z, '|', universe));\n  }\n\n  function exists(uint x, uint y, uint z) public constant returns (bool) \n  {\n    return ownerOfPlanet(x, y, z) != 0;\n  }\n\n  function ownerOfPlanet(uint x, uint y, uint z) public constant returns (address) \n  {\n    return tokenOwner[buildTokenId(x, y, z)];\n  }\n\n  function transferPlanet(address to, uint x, uint y, uint z) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].owner = to;\n  }\n\n  function planetName(uint x, uint y, uint z) constant public returns (string) \n  {\n    return tokenMetadata[buildTokenId(x, y, z)];\n  }\n    \n  function planetCordinates(uint tokenId) public constant returns (uint[]) \n  {\n    uint[] memory data = new uint[](3);\n    data[0] = cordX[tokenId];\n    data[1] = cordY[tokenId];\n    data[2] = cordZ[tokenId];\n    return data;\n  }\n    \n  function planetLife(uint x, uint y, uint z) constant public returns (uint[]) \n  {\n    uint[] memory dna = new uint[](3);\n    dna[0] = lifeD[buildTokenId(x, y, z)];\n    dna[1] = lifeN[buildTokenId(x, y, z)];\n    dna[2] = lifeA[buildTokenId(x, y, z)];\n    return dna;\n  }\n\n  function updatePlanetName(uint x, uint y, uint z, string _planetName) public \n  {\n    if(updateTokenMetadata(buildTokenId(x, y, z), _planetName))\n    {\n        planets[buildTokenId(x, y, z)].name = _planetName;\n    }\n  }\n  \n  function updatePlanetLiason(uint x, uint y, uint z, string LiasonName) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].liason = LiasonName;\n  }\n    \n  function updatePlanetURL(uint x, uint y, uint z, string LiasonURL) public \n  {\n    require(msg.sender == tokenOwner[buildTokenId(x, y, z)]);\n    planets[buildTokenId(x, y, z)].url = LiasonURL;\n  }\n}",
        "debug": "storage_19: 0x0\ncalldata_PlanetToken_4 + calldata_PlanetToken_32 + 68: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_keccac_UDiv(KECCAC_mem_128_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_PlanetToken_4_+_calldata_PlanetToken_32_+_68))),\n_____1): 0x0\ncaller: 0x0\ncalldata_PlanetToken_0: 0x16907c1200000000000000000000000000000000000000000000000000000000\ncalldatasize_PlanetToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `updatePlanetLiason(uint256,uint256,uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/17/0xce85675ea91f8afe2a67869a8b1f9136187dc772.sol",
        "function": "updatePlanetLiason(uint256,uint256,uint256,string)",
        "lineno": 190,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}