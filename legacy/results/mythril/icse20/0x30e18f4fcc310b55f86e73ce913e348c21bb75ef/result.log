{"error": null, "issues": [{"address": 167, "code": "\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * get", "debug": "calldata_History_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_History_0: 0x24e5bdb900000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getEventsCount(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEventsCount(string)", "lineno": 110, "title": "Integer Overflow ", "type": "Warning"}, {"address": 681, "code": "\n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruc", "debug": "calldata_History_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getEvent(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 118, "title": "Integer Overflow ", "type": "Warning"}, {"address": 693, "code": "\n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruc", "debug": "calldata_History_4 + calldata_History_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getEvent(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 118, "title": "Integer Overflow ", "type": "Warning"}, {"address": 702, "code": "\n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruc", "debug": "calldata_History_4 + calldata_History_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getEvent(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 118, "title": "Integer Overflow ", "type": "Warning"}, {"address": 708, "code": "\n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruc", "debug": "calldata_History_4 + calldata_History_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getEvent(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 118, "title": "Integer Overflow ", "type": "Warning"}, {"address": 831, "code": "\n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruc", "debug": "The exception is triggered under the following conditions:\n\nstorage_5*calldata_History_32 + 4 +\nkeccac_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+_calldata_History_4_+_calldata_History_4))_+\n192) +\n3: 0x0\nstorage_5*calldata_History_32 + 4 +\nkeccac_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+_calldata_History_4_+_calldata_History_4))_+\n192) +\n4: 0x0\ncalldata_History_4 + calldata_History_4: 0x20\nmem_128 +\n352 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_History_4 + calldata_History_4)): 0x3\ncalldata_History_32 + 4: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+_calldata_History_4_+_calldata_History_4))_+\n192): 0x1\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 118, "title": "Exception state", "type": "Informational"}, {"address": 1654, "code": "irOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * ", "debug": "The exception is triggered under the following conditions:\n\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0xc0\ncalldata_History_32 + 36: 0x80\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 96, "title": "Exception state", "type": "Informational"}, {"address": 1671, "code": "\n\n/**\n * @title Co", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0xc0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100))): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_History_32 + 36: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1843, "code": "ileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * R", "debug": "The exception is triggered under the following conditions:\n\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0xa0\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x3\ncalldata_History_32 + 36: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 95, "title": "Exception state", "type": "Informational"}, {"address": 1865, "code": "ileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * R", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0x60\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x0\ncalldata_History_32 + 36: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 95, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2558, "code": "\n        description = e.d", "debug": "The exception is triggered under the following conditions:\n\ncalldata_History_4 + calldata_History_4: 0x80\ncalldata_History_32 + 4: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+_calldata_History_4_+_calldata_History_4))_+\n192): 0x0\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 124, "title": "Exception state", "type": "Informational"}, {"address": 2730, "code": "ventType = e.eventType;\n        description = e.d", "debug": "The exception is triggered under the following conditions:\n\nstorage_5*calldata_History_32 + 4 +\nkeccac_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+_calldata_History_4_+_calldata_History_4))_+\n192) +\n3: 0x8000\ncalldata_History_4 + calldata_History_4: 0x60\ncalldata_History_32 + 4: 0x0\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+_calldata_History_4_+_calldata_History_4))_+\n192): 0x1\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 124, "title": "Exception state", "type": "Informational"}, {"address": 3073, "code": "act History  {\n\n    // The creator of this contract. This address can authorize Mechanics, Insurers, Car-Dealers etc\n    // to log events.\n    address owner;\n\n    // Currently 3 types suported. More to come soon.\n    enum EventType { NewOwner, Maintenance, DamageRepair }\n\n    // List of addresses controlled by Mechanics, Insurers, Car-Dealers etc. that are \n    // Authorized to log events this Vehicle-History-Log.\n    mapping(address => bool) public authorizedLoggers;\n\n    // This event is broadcasted when a new maintenance event is logged.\n    event EventLogged(string vin, EventType eventType, uint256 mileage, address verifier);\n\n    // The event is broadcasted when a new logger is authorized to log events.\n    event LoggerAuthorized(address loggerAddress);\n\n    struct LedgerEvent {\n        \n        uint256 creationTime;\n        uint256 mileage; \n        uint256 repairOrderNumber;\n        address verifier; \n        EventType eventType;\n        string description;   \n    }\n\n    mapping (bytes32 => LedgerEvent[]) events;\n\n    /**\n     * Set the owner.\n     */\n    function History() {\n        \n        owner = msg.sender; \n    }\n\n    /**\n     * Only allows addresses can call this function.\n     */\n    modifier onlyAuthorized {\n\n        if (!authorizedLoggers[msg.sender])\n            throw;\n        _;\n    }\n\n    /**\n     * Only owner can call this function.\n     */\n     modifier onlyOwner {\n\n        if (msg.sender != owner)\n            throw;\n        _;\n    }\n\n\n    /**\n     * Authorize the specified address to add evemnts to the historic log.\n     */\n    function authorize(address newLogger) onlyOwner {\n\n        authorizedLoggers[newLogger] = true;\n        LoggerAuthorized(newLogger);\n    }\n\n    /**\n     * Checks if the specified address is authorized to log events.\n     */\n    function isAuthorized(address logger) returns (bool) {\n\n         return authorizedLoggers[logger];\n    }\n\n    /**\n     * Add a historically significant event (i.e. maintenance, damage \n     * repair or new owner).\n     */\n    function addEvent(uint256 _mileage, \n                     uint256 _repairOrderNumber,\n                     EventType _eventType, \n                     string _description, \n                     string _vin) onlyAuthorized {\n\n        events[sha3(_vin)].push(LedgerEvent({\n            creationTime: now,\n            mileage: _mileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * Returns the number of events for a vin. (helper function for getEvent function)\n     */\n    function getEventsCount(string _vin) constant returns(uint256) {\n\n        return events[sha3(_vin)].length;\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * getEventsCount().\n     */\n    function getEvent(string _vin, uint256 _index) constant\n                returns (uint256 mileage, address verifier, \n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruct(owner); \n    }\n\n    /**\n     * Fallback function (Solidity best-practice).\n     */\n    function() payable {}\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0x60\nkeccac_4_+\n5*\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100)))_+\nkeccac_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100))): 0xfec306d0f99014dc208003fffef6fffff2e43fffa6fdd3fa7475deffab8dddd8\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x0\ncalldata_History_32 + 36: 0x0\nstorage_4 +\n5*\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100))) +\nkeccac_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100))): 0xf753a5bee97437efbee000044200000000f00013f10007ffffffffffffffffc3\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 6, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3102, "code": "act History  {\n\n    // The creator of this contract. This address can authorize Mechanics, Insurers, Car-Dealers etc\n    // to log events.\n    address owner;\n\n    // Currently 3 types suported. More to come soon.\n    enum EventType { NewOwner, Maintenance, DamageRepair }\n\n    // List of addresses controlled by Mechanics, Insurers, Car-Dealers etc. that are \n    // Authorized to log events this Vehicle-History-Log.\n    mapping(address => bool) public authorizedLoggers;\n\n    // This event is broadcasted when a new maintenance event is logged.\n    event EventLogged(string vin, EventType eventType, uint256 mileage, address verifier);\n\n    // The event is broadcasted when a new logger is authorized to log events.\n    event LoggerAuthorized(address loggerAddress);\n\n    struct LedgerEvent {\n        \n        uint256 creationTime;\n        uint256 mileage; \n        uint256 repairOrderNumber;\n        address verifier; \n        EventType eventType;\n        string description;   \n    }\n\n    mapping (bytes32 => LedgerEvent[]) events;\n\n    /**\n     * Set the owner.\n     */\n    function History() {\n        \n        owner = msg.sender; \n    }\n\n    /**\n     * Only allows addresses can call this function.\n     */\n    modifier onlyAuthorized {\n\n        if (!authorizedLoggers[msg.sender])\n            throw;\n        _;\n    }\n\n    /**\n     * Only owner can call this function.\n     */\n     modifier onlyOwner {\n\n        if (msg.sender != owner)\n            throw;\n        _;\n    }\n\n\n    /**\n     * Authorize the specified address to add evemnts to the historic log.\n     */\n    function authorize(address newLogger) onlyOwner {\n\n        authorizedLoggers[newLogger] = true;\n        LoggerAuthorized(newLogger);\n    }\n\n    /**\n     * Checks if the specified address is authorized to log events.\n     */\n    function isAuthorized(address logger) returns (bool) {\n\n         return authorizedLoggers[logger];\n    }\n\n    /**\n     * Add a historically significant event (i.e. maintenance, damage \n     * repair or new owner).\n     */\n    function addEvent(uint256 _mileage, \n                     uint256 _repairOrderNumber,\n                     EventType _eventType, \n                     string _description, \n                     string _vin) onlyAuthorized {\n\n        events[sha3(_vin)].push(LedgerEvent({\n            creationTime: now,\n            mileage: _mileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * Returns the number of events for a vin. (helper function for getEvent function)\n     */\n    function getEventsCount(string _vin) constant returns(uint256) {\n\n        return events[sha3(_vin)].length;\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * getEventsCount().\n     */\n    function getEvent(string _vin, uint256 _index) constant\n                returns (uint256 mileage, address verifier, \n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruct(owner); \n    }\n\n    /**\n     * Fallback function (Solidity best-practice).\n     */\n    function() payable {}\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0x80\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x0\ncalldata_History_32 + 36: 0x0\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 6, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3116, "code": "act History  {\n\n    // The creator of this contract. This address can authorize Mechanics, Insurers, Car-Dealers etc\n    // to log events.\n    address owner;\n\n    // Currently 3 types suported. More to come soon.\n    enum EventType { NewOwner, Maintenance, DamageRepair }\n\n    // List of addresses controlled by Mechanics, Insurers, Car-Dealers etc. that are \n    // Authorized to log events this Vehicle-History-Log.\n    mapping(address => bool) public authorizedLoggers;\n\n    // This event is broadcasted when a new maintenance event is logged.\n    event EventLogged(string vin, EventType eventType, uint256 mileage, address verifier);\n\n    // The event is broadcasted when a new logger is authorized to log events.\n    event LoggerAuthorized(address loggerAddress);\n\n    struct LedgerEvent {\n        \n        uint256 creationTime;\n        uint256 mileage; \n        uint256 repairOrderNumber;\n        address verifier; \n        EventType eventType;\n        string description;   \n    }\n\n    mapping (bytes32 => LedgerEvent[]) events;\n\n    /**\n     * Set the owner.\n     */\n    function History() {\n        \n        owner = msg.sender; \n    }\n\n    /**\n     * Only allows addresses can call this function.\n     */\n    modifier onlyAuthorized {\n\n        if (!authorizedLoggers[msg.sender])\n            throw;\n        _;\n    }\n\n    /**\n     * Only owner can call this function.\n     */\n     modifier onlyOwner {\n\n        if (msg.sender != owner)\n            throw;\n        _;\n    }\n\n\n    /**\n     * Authorize the specified address to add evemnts to the historic log.\n     */\n    function authorize(address newLogger) onlyOwner {\n\n        authorizedLoggers[newLogger] = true;\n        LoggerAuthorized(newLogger);\n    }\n\n    /**\n     * Checks if the specified address is authorized to log events.\n     */\n    function isAuthorized(address logger) returns (bool) {\n\n         return authorizedLoggers[logger];\n    }\n\n    /**\n     * Add a historically significant event (i.e. maintenance, damage \n     * repair or new owner).\n     */\n    function addEvent(uint256 _mileage, \n                     uint256 _repairOrderNumber,\n                     EventType _eventType, \n                     string _description, \n                     string _vin) onlyAuthorized {\n\n        events[sha3(_vin)].push(LedgerEvent({\n            creationTime: now,\n            mileage: _mileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * Returns the number of events for a vin. (helper function for getEvent function)\n     */\n    function getEventsCount(string _vin) constant returns(uint256) {\n\n        return events[sha3(_vin)].length;\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * getEventsCount().\n     */\n    function getEvent(string _vin, uint256 _index) constant\n                returns (uint256 mileage, address verifier, \n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruct(owner); \n    }\n\n    /**\n     * Fallback function (Solidity best-practice).\n     */\n    function() payable {}\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0x60\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0xbfab6680ac024e300862db6414090d3446314a400000000000001fffffffffe0\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x0\ncalldata_History_32 + 36: 0x0\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0xe82fe7cb98416f3483f5e7684571bc359792186f7ffffdffffffdffffffffc1d\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 6, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3133, "code": "act History  {\n\n    // The creator of this contract. This address can authorize Mechanics, Insurers, Car-Dealers etc\n    // to log events.\n    address owner;\n\n    // Currently 3 types suported. More to come soon.\n    enum EventType { NewOwner, Maintenance, DamageRepair }\n\n    // List of addresses controlled by Mechanics, Insurers, Car-Dealers etc. that are \n    // Authorized to log events this Vehicle-History-Log.\n    mapping(address => bool) public authorizedLoggers;\n\n    // This event is broadcasted when a new maintenance event is logged.\n    event EventLogged(string vin, EventType eventType, uint256 mileage, address verifier);\n\n    // The event is broadcasted when a new logger is authorized to log events.\n    event LoggerAuthorized(address loggerAddress);\n\n    struct LedgerEvent {\n        \n        uint256 creationTime;\n        uint256 mileage; \n        uint256 repairOrderNumber;\n        address verifier; \n        EventType eventType;\n        string description;   \n    }\n\n    mapping (bytes32 => LedgerEvent[]) events;\n\n    /**\n     * Set the owner.\n     */\n    function History() {\n        \n        owner = msg.sender; \n    }\n\n    /**\n     * Only allows addresses can call this function.\n     */\n    modifier onlyAuthorized {\n\n        if (!authorizedLoggers[msg.sender])\n            throw;\n        _;\n    }\n\n    /**\n     * Only owner can call this function.\n     */\n     modifier onlyOwner {\n\n        if (msg.sender != owner)\n            throw;\n        _;\n    }\n\n\n    /**\n     * Authorize the specified address to add evemnts to the historic log.\n     */\n    function authorize(address newLogger) onlyOwner {\n\n        authorizedLoggers[newLogger] = true;\n        LoggerAuthorized(newLogger);\n    }\n\n    /**\n     * Checks if the specified address is authorized to log events.\n     */\n    function isAuthorized(address logger) returns (bool) {\n\n         return authorizedLoggers[logger];\n    }\n\n    /**\n     * Add a historically significant event (i.e. maintenance, damage \n     * repair or new owner).\n     */\n    function addEvent(uint256 _mileage, \n                     uint256 _repairOrderNumber,\n                     EventType _eventType, \n                     string _description, \n                     string _vin) onlyAuthorized {\n\n        events[sha3(_vin)].push(LedgerEvent({\n            creationTime: now,\n            mileage: _mileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * Returns the number of events for a vin. (helper function for getEvent function)\n     */\n    function getEventsCount(string _vin) constant returns(uint256) {\n\n        return events[sha3(_vin)].length;\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * getEventsCount().\n     */\n    function getEvent(string _vin, uint256 _index) constant\n                returns (uint256 mileage, address verifier, \n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruct(owner); \n    }\n\n    /**\n     * Fallback function (Solidity best-practice).\n     */\n    function() payable {}\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0x20\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa1\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x0\ncalldata_History_32 + 36: 0x0\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0x39\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 6, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3138, "code": "act History  {\n\n    // The creator of this contract. This address can authorize Mechanics, Insurers, Car-Dealers etc\n    // to log events.\n    address owner;\n\n    // Currently 3 types suported. More to come soon.\n    enum EventType { NewOwner, Maintenance, DamageRepair }\n\n    // List of addresses controlled by Mechanics, Insurers, Car-Dealers etc. that are \n    // Authorized to log events this Vehicle-History-Log.\n    mapping(address => bool) public authorizedLoggers;\n\n    // This event is broadcasted when a new maintenance event is logged.\n    event EventLogged(string vin, EventType eventType, uint256 mileage, address verifier);\n\n    // The event is broadcasted when a new logger is authorized to log events.\n    event LoggerAuthorized(address loggerAddress);\n\n    struct LedgerEvent {\n        \n        uint256 creationTime;\n        uint256 mileage; \n        uint256 repairOrderNumber;\n        address verifier; \n        EventType eventType;\n        string description;   \n    }\n\n    mapping (bytes32 => LedgerEvent[]) events;\n\n    /**\n     * Set the owner.\n     */\n    function History() {\n        \n        owner = msg.sender; \n    }\n\n    /**\n     * Only allows addresses can call this function.\n     */\n    modifier onlyAuthorized {\n\n        if (!authorizedLoggers[msg.sender])\n            throw;\n        _;\n    }\n\n    /**\n     * Only owner can call this function.\n     */\n     modifier onlyOwner {\n\n        if (msg.sender != owner)\n            throw;\n        _;\n    }\n\n\n    /**\n     * Authorize the specified address to add evemnts to the historic log.\n     */\n    function authorize(address newLogger) onlyOwner {\n\n        authorizedLoggers[newLogger] = true;\n        LoggerAuthorized(newLogger);\n    }\n\n    /**\n     * Checks if the specified address is authorized to log events.\n     */\n    function isAuthorized(address logger) returns (bool) {\n\n         return authorizedLoggers[logger];\n    }\n\n    /**\n     * Add a historically significant event (i.e. maintenance, damage \n     * repair or new owner).\n     */\n    function addEvent(uint256 _mileage, \n                     uint256 _repairOrderNumber,\n                     EventType _eventType, \n                     string _description, \n                     string _vin) onlyAuthorized {\n\n        events[sha3(_vin)].push(LedgerEvent({\n            creationTime: now,\n            mileage: _mileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * Returns the number of events for a vin. (helper function for getEvent function)\n     */\n    function getEventsCount(string _vin) constant returns(uint256) {\n\n        return events[sha3(_vin)].length;\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * getEventsCount().\n     */\n    function getEvent(string _vin, uint256 _index) constant\n                returns (uint256 mileage, address verifier, \n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruct(owner); \n    }\n\n    /**\n     * Fallback function (Solidity best-practice).\n     */\n    function() payable {}\n}", "debug": "mem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)): 0x20\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0x9ffefffffffffffffe33730cfb3fff566659255404000000000000000000001b\nmem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n128: 0x0\nkeccac_4_+\n5*\nstorage_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100)))_+\nkeccac_keccac_115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\n115792089237316195423570985008687907853269984665640564039457584007913129639935_-\n0_&\nKECCAC_mem_160_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_68))_+\n32_+\n32*\nConcat(0,\n_______Extract(255,\n_______________5,\n_______________31_+\n_______________calldata_History_4_+_calldata_History_32_+_100))): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_History_32 + 36: 0x0\nmem_mem_192 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 68)) +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 +\n               calldata_History_4 + calldata_History_32 + 100)) +\n160: 0x114a52ffeffff77a77a7f6fffffffffffffffffffffffe8\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_History_0: 0x98c31b1d00000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `_function_0x98c31b1d`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "_function_0x98c31b1d", "lineno": 6, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3170, "code": "act History  {\n\n    // The creator of this contract. This address can authorize Mechanics, Insurers, Car-Dealers etc\n    // to log events.\n    address owner;\n\n    // Currently 3 types suported. More to come soon.\n    enum EventType { NewOwner, Maintenance, DamageRepair }\n\n    // List of addresses controlled by Mechanics, Insurers, Car-Dealers etc. that are \n    // Authorized to log events this Vehicle-History-Log.\n    mapping(address => bool) public authorizedLoggers;\n\n    // This event is broadcasted when a new maintenance event is logged.\n    event EventLogged(string vin, EventType eventType, uint256 mileage, address verifier);\n\n    // The event is broadcasted when a new logger is authorized to log events.\n    event LoggerAuthorized(address loggerAddress);\n\n    struct LedgerEvent {\n        \n        uint256 creationTime;\n        uint256 mileage; \n        uint256 repairOrderNumber;\n        address verifier; \n        EventType eventType;\n        string description;   \n    }\n\n    mapping (bytes32 => LedgerEvent[]) events;\n\n    /**\n     * Set the owner.\n     */\n    function History() {\n        \n        owner = msg.sender; \n    }\n\n    /**\n     * Only allows addresses can call this function.\n     */\n    modifier onlyAuthorized {\n\n        if (!authorizedLoggers[msg.sender])\n            throw;\n        _;\n    }\n\n    /**\n     * Only owner can call this function.\n     */\n     modifier onlyOwner {\n\n        if (msg.sender != owner)\n            throw;\n        _;\n    }\n\n\n    /**\n     * Authorize the specified address to add evemnts to the historic log.\n     */\n    function authorize(address newLogger) onlyOwner {\n\n        authorizedLoggers[newLogger] = true;\n        LoggerAuthorized(newLogger);\n    }\n\n    /**\n     * Checks if the specified address is authorized to log events.\n     */\n    function isAuthorized(address logger) returns (bool) {\n\n         return authorizedLoggers[logger];\n    }\n\n    /**\n     * Add a historically significant event (i.e. maintenance, damage \n     * repair or new owner).\n     */\n    function addEvent(uint256 _mileage, \n                     uint256 _repairOrderNumber,\n                     EventType _eventType, \n                     string _description, \n                     string _vin) onlyAuthorized {\n\n        events[sha3(_vin)].push(LedgerEvent({\n            creationTime: now,\n            mileage: _mileage,\n            repairOrderNumber: _repairOrderNumber,\n            verifier: msg.sender,\n            eventType: _eventType,\n            description: _description\n        }));\n        \n        EventLogged(_vin, _eventType, _mileage, msg.sender);\n    }\n    \n    /**\n     * Returns the number of events for a vin. (helper function for getEvent function)\n     */\n    function getEventsCount(string _vin) constant returns(uint256) {\n\n        return events[sha3(_vin)].length;\n    }\n    \n    /**\n     * Returns the details of a specific event. To be used together with the function\n     * getEventsCount().\n     */\n    function getEvent(string _vin, uint256 _index) constant\n                returns (uint256 mileage, address verifier, \n                        EventType eventType, string description) {\n\n        LedgerEvent memory e = events[sha3(_vin)][_index];\n        mileage = e.mileage;\n        verifier = e.verifier;\n        eventType = e.eventType;\n        description = e.description;\n    }\n\n    /**\n     * Lifecycle management (Solidity best-practice).\n     */\n    function kill() onlyOwner { \n\n        selfdestruct(owner); \n    }\n\n    /**\n     * Fallback function (Solidity best-practice).\n     */\n    function() payable {}\n}", "debug": "calldata_History_4 + calldata_History_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffec1\ncalldata_History_0: 0xc4a8a67000000000000000000000000000000000000000000000000000000000\ncalldatasize_History: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getEvent(string,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/34/0x30e18f4fcc310b55f86e73ce913e348c21bb75ef.sol", "function": "getEvent(string,uint256)", "lineno": 6, "title": "Integer Overflow ", "type": "Warning"}], "success": true}