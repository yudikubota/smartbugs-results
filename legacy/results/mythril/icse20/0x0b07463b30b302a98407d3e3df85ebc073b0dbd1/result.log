{"error": null, "issues": [{"address": 582, "code": "lic not_stopped registrar_owner_only {\n        stopped = true;\n    }\n\n    /**\n     * @dev Sets the address where domains are migrated to.\n     * @param _migration Address of the new registrar.\n     */\n    function setMigrationAddress(address _migration) public registrar_owner_only {\n        require(stopped);\n        migration = _migration;\n    }\n\n    ", "debug": "calldata_SubdomainRegistrar_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SubdomainRegistrar_0: 0xda9576100000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `upgrade(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 473, "title": "Integer Overflow ", "type": "Warning"}, {"address": 875, "code": "l];\n        return (data.name, data.price, 0, data.referralFeePPM);\n    }\n\n    /**\n     * @dev Registers a subdomain.\n     * @param label The label hash of the domain to register a subdomain of.\n     * @param subdomain The desired subdomain label.\n     * @param subdomainOwner The account that should own the newly configured subdomain.\n     * @param referrer The address of the account to receive the referral fee.\n     */\n    function register(by", "debug": "calldata_SubdomainRegistrar_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SubdomainRegistrar_0: 0x2eef3d6500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `query(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "query(bytes32,string)", "lineno": 374, "title": "Integer Overflow ", "type": "Warning"}, {"address": 887, "code": "l];\n        return (data.name, data.price, 0, data.referralFeePPM);\n    }\n\n    /**\n     * @dev Registers a subdomain.\n     * @param label The label hash of the domain to register a subdomain of.\n     * @param subdomain The desired subdomain label.\n     * @param subdomainOwner The account that should own the newly configured subdomain.\n     * @param referrer The address of the account to receive the referral fee.\n     */\n    function register(by", "debug": "calldata_SubdomainRegistrar_4 + calldata_SubdomainRegistrar_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_SubdomainRegistrar_0: 0x2eef3d6500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `query(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "query(bytes32,string)", "lineno": 374, "title": "Integer Overflow ", "type": "Warning"}, {"address": 896, "code": "l];\n        return (data.name, data.price, 0, data.referralFeePPM);\n    }\n\n    /**\n     * @dev Registers a subdomain.\n     * @param label The label hash of the domain to register a subdomain of.\n     * @param subdomain The desired subdomain label.\n     * @param subdomainOwner The account that should own the newly configured subdomain.\n     * @param referrer The address of the account to receive the referral fee.\n     */\n    function register(by", "debug": "calldata_SubdomainRegistrar_4 + calldata_SubdomainRegistrar_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_SubdomainRegistrar_0: 0x2eef3d6500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `query(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "query(bytes32,string)", "lineno": 374, "title": "Integer Overflow ", "type": "Warning"}, {"address": 902, "code": "l];\n        return (data.name, data.price, 0, data.referralFeePPM);\n    }\n\n    /**\n     * @dev Registers a subdomain.\n     * @param label The label hash of the domain to register a subdomain of.\n     * @param subdomain The desired subdomain label.\n     * @param subdomainOwner The account that should own the newly configured subdomain.\n     * @param referrer The address of the account to receive the referral fee.\n     */\n    function register(by", "debug": "calldata_SubdomainRegistrar_4 + calldata_SubdomainRegistrar_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_SubdomainRegistrar_0: 0x2eef3d6500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `query(bytes32,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "query(bytes32,string)", "lineno": 374, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1297, "code": ");\n\n        Domain storage domain = domains[label];\n\n        // Domain must be available for registration\n        require(keccak256(domain.name) == label);\n\n        // User must have paid enough\n        require(msg.value >= domain.price);\n\n        // Send any extra back\n        if (msg.value > domain.price) {\n            msg.sender.transfer(msg.value - domain.price);\n        }\n\n        // Send any referral fee\n        uint256 total = domain.price;\n        if (domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\n            referrer.transfer(referralFee);\n            total -= referralFee;\n        }\n\n        // Send the registration fee\n        if (total > 0) {\n            domain.owner.transfer(total);\n        }\n\n        // Register the domain\n        if (subdomainOwner == 0) {\n            subdomainOwner = msg.sender;\n        }\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\n\n        NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\n    }\n\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n        // Get the subdomain so we can configure it\n        ens.setSubnodeOwner(node, label, this);\n\n        bytes32 subnode = keccak256(node, label);\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, resolver);\n\n        // Set the address record on the resolver\n        resolver.setAddr(", "debug": "calldata_SubdomainRegistrar_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SubdomainRegistrar_0: 0x4254b15500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\n", "description": "A possible integer overflow exists in the function `register(bytes32,string,address,address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "register(bytes32,string,address,address,address)", "lineno": 390, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1309, "code": ");\n\n        Domain storage domain = domains[label];\n\n        // Domain must be available for registration\n        require(keccak256(domain.name) == label);\n\n        // User must have paid enough\n        require(msg.value >= domain.price);\n\n        // Send any extra back\n        if (msg.value > domain.price) {\n            msg.sender.transfer(msg.value - domain.price);\n        }\n\n        // Send any referral fee\n        uint256 total = domain.price;\n        if (domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\n            referrer.transfer(referralFee);\n            total -= referralFee;\n        }\n\n        // Send the registration fee\n        if (total > 0) {\n            domain.owner.transfer(total);\n        }\n\n        // Register the domain\n        if (subdomainOwner == 0) {\n            subdomainOwner = msg.sender;\n        }\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\n\n        NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\n    }\n\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n        // Get the subdomain so we can configure it\n        ens.setSubnodeOwner(node, label, this);\n\n        bytes32 subnode = keccak256(node, label);\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, resolver);\n\n        // Set the address record on the resolver\n        resolver.setAddr(", "debug": "calldata_SubdomainRegistrar_4 + calldata_SubdomainRegistrar_32 + 4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff8\ncalldata_SubdomainRegistrar_0: 0x4254b15500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\n", "description": "A possible integer overflow exists in the function `register(bytes32,string,address,address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "register(bytes32,string,address,address,address)", "lineno": 390, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1318, "code": ");\n\n        Domain storage domain = domains[label];\n\n        // Domain must be available for registration\n        require(keccak256(domain.name) == label);\n\n        // User must have paid enough\n        require(msg.value >= domain.price);\n\n        // Send any extra back\n        if (msg.value > domain.price) {\n            msg.sender.transfer(msg.value - domain.price);\n        }\n\n        // Send any referral fee\n        uint256 total = domain.price;\n        if (domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\n            referrer.transfer(referralFee);\n            total -= referralFee;\n        }\n\n        // Send the registration fee\n        if (total > 0) {\n            domain.owner.transfer(total);\n        }\n\n        // Register the domain\n        if (subdomainOwner == 0) {\n            subdomainOwner = msg.sender;\n        }\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\n\n        NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\n    }\n\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n        // Get the subdomain so we can configure it\n        ens.setSubnodeOwner(node, label, this);\n\n        bytes32 subnode = keccak256(node, label);\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, resolver);\n\n        // Set the address record on the resolver\n        resolver.setAddr(", "debug": "calldata_SubdomainRegistrar_4 + calldata_SubdomainRegistrar_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc1\ncalldata_SubdomainRegistrar_0: 0x4254b15500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\n", "description": "A possible integer overflow exists in the function `register(bytes32,string,address,address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "register(bytes32,string,address,address,address)", "lineno": 390, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1324, "code": ");\n\n        Domain storage domain = domains[label];\n\n        // Domain must be available for registration\n        require(keccak256(domain.name) == label);\n\n        // User must have paid enough\n        require(msg.value >= domain.price);\n\n        // Send any extra back\n        if (msg.value > domain.price) {\n            msg.sender.transfer(msg.value - domain.price);\n        }\n\n        // Send any referral fee\n        uint256 total = domain.price;\n        if (domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\n            referrer.transfer(referralFee);\n            total -= referralFee;\n        }\n\n        // Send the registration fee\n        if (total > 0) {\n            domain.owner.transfer(total);\n        }\n\n        // Register the domain\n        if (subdomainOwner == 0) {\n            subdomainOwner = msg.sender;\n        }\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\n\n        NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\n    }\n\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n        // Get the subdomain so we can configure it\n        ens.setSubnodeOwner(node, label, this);\n\n        bytes32 subnode = keccak256(node, label);\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, resolver);\n\n        // Set the address record on the resolver\n        resolver.setAddr(", "debug": "calldata_SubdomainRegistrar_4 + calldata_SubdomainRegistrar_32 + 4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff41\ncalldata_SubdomainRegistrar_0: 0x4254b15500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\n", "description": "A possible integer overflow exists in the function `register(bytes32,string,address,address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "register(bytes32,string,address,address,address)", "lineno": 390, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1704, "code": "r sale.\n     * @param name The name to configure.\n     * @param price The price in wei to charge for subdomain registrations\n     * @param referralFeePPM The referral fee to offer, in parts per million\n     */\n    function configur", "debug": "calldata_SubdomainRegistrar_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SubdomainRegistrar_0: 0x733ccaba00000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setResolver(string,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "setResolver(string,address)", "lineno": 279, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1939, "code": "      delete domains[label];\n\n        DomainTransferred(label, name);\n    }\n\n    function transferOwnership(address newOwner) public registrar_owner_only {\n        registrarOwner = newOwner;\n    }\n\n    function payRent(bytes32 label, string subdomain) public payable {\n        revert();\n    }\n\n    function deed(bytes32 label) internal view returns (Deed) {\n        var (,deedAddress,,,) = hashRegistrar.entries(label);\n        return Deed(deedAddress);\n    }\n}", "debug": "calldata_SubdomainRegistrar_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SubdomainRegistrar_0: 0xc9c5b5b400000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `migrate(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "migrate(string)", "lineno": 507, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2150, "code": ". Treat 0 as \"don't change\" for convenience.\n        require(domain.transferAddress == 0 || _transfer == 0 || domain.transferAddress == _transfer);\n\n        if (domain.owner != _owner) {\n            domain.owner = _owner;\n        }\n\n        if (keccak256(domain.name) != label) {\n            // New listing\n            domain.name = name;\n        }\n\n        domain.price = price;\n        domain.referralFeePPM = referralFeePPM;\n\n        if (domain.transferAddress != _transfer && _transfer != 0) {\n            domain.transferAddress = _transfer;\n            TransferAddressSet(label, _transfer);\n        }\n\n        DomainConfigured(label);\n    }\n\n    /**\n     * @dev Sets the transfer address of a domain for after an ENS update.\n     * @param name The name for which to set the transfer address.\n     * @param transfer The address to transfer to.\n     */\n    function setTransferAddress(string name, address transfer) public owner_only(keccak256(name)) {\n        byt", "debug": "calldata_SubdomainRegistrar_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_SubdomainRegistrar_0: 0xcf77525500000000000000000000000000000000000000000000000000000000\ncalldatasize_SubdomainRegistrar: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `configureDomainFor(string,uint256,uint256,address,address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "configureDomainFor(string,uint256,uint256,address,address)", "lineno": 302, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3334, "code": "ame The name to tr", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 258, "title": "Message call to external contract", "type": "Warning"}, {"address": 3334, "code": "ame The name to tr", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3531\n", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 258, "title": "Multiple Calls", "type": "Information"}, {"address": 3531, "code": "nction transfer(string nam", "debug": "", "description": "This contract executes a message call to an address provided as a function argument. Generally, it is not recommended to call user-supplied addresses using Solidity's call() construct. Note that attackers might leverage reentrancy attacks to exploit race conditions or manipulate this contract's state.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 261, "title": "Message call to external contract", "type": "Warning"}, {"address": 4159, "code": "    require(!stoppe", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 214, "title": "Message call to external contract", "type": "Informational"}, {"address": 5464, "code": "ubdomainOwner The ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "query(bytes32,string)", "lineno": 382, "title": "Message call to external contract", "type": "Informational"}, {"address": 6341, "code": "sender.transfer(msg.value - domain.price);\n     ", "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "register(bytes32,string,address,address,address)", "lineno": 402, "title": "Message call to external contract", "type": "Informational"}, {"address": 6341, "code": "sender.transfer(msg.value - domain.price);\n     ", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 6674\n", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "register(bytes32,string,address,address,address)", "lineno": 402, "title": "Multiple Calls", "type": "Information"}, {"address": 12869, "debug": "", "description": "This contract executes a message call to to another contract. Make sure that the called contract is trusted and does not execute user-supplied code.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "setResolver(string,address)", "lineno": 524, "title": "Message call to external contract", "type": "Informational"}, {"address": 12869, "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3334\n", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 524, "title": "Multiple Calls", "type": "Information"}, {"address": 13959, "code": "e;\n\n    bool public stopped = false;\n    address public registrarOwner;\n    address public migration;\n\n    ENS public ens;\n    HashRegistrarSimplified public hashRegistrar;\n\n    struct Domain {\n        string name;\n        address owner;\n        address transferAddress;\n        uint price;\n        uint referralFeePPM;\n    }\n\n    mapping (bytes32 => Domain) domains;\n\n    modifier new_registrar() {\n        require(ens.owner(TLD_NODE) != address(hashRegistrar));\n        _;\n    }\n\n    modifier owner_only(bytes32 label) {\n        require(owner(label) == msg.sender);\n        _;\n    }\n\n    modifier not_stopped() {\n        require(!stopped);\n        _;\n    }\n\n    modifier registrar_owner_only() {\n        require(msg.sender == registrarOwner);\n        _;\n    }\n\n    event TransferAddressSet(bytes32 indexed label, address addr);\n    event DomainTransferred(bytes32 indexed label, string name);\n\n    function SubdomainRegistrar(ENS _ens) public {\n        ens = _ens;\n        hashRegistrar = HashRegistrarSimplified(ens.owner(TLD_NODE));\n        registrarOwner = msg.sender;\n    }\n\n    /**\n     * @dev owner returns the address of the account that controls a domain.\n     *      Initially this is a null address. If the name has been\n     *      transferred to this contract, then the internal mapping is consulted\n     *      to determine who controls it. If the owner is not set,\n     *      the previous owner of the deed is returned.\n     * @param label The label hash of the deed to check.\n     * @return The address owning the deed.\n     */\n    function owner(bytes32 label) public view returns (address) {\n\n        if (domains[label].owner != 0x0) {\n            return domains[label].owner;\n        }\n\n        Deed domainDeed = deed(label);\n        if (domainDeed.owner() != address(this)) {\n            return 0x0;\n        }\n\n        return domainDeed.previousOwner();\n    }\n\n    /**\n     * @dev Transfers internal control of a name to a new account. Does not update\n     *      ENS.\n     * @param name The name to transfer.\n     * @param newOwner The address of the new owner.\n     */\n    function transfer(string name, address newOwner) public owner_only(keccak256(name)) {\n        bytes32 label = keccak256(name);\n        OwnerChanged(keccak256(name), domains[label].owner, newOwner);\n        domains[label].owner = newOwner;\n    }\n\n    /**\n     * @dev Sets the resolver record for a name in ENS.\n     * @param name The name to set the resolver for.\n     * @param resolver The address of the resolver\n     */\n    function setResolver(string name, address resolver) public owner_only(keccak256(name)) {\n        bytes32 label = keccak256(name);\n        bytes32 node = keccak256(TLD_NODE, label);\n        ens.setResolver(node, resolver);\n    }\n\n    /**\n     * @dev Configures a domain for sale.\n     * @param name The name to configure.\n     * @param price The price in wei to charge for subdomain registrations\n     * @param referralFeePPM The referral fee to offer, in parts per million\n     */\n    function configureDomain(string name, uint price, uint referralFeePPM) public {\n        configureDomainFor(name, price, referralFeePPM, msg.sender, 0x0);\n    }\n\n    /**\n     * @dev Configures a domain, optionally transferring it to a new owner.\n     * @param name The name to configure.\n     * @param price The price in wei to charge for subdomain registrations.\n     * @param referralFeePPM The referral fee to offer, in parts per million.\n     * @param _owner The address to assign ownership of this domain to.\n     * @param _transfer The address to set as the transfer address for the name\n     *        when the permanent registrar is replaced. Can only be set to a non-zero\n     *        value once.\n     */\n    function configureDomainFor(string name, uint price, uint referralFeePPM, address _owner, address _transfer) public owner_only(keccak256(name)) {\n        bytes32 label = keccak256(name);\n        Domain storage domain = domains[label];\n\n        // Don't allow changing the transfer address once set. Treat 0 as \"don't change\" for convenience.\n        require(domain.transferAddress == 0 || _transfer == 0 || domain.transferAddress == _transfer);\n\n        if (domain.owner != _owner) {\n            domain.owner = _owner;\n        }\n\n        if (keccak256(domain.name) != label) {\n            // New listing\n            domain.name = name;\n        }\n\n        domain.price = price;\n        domain.referralFeePPM = referralFeePPM;\n\n        if (domain.transferAddress != _transfer && _transfer != 0) {\n            domain.transferAddress = _transfer;\n            TransferAddressSet(label, _transfer);\n        }\n\n        DomainConfigured(label);\n    }\n\n    /**\n     * @dev Sets the transfer address of a domain for after an ENS update.\n     * @param name The name for which to set the transfer address.\n     * @param transfer The address to transfer to.\n     */\n    function setTransferAddress(string name, address transfer) public owner_only(keccak256(name)) {\n        bytes32 label = keccak256(name);\n        Domain storage domain = domains[label];\n\n        require(domain.transferAddress == 0x0);\n\n        domain.transferAddress = transfer;\n        TransferAddressSet(label, transfer);\n    }\n\n    /**\n     * @dev Unlists a domain\n     * May only be called by the owner.\n     * @param name The name of the domain to unlist.\n     */\n    function unlistDomain(string name) public owner_only(keccak256(name)) {\n        bytes32 label = keccak256(name);\n        Domain storage domain = domains[label];\n        DomainUnlisted(label);\n\n        domain.name = '';\n        domain.owner = owner(label);\n        domain.price = 0;\n        domain.referralFeePPM = 0;\n    }\n\n    /**\n     * @dev Returns information about a subdomain.\n     * @param label The label hash for the domain.\n     * @param subdomain The label for the subdomain.\n     * @return domain The name of the domain, or an empty string if the subdomain\n     *                is unavailable.\n     * @return price The price to register a subdomain, in wei.\n     * @return rent The rent to retain a subdomain, in wei per second.\n     * @return referralFeePPM The referral fee for the dapp, in ppm.\n     */\n    function query(bytes32 label, string subdomain) public view returns (string domain, uint price, uint rent, uint referralFeePPM) {\n        bytes32 node = keccak256(TLD_NODE, label);\n        bytes32 subnode = keccak256(node, keccak256(subdomain));\n\n        if (ens.owner(subnode) != 0) {\n            return ('', 0, 0, 0);\n        }\n\n        Domain data = domains[label];\n        return (data.name, data.price, 0, data.referralFeePPM);\n    }\n\n    /**\n     * @dev Registers a subdomain.\n     * @param label The label hash of the domain to register a subdomain of.\n     * @param subdomain The desired subdomain label.\n     * @param subdomainOwner The account that should own the newly configured subdomain.\n     * @param referrer The address of the account to receive the referral fee.\n     */\n    function register(bytes32 label, string subdomain, address subdomainOwner, address referrer, address resolver) public not_stopped payable {\n        bytes32 domainNode = keccak256(TLD_NODE, label);\n        bytes32 subdomainLabel = keccak256(subdomain);\n\n        // Subdomain must not be registered already.\n        require(ens.owner(keccak256(domainNode, subdomainLabel)) == address(0));\n\n        Domain storage domain = domains[label];\n\n        // Domain must be available for registration\n        require(keccak256(domain.name) == label);\n\n        // User must have paid enough\n        require(msg.value >= domain.price);\n\n        // Send any extra back\n        if (msg.value > domain.price) {\n            msg.sender.transfer(msg.value - domain.price);\n        }\n\n        // Send any referral fee\n        uint256 total = domain.price;\n        if (domain.referralFeePPM * domain.price > 0 && referrer != 0 && referrer != domain.owner) {\n            uint256 referralFee = (domain.price * domain.referralFeePPM) / 1000000;\n            referrer.transfer(referralFee);\n            total -= referralFee;\n        }\n\n        // Send the registration fee\n        if (total > 0) {\n            domain.owner.transfer(total);\n        }\n\n        // Register the domain\n        if (subdomainOwner == 0) {\n            subdomainOwner = msg.sender;\n        }\n        doRegistration(domainNode, subdomainLabel, subdomainOwner, Resolver(resolver));\n\n        NewRegistration(label, subdomain, subdomainOwner, referrer, domain.price);\n    }\n\n    function doRegistration(bytes32 node, bytes32 label, address subdomainOwner, Resolver resolver) internal {\n        // Get the subdomain so we can configure it\n        ens.setSubnodeOwner(node, label, this);\n\n        bytes32 subnode = keccak256(node, label);\n        // Set the subdomain's resolver\n        ens.setResolver(subnode, resolver);\n\n        // Set the address record on the resolver\n        resolver.setAddr(subnode, subdomainOwner);\n\n        // Pass ownership of the new subdomain to the registrant\n        ens.setOwner(subnode, subdomainOwner);\n    }\n\n    function supportsInterface(bytes4 interfaceID) public pure returns (bool) {\n        return (\n            (interfaceID == 0x01ffc9a7) // supportsInterface(bytes4)\n            || (interfaceID == 0xc1b15f5a) // RegistrarInterface\n        );\n    }\n\n    function rentDue(bytes32 label, string subdomain) public view returns (uint timestamp) {\n        return 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\n    }\n\n    /**\n     * @dev Upgrades the domain to a new registrar.\n     * @param name The name of the domain to transfer.\n     */\n    function upgrade(string name) public owner_only(keccak256(name)) new_registrar {\n        bytes32 label = keccak256(name);\n        address transfer = domains[label].transferAddress;\n\n        require(transfer != 0x0);\n\n        delete domains[label];\n\n        hashRegistrar.transfer(label, transfer);\n        DomainTransferred(label, name);\n    }\n\n\n    /**\n     * @dev Stops the registrar, disabling configuring of new domains.\n     */\n    function stop() public not_stopped registrar_owner_only {\n        stopped = true;\n    }\n\n    /**\n     * @dev Sets the address where domains are migrated to.\n     * @param _migration Address of the new registrar.\n     */\n    function setMigrationAddress(address _migration) public registrar_owner_only {\n        require(stopped);\n        migration = _migration;\n    }\n\n    /**\n     * @dev Migrates the domain to a new registrar.\n     * @param name The name of the domain to migrate.\n     */\n    function migrate(string name) public owner_only(keccak256(name)) {\n        require(stopped);\n        require(migration != 0x0);\n\n        bytes32 label = keccak256(name);\n        Domain storage domain = domains[label];\n\n        hashRegistrar.transfer(label, migration);\n\n        SubdomainRegistrar(migration).configureDomainFor(\n            domain.name,\n            domain.price,\n            domain.referralFeePPM,\n            domain.owner,\n            domain.transferAddress\n        );\n\n        delete domains[label];\n\n        DomainTransferred(label, name);\n    }\n\n    function transferOwnership(address newOwner) public registrar_owner_only {\n        registrarOwner = newOwner;\n    }\n\n    function payRent(bytes32 label, string subdomain) public payable {\n        revert();\n    }\n\n    function deed(bytes32 label) internal view returns (Deed) {\n        var (,deedAddress,,,) = hashRegistrar.entries(label);\n        return Deed(deedAddress);\n    }\n}", "debug": "", "description": "The contract account state is changed after an external call. Consider that the called contract could re-enter the function before this state change takes place. This can lead to business logic vulnerabilities.", "filename": "/unique_chucks/6/0x0b07463b30b302a98407d3e3df85ebc073b0dbd1.sol", "function": "upgrade(string)", "lineno": 184, "title": "State change after external call", "type": "Warning"}], "success": true}