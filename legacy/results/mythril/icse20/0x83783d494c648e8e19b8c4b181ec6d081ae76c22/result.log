{"error": null, "issues": [{"address": 337, "code": "Data(bytes _data) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        uint startPoint;\n\n        if(remainder != 0) {\n\n            startPoint = 32 - remainder;\n            bytes memory rest = new bytes(32);\n            for(uint i = 0; i < remainder; i++) {\n                rest[i] = data[data.length - 1][i];\n            }\n            for(i = 0; i < startPoint; i++) {\n                rest[remainder + i] = _data[i];\n            }\n            bytes32 p;\n            assembly {\n                p := mload(add(rest, 32))\n            }\n            data[data.length - 1] = p;\n        }\n        for(i = 0; i < (uint(_data.length - startPoint) / 32); i++) {\n            bytes32 word;\n            assembly {\n                word:= mload(add(_data, add(add(32, startPoint), mul(i, 32))))\n            }\n            data.push(word);\n        }\n        uint loose = (_data.length - startPoint) % 32;\n        if(loose != 0) {\n            uint position = _data.length - loose;\n            bytes32 leftover;\n            assembly {\n                leftover := mload(add(_data, add(32, position)))\n            }\n            data.push(leftover);\n        }\n        remainder = loose;\n    }\n    // If a mistake is done during upload, reverse u", "debug": "calldata_Storage_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `uploadData(bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 16, "title": "Integer Overflow ", "type": "Warning"}, {"address": 713, "code": "       bytes32 w", "debug": "storage_1: 0x800000000000000000000000000000000000000000000000000000000000000\ncalldata_Storage_0: 0x3bc5de3000000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `getData()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "getData()", "lineno": 75, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1002, "code": "      bytes me", "debug": "storage_2: 0x30\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `uploadData(bytes)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 24, "title": "Integer Underflow", "type": "Warning"}, {"address": 1094, "code": "\n            }\n      ", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0x0\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 26, "title": "Exception state", "type": "Informational"}, {"address": 1167, "code": "h - 1][", "debug": "The exception is triggered under the following conditions:\n\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa\nstorage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Storage_4 + calldata_Storage_4)): 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 26, "title": "Exception state", "type": "Informational"}, {"address": 1255, "code": "        ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0x1\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Storage_4 + calldata_Storage_4)): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncalldata_Storage_4 + calldata_Storage_4: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 31, "title": "Exception state", "type": "Informational"}, {"address": 1348, "code": "i];\n            }\n ", "debug": "The exception is triggered under the following conditions:\n\nstorage_2: 0x1\nmem_128 +\n32 +\n32*\nConcat(0,\n       Extract(255,\n               5,\n               31 + calldata_Storage_4 + calldata_Storage_4)): 0x1\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffa\ncalldata_Storage_4 + calldata_Storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 29, "title": "Exception state", "type": "Informational"}, {"address": 1510, "code": ";\n\ncontract Storag", "debug": "storage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Storage_4 + calldata_Storage_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\nstorage_2: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `uploadData(bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1616, "code": ";\n\ncontract Storag", "debug": "storage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Storage_4 + calldata_Storage_4: 0x70\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x69cef46c00000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\nstorage_2: 0x0\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `uploadData(bytes)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "uploadData(bytes)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1809, "code": "32[] public data; // ", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Storage_4: 0x0\nstorage_1: 0x0\ncalldata_Storage_0: 0xf0ba844000000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "_function_0xf0ba8440", "lineno": 6, "title": "Exception state", "type": "Informational"}, {"address": 1849, "code": "ntract Storage {\n    address owner; // This address has permission to upload data\n    \n    bytes32[] public data; // Storage container in pieces of 32 byte\n    uint remainder; // Where the previous uploadData() left off\n    \n    bool readOnly; // Set the contract to read only once upload is finished\n\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    // Data is uploaded over many transactions, until the whole file is stored in the contract\n    function uploadData(bytes _data) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        uint startPoint;\n\n        if(remainder != 0) {\n\n            startPoint = 32 - remainder;\n            bytes memory rest = new bytes(32);\n            for(uint i = 0; i < remainder; i++) {\n                rest[i] = data[data.length - 1][i];\n            }\n            for(i = 0; i < startPoint; i++) {\n                rest[remainder + i] = _data[i];\n            }\n            bytes32 p;\n            assembly {\n                p := mload(add(rest, 32))\n            }\n            data[data.length - 1] = p;\n        }\n        for(i = 0; i < (uint(_data.length - startPoint) / 32); i++) {\n            bytes32 word;\n            assembly {\n                word:= mload(add(_data, add(add(32, startPoint), mul(i, 32))))\n            }\n            data.push(word);\n        }\n        uint loose = (_data.length - startPoint) % 32;\n        if(loose != 0) {\n            uint position = _data.length - loose;\n            bytes32 leftover;\n            assembly {\n                leftover := mload(add(_data, add(32, position)))\n            }\n            data.push(leftover);\n        }\n        remainder = loose;\n    }\n    // If a mistake is done during upload, reverse using erase()\n    function erase(uint _entriesToDelete) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        if(data.length < _entriesToDelete) { \n            delete data;\n        }\n        else data.length -= _entriesToDelete;\n        remainder = 0;\n    }\n    function uploadFinish() public {\n        require(msg.sender == owner);\n        readOnly = true;\n    }\n\n    // This loads the entire file as a single byte array. Since it does not\n    // affect the contract state, there are no gas costs\n    function getData() public view returns (bytes){\n        bytes memory result = new bytes(data.length*0x20);\n        for(uint i = 0; i < data.length; i++) {\n            bytes32 word = data[i];\n            assembly {\n                mstore(add(result, add(0x20, mul(i, 32))), word)\n            }\n        }\n        return result;\n    }\n}", "debug": "storage_1: 0xa700f36fbdeffd40eff9ffffffff980000000000000000001ff8000007fefd8c\ncalldata_Storage_4: 0xa700f36fbdeffd40eff9ffffffff980000000000000000001ff8000007fefd8d\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x1007f75300000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `erase(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "erase(uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1889, "code": "ntract Storage {\n    address owner; // This address has permission to upload data\n    \n    bytes32[] public data; // Storage container in pieces of 32 byte\n    uint remainder; // Where the previous uploadData() left off\n    \n    bool readOnly; // Set the contract to read only once upload is finished\n\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    // Data is uploaded over many transactions, until the whole file is stored in the contract\n    function uploadData(bytes _data) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        uint startPoint;\n\n        if(remainder != 0) {\n\n            startPoint = 32 - remainder;\n            bytes memory rest = new bytes(32);\n            for(uint i = 0; i < remainder; i++) {\n                rest[i] = data[data.length - 1][i];\n            }\n            for(i = 0; i < startPoint; i++) {\n                rest[remainder + i] = _data[i];\n            }\n            bytes32 p;\n            assembly {\n                p := mload(add(rest, 32))\n            }\n            data[data.length - 1] = p;\n        }\n        for(i = 0; i < (uint(_data.length - startPoint) / 32); i++) {\n            bytes32 word;\n            assembly {\n                word:= mload(add(_data, add(add(32, startPoint), mul(i, 32))))\n            }\n            data.push(word);\n        }\n        uint loose = (_data.length - startPoint) % 32;\n        if(loose != 0) {\n            uint position = _data.length - loose;\n            bytes32 leftover;\n            assembly {\n                leftover := mload(add(_data, add(32, position)))\n            }\n            data.push(leftover);\n        }\n        remainder = loose;\n    }\n    // If a mistake is done during upload, reverse using erase()\n    function erase(uint _entriesToDelete) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        if(data.length < _entriesToDelete) { \n            delete data;\n        }\n        else data.length -= _entriesToDelete;\n        remainder = 0;\n    }\n    function uploadFinish() public {\n        require(msg.sender == owner);\n        readOnly = true;\n    }\n\n    // This loads the entire file as a single byte array. Since it does not\n    // affect the contract state, there are no gas costs\n    function getData() public view returns (bytes){\n        bytes memory result = new bytes(data.length*0x20);\n        for(uint i = 0; i < data.length; i++) {\n            bytes32 word = data[i];\n            assembly {\n                mstore(add(result, add(0x20, mul(i, 32))), word)\n            }\n        }\n        return result;\n    }\n}", "debug": "calldata_Storage_4: 0x4000\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffeffffffffeffffffffffffffe\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x1007f75300000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `erase(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "erase(uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1891, "code": "ntract Storage {\n    address owner; // This address has permission to upload data\n    \n    bytes32[] public data; // Storage container in pieces of 32 byte\n    uint remainder; // Where the previous uploadData() left off\n    \n    bool readOnly; // Set the contract to read only once upload is finished\n\n    constructor() {\n        owner = msg.sender;\n    }\n    \n    // Data is uploaded over many transactions, until the whole file is stored in the contract\n    function uploadData(bytes _data) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        uint startPoint;\n\n        if(remainder != 0) {\n\n            startPoint = 32 - remainder;\n            bytes memory rest = new bytes(32);\n            for(uint i = 0; i < remainder; i++) {\n                rest[i] = data[data.length - 1][i];\n            }\n            for(i = 0; i < startPoint; i++) {\n                rest[remainder + i] = _data[i];\n            }\n            bytes32 p;\n            assembly {\n                p := mload(add(rest, 32))\n            }\n            data[data.length - 1] = p;\n        }\n        for(i = 0; i < (uint(_data.length - startPoint) / 32); i++) {\n            bytes32 word;\n            assembly {\n                word:= mload(add(_data, add(add(32, startPoint), mul(i, 32))))\n            }\n            data.push(word);\n        }\n        uint loose = (_data.length - startPoint) % 32;\n        if(loose != 0) {\n            uint position = _data.length - loose;\n            bytes32 leftover;\n            assembly {\n                leftover := mload(add(_data, add(32, position)))\n            }\n            data.push(leftover);\n        }\n        remainder = loose;\n    }\n    // If a mistake is done during upload, reverse using erase()\n    function erase(uint _entriesToDelete) public {\n        require(msg.sender == owner);\n        require(readOnly != true);\n        if(data.length < _entriesToDelete) { \n            delete data;\n        }\n        else data.length -= _entriesToDelete;\n        remainder = 0;\n    }\n    function uploadFinish() public {\n        require(msg.sender == owner);\n        readOnly = true;\n    }\n\n    // This loads the entire file as a single byte array. Since it does not\n    // affect the contract state, there are no gas costs\n    function getData() public view returns (bytes){\n        bytes memory result = new bytes(data.length*0x20);\n        for(uint i = 0; i < data.length; i++) {\n            bytes32 word = data[i];\n            assembly {\n                mstore(add(result, add(0x20, mul(i, 32))), word)\n            }\n        }\n        return result;\n    }\n}", "debug": "calldata_Storage_4: 0x8000000001000000000000000000000000000000000000000000000000000000\nstorage_1: 0xcffffffff94cf8ffffffffff0e8195cdf30b7ffffffffffffffffffffffffff8\nstorage_3: 0x0\nstorage_0: 0x0\ncaller: 0x0\ncalldata_Storage_0: 0x1007f75300000000000000000000000000000000000000000000000000000000\ncalldatasize_Storage: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `erase(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_contracts/0x83783d494c648e8e19b8c4b181ec6d081ae76c22.sol", "function": "erase(uint256)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}