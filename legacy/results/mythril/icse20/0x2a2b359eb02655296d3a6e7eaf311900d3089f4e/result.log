{"error": null, "issues": [{"address": 1267, "code": "_from] == 0) airdroped[_from] = 1;\n\tif(airdroped[_to] == 0) airdroped[_to] = 1;\n", "debug": "calldata_Token_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_Token_0: 0x5353a2d800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `changeName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "changeName(string)", "lineno": 218, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2692, "code": "ner]) retur", "debug": "calldata_Token_4: 0xa8795cd3fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_14: 0x57f25cd000000000000000000000000000000000000000000000000000000000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_13,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x38c9027a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `calc(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "calc(uint256)", "lineno": 371, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2707, "code": "\n}", "debug": "storage_16: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_14: 0x0\ncalldata_Token_4: 0x1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_13,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x38c9027a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `calc(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "calc(uint256)", "lineno": 373, "title": "Integer Overflow ", "type": "Warning"}, {"address": 2914, "debug": "storage_16: 0x0\ncalldata_Token_4: 0xc57dd5eefe7ffd7a2de911bbbdbb76d810f448fdfaf5f9fab7fe18797f53efba\nstorage_14: 0x979c160f0fd5460c1e827323fbc700670fc7fff7bffe20047e09805fb034f85\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_13,_256): 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_1: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_Token_0: 0x38c9027a00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `calc(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "calc(uint256)", "lineno": 374, "title": "Integer Underflow", "type": "Warning"}, {"address": 3753, "code": " add a frac of airdrop with each */ \n\tuint256 ", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\nUDiv(storage_13,_256): 0x4000000000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x11c37937e08001\nstorage_10: 0x0\nstorage_15: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_1: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldatasize_Token: 0x3\nstorage_16: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xc000000000000000000000000000000000000000000000000000000000000000\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "fallback", "lineno": 367, "title": "Exception state", "type": "Informational"}, {"address": 11119, "code": "n c;\n", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0xf3d71d660cff11fbd3303f4abfdbbe9317b3e0af48020092f0c5e3b733d2fff0\ncalldata_Token_32 + 36: 0xe86938cd473f93f55b30667433ce7ac826aefff6ba013e0db1294942d1a99435\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_32_+_4: 0x8e73fddb14fe53ff4c1a74c5b38fdbcd78cc8000ba003c6a498ed50a9a7117b1\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xe86938cd473f93f55b30667433ce7ac826aefff6ba013e0db1294942d1a99435\ncalldata_Token_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "transferFrom(address,address,uint256)", "lineno": 39, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11132, "code": "/**\n * @title ", "debug": "The exception is triggered under the following conditions:\n\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_4: 0x8671dcb40fdee8040400000389c1095c530880e0184c197484b8b07eef728dbe\ncalldata_Token_32 + 36: 0x8060008027eee8800400000340480185000000602c00007911201171e73c7d95\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Token_32_+_4: 0x8c36ff26404e72d3f6f63e491f83f60006b9fb1ec2d657fddcaa8c61005c412d\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x8060008027eee8800400000340480185000000602c00007911201171e73c7d95\ncalldata_Token_32 + 4: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Token_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "transferFrom(address,address,uint256)", "lineno": 43, "title": "Exception state", "type": "Informational"}, {"address": 11233, "code": "isable-line uppercase\n  uint64 public constant sequence = 63329460478;\n  uint256 public aDropedThisWeek;\n  uint256 lastWeek;\n  uint256 decimate;\n  uint256 weekly_limit;\n  uint256 air_drop;\n  mapping(address => uint256) airdroped;\n  address control;\n  address public owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  uint256 public Market; // @ current frac\n  uint256 public AvailableTokenPool; // all of contracts initial tokens on creation\n  \n  /**\n   * @dev Throws if called by any account other than the owner, control.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner || msg.sender == control);\n    _;\n  }\n  modifier onlyControl() {\n    require(msg.sender == control);\n    _;\n  }\n  \n  function changeName(string newName) onlyOwner public {\n    name = newName;\n  }\n  \n  function RecordTransfer(address _from, address _to, uint256 _value) internal {\n    Transfer(_from, _to, _value);\n\tif(airdroped[_from] == 0) airdroped[_from] = 1;\n\tif(airdroped[_to] == 0) airdroped[_to] = 1;\n  }\n  \n  /*** @param newOwner  The address to transfer ownership to\n    owner tokens go with owner, airdrops always from owner pool */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n\tOwnershipTransferred(owner, newOwner);\n\tif(owner != newOwner) {\n\t  uint256 t = balances[owner] / 10;\n\t  balances[newOwner] += balances[owner] - t;\n\t  balances[owner] = t;\n    }\t\n    owner = newOwner;\n\tupdate();\n  } /*** @param newControl  The address to transfer control to.   */\n  function transferControl(address newControl) public onlyControl {\n    require(newControl != address(0) && newControl != address(this));  \n\tcontrol =newControl;\n } /*init contract itself as owner of all its tokens, all tokens set'''''to air drop, and always comes form owner's bucket \n   .+------+     +------+     +------+     +------+     +------+.     =================== ===================\n .' |    .'|    /|     /|     |      |     |\\     |\\    |`.    | `.   */function Token(uint256 _initialAmount,/*\n+---+--+'  |   +-+----+ |     +------+     | +----+-+   |  `+--+---+  */string _tokenName, uint8 _decimalUnits,/*\n|   |  |   |   | |  K | |     |  N   |     | | 0  | |   |   |  |   |  */string _tokenSymbol) public { control = msg.sender; /*\n|  ,+--+---+   | +----+-+     +------+     +-+----+ |   +---+--+   |  */owner = address(this);OwnershipTransferred(address(0), owner);/*\n|.'    | .'    |/     |/      |      |      \\|     \\|    `. |   `. |  */balances[owner] = totalSupply_; /*\n+------+'      +------+       +------+       +------+      `+------+  */RecordTransfer(0x0, owner, totalSupply_);\n    symbol = _tokenSymbol;   \n\tname = _tokenName;\n    decimals = _decimalUnits;                            \n\ttotalSupply_ = _initialAmount;\n\tdecimate = (10 ** uint256(decimals));\n\tweekly_limit = 100000 * decimate;\n\tair_drop = 1018 * decimate;\n\tif(((totalSupply_  *2)/decimate) > 1 ether) coef = 1;\n\telse coef = 1 ether / ((totalSupply_  *2)/decimate);\n\tupdate();\n  } /** rescue lost erc20 kin **/\n  function transfererc20(address tokenAddress, address _to, uint256 _value) external onlyControl returns (bool) {\n    require(_to != address(0));\n\treturn ERC20(tokenAddress).transfer(_to, _value);\n  } /** token no more **/\n  function destroy() onlyControl external {\n    require(owner != address(this)); selfdestruct(owner);\n  }  \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\trequire(_value <= allowed[_from][msg.sender]);\n\tif(balances[_from] == 0) { \n      uint256 qty = availableAirdrop(_from);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[_to] += qty;\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\tRecordTransfer(owner, _from, _value);\n\t\tRecordTransfer(_from, _to, _value);\n\t\tupdate();\n\t\taDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    require(_value <= balances[_from]);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    RecordTransfer(_from, _to, _value);\n\tupdate();\n    return true;\n  }  \n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\t// if no balance, see if eligible for airdrop instead\n    if(balances[msg.sender] == 0) { \n      uint256 qty = availableAirdrop(msg.sender);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[msg.sender] += qty;\n\t\tRecordTransfer(owner, _to, _value);\n\t\tupdate();\n\t\tairdroped[msg.sender] = 1;\n\t\taDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    // existing balance\n    if(balances[msg.sender] < _value) revert();\n\tif(balances[_to] + _value < balances[_to]) revert();\n\t\n    balances[_to] += _value;\n\tbalances[msg.sender] -= _value;\n    RecordTransfer(msg.sender, _to, _value);\n\tupdate();\n\treturn true;\n  }  \n  function balanceOf(address who) public view returns (uint256 balance) {\n    balance = balances[who];\n\tif(balance == 0) \n\t  return availableAirdrop(who);\n\t\n    return balance;\n  }  \n  /*  * check the faucet  */  \n  function availableAirdrop(address who) internal constant returns (uint256) {\n    if(balances[owner] == 0) return 0;\n\tif(airdroped[who] > 0) return 0; // already seen this\n\t\n\tif (thisweek() > lastWeek || aDropedThisWeek < weekly_limit) {\n\t  if(balances[owner] > air_drop) return air_drop;\n\t  else return balances[owner];\n\t}\n\treturn 0;\n  }  function thisweek() internal view returns (uint256) {\n    return now / 1 weeks;\n  }  function getAirDropedToday() public view returns (uint256) {\n    if (thisweek() > lastWeek) return 0;\n\telse return aDropedThisWeek;\n  }  \n  function transferBalance(address upContract) external onlyControl {\n    require(upContract != address(0) && upContract.send(this.balance));\n  }\n  function () payable public {\n    uint256 qty = calc(msg.value);\n\tif(qty > 0) {\n\t  balances[msg.sender] += qty;\n\t  balances[owner] -= qty;\n\t  RecordTransfer(owner, msg.sender, qty);\n\t  update();\n\t} else revert();\n  } \n  uint256 coef;\n  function update() internal {\n    if(balances[owner] != AvailableTokenPool) {\n\t  Market = (((totalSupply_ - balances[owner]) ** 2) / coef);\n\t  AvailableTokenPool = balances[owner];\n\t}\n  }\n  function calc(uint256 _v) public view returns (uint256) {\n    if(balances[owner] == 0) return 0;\n\tuint256 x = (coef * (_v + Market)); \n\tuint256 qty = x;\n\tuint256 z = (x + 1) / 2;\n    while (z < qty) {\n        qty = z;\n        z = (x / z + z) / 2;\n    } /* add a frac of airdrop with each */ \n\tuint256 drop = 0;\n\tif(_v > 5000000000000000) drop = (air_drop * (1 + (_v / 3000000000000000)));\t\n\tuint256 worth = (qty - (totalSupply_ - balances[owner])) + drop;\n\tif(worth > balances[owner]) return balances[owner];\n\treturn worth;\n  }  \n}", "debug": "calldata_Token_4 + calldata_Token_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nstorage_12: 0x0\nstorage_13: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_Token_0: 0x5353a2d800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `changeName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "changeName(string)", "lineno": 186, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11247, "code": "isable-line uppercase\n  uint64 public constant sequence = 63329460478;\n  uint256 public aDropedThisWeek;\n  uint256 lastWeek;\n  uint256 decimate;\n  uint256 weekly_limit;\n  uint256 air_drop;\n  mapping(address => uint256) airdroped;\n  address control;\n  address public owner;\n  event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n  uint256 public Market; // @ current frac\n  uint256 public AvailableTokenPool; // all of contracts initial tokens on creation\n  \n  /**\n   * @dev Throws if called by any account other than the owner, control.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner || msg.sender == control);\n    _;\n  }\n  modifier onlyControl() {\n    require(msg.sender == control);\n    _;\n  }\n  \n  function changeName(string newName) onlyOwner public {\n    name = newName;\n  }\n  \n  function RecordTransfer(address _from, address _to, uint256 _value) internal {\n    Transfer(_from, _to, _value);\n\tif(airdroped[_from] == 0) airdroped[_from] = 1;\n\tif(airdroped[_to] == 0) airdroped[_to] = 1;\n  }\n  \n  /*** @param newOwner  The address to transfer ownership to\n    owner tokens go with owner, airdrops always from owner pool */\n  function transferOwnership(address newOwner) public onlyOwner {\n    require(newOwner != address(0));\n\tOwnershipTransferred(owner, newOwner);\n\tif(owner != newOwner) {\n\t  uint256 t = balances[owner] / 10;\n\t  balances[newOwner] += balances[owner] - t;\n\t  balances[owner] = t;\n    }\t\n    owner = newOwner;\n\tupdate();\n  } /*** @param newControl  The address to transfer control to.   */\n  function transferControl(address newControl) public onlyControl {\n    require(newControl != address(0) && newControl != address(this));  \n\tcontrol =newControl;\n } /*init contract itself as owner of all its tokens, all tokens set'''''to air drop, and always comes form owner's bucket \n   .+------+     +------+     +------+     +------+     +------+.     =================== ===================\n .' |    .'|    /|     /|     |      |     |\\     |\\    |`.    | `.   */function Token(uint256 _initialAmount,/*\n+---+--+'  |   +-+----+ |     +------+     | +----+-+   |  `+--+---+  */string _tokenName, uint8 _decimalUnits,/*\n|   |  |   |   | |  K | |     |  N   |     | | 0  | |   |   |  |   |  */string _tokenSymbol) public { control = msg.sender; /*\n|  ,+--+---+   | +----+-+     +------+     +-+----+ |   +---+--+   |  */owner = address(this);OwnershipTransferred(address(0), owner);/*\n|.'    | .'    |/     |/      |      |      \\|     \\|    `. |   `. |  */balances[owner] = totalSupply_; /*\n+------+'      +------+       +------+       +------+      `+------+  */RecordTransfer(0x0, owner, totalSupply_);\n    symbol = _tokenSymbol;   \n\tname = _tokenName;\n    decimals = _decimalUnits;                            \n\ttotalSupply_ = _initialAmount;\n\tdecimate = (10 ** uint256(decimals));\n\tweekly_limit = 100000 * decimate;\n\tair_drop = 1018 * decimate;\n\tif(((totalSupply_  *2)/decimate) > 1 ether) coef = 1;\n\telse coef = 1 ether / ((totalSupply_  *2)/decimate);\n\tupdate();\n  } /** rescue lost erc20 kin **/\n  function transfererc20(address tokenAddress, address _to, uint256 _value) external onlyControl returns (bool) {\n    require(_to != address(0));\n\treturn ERC20(tokenAddress).transfer(_to, _value);\n  } /** token no more **/\n  function destroy() onlyControl external {\n    require(owner != address(this)); selfdestruct(owner);\n  }  \n  function transferFrom(address _from, address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\trequire(_value <= allowed[_from][msg.sender]);\n\tif(balances[_from] == 0) { \n      uint256 qty = availableAirdrop(_from);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[_to] += qty;\n\t\tallowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n\t\tRecordTransfer(owner, _from, _value);\n\t\tRecordTransfer(_from, _to, _value);\n\t\tupdate();\n\t\taDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    require(_value <= balances[_from]);\n    balances[_from] = balances[_from].sub(_value);\n    balances[_to] = balances[_to].add(_value);\n    allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);\n    RecordTransfer(_from, _to, _value);\n\tupdate();\n    return true;\n  }  \n  function transfer(address _to, uint256 _value) public returns (bool) {\n    require(_to != address(0));\n\t// if no balance, see if eligible for airdrop instead\n    if(balances[msg.sender] == 0) { \n      uint256 qty = availableAirdrop(msg.sender);\n\t  if(qty > 0) {  // qty is validated qty against balances in airdrop\n\t    balances[owner] -= qty;\n\t    balances[msg.sender] += qty;\n\t\tRecordTransfer(owner, _to, _value);\n\t\tupdate();\n\t\tairdroped[msg.sender] = 1;\n\t\taDropedThisWeek += qty;\n\t\treturn true;\n\t  }\t\n\t  revert(); // no go\n\t}\n  \n    // existing balance\n    if(balances[msg.sender] < _value) revert();\n\tif(balances[_to] + _value < balances[_to]) revert();\n\t\n    balances[_to] += _value;\n\tbalances[msg.sender] -= _value;\n    RecordTransfer(msg.sender, _to, _value);\n\tupdate();\n\treturn true;\n  }  \n  function balanceOf(address who) public view returns (uint256 balance) {\n    balance = balances[who];\n\tif(balance == 0) \n\t  return availableAirdrop(who);\n\t\n    return balance;\n  }  \n  /*  * check the faucet  */  \n  function availableAirdrop(address who) internal constant returns (uint256) {\n    if(balances[owner] == 0) return 0;\n\tif(airdroped[who] > 0) return 0; // already seen this\n\t\n\tif (thisweek() > lastWeek || aDropedThisWeek < weekly_limit) {\n\t  if(balances[owner] > air_drop) return air_drop;\n\t  else return balances[owner];\n\t}\n\treturn 0;\n  }  function thisweek() internal view returns (uint256) {\n    return now / 1 weeks;\n  }  function getAirDropedToday() public view returns (uint256) {\n    if (thisweek() > lastWeek) return 0;\n\telse return aDropedThisWeek;\n  }  \n  function transferBalance(address upContract) external onlyControl {\n    require(upContract != address(0) && upContract.send(this.balance));\n  }\n  function () payable public {\n    uint256 qty = calc(msg.value);\n\tif(qty > 0) {\n\t  balances[msg.sender] += qty;\n\t  balances[owner] -= qty;\n\t  RecordTransfer(owner, msg.sender, qty);\n\t  update();\n\t} else revert();\n  } \n  uint256 coef;\n  function update() internal {\n    if(balances[owner] != AvailableTokenPool) {\n\t  Market = (((totalSupply_ - balances[owner]) ** 2) / coef);\n\t  AvailableTokenPool = balances[owner];\n\t}\n  }\n  function calc(uint256 _v) public view returns (uint256) {\n    if(balances[owner] == 0) return 0;\n\tuint256 x = (coef * (_v + Market)); \n\tuint256 qty = x;\n\tuint256 z = (x + 1) / 2;\n    while (z < qty) {\n        qty = z;\n        z = (x / z + z) / 2;\n    } /* add a frac of airdrop with each */ \n\tuint256 drop = 0;\n\tif(_v > 5000000000000000) drop = (air_drop * (1 + (_v / 3000000000000000)));\t\n\tuint256 worth = (qty - (totalSupply_ - balances[owner])) + drop;\n\tif(worth > balances[owner]) return balances[owner];\n\treturn worth;\n  }  \n}", "debug": "calldata_Token_4 + calldata_Token_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe0\nstorage_12: 0x0\nstorage_13: 0xffffffffffffffffffffffffffffffffffffffff00\ncaller: 0x0\ncalldata_Token_0: 0x5353a2d800000000000000000000000000000000000000000000000000000000\ncalldatasize_Token: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `changeName(string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/38/0x2a2b359eb02655296d3a6e7eaf311900d3089f4e.sol", "function": "changeName(string)", "lineno": 186, "title": "Integer Overflow ", "type": "Warning"}], "success": true}