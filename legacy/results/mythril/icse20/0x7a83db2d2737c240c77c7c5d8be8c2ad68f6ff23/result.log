{"error": null, "issues": [{"address": 432, "code": "\n        uint newTota", "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffe3cd3f787e00400000\ncalldatasize_UselessReserveBank: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "fallback", "lineno": 279, "title": "Integer Overflow ", "type": "Warning"}, {"address": 508, "code": "nt ethers, uint newEtherBalanc", "debug": "storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffe3cd3f787e00400000\ncalldatasize_UselessReserveBank: 0x3\n", "description": "A possible integer overflow exists in the function `fallback`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "fallback", "lineno": 280, "title": "Integer Overflow ", "type": "Warning"}, {"address": 1544, "code": "\n\n    function currentTokenBalance() constant returns (uint) {\n        return totalSupply;\n    }\n\n    function numbe", "debug": "calldata_UselessReserveBank_4: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffc\ncalldata_UselessReserveBank_0: 0x44af1f4b00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `replaceOfficials(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "replaceOfficials(address[])", "lineno": 411, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3366, "code": "alance);\n\n\n    // -----", "debug": "storage_8: 0xa8723c77fffffffffffffffffffffffffffffffffffffffffffffffffffffffe\ncalldata_UselessReserveBank_4: 0x57f03cc000000000000000000000000000000000000000000000000000000000\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x57f03cbfffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_3: 0x0\ncaller: 0x0\ncalldata_UselessReserveBank_0: 0x143a1a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `pilfer(uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "pilfer(uint256)", "lineno": 383, "title": "Integer Overflow ", "type": "Warning"}, {"address": 3486, "code": "/ -------------------------------", "debug": "The exception is triggered under the following conditions:\n\nbalance_at_1461501637330902918203684832716283019655932542975 & 0: 0x0\ncalldata_UselessReserveBank_4: 0x1\nstorage_3: 0x0\ncaller: 0x0\ncalldata_UselessReserveBank_0: 0x143a1a2f00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\nstorage_5: 0x0\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "pilfer(uint256)", "lineno": 388, "title": "Exception state", "type": "Informational"}, {"address": 3613, "code": "s tokenAddress) \n      onlyGubberment returns (b", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 3613\nCall at address: 3613\n", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "pilfer(uint256)", "lineno": 389, "title": "Multiple Calls", "type": "Information"}, {"address": 3613, "code": "s tokenAddress) \n      onlyGubberment returns (b", "debug": "", "description": "A possible transaction order independence vulnerability exists in function pilfer(uint256). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "pilfer(uint256)", "lineno": 389, "title": "Transaction order dependence", "type": "Warning"}, {"address": 4011, "code": "t);\n            return ", "debug": "calldata_UselessReserveBank_32 + 36: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_UselessReserveBank_32_+_4: 0x800000000000000000008eb2e34648ee0801030820000000000000000000a000\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_UselessReserveBank_4: 0x800000000000000003ffd0badcb9b7000000002781000000000000000006bfff\ncalldata_UselessReserveBank_0: 0x23b872dd00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `transferFrom(address,address,uint256)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "transferFrom(address,address,uint256)", "lineno": 216, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4485, "code": "-------------------------", "debug": "storage_7: 0xb2c81e3be60b809eebca250ae5f3958de8241f3c0942692d3cecd1fd00743211\ncallvalue: 0x93931c13e507cbbcbf74d9eee4fb920eeaef84aa5110428da2eddb017d5ebcdd\ncalldata_UselessReserveBank_0: 0x37d0208c00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\n", "description": "A possible integer overflow exists in the function `bribe()`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "bribe()", "lineno": 366, "title": "Integer Overflow ", "type": "Warning"}, {"address": 4572, "code": " necessity\n    // ------------------", "debug": "The exception is triggered under the following conditions:\n\ncallvalue: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UselessReserveBank_0: 0x37d0208c00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\nstorage_5: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "bribe()", "lineno": 367, "title": "Exception state", "type": "Informational"}, {"address": 4699, "code": "t amount) onlyGubberment {\n        // Cannot pi", "debug": "", "description": "Multiple sends exist in one transaction, try to isolate each external call into its own transaction. As external calls can fail accidentally or deliberately.\nConsecutive calls: \nCall at address: 4699\n", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "bribe()", "lineno": 369, "title": "Multiple Calls", "type": "Information"}, {"address": 4699, "code": "t amount) onlyGubberment {\n        // Cannot pi", "debug": "", "description": "A possible transaction order independence vulnerability exists in function bribe(). The value or direction of the call statement is determined from a tainted storage location", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "bribe()", "lineno": 369, "title": "Transaction order dependence", "type": "Warning"}, {"address": 4909, "code": "100));\n\n        // Log messag", "debug": "calldata_UselessReserveBank_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_2: 0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffe\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_UselessReserveBank_0: 0x415f124000000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer underflow exists in the function `liquidate(uint256)`.\nThe subtraction may result in a value < 0.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "liquidate(uint256)", "lineno": 332, "title": "Integer Underflow", "type": "Warning"}, {"address": 5460, "code": "ING_BLOCK = 3999998; \n\n    functio", "debug": "The exception is triggered under the following conditions:\n\ncalldata_UselessReserveBank_4: 0x0\nstorage_5: 0x0\ncalldata_UselessReserveBank_0: 0x652f649400000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "_function_0x652f6494", "lineno": 261, "title": "Exception state", "type": "Informational"}, {"address": 8153, "code": "--\n    string public constant symbol = \"URB\";\n    string public constant name = \"Useless Reserve Bank\";\n    uint8 public constant decimals = 18;\n    \n    uint public constant WELFARE_HANDOUT = 1000;\n    uint public constant ONEPERCENT_TOKENS_PER_ETH = 100000;\n    uint public constant LIQUIDATION_TOKENS_PER_ETH = 30000;\n\n    address[] public treasuryOfficials;\n    uint public constant TAXRATE = 20;\n    uint public constant LIQUIDATION_RESERVE_RATIO = 75;\n\n    uint public totalTaxed;\n    uint public totalBribery;\n    uint public totalPilfered;\n\n    uint public constant SENDING_BLOCK = 3999998; \n\n    function UselessReserveBank() {\n        treasuryOfficials.push(0xDe18789c4d65DC8ecE671A4145F32F1590c4D802);\n        treasuryOfficials.push(0x8899822D031891371afC369767511164Ef21e55c);\n    }\n\n    // ------------------------------------------------------------------------\n    // Just give the welfare handouts\n    // ------------------------------------------------------------------------\n    function () payable {\n        uint tokens = WELFARE_HANDOUT * 1 ether;\n        totalSupply += tokens;\n        balances[msg.sender] += tokens;\n        WelfareHandout(msg.sender, tokens, totalSupply, msg.value, \n            this.balance);\n        Transfer(0x0, msg.sender, tokens);\n    }\n    event WelfareHandout(address indexed recipient, uint tokens, \n        uint newTotalSupply, uint ethers, uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // If you consider yourself rich, donate for world peace\n    // ------------------------------------------------------------------------\n    function philanthropise(string name) payable {\n        // Sending something real?\n        require(msg.value > 0);\n\n        // Calculate the number of tokens\n        uint tokens = msg.value * ONEPERCENT_TOKENS_PER_ETH;\n\n        // Assign tokens to account and inflate total supply\n        balances[msg.sender] += tokens;\n        totalSupply += tokens;\n\n        // Calculate and forward taxes to the treasury\n        uint taxAmount = msg.value * TAXRATE / 100;\n        if (taxAmount > 0) {\n            totalTaxed += taxAmount;\n            uint taxPerOfficial = taxAmount / treasuryOfficials.length;\n            for (uint i = 0; i < treasuryOfficials.length; i++) {\n                treasuryOfficials[i].transfer(taxPerOfficial);\n            }\n        }\n\n        Philanthropy(msg.sender, name, tokens, totalSupply, msg.value, \n            this.balance, totalTaxed);\n        Transfer(0x0, msg.sender, tokens);\n    }\n    event Philanthropy(address indexed buyer, string name, uint tokens, \n        uint newTotalSupply, uint ethers, uint newEtherBalance,\n        uint totalTaxed);\n\n\n    // ------------------------------------------------------------------------\n    // Liquidate your tokens for ETH, if this contract has sufficient ETH\n    // ------------------------------------------------------------------------\n    function liquidate(uint amountOfTokens) {\n        // Account must have sufficient tokens\n        require(amountOfTokens <= balances[msg.sender]);\n\n        // Burn tokens\n        balances[msg.sender] -= amountOfTokens;\n        totalSupply -= amountOfTokens;\n\n        // Calculate ETH to exchange\n        uint ethersToSend = amountOfTokens / LIQUIDATION_TOKENS_PER_ETH;\n\n        // Is there sufficient ETH to support this liquidation?\n        require(ethersToSend > 0 && \n            ethersToSend <= (this.balance * (100 - LIQUIDATION_RESERVE_RATIO) / 100));\n\n        // Log message\n        Liquidate(msg.sender, amountOfTokens, totalSupply, \n            ethersToSend, this.balance - ethersToSend);\n        Transfer(msg.sender, 0x0, amountOfTokens);\n\n        // Send ETH\n        msg.sender.transfer(ethersToSend);\n    }\n    event Liquidate(address indexed seller, \n        uint tokens, uint newTotalSupply, \n        uint ethers, uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // Gubberment officials will accept 100% of bribes\n    // ------------------------------------------------------------------------\n    function bribe() payable {\n        // Briber must be offering something real\n        require(msg.value > 0);\n\n        // Do we really need to keep track of the total bribes?\n        totalBribery += msg.value;\n        Bribed(msg.value, totalBribery);\n\n        uint bribePerOfficial = msg.value / treasuryOfficials.length;\n        for (uint i = 0; i < treasuryOfficials.length; i++) {\n            treasuryOfficials[i].transfer(bribePerOfficial);\n        }\n    }\n    event Bribed(uint amount, uint newTotalBribery);\n\n\n    // ------------------------------------------------------------------------\n    // Gubberment officials can pilfer out of necessity\n    // ------------------------------------------------------------------------\n    function pilfer(uint amount) onlyGubberment {\n        // Cannot pilfer more than the contract balance\n        require(amount > this.balance);\n\n        // Do we really need to keep track of the total pilfered amounts?\n        totalPilfered += amount;\n        Pilfered(amount, totalPilfered, this.balance - amount);\n\n        uint amountPerOfficial = amount / treasuryOfficials.length;\n        for (uint i = 0; i < treasuryOfficials.length; i++) {\n            treasuryOfficials[i].transfer(amountPerOfficial);\n        }\n    }\n    event Pilfered(uint amount, uint totalPilfered, \n        uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // Accept any ERC20 gifts\n    // ------------------------------------------------------------------------\n    function acceptGiftTokens(address tokenAddress) \n      onlyGubberment returns (bool success) \n    {\n        ERC20Token token = ERC20Token(tokenAddress);\n        uint amount = token.balanceOf(this);\n        return token.transfer(gubberment, amount);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Change gubberment officials\n    // ------------------------------------------------------------------------\n    function replaceOfficials(address[] newOfficials) onlyGubberment {\n        treasuryOfficials = newOfficials;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Information function\n    // ------------------------------------------------------------------------\n    function currentEtherBalance() constant returns (uint) {\n        return this.balance;\n    }\n\n    function currentTokenBalance() constant returns (uint) {\n        return totalSupply;\n    }\n\n    function numberOfTreasuryOfficials() constant returns (uint) {\n        return treasuryOfficials.length;\n    }\n}", "debug": "storage_5: 0xfe7bacf80e010c763a9f40015377a80000fb3ffd9e00c011fff0003f07fce340\nstorage_3: 0x0\ncaller: 0x0\ncalldata_UselessReserveBank_0: 0x44af1f4b00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `replaceOfficials(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "replaceOfficials(address[])", "lineno": 244, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8164, "code": "--\n    string public constant symbol = \"URB\";\n    string public constant name = \"Useless Reserve Bank\";\n    uint8 public constant decimals = 18;\n    \n    uint public constant WELFARE_HANDOUT = 1000;\n    uint public constant ONEPERCENT_TOKENS_PER_ETH = 100000;\n    uint public constant LIQUIDATION_TOKENS_PER_ETH = 30000;\n\n    address[] public treasuryOfficials;\n    uint public constant TAXRATE = 20;\n    uint public constant LIQUIDATION_RESERVE_RATIO = 75;\n\n    uint public totalTaxed;\n    uint public totalBribery;\n    uint public totalPilfered;\n\n    uint public constant SENDING_BLOCK = 3999998; \n\n    function UselessReserveBank() {\n        treasuryOfficials.push(0xDe18789c4d65DC8ecE671A4145F32F1590c4D802);\n        treasuryOfficials.push(0x8899822D031891371afC369767511164Ef21e55c);\n    }\n\n    // ------------------------------------------------------------------------\n    // Just give the welfare handouts\n    // ------------------------------------------------------------------------\n    function () payable {\n        uint tokens = WELFARE_HANDOUT * 1 ether;\n        totalSupply += tokens;\n        balances[msg.sender] += tokens;\n        WelfareHandout(msg.sender, tokens, totalSupply, msg.value, \n            this.balance);\n        Transfer(0x0, msg.sender, tokens);\n    }\n    event WelfareHandout(address indexed recipient, uint tokens, \n        uint newTotalSupply, uint ethers, uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // If you consider yourself rich, donate for world peace\n    // ------------------------------------------------------------------------\n    function philanthropise(string name) payable {\n        // Sending something real?\n        require(msg.value > 0);\n\n        // Calculate the number of tokens\n        uint tokens = msg.value * ONEPERCENT_TOKENS_PER_ETH;\n\n        // Assign tokens to account and inflate total supply\n        balances[msg.sender] += tokens;\n        totalSupply += tokens;\n\n        // Calculate and forward taxes to the treasury\n        uint taxAmount = msg.value * TAXRATE / 100;\n        if (taxAmount > 0) {\n            totalTaxed += taxAmount;\n            uint taxPerOfficial = taxAmount / treasuryOfficials.length;\n            for (uint i = 0; i < treasuryOfficials.length; i++) {\n                treasuryOfficials[i].transfer(taxPerOfficial);\n            }\n        }\n\n        Philanthropy(msg.sender, name, tokens, totalSupply, msg.value, \n            this.balance, totalTaxed);\n        Transfer(0x0, msg.sender, tokens);\n    }\n    event Philanthropy(address indexed buyer, string name, uint tokens, \n        uint newTotalSupply, uint ethers, uint newEtherBalance,\n        uint totalTaxed);\n\n\n    // ------------------------------------------------------------------------\n    // Liquidate your tokens for ETH, if this contract has sufficient ETH\n    // ------------------------------------------------------------------------\n    function liquidate(uint amountOfTokens) {\n        // Account must have sufficient tokens\n        require(amountOfTokens <= balances[msg.sender]);\n\n        // Burn tokens\n        balances[msg.sender] -= amountOfTokens;\n        totalSupply -= amountOfTokens;\n\n        // Calculate ETH to exchange\n        uint ethersToSend = amountOfTokens / LIQUIDATION_TOKENS_PER_ETH;\n\n        // Is there sufficient ETH to support this liquidation?\n        require(ethersToSend > 0 && \n            ethersToSend <= (this.balance * (100 - LIQUIDATION_RESERVE_RATIO) / 100));\n\n        // Log message\n        Liquidate(msg.sender, amountOfTokens, totalSupply, \n            ethersToSend, this.balance - ethersToSend);\n        Transfer(msg.sender, 0x0, amountOfTokens);\n\n        // Send ETH\n        msg.sender.transfer(ethersToSend);\n    }\n    event Liquidate(address indexed seller, \n        uint tokens, uint newTotalSupply, \n        uint ethers, uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // Gubberment officials will accept 100% of bribes\n    // ------------------------------------------------------------------------\n    function bribe() payable {\n        // Briber must be offering something real\n        require(msg.value > 0);\n\n        // Do we really need to keep track of the total bribes?\n        totalBribery += msg.value;\n        Bribed(msg.value, totalBribery);\n\n        uint bribePerOfficial = msg.value / treasuryOfficials.length;\n        for (uint i = 0; i < treasuryOfficials.length; i++) {\n            treasuryOfficials[i].transfer(bribePerOfficial);\n        }\n    }\n    event Bribed(uint amount, uint newTotalBribery);\n\n\n    // ------------------------------------------------------------------------\n    // Gubberment officials can pilfer out of necessity\n    // ------------------------------------------------------------------------\n    function pilfer(uint amount) onlyGubberment {\n        // Cannot pilfer more than the contract balance\n        require(amount > this.balance);\n\n        // Do we really need to keep track of the total pilfered amounts?\n        totalPilfered += amount;\n        Pilfered(amount, totalPilfered, this.balance - amount);\n\n        uint amountPerOfficial = amount / treasuryOfficials.length;\n        for (uint i = 0; i < treasuryOfficials.length; i++) {\n            treasuryOfficials[i].transfer(amountPerOfficial);\n        }\n    }\n    event Pilfered(uint amount, uint totalPilfered, \n        uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // Accept any ERC20 gifts\n    // ------------------------------------------------------------------------\n    function acceptGiftTokens(address tokenAddress) \n      onlyGubberment returns (bool success) \n    {\n        ERC20Token token = ERC20Token(tokenAddress);\n        uint amount = token.balanceOf(this);\n        return token.transfer(gubberment, amount);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Change gubberment officials\n    // ------------------------------------------------------------------------\n    function replaceOfficials(address[] newOfficials) onlyGubberment {\n        treasuryOfficials = newOfficials;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Information function\n    // ------------------------------------------------------------------------\n    function currentEtherBalance() constant returns (uint) {\n        return this.balance;\n    }\n\n    function currentTokenBalance() constant returns (uint) {\n        return totalSupply;\n    }\n\n    function numberOfTreasuryOfficials() constant returns (uint) {\n        return treasuryOfficials.length;\n    }\n}", "debug": "calldata_UselessReserveBank_4 + calldata_UselessReserveBank_4: 0x8421003f084001f4210815cf88407c00000000000000037c1d000e8d178001f\nstorage_3: 0x0\ncaller: 0x0\ncalldata_UselessReserveBank_0: 0x44af1f4b00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `replaceOfficials(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "replaceOfficials(address[])", "lineno": 244, "title": "Integer Overflow ", "type": "Warning"}, {"address": 8166, "code": "--\n    string public constant symbol = \"URB\";\n    string public constant name = \"Useless Reserve Bank\";\n    uint8 public constant decimals = 18;\n    \n    uint public constant WELFARE_HANDOUT = 1000;\n    uint public constant ONEPERCENT_TOKENS_PER_ETH = 100000;\n    uint public constant LIQUIDATION_TOKENS_PER_ETH = 30000;\n\n    address[] public treasuryOfficials;\n    uint public constant TAXRATE = 20;\n    uint public constant LIQUIDATION_RESERVE_RATIO = 75;\n\n    uint public totalTaxed;\n    uint public totalBribery;\n    uint public totalPilfered;\n\n    uint public constant SENDING_BLOCK = 3999998; \n\n    function UselessReserveBank() {\n        treasuryOfficials.push(0xDe18789c4d65DC8ecE671A4145F32F1590c4D802);\n        treasuryOfficials.push(0x8899822D031891371afC369767511164Ef21e55c);\n    }\n\n    // ------------------------------------------------------------------------\n    // Just give the welfare handouts\n    // ------------------------------------------------------------------------\n    function () payable {\n        uint tokens = WELFARE_HANDOUT * 1 ether;\n        totalSupply += tokens;\n        balances[msg.sender] += tokens;\n        WelfareHandout(msg.sender, tokens, totalSupply, msg.value, \n            this.balance);\n        Transfer(0x0, msg.sender, tokens);\n    }\n    event WelfareHandout(address indexed recipient, uint tokens, \n        uint newTotalSupply, uint ethers, uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // If you consider yourself rich, donate for world peace\n    // ------------------------------------------------------------------------\n    function philanthropise(string name) payable {\n        // Sending something real?\n        require(msg.value > 0);\n\n        // Calculate the number of tokens\n        uint tokens = msg.value * ONEPERCENT_TOKENS_PER_ETH;\n\n        // Assign tokens to account and inflate total supply\n        balances[msg.sender] += tokens;\n        totalSupply += tokens;\n\n        // Calculate and forward taxes to the treasury\n        uint taxAmount = msg.value * TAXRATE / 100;\n        if (taxAmount > 0) {\n            totalTaxed += taxAmount;\n            uint taxPerOfficial = taxAmount / treasuryOfficials.length;\n            for (uint i = 0; i < treasuryOfficials.length; i++) {\n                treasuryOfficials[i].transfer(taxPerOfficial);\n            }\n        }\n\n        Philanthropy(msg.sender, name, tokens, totalSupply, msg.value, \n            this.balance, totalTaxed);\n        Transfer(0x0, msg.sender, tokens);\n    }\n    event Philanthropy(address indexed buyer, string name, uint tokens, \n        uint newTotalSupply, uint ethers, uint newEtherBalance,\n        uint totalTaxed);\n\n\n    // ------------------------------------------------------------------------\n    // Liquidate your tokens for ETH, if this contract has sufficient ETH\n    // ------------------------------------------------------------------------\n    function liquidate(uint amountOfTokens) {\n        // Account must have sufficient tokens\n        require(amountOfTokens <= balances[msg.sender]);\n\n        // Burn tokens\n        balances[msg.sender] -= amountOfTokens;\n        totalSupply -= amountOfTokens;\n\n        // Calculate ETH to exchange\n        uint ethersToSend = amountOfTokens / LIQUIDATION_TOKENS_PER_ETH;\n\n        // Is there sufficient ETH to support this liquidation?\n        require(ethersToSend > 0 && \n            ethersToSend <= (this.balance * (100 - LIQUIDATION_RESERVE_RATIO) / 100));\n\n        // Log message\n        Liquidate(msg.sender, amountOfTokens, totalSupply, \n            ethersToSend, this.balance - ethersToSend);\n        Transfer(msg.sender, 0x0, amountOfTokens);\n\n        // Send ETH\n        msg.sender.transfer(ethersToSend);\n    }\n    event Liquidate(address indexed seller, \n        uint tokens, uint newTotalSupply, \n        uint ethers, uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // Gubberment officials will accept 100% of bribes\n    // ------------------------------------------------------------------------\n    function bribe() payable {\n        // Briber must be offering something real\n        require(msg.value > 0);\n\n        // Do we really need to keep track of the total bribes?\n        totalBribery += msg.value;\n        Bribed(msg.value, totalBribery);\n\n        uint bribePerOfficial = msg.value / treasuryOfficials.length;\n        for (uint i = 0; i < treasuryOfficials.length; i++) {\n            treasuryOfficials[i].transfer(bribePerOfficial);\n        }\n    }\n    event Bribed(uint amount, uint newTotalBribery);\n\n\n    // ------------------------------------------------------------------------\n    // Gubberment officials can pilfer out of necessity\n    // ------------------------------------------------------------------------\n    function pilfer(uint amount) onlyGubberment {\n        // Cannot pilfer more than the contract balance\n        require(amount > this.balance);\n\n        // Do we really need to keep track of the total pilfered amounts?\n        totalPilfered += amount;\n        Pilfered(amount, totalPilfered, this.balance - amount);\n\n        uint amountPerOfficial = amount / treasuryOfficials.length;\n        for (uint i = 0; i < treasuryOfficials.length; i++) {\n            treasuryOfficials[i].transfer(amountPerOfficial);\n        }\n    }\n    event Pilfered(uint amount, uint totalPilfered, \n        uint newEtherBalance);\n\n\n    // ------------------------------------------------------------------------\n    // Accept any ERC20 gifts\n    // ------------------------------------------------------------------------\n    function acceptGiftTokens(address tokenAddress) \n      onlyGubberment returns (bool success) \n    {\n        ERC20Token token = ERC20Token(tokenAddress);\n        uint amount = token.balanceOf(this);\n        return token.transfer(gubberment, amount);\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Change gubberment officials\n    // ------------------------------------------------------------------------\n    function replaceOfficials(address[] newOfficials) onlyGubberment {\n        treasuryOfficials = newOfficials;\n    }\n\n\n    // ------------------------------------------------------------------------\n    // Information function\n    // ------------------------------------------------------------------------\n    function currentEtherBalance() constant returns (uint) {\n        return this.balance;\n    }\n\n    function currentTokenBalance() constant returns (uint) {\n        return totalSupply;\n    }\n\n    function numberOfTreasuryOfficials() constant returns (uint) {\n        return treasuryOfficials.length;\n    }\n}", "debug": "calldata_UselessReserveBank_4 + calldata_UselessReserveBank_4: 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffb\nstorage_3: 0x0\ncaller: 0x0\ncalldata_UselessReserveBank_0: 0x44af1f4b00000000000000000000000000000000000000000000000000000000\ncalldatasize_UselessReserveBank: 0x4\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `replaceOfficials(address[])`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/14/0x7a83db2d2737c240c77c7c5d8be8c2ad68f6ff23.sol", "function": "replaceOfficials(address[])", "lineno": 244, "title": "Integer Overflow ", "type": "Warning"}], "success": true}