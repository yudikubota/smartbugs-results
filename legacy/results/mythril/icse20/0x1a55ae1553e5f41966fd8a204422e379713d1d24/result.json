{
  "contract": "0x1a55ae1553e5f41966fd8a204422e379713d1d24",
  "tool": "mythril",
  "start": 1563820156.2324827,
  "end": 1563820455.0358603,
  "duration": 298.8033776283264,
  "analysis": {
    "error": null,
    "issues": [
      {
        "address": 4136,
        "code": ";\n\ncontract MultiO",
        "debug": "storage_2: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x7065cb4800000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `addOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/31/0x1a55ae1553e5f41966fd8a204422e379713d1d24.sol",
        "function": "addOwner(address)",
        "lineno": 1,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8009,
        "code": "sactionHash);\n\tevent Confirmation(address sender, bytes32 transactionHash);\n\tevent Execution(bytes32 transactionHash);\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\t\n\tstring public name;\n\tstring public symbol;\n\tuint8 public decimals;\n\tuint256 public totalSupply;\n\tuint256 public EthPerToken = 300;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction VVToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tdecimals = decimalUnits;\t\t\t\t// Amount of decimals for display purposes \n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);\n\t\tbalanceOf[msg.sender] = totalSupply; \t\t\t// Give the creator all initial tokens                    \n\t\tname = tokenName; \t\t\t\t\t\t// Set the name for display purposes     \n\t\tsymbol = tokenSymbol; \t\t\t\t\t// Set the symbol for display purposes    \n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] > _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n    \n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable {\n\t\trevert();\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = sha3(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction kill() onlyOwner() private {\n        selfdestruct(msg.sender);\n    }\n}",
        "debug": "storage_2: 0xdf803800e003cc0f00000c6019e000033c30000e003e6666000000000c006539\ncalldata_VVToken_4: 0x0\nstorage_29102676481673041902632991033461445430619272659676223336789171408008386403022: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/31/0x1a55ae1553e5f41966fd8a204422e379713d1d24.sol",
        "function": "removeOwner(address)",
        "lineno": 71,
        "title": "Integer Overflow ",
        "type": "Warning"
      },
      {
        "address": 8011,
        "code": "sactionHash);\n\tevent Confirmation(address sender, bytes32 transactionHash);\n\tevent Execution(bytes32 transactionHash);\n\tevent FrozenFunds(address target, bool frozen);\n\tevent Transfer(address indexed from, address indexed to, uint256 value);\n\t\n\tstring public name;\n\tstring public symbol;\n\tuint8 public decimals;\n\tuint256 public totalSupply;\n\tuint256 public EthPerToken = 300;\n\t\n\tmapping(address => uint256) public balanceOf;\n\tmapping(address => bool) public frozenAccount;\n\tmapping (bytes32 => mapping (address => bool)) public Confirmations;\n\tmapping (bytes32 => Transaction) public Transactions;\n\t\n\tstruct Transaction {\n\t\taddress destination;\n\t\tuint value;\n\t\tbytes data;\n\t\tbool executed;\n    }\n\t\n\tmodifier notNull(address destination) {\n\t\trequire (destination != 0x0);\n        _;\n    }\n\t\n\tmodifier confirmed(bytes32 transactionHash) {\n\t\trequire (Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\n    modifier notConfirmed(bytes32 transactionHash) {\n\t\trequire (!Confirmations[transactionHash][msg.sender]);\n        _;\n    }\n\t\n\tmodifier notExecuted(bytes32 TransHash) {\n\t\trequire (!Transactions[TransHash].executed);\n        _;\n    }\n    \n\tfunction VVToken(uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol, address[] _owners, uint256 _required) MultiOwner(_owners, _required) public {\n\t\tdecimals = decimalUnits;\t\t\t\t// Amount of decimals for display purposes \n\t\ttotalSupply = initialSupply * 10 ** uint256(decimals);\n\t\tbalanceOf[msg.sender] = totalSupply; \t\t\t// Give the creator all initial tokens                    \n\t\tname = tokenName; \t\t\t\t\t\t// Set the name for display purposes     \n\t\tsymbol = tokenSymbol; \t\t\t\t\t// Set the symbol for display purposes    \n    }\n\t\n\t/* Internal transfer, only can be called by this contract */\n    function _transfer(address _from, address _to, uint256 _value) internal {\n        require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead\n        require (balanceOf[_from] > _value);                // Check if the sender has enough\n        require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows\n        require(!frozenAccount[_from]);                     // Check if sender is frozen\n\t\tuint256 previousBalances = balanceOf[_from] + balanceOf[_to];\n        balanceOf[_from] -= _value;                         // Subtract from the sender\n        balanceOf[_to] += _value;                           // Add the same to the recipient\n        Transfer(_from, _to, _value);\n\t\tassert(balanceOf[_from] + balanceOf[_to] == previousBalances);\n    }\n\t\n\tfunction transfer(address _to, uint256 _value) public {\n\t\t_transfer(msg.sender, _to, _value);\n\t}\n\t\n\tfunction setPrices(uint256 newValue) onlyOwner public {\n        EthPerToken = newValue;\n    }\n    \n    function freezeAccount(address target, bool freeze) onlyOwner public {\n        frozenAccount[target] = freeze;\n        FrozenFunds(target, freeze);\n    }\n\t\n\tfunction() payable {\n\t\trevert();\n    }\n\t\n\tfunction remainBalanced() public constant returns (uint256){\n        return balanceOf[this];\n    }\n\t\n\t/*Transfer Eth */\n\tfunction execute(address _to, uint _value, bytes _data) notNull(_to) onlyOwner external returns (bytes32 _r) {\n\t\t_r = addTransaction(_to, _value, _data);\n\t\tconfirmTransaction(_r);\n    }\n\t\n\tfunction addTransaction(address destination, uint value, bytes data) private notNull(destination) returns (bytes32 TransHash){\n        TransHash = sha3(destination, value, data);\n        if (Transactions[TransHash].destination == 0) {\n            Transactions[TransHash] = Transaction({\n                destination: destination,\n                value: value,\n                data: data,\n                executed: false\n            });\n            SubmitTransaction(TransHash);\n        }\n    }\n\t\n\tfunction addConfirmation(bytes32 TransHash) private onlyOwner notConfirmed(TransHash){\n        Confirmations[TransHash][msg.sender] = true;\n        Confirmation(msg.sender, TransHash);\n    }\n\t\n\tfunction isConfirmed(bytes32 TransHash) public constant returns (bool){\n        uint count = 0;\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n            if (count == ownerRequired)\n                return true;\n    }\n\t\n\tfunction confirmationCount(bytes32 TransHash) external constant returns (uint count){\n        for (uint i=0; i<owners.length; i++)\n            if (Confirmations[TransHash][owners[i]])\n                count += 1;\n    }\n    \n    function confirmTransaction(bytes32 TransHash) public onlyOwner(){\n        addConfirmation(TransHash);\n        executeTransaction(TransHash);\n    }\n    \n    function executeTransaction(bytes32 TransHash) public notExecuted(TransHash){\n        if (isConfirmed(TransHash)) {\n\t\t\tTransactions[TransHash].executed = true;\n            require(Transactions[TransHash].destination.call.value(Transactions[TransHash].value)(Transactions[TransHash].data));\n            Execution(TransHash);\n        }\n    }\n\t\n\tfunction kill() onlyOwner() private {\n        selfdestruct(msg.sender);\n    }\n}",
        "debug": "storage_2: 0xc00000000000000000007e00101ffe01fffe1e0e3fff2f000000000000000000\ncalldata_VVToken_4: 0x0\nstorage_29102676481673041902632991033461445430619272659676223336789171408008386403022: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_VVToken_4: 0xff00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0xff00\ncalldata_VVToken_0: 0x173825d900000000000000000000000000000000000000000000000000000000\ncalldatasize_VVToken: 0x4\ncallvalue: 0x0\n",
        "description": "A possible integer overflow exists in the function `removeOwner(address)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.",
        "filename": "/unique_chucks/31/0x1a55ae1553e5f41966fd8a204422e379713d1d24.sol",
        "function": "removeOwner(address)",
        "lineno": 71,
        "title": "Integer Overflow ",
        "type": "Warning"
      }
    ],
    "success": true
  }
}