{"error": null, "issues": [{"address": 2147, "code": "fers;\n    mapping(uint256 => mapping(ad", "debug": "The exception is triggered under the following conditions:\n\nstorage_3 + keccac_calldata_Pmes_4: 0x0\nstorage_2 + keccac_calldata_Pmes_4: 0x0\nstorage_1 + keccac_calldata_Pmes_4: 0x20\ncalldatasize_Pmes: 0x20000000000\nstorage_4 + keccac_calldata_Pmes_4: 0xfc00\ncalldata_Pmes_0: 0x8a72ea6a00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "_function_0x8a72ea6a", "lineno": 36, "title": "Exception state", "type": "Informational"}, {"address": 5460, "code": ";\n    }\n\n    function setDescription(uint256 c", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Pmes_4 + calldata_Pmes_32 + 36: 0x0\ncalldata_Pmes_32 + 36: 0x1\ncalldatasize_Pmes: 0x20000002000000000000000000000000000000000000000000000000000080\nstorage_4 +\nkeccac_storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Pmes_32_+_4: 0xfc00\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Pmes_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_0: 0x41309af400000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "addReview(uint256,address,string)", "lineno": 114, "title": "Exception state", "type": "Informational"}, {"address": 5500, "code": "\n\ncontract Pmes {\n", "debug": "calldata_Pmes_4 + calldata_Pmes_32 + 36: 0x0\nstorage_4 +\nkeccac_storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Pmes_32_+_4: 0x300\nstorage_keccac_calldata_Pmes_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_32 + 36: 0x1\ncalldatasize_Pmes: 0x80\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Pmes_32_+_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_0: 0x41309af400000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `addReview(uint256,address,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "addReview(uint256,address,string)", "lineno": 1, "title": "Integer Overflow ", "type": "Warning"}, {"address": 5630, "code": "idToOfferIds;\n    mapping(address => uint256[]) pu", "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_Pmes: 0x4000000000000000000000000000000000000000000000000000000000000040\ncalldata_Pmes_32 + 4: 0x0\nstorage_keccac_calldata_Pmes_4: 0x0\ncalldata_Pmes_0: 0x421e85c500000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "_function_0x421e85c5", "lineno": 39, "title": "Exception state", "type": "Informational"}, {"address": 6096, "code": "   \"Offer already exist\"\n        );\n\n        offers[nextOfferId] = Offer", "debug": "The exception is triggered under the following conditions:\n\ncalldata_Pmes_4: 0x8000000000000000000000000000000000000000000000000000000000000000\ncalldata_Pmes_4 + calldata_Pmes_32 + 100: 0x0\ncalldata_Pmes_32 + 100: 0x0\ncalldatasize_Pmes: 0x800fffffffff7fffffffffdffffffff007ffffffc00000002\nstorage_4 +\nkeccac_storage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncalldata_Pmes_32_+_4: 0xfc00\nstorage_1: 0x8000000000000000000000000000000000000000000000000000000000000001\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x2\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_0: 0x65d7241600000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "makeOffer(uint256,address,uint256,uint256,string)", "lineno": 172, "title": "Exception state", "type": "Informational"}, {"address": 9577, "code": "yerIdToOfferIds;\n\n    // Access level mapping [address", "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_Pmes: 0x4000000000000000000000000000000000000000000000000000000000000040\ncalldata_Pmes_32 + 4: 0x0\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\ncalldata_Pmes_4: 0x0\ncalldata_Pmes_0: 0xa4aa3f7000000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "_function_0xa4aa3f70", "lineno": 40, "title": "Exception state", "type": "Informational"}, {"address": 9625, "code": "6 => string[]) public reviews;\n    enum Off", "debug": "The exception is triggered under the following conditions:\n\ncalldatasize_Pmes: 0x4000000000000000000000000000000000000000000000000000000000000040\ncalldata_Pmes_32 + 4: 0x0\nstorage_keccac_calldata_Pmes_4: 0x0\ncalldata_Pmes_0: 0xa7264f8800000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A reachable exception (opcode 0xfe) has been detected. This can be caused by type errors, division by zero, out-of-bounds array access, or assert violations. This is acceptable in most situations. Note however that `assert()` should only be used to check invariants. Use `require()` for regular input checking. ", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "_function_0xa7264f88", "lineno": 15, "title": "Exception state", "type": "Informational"}, {"address": 11847, "code": "ntract Pmes {\n\n    address public owner;\n    uint256 public nextCid = 1;\n\n    struct Content {\n        string cus;\n        string description;\n        address owner;\n        uint256 readPrice;\n        uint256 writePrice;\n    }\n    mapping(uint256 => string[]) public reviews;\n    enum OfferStatus {Cancelled, Rejected, Opened, Accepted}\n    struct Offer {\n        uint256 id;\n        string buyerAccessString;\n        string sellerPublicKey;\n        string sellerAccessString;\n        OfferStatus status;\n        uint256 cid;\n        address buyerId;\n        uint256 offerType;\n        uint256 price;\n    }\n\n    mapping(uint256 => Content) public contents;\n    mapping(string => uint256)  CusToCid;\n    function getCid(string memory cus) public view returns (uint256) {\n        return CusToCid[cus];\n    }\n\n    uint256 public nextOfferId = 1;\n    mapping(uint256 => Offer) public offers;\n    mapping(uint256 => mapping(address => uint256)) public CidBuyerIdToOfferId;\n\n    mapping(uint256 => uint256[]) public CidToOfferIds;\n    mapping(address => uint256[]) public BuyerIdToOfferIds;\n\n    // Access level mapping [address]\n    // 0 - access denied\n    // 1 - can edit existing content\n    // 2 - can add content\n    // 3 - can saleAccess\n    // 4 - can changeOwner\n    // 5 - can setAccessLevel\n    mapping(address => uint256) public publishersMap;\n\n    event postContent(uint256); // makeCid\n    event postOffer(uint256, uint256, uint256, address); // makeOffer\n    event acceptOffer(uint256); // sellContent, changeOwner\n    event postReview(); // newReview\n\n    constructor() public\n    {\n        // to prevent repeated calls\n        require (owner == address(0x0));\n        // set owner address\n        owner = msg.sender;\n    }\n\n    function setAccessLevel(\n        address publisherAddress,\n        uint256 accessLevel\n    )\n        public\n        minAccessLevel(5)\n    {\n        publishersMap[publisherAddress] = accessLevel;\n    }\n\n    function makeCid(\n        string memory cus,\n        address ownerId,\n        string memory description,\n        uint256 readPrice,\n        uint256 writePrice\n    )\n        public\n        minAccessLevel(2)\n        returns (uint256)\n    {\n        // To prevent create already exist\n        uint256 cid = CusToCid[cus];\n        require(cid == 0, \"Content already uploaded\");\n\n        cid = nextCid++;\n        CusToCid[cus] = cid;\n\n        contents[cid] = Content(cus, description, ownerId, readPrice, writePrice);\n        emit postContent(cid);\n\n        return cid;\n    }\n\n    function setReadPrice(uint256 cid, uint256 price) public minAccessLevel(1) {\n        require(cid > 0 && cid < nextCid);\n        contents[cid].readPrice = price;\n    }\n\n    function setWritePrice(uint256 cid, uint256 price) public minAccessLevel(1) {\n        require(cid > 0 && cid < nextCid);\n        contents[cid].writePrice = price;\n    }\n\n    function addReview(uint256 cid, address buyerId, string memory review) public minAccessLevel(1) {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offerId != 0);\n        require(offers[offerId].status == OfferStatus.Accepted);\n\n        reviews[cid].push(review);\n        emit postReview();\n    }\n\n    function setDescription(uint256 cid, string memory description) public minAccessLevel(1) {\n        require(cid > 0 && cid < nextCid);\n        contents[cid].description = description;\n    }\n\n    function changeOwner(\n        uint256 cid,\n        address buyerId,\n        string memory sellerPublicKey,\n        string memory sellerAccessString\n    )\n        public\n        minAccessLevel(4)\n    {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        contents[cid].owner = buyerId;\n        offers[offerId].sellerAccessString = sellerAccessString;\n        offers[offerId].sellerPublicKey = sellerPublicKey;\n        offers[offerId].status = OfferStatus.Accepted;\n        emit acceptOffer(cid);\n    }\n\n    function sellContent(\n        uint256 cid,\n        address buyerId,\n        string memory sellerPublicKey,\n        string memory sellerAccessString\n    )\n        public\n        minAccessLevel(3)\n    {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        offers[offerId].sellerAccessString = sellerAccessString;\n        offers[offerId].sellerPublicKey = sellerPublicKey;\n        offers[offerId].status = OfferStatus.Accepted;\n        emit acceptOffer(cid);\n    }\n\n    function makeOffer(\n        uint256 cid,\n        address buyerId,\n        uint256 offerType,\n        uint256 price,\n        string memory buyerAccessString\n    )\n        public\n        minAccessLevel(2)\n    {\n        require(cid > 0 && cid < nextCid, \"Wrong cid\");\n        // require(CidBuyerIdToOfferId[cid][buyerId] == 0, \"\");\n        require(\n            offers[CidBuyerIdToOfferId[cid][buyerId]].status != OfferStatus.Accepted &&\n            offers[CidBuyerIdToOfferId[cid][buyerId]].status != OfferStatus.Opened,\n            \"Offer already exist\"\n        );\n\n        offers[nextOfferId] = Offer(\n            offers[CidBuyerIdToOfferId[cid][buyerId]].id + 1,\n            buyerAccessString, \n            \"none\", \n            \"none\", \n            OfferStatus.Opened, \n            cid, \n            buyerId, \n            offerType, \n            price\n        );\n\n        CidBuyerIdToOfferId[cid][buyerId] = nextOfferId;\n\n        CidToOfferIds[cid].push(nextOfferId);\n        BuyerIdToOfferIds[buyerId].push(nextOfferId);\n\n        emit postOffer(cid, offerType, price, buyerId);\n        \n        nextOfferId++;\n    }\n\n    function cancelOffer(uint256 cid, address buyerId) public minAccessLevel(2) {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        offers[offerId].status = OfferStatus.Cancelled;\n    }\n\n    function rejectOffer(uint256 cid, address buyerId) public minAccessLevel(2) {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        offers[offerId].status = OfferStatus.Rejected;\n    }\n\n    modifier minAccessLevel(uint256 level) {\n        if(msg.sender != owner) {\n            require(publishersMap[msg.sender] >= level);\n        }\n        _;\n    }\n}", "debug": "calldata_Pmes_4 + calldata_Pmes_32 + 4: 0xf3f5bb04\ncalldata_Pmes_4: 0x40000000000000000000000000000000000000000000000000000\nstorage_1 + keccac_calldata_Pmes_4: 0xe8479b0cf79f5ab95040d54470b92ca0867e9b738a0bbff55b371600827fffc9\nkeccac_1_+_keccac_calldata_Pmes_4: 0xfea13e605beedf4fcdeeff5a0eb68f428af141bf89282080054adb9ffcfdfffe\ncalldata_Pmes_32 + 4: 0x6c1450ee\ncalldatasize_Pmes: 0x8000000000000000000800344000000000000000040000000880130061427a80\nstorage_1: 0x40000000000000000000000000000000000000000000000000001\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_0: 0x2a6446ca00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setDescription(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "setDescription(uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}, {"address": 11912, "code": "ntract Pmes {\n\n    address public owner;\n    uint256 public nextCid = 1;\n\n    struct Content {\n        string cus;\n        string description;\n        address owner;\n        uint256 readPrice;\n        uint256 writePrice;\n    }\n    mapping(uint256 => string[]) public reviews;\n    enum OfferStatus {Cancelled, Rejected, Opened, Accepted}\n    struct Offer {\n        uint256 id;\n        string buyerAccessString;\n        string sellerPublicKey;\n        string sellerAccessString;\n        OfferStatus status;\n        uint256 cid;\n        address buyerId;\n        uint256 offerType;\n        uint256 price;\n    }\n\n    mapping(uint256 => Content) public contents;\n    mapping(string => uint256)  CusToCid;\n    function getCid(string memory cus) public view returns (uint256) {\n        return CusToCid[cus];\n    }\n\n    uint256 public nextOfferId = 1;\n    mapping(uint256 => Offer) public offers;\n    mapping(uint256 => mapping(address => uint256)) public CidBuyerIdToOfferId;\n\n    mapping(uint256 => uint256[]) public CidToOfferIds;\n    mapping(address => uint256[]) public BuyerIdToOfferIds;\n\n    // Access level mapping [address]\n    // 0 - access denied\n    // 1 - can edit existing content\n    // 2 - can add content\n    // 3 - can saleAccess\n    // 4 - can changeOwner\n    // 5 - can setAccessLevel\n    mapping(address => uint256) public publishersMap;\n\n    event postContent(uint256); // makeCid\n    event postOffer(uint256, uint256, uint256, address); // makeOffer\n    event acceptOffer(uint256); // sellContent, changeOwner\n    event postReview(); // newReview\n\n    constructor() public\n    {\n        // to prevent repeated calls\n        require (owner == address(0x0));\n        // set owner address\n        owner = msg.sender;\n    }\n\n    function setAccessLevel(\n        address publisherAddress,\n        uint256 accessLevel\n    )\n        public\n        minAccessLevel(5)\n    {\n        publishersMap[publisherAddress] = accessLevel;\n    }\n\n    function makeCid(\n        string memory cus,\n        address ownerId,\n        string memory description,\n        uint256 readPrice,\n        uint256 writePrice\n    )\n        public\n        minAccessLevel(2)\n        returns (uint256)\n    {\n        // To prevent create already exist\n        uint256 cid = CusToCid[cus];\n        require(cid == 0, \"Content already uploaded\");\n\n        cid = nextCid++;\n        CusToCid[cus] = cid;\n\n        contents[cid] = Content(cus, description, ownerId, readPrice, writePrice);\n        emit postContent(cid);\n\n        return cid;\n    }\n\n    function setReadPrice(uint256 cid, uint256 price) public minAccessLevel(1) {\n        require(cid > 0 && cid < nextCid);\n        contents[cid].readPrice = price;\n    }\n\n    function setWritePrice(uint256 cid, uint256 price) public minAccessLevel(1) {\n        require(cid > 0 && cid < nextCid);\n        contents[cid].writePrice = price;\n    }\n\n    function addReview(uint256 cid, address buyerId, string memory review) public minAccessLevel(1) {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offerId != 0);\n        require(offers[offerId].status == OfferStatus.Accepted);\n\n        reviews[cid].push(review);\n        emit postReview();\n    }\n\n    function setDescription(uint256 cid, string memory description) public minAccessLevel(1) {\n        require(cid > 0 && cid < nextCid);\n        contents[cid].description = description;\n    }\n\n    function changeOwner(\n        uint256 cid,\n        address buyerId,\n        string memory sellerPublicKey,\n        string memory sellerAccessString\n    )\n        public\n        minAccessLevel(4)\n    {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        contents[cid].owner = buyerId;\n        offers[offerId].sellerAccessString = sellerAccessString;\n        offers[offerId].sellerPublicKey = sellerPublicKey;\n        offers[offerId].status = OfferStatus.Accepted;\n        emit acceptOffer(cid);\n    }\n\n    function sellContent(\n        uint256 cid,\n        address buyerId,\n        string memory sellerPublicKey,\n        string memory sellerAccessString\n    )\n        public\n        minAccessLevel(3)\n    {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        offers[offerId].sellerAccessString = sellerAccessString;\n        offers[offerId].sellerPublicKey = sellerPublicKey;\n        offers[offerId].status = OfferStatus.Accepted;\n        emit acceptOffer(cid);\n    }\n\n    function makeOffer(\n        uint256 cid,\n        address buyerId,\n        uint256 offerType,\n        uint256 price,\n        string memory buyerAccessString\n    )\n        public\n        minAccessLevel(2)\n    {\n        require(cid > 0 && cid < nextCid, \"Wrong cid\");\n        // require(CidBuyerIdToOfferId[cid][buyerId] == 0, \"\");\n        require(\n            offers[CidBuyerIdToOfferId[cid][buyerId]].status != OfferStatus.Accepted &&\n            offers[CidBuyerIdToOfferId[cid][buyerId]].status != OfferStatus.Opened,\n            \"Offer already exist\"\n        );\n\n        offers[nextOfferId] = Offer(\n            offers[CidBuyerIdToOfferId[cid][buyerId]].id + 1,\n            buyerAccessString, \n            \"none\", \n            \"none\", \n            OfferStatus.Opened, \n            cid, \n            buyerId, \n            offerType, \n            price\n        );\n\n        CidBuyerIdToOfferId[cid][buyerId] = nextOfferId;\n\n        CidToOfferIds[cid].push(nextOfferId);\n        BuyerIdToOfferIds[buyerId].push(nextOfferId);\n\n        emit postOffer(cid, offerType, price, buyerId);\n        \n        nextOfferId++;\n    }\n\n    function cancelOffer(uint256 cid, address buyerId) public minAccessLevel(2) {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        offers[offerId].status = OfferStatus.Cancelled;\n    }\n\n    function rejectOffer(uint256 cid, address buyerId) public minAccessLevel(2) {\n        uint256 offerId = CidBuyerIdToOfferId[cid][buyerId];\n        require(offers[offerId].status == OfferStatus.Opened);\n        offers[offerId].status = OfferStatus.Rejected;\n    }\n\n    modifier minAccessLevel(uint256 level) {\n        if(msg.sender != owner) {\n            require(publishersMap[msg.sender] >= level);\n        }\n        _;\n    }\n}", "debug": "calldata_Pmes_4 + calldata_Pmes_32 + 4: 0x5bef211\ncalldata_Pmes_4: 0x8000000000000000000000000000000000000000000000000000000000000000\nkeccac_1_+_keccac_calldata_Pmes_4: 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_32 + 4: 0x362635bc\ncalldatasize_Pmes: 0x180000000000000000000000000000000000000000000000000000000000000\nstorage_1: 0x8000000000000000000000000000000000000000000000000000000000000001\nstorage_keccac_1461501637330902918203684832716283019655932542975_&\n1461501637330902918203684832716283019655932542975_&\ncaller: 0x1\nstorage_0: 0x0\ncaller: 0xffffffffffffffffffffffffffffffffffffffff\ncalldata_Pmes_0: 0x2a6446ca00000000000000000000000000000000000000000000000000000000\ncallvalue: 0x0\n", "description": "A possible integer overflow exists in the function `setDescription(uint256,string)`.\nThe addition or multiplication may result in a value higher than the maximum representable integer.", "filename": "/unique_chucks/6/0xbfe6358cf9864149582890b00a04a02a73f0ae7e.sol", "function": "setDescription(uint256,string)", "lineno": 3, "title": "Integer Overflow ", "type": "Warning"}], "success": true}